// Model Configuration UI - Dynamic model selection with 3-step wizard
import { state, elements } from './state.js';
import { discoverAvailableModels } from './api.js';

// Current wizard state
let wizardState = {
    currentStep: 1,
    selectedModel: null,
    selectedQueryType: null,
    apiKeyConfig: null,
    existingKeyChoice: 'reuse' // 'reuse' or 'new'
};

// Initialize model configuration UI
export async function initModelConfig() {
    console.log('[ModelConfig] Initializing...');

    // Discover available models
    await discoverAvailableModels();

    // Update auto-detection status
    updateAutoDetectStatus();

    // Load saved configuration
    loadSavedConfiguration();

    // Setup event listeners
    setupEventListeners();

    // Render selected models
    renderSelectedModels();
}

// Update auto-detection status indicators
function updateAutoDetectStatus() {
    const env = state.detectedEnv;
    const models = state.availableModels;

    const detectWebGPU = document.getElementById('detect-webgpu');
    const detectProxy = document.getElementById('detect-proxy');
    const detectOllama = document.getElementById('detect-ollama');
    const detectKeys = document.getElementById('detect-keys');

    if (detectWebGPU) detectWebGPU.textContent = env.hasWebGPU ? '‚úì' : '‚úó';
    if (detectProxy) detectProxy.textContent = env.hasServer ? '‚úì' : '‚úó';
    if (detectOllama) detectOllama.textContent = (models.ollama.length > 0) ? '‚úì' : '‚úó';

    const hasKeys = models.cloud.length > 0 || localStorage.getItem('GEMINI_API_KEY') || localStorage.getItem('OPENAI_API_KEY') || localStorage.getItem('ANTHROPIC_API_KEY');
    if (detectKeys) detectKeys.textContent = hasKeys ? '‚úì' : '‚úó';
}

// Setup event listeners
function setupEventListeners() {
    const addModelBtn = document.getElementById('add-model-btn');
    const closeAddModelBtn = document.getElementById('close-add-model');
    const wizardBackBtn = document.getElementById('wizard-back-btn');
    const wizardNextBtn = document.getElementById('wizard-next-btn');
    const wizardAddBtn = document.getElementById('wizard-add-btn');
    const consensusSelect = document.getElementById('consensus-strategy');
    const saveConfigBtn = document.getElementById('save-model-config');

    if (addModelBtn) addModelBtn.addEventListener('click', openAddModelModal);
    if (closeAddModelBtn) closeAddModelBtn.addEventListener('click', closeAddModelModal);
    if (wizardBackBtn) wizardBackBtn.addEventListener('click', wizardGoBack);
    if (wizardNextBtn) wizardNextBtn.addEventListener('click', wizardGoNext);
    if (wizardAddBtn) wizardAddBtn.addEventListener('click', wizardAddModel);
    if (consensusSelect) consensusSelect.addEventListener('change', updateConsensusStrategy);
    if (saveConfigBtn) saveConfigBtn.addEventListener('click', saveConfiguration);
}

// Open Add Model Modal
async function openAddModelModal() {
    const modal = document.getElementById('add-model-modal');
    if (!modal) return;

    modal.classList.remove('hidden');

    // Reset wizard state
    wizardState = {
        currentStep: 1,
        selectedModel: null,
        selectedQueryType: null,
        apiKeyConfig: null,
        existingKeyChoice: 'reuse'
    };

    // Reset wizard UI
    showWizardStep(1);

    // Show loading
    const loadingEl = document.getElementById('model-list-loading');
    const containerEl = document.getElementById('model-list-container');
    if (loadingEl) loadingEl.classList.remove('hidden');
    if (containerEl) containerEl.classList.add('hidden');

    // Populate model list
    await populateModelList();

    // Hide loading
    if (loadingEl) loadingEl.classList.add('hidden');
    if (containerEl) containerEl.classList.remove('hidden');
}

// Close Add Model Modal
function closeAddModelModal() {
    const modal = document.getElementById('add-model-modal');
    if (modal) modal.classList.add('hidden');
}

// Populate model list from availableModels
async function populateModelList() {
    const models = state.availableModels;

    // Cloud models
    const cloudList = document.getElementById('cloud-models-list');
    const cloudGroup = document.getElementById('cloud-models-group');
    if (cloudList) {
        cloudList.innerHTML = '';
        if (models.cloud.length > 0) {
            models.cloud.forEach(model => {
                const option = createModelOption(model);
                cloudList.appendChild(option);
            });
            if (cloudGroup) cloudGroup.classList.remove('hidden');
        } else {
            cloudList.innerHTML = '<p class="no-models">‚ö† No cloud API keys detected. Enter keys in Step 3.</p>';
            if (cloudGroup) cloudGroup.classList.remove('hidden');
        }
    }

    // WebLLM models
    const webllmList = document.getElementById('webllm-models-list');
    const webllmGroup = document.getElementById('webllm-models-group');
    if (webllmList) {
        webllmList.innerHTML = '';
        if (models.webllm.length > 0) {
            models.webllm.forEach(model => {
                const option = createModelOption(model);
                webllmList.appendChild(option);
            });
            if (webllmGroup) webllmGroup.classList.remove('hidden');
        } else {
            webllmList.innerHTML = '<p class="no-models">‚ö† WebGPU not available in this browser</p>';
            if (webllmGroup) webllmGroup.classList.add('hidden');
        }
    }

    // Ollama models
    const ollamaList = document.getElementById('ollama-models-list');
    const ollamaGroup = document.getElementById('ollama-models-group');
    if (ollamaList) {
        ollamaList.innerHTML = '';
        if (models.ollama.length > 0) {
            models.ollama.forEach(model => {
                const option = createModelOption(model);
                ollamaList.appendChild(option);
            });
            if (ollamaGroup) ollamaGroup.classList.remove('hidden');
        } else {
            ollamaList.innerHTML = '<p class="no-models">‚ö† Ollama not detected. Install and run: <code>ollama serve</code></p>';
            if (ollamaGroup) ollamaGroup.classList.remove('hidden');
        }
    }
}

// Create model option element
function createModelOption(model) {
    const option = document.createElement('div');
    option.className = 'model-option';
    option.dataset.modelId = model.id;

    const alreadySelected = state.selectedModels.find(m => m.id === model.id);
    if (alreadySelected) {
        option.classList.add('already-selected');
        option.innerHTML = `
            <div class="model-option-main">
                <input type="radio" name="model-select" value="${model.id}" disabled />
                <div class="model-info">
                    <span class="model-name">${model.name || model.id}</span>
                    <span class="model-provider">${model.provider}</span>
                </div>
            </div>
            <span class="already-selected-badge">Already Selected</span>
        `;
    } else {
        option.innerHTML = `
            <div class="model-option-main">
                <input type="radio" name="model-select" value="${model.id}" />
                <div class="model-info">
                    <span class="model-name">${model.name || model.id}</span>
                    <span class="model-provider">${model.provider}</span>
                    ${model.size ? `<span class="model-size">${formatSize(model.size)}</span>` : ''}
                </div>
            </div>
        `;

        option.addEventListener('click', () => selectModel(model));
    }

    return option;
}

// Select model (Step 1)
function selectModel(model) {
    wizardState.selectedModel = model;
    const radio = document.querySelector(`input[name="model-select"][value="${model.id}"]`);
    if (radio) radio.checked = true;

    const nextBtn = document.getElementById('wizard-next-btn');
    if (nextBtn) nextBtn.disabled = false;
}

// Format size in bytes to GB
function formatSize(bytes) {
    if (!bytes) return '';
    const gb = (bytes / (1024 ** 3)).toFixed(1);
    return `${gb}GB`;
}

// Show wizard step
function showWizardStep(step) {
    // Update step indicators
    document.querySelectorAll('.wizard-step').forEach(stepEl => {
        const stepNum = parseInt(stepEl.dataset.step);
        if (stepNum < step) {
            stepEl.classList.add('completed');
            stepEl.classList.remove('active');
        } else if (stepNum === step) {
            stepEl.classList.add('active');
            stepEl.classList.remove('completed');
        } else {
            stepEl.classList.remove('active', 'completed');
        }
    });

    // Show/hide step content
    for (let i = 1; i <= 3; i++) {
        const content = document.getElementById(`wizard-step-${i}`);
        if (content) {
            content.classList.toggle('hidden', i !== step);
            content.classList.toggle('active', i === step);
        }
    }

    // Update buttons
    const backBtn = document.getElementById('wizard-back-btn');
    const nextBtn = document.getElementById('wizard-next-btn');
    const addBtn = document.getElementById('wizard-add-btn');

    if (backBtn) {
        backBtn.classList.toggle('hidden', step === 1);
    }

    if (nextBtn) {
        nextBtn.classList.toggle('hidden', step === 3);
        nextBtn.disabled = true; // Re-enable based on step validation
    }

    if (addBtn) {
        addBtn.classList.toggle('hidden', step !== 3);
        addBtn.disabled = true; // Re-enable when validated
    }

    wizardState.currentStep = step;
}

// Wizard navigation: Go Back
function wizardGoBack() {
    if (wizardState.currentStep > 1) {
        showWizardStep(wizardState.currentStep - 1);

        // Re-enable next button if previous step was completed
        if (wizardState.currentStep === 1 && wizardState.selectedModel) {
            const nextBtn = document.getElementById('wizard-next-btn');
            if (nextBtn) nextBtn.disabled = false;
        } else if (wizardState.currentStep === 2 && wizardState.selectedQueryType) {
            const nextBtn = document.getElementById('wizard-next-btn');
            if (nextBtn) nextBtn.disabled = false;
        }
    }
}

// Wizard navigation: Go Next
function wizardGoNext() {
    if (wizardState.currentStep === 1 && wizardState.selectedModel) {
        // Move to Step 2: Query Type Selection
        showWizardStep(2);
        populateQueryTypeOptions();
    } else if (wizardState.currentStep === 2 && wizardState.selectedQueryType) {
        // Move to Step 3: API Key Configuration
        showWizardStep(3);
        populateApiKeyConfig();
    }
}

// Populate query type options (Step 2)
function populateQueryTypeOptions() {
    const container = document.getElementById('query-type-options');
    const modelNameEl = document.getElementById('step2-model-name');

    if (!container || !wizardState.selectedModel) return;

    const model = wizardState.selectedModel;
    if (modelNameEl) modelNameEl.textContent = model.name || model.id;

    container.innerHTML = '';

    const queryTypes = getAvailableQueryTypes(model);

    queryTypes.forEach(qt => {
        const option = document.createElement('div');
        option.className = 'query-type-option';
        if (!qt.available) option.classList.add('disabled');

        option.innerHTML = `
            <input type="radio" name="query-type" value="${qt.type}" ${!qt.available ? 'disabled' : ''} />
            <div class="query-type-info">
                <strong>${qt.label}</strong>
                <p>${qt.description}</p>
                ${qt.available ? '<span class="status-badge available">‚úì Available</span>' : '<span class="status-badge unavailable">‚úó ' + qt.reason + '</span>'}
            </div>
        `;

        if (qt.available) {
            option.addEventListener('click', () => selectQueryType(qt.type));
        }

        container.appendChild(option);
    });

    // Auto-select if only one option
    const available = queryTypes.filter(qt => qt.available);
    if (available.length === 1) {
        selectQueryType(available[0].type);
    }
}

// Get available query types for model
function getAvailableQueryTypes(model) {
    const env = state.detectedEnv;
    const types = [];

    if (model.provider === 'gemini' || model.provider === 'openai' || model.provider === 'anthropic') {
        // Cloud models: Q1 (browser-direct) or Q2 (via proxy)
        types.push({
            type: 'Q1',
            label: 'Browser-Direct (Q1)',
            description: 'Browser makes API calls directly to cloud provider',
            available: true
        });

        types.push({
            type: 'Q2',
            label: 'Via Proxy Server (Q2)',
            description: 'Proxy server forwards requests to cloud provider',
            available: env.hasServer,
            reason: env.hasServer ? '' : 'Proxy server not running'
        });
    } else if (model.provider === 'ollama') {
        // Ollama: Q3 only
        types.push({
            type: 'Q3',
            label: 'Local via Proxy (Q3)',
            description: 'Proxy server forwards to local Ollama runtime',
            available: env.hasServer,
            reason: env.hasServer ? '' : 'Proxy server not running'
        });
    } else if (model.provider === 'webllm') {
        // WebLLM: Q4 only
        types.push({
            type: 'Q4',
            label: 'Browser WebGPU (Q4)',
            description: 'Model runs entirely in browser using WebGPU',
            available: env.hasWebGPU,
            reason: env.hasWebGPU ? '' : 'WebGPU not available'
        });
    }

    return types;
}

// Select query type (Step 2)
function selectQueryType(queryType) {
    wizardState.selectedQueryType = queryType;
    const radio = document.querySelector(`input[name="query-type"][value="${queryType}"]`);
    if (radio) radio.checked = true;

    const nextBtn = document.getElementById('wizard-next-btn');
    if (nextBtn) nextBtn.disabled = false;
}

// Populate API key configuration (Step 3)
function populateApiKeyConfig() {
    const container = document.getElementById('api-key-config');
    const modelNameEl = document.getElementById('step3-model-name');

    if (!container || !wizardState.selectedModel) return;

    const model = wizardState.selectedModel;
    const queryType = wizardState.selectedQueryType;

    if (modelNameEl) modelNameEl.textContent = model.name || model.id;

    container.innerHTML = '';

    if (queryType === 'Q1') {
        // Browser-direct: Need API key in localStorage
        renderBrowserDirectKeyConfig(container, model);
    } else if (queryType === 'Q2') {
        // Via proxy: Check if key in .env
        renderProxyKeyConfig(container, model);
    } else if (queryType === 'Q3' || queryType === 'Q4') {
        // Ollama or WebLLM: No key needed
        container.innerHTML = `
            <div class="no-key-needed">
                <p>‚úì No API key required for this model</p>
                <p class="hint">${queryType === 'Q3' ? 'Model will be accessed via local Ollama' : 'Model will run in your browser using WebGPU'}</p>
            </div>
        `;

        // Enable add button immediately
        const addBtn = document.getElementById('wizard-add-btn');
        if (addBtn) addBtn.disabled = false;
    }
}

// Render browser-direct key configuration
function renderBrowserDirectKeyConfig(container, model) {
    const provider = model.provider;
    const keyName = `${provider.toUpperCase()}_API_KEY`;
    const existingKey = state.configuredKeys[provider] || localStorage.getItem(keyName);

    if (existingKey) {
        // Key already configured - offer reuse or new
        container.innerHTML = `
            <div class="api-key-reuse">
                <p><strong>${capitalize(provider)} API Key</strong></p>

                <label class="key-choice-option">
                    <input type="radio" name="key-choice" value="reuse" checked />
                    <div>
                        <strong>Use existing key</strong>
                        <p>Key ending in: ...${existingKey.slice(-4)}</p>
                    </div>
                </label>

                <label class="key-choice-option">
                    <input type="radio" name="key-choice" value="new" />
                    <div>
                        <strong>Use different key</strong>
                        <p>Enter a new API key below</p>
                    </div>
                </label>

                <div id="new-key-input" class="new-key-input hidden">
                    <input type="password" id="api-key-input-new" placeholder="Enter ${provider} API key..." />
                </div>
            </div>
        `;

        // Setup listeners for key choice
        const reuseRadio = container.querySelector('input[value="reuse"]');
        const newRadio = container.querySelector('input[value="new"]');
        const newKeyInput = container.querySelector('#new-key-input');
        const newKeyField = container.querySelector('#api-key-input-new');

        if (reuseRadio) {
            reuseRadio.addEventListener('change', () => {
                if (newKeyInput) newKeyInput.classList.add('hidden');
                wizardState.existingKeyChoice = 'reuse';
                wizardState.apiKeyConfig = { provider, key: existingKey };
                const addBtn = document.getElementById('wizard-add-btn');
                if (addBtn) addBtn.disabled = false;
            });
        }

        if (newRadio) {
            newRadio.addEventListener('change', () => {
                if (newKeyInput) newKeyInput.classList.remove('hidden');
                wizardState.existingKeyChoice = 'new';
                wizardState.apiKeyConfig = null;
                const addBtn = document.getElementById('wizard-add-btn');
                if (addBtn) addBtn.disabled = true;
            });
        }

        if (newKeyField) {
            newKeyField.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                wizardState.apiKeyConfig = value ? { provider, key: value } : null;
                const addBtn = document.getElementById('wizard-add-btn');
                if (addBtn) addBtn.disabled = !value;
            });
        }

        // Default: reuse
        wizardState.existingKeyChoice = 'reuse';
        wizardState.apiKeyConfig = { provider, key: existingKey };
        const addBtn = document.getElementById('wizard-add-btn');
        if (addBtn) addBtn.disabled = false;

    } else {
        // No existing key - need new one
        container.innerHTML = `
            <div class="api-key-input-section">
                <p><strong>${capitalize(provider)} API Key Required</strong></p>
                <p class="hint">This will be stored in browser localStorage</p>
                <input type="password" id="api-key-input-new" placeholder="Enter ${provider} API key..." />
                <small>Get your API key from ${getProviderURL(provider)}</small>
            </div>
        `;

        const inputField = container.querySelector('#api-key-input-new');
        if (inputField) {
            inputField.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                wizardState.apiKeyConfig = value ? { provider, key: value } : null;
                const addBtn = document.getElementById('wizard-add-btn');
                if (addBtn) addBtn.disabled = !value;
            });
        }
    }
}

// Render proxy key configuration
async function renderProxyKeyConfig(container, model) {
    const provider = model.provider;

    container.innerHTML = `
        <div class="proxy-key-check">
            <p><strong>${capitalize(provider)} API Key Status</strong></p>
            <p class="checking">üîç Checking proxy server configuration...</p>
        </div>
    `;

    // Check if key is in proxy .env
    try {
        const response = await fetch('http://localhost:8000/api/proxy-status', {
            method: 'GET',
            signal: AbortSignal.timeout(3000)
        });

        if (response.ok) {
            const data = await response.json();
            const hasKey = data.providers && data.providers[provider];

            if (hasKey) {
                container.innerHTML = `
                    <div class="proxy-key-status success">
                        <p>‚úì <strong>${capitalize(provider)} key detected in proxy</strong></p>
                        <p class="hint">Key is configured in server .env file</p>
                    </div>
                `;

                wizardState.apiKeyConfig = { provider, keySource: 'proxy-env' };
                const addBtn = document.getElementById('wizard-add-btn');
                if (addBtn) addBtn.disabled = false;
            } else {
                container.innerHTML = `
                    <div class="proxy-key-status error">
                        <p>‚ö† <strong>${capitalize(provider)} key not found in proxy</strong></p>
                        <p class="hint">Add this to your server .env file:</p>
                        <code>${provider.toUpperCase()}_API_KEY=your-key-here</code>
                        <p class="hint">Then restart the proxy server.</p>
                        <button type="button" id="switch-to-browser-direct" class="btn-secondary">Use Browser-Direct Instead</button>
                    </div>
                `;

                const switchBtn = container.querySelector('#switch-to-browser-direct');
                if (switchBtn) {
                    switchBtn.addEventListener('click', () => {
                        wizardState.selectedQueryType = 'Q1';
                        showWizardStep(2);
                        populateQueryTypeOptions();
                    });
                }
            }
        }
    } catch (error) {
        container.innerHTML = `
            <div class="proxy-key-status error">
                <p>‚úó <strong>Cannot connect to proxy server</strong></p>
                <p class="hint">Make sure proxy is running: <code>npm start</code></p>
            </div>
        `;
    }
}

// Wizard: Add Model
function wizardAddModel() {
    if (!wizardState.selectedModel || !wizardState.selectedQueryType) return;

    const model = wizardState.selectedModel;
    const queryType = wizardState.selectedQueryType;

    // Build model configuration object
    const modelConfig = {
        id: model.id,
        name: model.name || model.id,
        provider: model.provider,
        queryType: queryType,
        tier: model.tier,
        size: model.size
    };

    // Add key configuration if needed
    if (wizardState.apiKeyConfig) {
        if (queryType === 'Q1') {
            // Save key to localStorage
            const keyName = `${model.provider.toUpperCase()}_API_KEY`;
            localStorage.setItem(keyName, wizardState.apiKeyConfig.key);
            state.configuredKeys[model.provider] = wizardState.apiKeyConfig.key;
            modelConfig.keySource = 'localStorage';
            modelConfig.keyId = keyName;
        } else if (queryType === 'Q2') {
            modelConfig.keySource = 'proxy-env';
        }
    }

    // Add to selectedModels
    state.selectedModels.push(modelConfig);

    // Save to localStorage immediately
    saveSelectedModelsToStorage();

    // Re-render
    renderSelectedModels();

    // Close modal
    closeAddModelModal();
}

// Render selected models
function renderSelectedModels() {
    const container = document.getElementById('selected-models-list');
    const emptyState = document.getElementById('models-empty-state');
    const consensusSection = document.getElementById('consensus-section');
    const saveBtn = document.getElementById('save-model-config');

    if (!container) return;

    if (state.selectedModels.length === 0) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (consensusSection) consensusSection.classList.add('hidden');
        if (saveBtn) saveBtn.disabled = true;
    } else {
        if (emptyState) emptyState.classList.add('hidden');

        // Clear and render model cards
        Array.from(container.children).forEach(child => {
            if (!child.id || child.id !== 'models-empty-state') {
                child.remove();
            }
        });

        state.selectedModels.forEach((model, index) => {
            const card = createModelCard(model, index);
            container.appendChild(card);
        });

        // Show consensus if 2+ models
        if (consensusSection) {
            consensusSection.classList.toggle('hidden', state.selectedModels.length < 2);
        }

        if (saveBtn) saveBtn.disabled = false;
    }
}

// Create model card element
function createModelCard(model, index) {
    const card = document.createElement('div');
    card.className = 'model-card';
    card.dataset.index = index;

    const queryTypeLabel = {
        'Q1': 'Browser-direct',
        'Q2': 'Via proxy',
        'Q3': 'Local via proxy',
        'Q4': 'Browser WebGPU'
    }[model.queryType] || model.queryType;

    const keyInfo = model.keySource === 'localStorage'
        ? `Key: ...${state.configuredKeys[model.provider]?.slice(-4) || 'stored'}`
        : model.keySource === 'proxy-env'
        ? 'Key: server .env'
        : 'No key needed';

    card.innerHTML = `
        <div class="model-card-header">
            <span class="model-card-status">üü¢</span>
            <div class="model-card-info">
                <strong class="model-card-name">${model.name}</strong>
                <span class="model-card-details">${queryTypeLabel} ‚Ä¢ ${keyInfo}</span>
            </div>
        </div>
        <div class="model-card-actions">
            <button type="button" class="model-card-btn edit" data-index="${index}" title="Edit">‚úé</button>
            <button type="button" class="model-card-btn remove" data-index="${index}" title="Remove">√ó</button>
        </div>
    `;

    // Edit button
    const editBtn = card.querySelector('.edit');
    if (editBtn) {
        editBtn.addEventListener('click', () => editModel(index));
    }

    // Remove button
    const removeBtn = card.querySelector('.remove');
    if (removeBtn) {
        removeBtn.addEventListener('click', () => removeModel(index));
    }

    return card;
}

// Edit model
function editModel(index) {
    // TODO: Implement edit functionality
    // For now, just show alert
    alert('Edit functionality: Re-open wizard with pre-filled values (not yet implemented)');
}

// Remove model
function removeModel(index) {
    state.selectedModels.splice(index, 1);
    saveSelectedModelsToStorage();
    renderSelectedModels();
}

// Update consensus strategy
function updateConsensusStrategy(e) {
    state.consensusStrategy = e.target.value;
    localStorage.setItem('CONSENSUS_TYPE', state.consensusStrategy);
}

// Save configuration
function saveConfiguration() {
    if (state.selectedModels.length === 0) {
        alert('Please add at least one model before saving');
        return;
    }

    // Save to localStorage
    saveSelectedModelsToStorage();

    // Update legacy fields for backward compatibility
    const primaryModel = state.selectedModels[0];
    localStorage.setItem('SELECTED_MODEL', primaryModel.id);
    localStorage.setItem('AI_PROVIDER', primaryModel.provider);
    localStorage.setItem('DEPLOYMENT_MODE', 'dynamic'); // New mode identifier

    // Show success message
    alert('Configuration saved successfully!');

    // Close modal if in modal
    const modal = document.getElementById('config-modal');
    if (modal && !modal.classList.contains('hidden')) {
        modal.classList.add('hidden');
    }

    // Trigger page reload to apply new configuration
    setTimeout(() => {
        window.location.reload();
    }, 500);
}

// Save selected models to localStorage
function saveSelectedModelsToStorage() {
    localStorage.setItem('SELECTED_MODELS', JSON.stringify(state.selectedModels));
    localStorage.setItem('CONSENSUS_TYPE', state.consensusStrategy);
}

// Load saved configuration
function loadSavedConfiguration() {
    try {
        const saved = localStorage.getItem('SELECTED_MODELS');
        if (saved) {
            state.selectedModels = JSON.parse(saved);
        }

        const consensus = localStorage.getItem('CONSENSUS_TYPE');
        if (consensus) {
            state.consensusStrategy = consensus;
            const select = document.getElementById('consensus-strategy');
            if (select) select.value = consensus;
        }

        // Load configured keys from localStorage
        ['gemini', 'openai', 'anthropic'].forEach(provider => {
            const key = localStorage.getItem(`${provider.toUpperCase()}_API_KEY`);
            if (key) {
                state.configuredKeys[provider] = key;
            }
        });
    } catch (error) {
        console.error('[ModelConfig] Failed to load saved configuration:', error);
    }
}

// Helper: Capitalize
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper: Get provider URL
function getProviderURL(provider) {
    const urls = {
        gemini: 'aistudio.google.com',
        openai: 'platform.openai.com/api-keys',
        anthropic: 'console.anthropic.com'
    };
    return urls[provider] || 'provider website';
}
