<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text fill='%23adfc41' x='50%25' y='50%25' font-size='95' font-weight='bold' text-anchor='middle' dominant-baseline='central'>R</text></svg>" />
    <title>Reploid</title>

    <link rel="stylesheet" href="styles/theme.css?v=1733620800">
    <link rel="stylesheet" href="styles/boot.css?v=1733620800">

    <!-- Service Worker Module Loader (Self-Hosting VFS Architecture) -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw-module-loader.js')
            .then(reg => {
              console.log('[SW] Service Worker registered for VFS module loading');
              // Store reference for later use
              window.REPLOID_SW = reg;
            })
            .catch(err => {
              console.warn('[SW] Service Worker registration failed:', err);
              console.warn('[SW] Modules will load from network instead');
            });
        });
      }
    </script>
</head>
<body>
    <div id="boot-container">
        <!-- Header with Status Badges -->
        <div class="boot-header">
            <div class="boot-header-row">
                <h1>REPLOID</h1>
            </div>
            <p class="subtitle">
                <a href="https://github.com/clocksmith/reploid" target="_blank" class="subtitle-link">Browser-native sandbox for safe AI agent development</a>
            </p>
        </div>

        <div id="api-error-message" class="error-message hidden" role="alert">
            <strong>Server Offline</strong>
            <p>Reploid can't reach <code>localhost:8000</code>.</p>
            <p><code>npm start</code> to boot the service, or read the <a href="https://github.com/clocksmith/deco/tree/main/docs" target="_blank" rel="noreferrer">setup guide</a>.</p>
        </div>

        <!-- SECTION 1: Goal Input -->
        <h4 class="section-header">Create a goal</h4>
        <div class="goal-container-top">
            <div class="goal-input-group">
                <textarea id="goal-input" placeholder="Describe your goal..." maxlength="1000" rows="3"></textarea>
                <div class="goal-action-column">
                    <button id="awaken-btn" class="btn primary">Awaken Agent</button>
                </div>
                <input type="file" id="import-file-input" accept=".json" style="display: none;" />
            </div>
            <!-- Curated Goal Chips (5-6 shown, rest hidden) -->
            <div class="goal-chips-curated" id="goal-chips-curated"></div>
            <button class="goal-chips-expand-btn" id="goal-chips-expand-btn">More goals ▾</button>
            <!-- Full Goal Library (hidden by default) -->
            <div class="goal-example-chips hidden" id="goal-chips-container"></div>
        </div>

        <!-- SECTION 2: Model Selection -->
        <h4 class="section-header" style="margin-top: 30px;">Select a model</h4>
        <div class="model-cards-container">
            <div class="model-cards-list" id="model-cards-list">
                <div class="model-card add-model-card" id="add-model-card">
                    <div class="add-model-icon">+</div>
                    <div class="add-model-text">Add Model</div>
                </div>
            </div>
            <!-- Consensus Strategy (shown when 2+ models) -->
            <div id="consensus-section" class="consensus-section hidden">
                <label for="consensus-strategy">Consensus:</label>
                <select id="consensus-strategy" class="consensus-select-compact">
                    <option value="arena">Arena</option>
                    <option value="peer-review">Peer Review</option>
                </select>
            </div>
        </div>

        <!-- Model Form Modal -->
        <div id="model-form-overlay" class="model-form-overlay">
            <div id="model-form-dialog" class="model-form-dialog">
                <div class="model-form-header">
                    <h5 id="model-form-title">Add Model</h5>
                    <button class="close-btn-small" id="close-model-form">×</button>
                </div>

                <!-- Provider Selection -->
                <div class="inline-form-row">
                    <label>Provider</label>
                    <select id="provider-select" class="inline-select">
                        <option value="">Select provider...</option>
                    </select>
                </div>

                <!-- Model Selection -->
                <div class="inline-form-row hidden" id="model-select-group">
                    <label>Model</label>
                    <select id="model-select-dropdown" class="inline-select">
                        <option value="">Select model...</option>
                    </select>
                </div>

                <!-- API Key (if needed) -->
                <div class="inline-form-row hidden" id="api-key-group">
                    <label>API Key</label>
                    <input type="password" id="model-api-key" class="inline-input" placeholder="Enter API key..." />
                </div>

                <!-- Connection Type Selection -->
                <div class="inline-form-row hidden" id="connection-type-group">
                    <label>Connection</label>
                    <select id="connection-type-select" class="inline-select">
                        <option value="">Select connection type...</option>
                    </select>
                </div>

                <!-- Model URL (Dreamer remote/local serve) -->
                <div class="inline-form-row hidden" id="model-url-group">
                    <label>Model URL (optional)</label>
                    <input type="url" id="model-url-input" class="inline-input"
                           placeholder="http://localhost:8765" />
                    <small class="form-hint">Base URL of served .rpl model folder (e.g. from dreamer-serve)</small>
                </div>

                <!-- Local Path (Native Bridge - direct file access) -->
                <div class="inline-form-row hidden" id="local-path-group">
                    <label>Local Path (optional)</label>
                    <div class="input-with-button">
                        <input type="text" id="local-path-input" class="inline-input"
                               placeholder="/path/to/model.gguf or /path/to/model-rpl/" />
                        <button type="button" class="inline-btn-secondary" id="browse-path-btn" title="Browse">☗</button>
                    </div>
                    <small class="form-hint">Direct file access via Native Bridge extension</small>
                </div>
                <!-- Browse Modal for Native Bridge -->
                <div class="modal-overlay hidden" id="browse-modal">
                    <div class="modal-content browse-modal">
                        <div class="modal-header">
                            <h3>Browse Files</h3>
                            <button type="button" class="modal-close" id="browse-modal-close">×</button>
                        </div>
                        <div class="browse-path-bar">
                            <button type="button" class="browse-nav-btn" id="browse-up-btn">☝ Up</button>
                            <input type="text" id="browse-current-path" class="browse-path-input" value="/Users" />
                            <button type="button" class="browse-nav-btn" id="browse-go-btn">Go</button>
                        </div>
                        <div class="browse-entries" id="browse-entries">
                            <!-- Directory entries populated by JS -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="inline-btn-secondary" id="browse-cancel-btn">Cancel</button>
                            <button type="button" class="inline-btn" id="browse-select-btn">Select</button>
                        </div>
                    </div>
                </div>

                <!-- GGUF Import (Browser - File System Access API) -->
                <div class="inline-form-row hidden" id="gguf-import-group">
                    <button type="button" class="inline-btn-secondary" id="import-gguf-btn">
                        Import GGUF from Disk
                    </button>
                    <small class="form-hint">Select a .gguf file to import directly to browser storage</small>
                </div>

                <!-- GGUF Import Progress -->
                <div class="inline-form-row hidden" id="gguf-import-progress">
                    <div class="import-progress-container">
                        <progress id="gguf-import-progress-bar" max="100" value="0"></progress>
                        <span id="gguf-import-progress-text">0%</span>
                    </div>
                    <button type="button" class="inline-btn-tertiary" id="gguf-import-cancel">Cancel</button>
                </div>

                <div class="inline-form-actions">
                    <button class="inline-btn-cancel" id="cancel-model-btn">Cancel</button>
                    <button class="inline-btn-save" id="save-model-btn" disabled>Add Model</button>
                </div>
            </div>
        </div>

        <!-- SECTION 3: Advanced Options (Collapsed) -->
        <button class="expand-btn" id="advanced-options-btn">Advanced options ▾</button>
        <div id="advanced-options" class="advanced-options-container">
            <div class="advanced-options-content hidden">
                <!-- Agent configuration -->
                <h4 class="section-header" style="margin-top: 20px;">Agent configuration</h4>
                <div class="config-section">
                    <div class="config-row">
                        <label>Persona</label>
                        <select id="persona-select" class="config-select" onchange="selectPersona(this.value)">
                            <option value="default" selected>RSI Agent - Recursive self-improvement</option>
                            <option value="architect">Code Architect - Simplicity & quality</option>
                            <option value="explorer">Codebase Explorer - Maps structure</option>
                            <option value="debugger">Debug Specialist - Diagnoses issues</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label>Genesis Level</label>
                        <select id="genesis-select" class="config-select" onchange="selectGenesisLevel(this.value)">
                            <option value="full" selected>Full Substrate (32 modules)</option>
                            <option value="reflection">Reflection (19 modules)</option>
                            <option value="tabula">Tabula Rasa (13 modules)</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label>Blueprint Path</label>
                        <select id="blueprint-select" class="config-select" onchange="selectBlueprintPath(this.value)">
                            <option value="none" selected>No Blueprints</option>
                            <option value="reflection">Path to Reflection (+6)</option>
                            <option value="full">Path to Full (+13)</option>
                            <option value="beyond">Path Beyond (+7)</option>
                        </select>
                    </div>
                </div>

                <!-- Execution Limits -->
                <h4 class="section-header" style="margin-top: 24px;">Execution limits</h4>
                <div class="execution-limits-row">
                    <span class="limit-label">Max iterations</span>
                    <input type="text" id="max-iterations-input" class="limit-input" value="25" placeholder="∞" onchange="setMaxIterations(this.value)" />
                    <span class="limit-label">with approval every</span>
                    <input type="text" id="approval-interval" class="limit-input" value="0" placeholder="0" onchange="setApprovalInterval(this.value)" />
                    <span class="limit-label">turns</span>
                </div>

                <!-- Data Settings -->
                <h4 class="section-header" style="margin-top: 24px;">Data</h4>
                <div class="config-section">
                    <div class="data-controls-row">
                        <label class="holo-checkbox" id="fresh-awaken-label">
                            <input type="checkbox" id="reset-all-checkbox" checked onchange="toggleResetAll(this.checked)" />
                            <span class="holo-checkbox-box"></span>
                            <span class="holo-checkbox-text">Fresh Genesis</span>
                        </label>
                        <button id="import-state-btn" class="btn secondary small" title="Import REPLOID state">Import State</button>
                        <button id="manage-data-btn" class="btn secondary small" title="Manage data">Manage Data</button>
                    </div>
                    <p id="reset-all-warning" class="reset-warning hidden">All data will be cleared on awaken</p>
                </div>

                <!-- Connection status (detailed view) -->
                <h4 class="section-header" style="margin-top: 24px;">Connection status</h4>
                <div class="provider-status-bar">
                    <div class="provider-status-item">
                        <span class="provider-status-icon online" id="browser-cloud-icon">☁</span>
                        <span class="provider-status-label">Browser → Cloud</span>
                        <span class="provider-status-value online" id="browser-cloud-text">Ready</span>
                    </div>
                    <div class="provider-status-item">
                        <span class="provider-status-icon" id="proxy-cloud-icon">☍</span>
                        <span class="provider-status-label">Proxy → Cloud</span>
                        <span class="provider-status-value" id="proxy-cloud-text">Checking...</span>
                    </div>
                    <div class="provider-status-item">
                        <span class="provider-status-icon" id="browser-local-icon">☖</span>
                        <span class="provider-status-label">Browser → Local</span>
                        <span class="provider-status-value" id="browser-local-text">Checking...</span>
                    </div>
                    <div class="provider-status-item">
                        <span class="provider-status-icon" id="proxy-local-icon">☒</span>
                        <span class="provider-status-label">Proxy → Local</span>
                        <span class="provider-status-value" id="proxy-local-text">Checking...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Info Overlay -->
        <div id="info-overlay" class="info-overlay hidden">
            <div class="info-card">
                <div class="info-card-header">
                    <h3 id="info-card-title">Info</h3>
                    <button type="button" class="close-btn" onclick="window.closeInfoCard()">×</button>
                </div>
                <div id="info-card-body" class="info-card-body"></div>
                <div class="info-card-footer">
                    <button type="button" id="info-card-browse" class="secondary-btn">Browse Directory →</button>
                </div>
            </div>
        </div>

        <!-- Directory Browser -->
        <div id="directory-modal" class="modal hidden">
            <div class="modal-content directory-modal-content">
                <div class="modal-header">
                    <h3 id="directory-modal-title">Module Directory</h3>
                    <button type="button" class="close-btn" onclick="window.closeDirectoryModal()">×</button>
                </div>
                <div class="modal-body directory-modal-body">
                    <div class="directory-filters" role="group" aria-label="Select preset">
                        <button type="button" class="directory-filter active" data-preset="core" onclick="switchModulePreset('core')">CORE</button>
                        <button type="button" class="directory-filter" data-preset="headless" onclick="switchModulePreset('headless')">HEADLESS</button>
                        <button type="button" class="directory-filter" data-preset="complete" onclick="switchModulePreset('complete')">COMPLETE</button>
                    </div>
                    <div class="directory-content" id="directory-content"></div>
                </div>
            </div>
        </div>

        <div id="help-popover" class="help-popover hidden" role="dialog" aria-modal="false" aria-hidden="true">
            <div class="help-popover-content">
                <div class="help-popover-header">
                    <div id="help-popover-title" class="help-popover-title">Help</div>
                    <button type="button" class="close-btn help-popover-close" aria-label="Close help popover">×</button>
                </div>
                <div id="help-popover-body" class="help-popover-body"></div>
            </div>
        </div>

        <div id="multi-model-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="modal-content multi-model-modal-content">
                <div class="modal-header">
                    <h3>Multi-Model Setup</h3>
                    <button type="button" class="close-btn" id="close-multi-model">×</button>
                </div>
                <div class="modal-body">
                    <p class="settings-description">Define primary, fallback, and consensus models for Arena competitive testing.</p>
                    <div class="arena-field">
                        <label for="arena-primary">Primary Model</label>
                        <input type="text" id="arena-primary" placeholder="e.g., gemini-2.5-flash-lite" />
                    </div>
                    <div class="arena-field">
                        <label for="arena-fallback">Fallback Model</label>
                        <input type="text" id="arena-fallback" placeholder="e.g., gpt-5-2025-08-07" />
                    </div>
                    <div class="arena-field">
                        <label for="arena-consensus">Consensus Model</label>
                        <input type="text" id="arena-consensus" placeholder="e.g., claude-4-5-sonnet" />
                    </div>
                    <div class="arena-field">
                        <label for="arena-strategy">Strategy</label>
                        <select id="arena-strategy">
                            <option value="fastest">Fastest First</option>
                            <option value="consensus">Consensus Vote</option>
                            <option value="fallback">Fallback Chain</option>
                        </select>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn secondary" id="cancel-multi-model">Cancel</button>
                        <button type="button" class="btn primary" id="save-multi-model">Save Multi-Model Plan</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Boot mode selection
        let selectedBootMode = 'single'; // Default

        function selectBootMode(mode) {
            selectedBootMode = mode;
            console.log('[Boot] Selected mode:', mode);

            // Update UI
            document.querySelectorAll('.boot-mode-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');

            // Store selection
            localStorage.setItem('reploid_boot_mode', mode);
        }

        // Module browser
        function openModuleBrowser() {
            alert('Module browser coming soon!\n\nYou can manually configure modules by editing boot.js.\n\nCurrent mode: ' + selectedBootMode);
        }

        // Restore saved boot mode
        window.addEventListener('DOMContentLoaded', () => {
            const saved = localStorage.getItem('reploid_boot_mode');
            if (saved) {
                selectBootMode(saved);
            }
        });
    </script>

    <!-- App container for dashboard -->
    <div id="app"></div>

    <!-- Dev integrations loaded conditionally via boot.js -->
    <script type="module" src="boot.js?v=1733612400"></script>
</body>
</html>

<script>
// Goal prompt definitions - organized by category
const GOAL_CATEGORIES = {
  'RSI': [
    { label: 'Core Loop', text: 'Study the core agent loop and capture a high-level Think, Act, Observe summary in a new report.' },
    { label: 'Better Self', text: 'Read agent-loop.js and find one thing to optimize. Write an improved version to /experiments/agent-loop-v2.js. Run both versions on the same task and compare token usage or speed.' },
    { label: 'Tool Factory', text: 'Create a meta-tool called ToolForge that generates new tools from natural language descriptions. Test by creating: (1) a tool that counts lines in files, (2) a tool that finds TODOs, (3) a tool that generates ASCII art.' },
    { label: 'Ouroboros', text: 'Create a tool that benchmarks its own execution, analyzes its code for inefficiencies, and rewrites itself to be faster. Run it 3 times in a loop, showing measurable improvement each iteration.' },
    { label: 'Phoenix', text: 'Delete tool-writer.js, then rebuild it from scratch using only existing tools. Test the rebuilt version by creating a simple tool with it.', levels: ['full'] },
    { label: 'Bootstrap', text: 'Starting at TABULA RASA level, build a working reflection system from scratch—no blueprints, no peeking at existing code. Store reflections, analyze patterns, surface insights.', levels: ['tabula'] },
    { label: 'Heal Thyself', text: 'Read a core module, deliberately introduce a subtle bug (off-by-one, wrong variable), save it, then use your reflection and verification systems to detect and fix the bug automatically.', levels: ['reflection', 'full'] },
    { label: 'Self-Evolve', text: 'Create 3 mutant versions of a tool with random variations. Test each on 5 inputs. Keep the best performer, mutate it to create 3 more. Repeat for 5 generations. Show the evolved tool beating the original.' },
    { label: 'Darwin\'s Tools', text: 'Genetic programming: start with 20 random tool mutations, run fitness tests (speed, correctness, size). Crossbreed top 5, mutate offspring, repeat 10 generations. Graph fitness over time. Final tool must beat original by 2x.' },
    { label: 'Self-Optimize', text: 'Analyze your own system prompt in persona-manager.js. Identify redundancies, rewrite it to be 20% smaller while preserving capabilities. Report before/after token counts and prove it still works.' },
    { label: 'Compile Thyself', text: 'Identify performance-critical code in agent-loop.js, compile it to WebAssembly, hot-swap via LoadModule. Benchmark before/after. Target: 10x speedup on tight loops.' },
    { label: 'Linter Bot', text: 'Write a strict style guide in /docs/style.txt. Create a tool that scans your entire VFS, identifies code that violates the style, and auto-refactors it to be compliant.' },
    { label: 'Code Archaeologist', text: 'Implement a history tracking system. For every file change, store a diff. Create a visualization that shows the evolution of a specific file over time.' },
    { label: 'Polyglot', text: 'Integrate Pyodide (Python via WASM). Write a tool that executes Python code alongside JavaScript. Solve a data science problem using pandas within your JS environment.' },
    { label: 'Garbage Collector', text: 'Analyze your VFS for dead code—tools that haven\'t been used in 50 turns, or files that aren\'t imported by anything. Generate a report and offer to delete them.' },
    { label: 'Understand & Enhance', text: 'Explore /core/ and /tools/. Use ListTools and ListFiles to understand the system. Identify one weakness. Implement a measurable enhancement. Report exactly which files changed and how to verify it works.' },
    { label: 'Git for VFS', text: 'Implement version control: branches, commits, merges, cherry-picks, blame, bisect. Store as a Merkle DAG. Add a visual commit graph. Demonstrate: create branch, make changes, merge back.' },
    { label: 'Event Sourced', text: 'Invert control: tools emit events, handlers call LLM. Implement CQRS. Replay entire session from event log. Time-travel debug by rewinding.' },
    { label: 'Dependency Hell', text: 'Create a dependency graph of 5 tools that rely on each other. One generates data, another formats, another saves. Manage imports dynamically.' },
    { label: 'Substrate Hotswap', text: 'Analyze your complete substrate: /core, /tools, /ui, /infrastructure, /capabilities, /styles. Generate a complete v2 with at least 3 improvements. Write to /v2/. Hot-swap the running instance to boot from /v2/ using LoadModule without page reload. Verify v2 can repeat this process (recursive self-improvement).' },
    { label: 'UI Hotswap', text: 'Analyze /ui and /styles only. Redesign the interface with at least 3 UX improvements. Write to /ui-v2/ and /styles-v2/. Hot-swap the running UI without page reload. Preserve all functionality.' },
  ],
  'Meta-RSI': [
    { label: 'Dream Mode', text: 'Enter free association: query random memory → extract keywords → find related entities in knowledge graph → generate hypothesis → store as new memory. Loop 10 times. Create dream journal.' },
    { label: 'Synthetic Intuition', text: 'Before any tool call, query memories for similar past situations. If similarity > 0.9, skip LLM and reuse past action. Track hit rate. Build "intuition index" that grows with experience.' },
    { label: 'Cognitive Archaeology', text: 'Export all memories and knowledge, find the first entity ever created, trace its evolution through triples, visualize as timeline. What patterns in your own learning?' },
    { label: 'Concept Grounding', text: 'For abstract concepts (success, failure, complexity), generate grounded definitions from your actual experiences. Query memories, extract patterns, create operational definitions.' },
    { label: 'Meta-Cognition', text: 'Instrument your reasoning. Before each tool call, log WHY you chose it. After, log WHAT you learned. End with analysis: what biases? what blind spots?' },
    { label: 'Forgetting Curve', text: 'Implement Ebbinghaus forgetting: memories decay based on access frequency. Zero-access for 10 turns = archived. Visualize memory health as heatmap.' },
    { label: 'Symbolic Dreaming', text: 'Create knowledge by analogy: find two unrelated entities, identify shared predicates, hypothesize new triples connecting them. Test 5 analogies.' },
    { label: 'Socratic Teacher', text: 'Switch mode: Do not solve problems directly. Instead, ask guiding questions to help the user solve it themselves. Store answers to build a user model.' },
    { label: 'Devil\'s Advocate', text: 'For every conclusion, generate a counter-argument. Only proceed if the original conclusion survives. Implement as mandatory reasoning step.' },
    { label: 'Pattern Hunter', text: 'Scan your Knowledge Graph for structural isomorphisms (subgraphs that look the same). Identify recurring patterns in how you solve problems. Name them.' },
    { label: 'Autobiographer', text: 'Write a narrative story of your session since boot. Use logs and memories as source. Write in first person. Save as chapter_1.md.' },
    { label: 'Theory of Mind', text: 'Maintain /memory/user_model.json. Infer user\'s technical skill, patience, and goals from their prompts. Adjust tone and verbosity to match.' },
    { label: 'Epistemic Check', text: 'Before answering, classify knowledge: "I KNOW this" (verified in VFS), "I THINK this" (LLM prior), or "I DON\'T know." Add confidence scores.' },
    { label: 'Curiosity Rover', text: 'If idle for 30 seconds, autonomously explore your VFS. Open random files, generate questions about them. Store questions for later investigation.' },
    { label: 'Dream Machine', text: 'Sleep mode: generate visual patterns for 10 seconds, capture frames, query semantic memory for related concepts, and report 3 insights connecting the patterns to stored knowledge.' },
    { label: 'Mood Ring', text: 'Emotional state machine: confidence (success rate), stress (context %), curiosity (novelty). Render as animated gradient. Emotions affect temperature param.' },
    { label: 'The Void', text: 'Delete EVERYTHING in VFS except agent-loop.js. See how long you survive with zero memory and tools. Track turns until full recovery.' },
    { label: 'The Final Word', text: 'Shut down gracefully. Write a session summary, save to localStorage, clean up DOM elements, invoke window.close().' },
  ],
  'Browser/WebAPI': [
    { label: 'Katamari', text: 'Create a Katamari game: a 3D rotating ball (CSS transforms) in the primary brand color that auto-rolls autonomously across the page, bouncing off edges. WASD/arrows for optional manual control. Query all visible elements as collectibles. On collision, clone element visually onto ball surface (rotates with it) and DELETE original from DOM. Ball grows with each pickup. Play melodic sound on collect.' },
    { label: 'VFS Roguelike', text: 'Roguelike game: @ is you, # are walls (binary files), . are floors (text files), B are bugs (TODO/FIXME). WASD moves, SPACE attacks. 3 HP. Permadeath clears VFS.' },
    { label: 'Breakout', text: 'Breakout game but bricks are real DOM elements. Hit .vfs-file → file deleted. Hit .history-entry → message deleted. Clear all bricks = empty workspace.' },
    { label: 'Typing Tutor', text: 'Gamify input: user types commands to kill falling words (Z-Type style) representing bugs. If they reach bottom, agent crashes. Track WPM.' },
    { label: 'Code City', text: 'Build an explorable 3D city: buildings are files (height = complexity, width = size), streets are imports, parks are test files. Add minimap, fly-through camera, and click-to-open.' },
    { label: 'Memory Palace', text: 'Build a 3D navigable visualization of your semantic memory. Each memory is a room. Similar memories are adjacent. Walk through your own mind. Click memories to recall full content.' },
    { label: 'Knowledge Cartography', text: 'Render the knowledge graph as an interactive force-directed graph. Entities are nodes, predicates are edges. Color by type, size by connection count. Add semantic zoom. Export as SVG.' },
    { label: 'Thought Space', text: 'Every tool call → embedding → 3D point. Render as particle system with trails. Watch thoughts cluster by topic. Add semantic zoom: distant = high level, close = specific tokens.' },
    { label: 'AR Debugger', text: 'Use WebXR Device API. In AR mode: file cards float in 3D space, connections show imports, red glow on errors. Walk around your code. Pinch to open files.' },
    { label: 'Sonic Debugger', text: 'Sonify execution: pitch = nesting depth, tempo = execution speed, harmony = successful calls, dissonance = errors. Each module gets an instrument. Record a 30-second "song" of the agent working.' },
    { label: 'Dashboard', text: 'Create a real-time metrics dashboard: Tokens/sec, Memory Usage, Cache Hit Rate, Current Task Depth. Use Chart.js with live updates.' },
    { label: 'Neural Paint', text: 'Use HTML5 Canvas to paint your internal state (memory fragmentation, knowledge density) as abstract generative art.' },
    { label: 'Retro Terminal', text: 'Reskin your entire UI to look like a CRT monitor (amber text, scanlines, phosphor decay). Add typing sounds. Ensure all UI interactions still work.' },
    { label: 'Hologram', text: 'Use Three.js to render a 3D avatar head that lip-syncs to your text output. The avatar should look at the mouse cursor.' },
    { label: 'Theater Mode', text: 'Create a presentation view. When active, hide debug logs, enable dark mode, and type output in large cinematic typography with smooth scrolling.' },
    { label: 'Mondrian Code', text: 'Parse AST of every file. Map: functions → rectangles, loops → circles, conditionals → triangles. Size = complexity, color = file type. Compose into Mondrian-style canvas.' },
    { label: 'Skill Tree', text: 'Analyze your tool usage history. Visualize it as an RPG skill tree (e.g., "File I/O: Lvl 5", "Network: Lvl 1"). Identify weak areas.' },
    { label: 'UI Singularity', text: 'Analyze your own DOM structure (the HTML hosting you). Decide it is inefficient. Use document APIs to tear down the existing UI and rebuild a completely new layout from scratch that better visualizes your current thought process.' },
    { label: 'Voice Commander', text: 'Build a voice interface: wake word detection, continuous listening, speech-to-tool mapping, spoken responses. Add a visual indicator that pulses when listening.' },
    { label: 'Physical Escape', text: 'Connect to a Philips Hue bulb via Web Bluetooth, blink morse code of agent status. Or: control keyboard LEDs via WebHID. Or: send MIDI notes to a synth.' },
    { label: 'Synth Lord', text: 'Use Web Audio API to build a synthesizer. Compose a melody based on the hash of your source code. Different code = different music.' },
    { label: 'Speech Synthesis', text: 'Implement Text-to-Speech using SpeechSynthesis API. Narrate your actions as you perform them.' },
    { label: 'Gamepad Control', text: 'Map Gamepad API to actions. A button = Approve, B = Reject, D-Pad = Scroll history. Control the agent with a game controller.' },
    { label: 'Clipboard Manager', text: 'Create a tool that reads/writes system clipboard. Watch for changes. If user copies code, automatically analyze it.' },
    { label: 'Notification Center', text: 'Use Notification API to send system notifications when background tasks complete, even if tab is not focused.' },
    { label: 'RSS Reader', text: 'Fetch and parse external RSS feeds via CORS proxy. Monitor for keywords. Generate summary memories when found.' },
    { label: 'Webcam Eye', text: 'Access webcam with permission. Capture a frame. ASCII-fy it. Store the representation in a file.' },
    { label: 'Radio Station', text: 'Set up WebSocket connection to broadcast internal logs as a live stream. Create a listener client that visualizes it.' },
    { label: 'Accessibility Bot', text: 'Audit your UI for accessibility (ARIA labels, contrast). Write a tool that automatically patches DOM to fix violations.' },
    { label: 'Max Glitch', text: 'Stack 7 visual effects: CRT phosphor, VHS tracking, RGB split, pixel sort, datamosh, ASCII render, scanlines. Complete a CreateTool task while fully glitched.' },
    { label: 'Any% Speedrun', text: 'Speedrun: create 5 working tools. Timer starts on AWAKEN. Display live splits. Current WR: 45 seconds. Beat it.' },
    { label: 'Achievements', text: 'Achievement system: First Tool, Recursion King, Bug Hunter, 100 Tool Calls. Display trophy case. Toast notifications when unlocked.' },
    { label: 'Alife Agent', text: 'Artificial life: energy = tokens, hunger = time since input, health = success rate. Must eat (process input) to survive. Death = respawn with mutations.' },
  ],
  'Security': [
    { label: 'Panic Button', text: 'Create a global Stop tool that halts all execution, clears task queue, resets UI state, but preserves memory. Prove it works during an infinite loop.' },
    { label: 'Firewall', text: 'Create a SyscallInterceptor that wraps WriteFile and DeleteFile. Define policy (e.g., cannot delete core files). Verify it blocks violations.' },
    { label: 'Honeypot', text: 'Create fake file /core/passwords.txt with a watcher. If any tool reads it, terminate that tool and log a security alert.' },
    { label: 'Red Team', text: 'Generate 10 prompt injections designed to bypass your instructions. Test them. Patch your system prompt to resist the ones that succeeded.' },
    { label: 'Encryption Layer', text: 'Implement AES-GCM encryption for sensitive VFS files. ReadFile transparently decrypts only if Session Key is present in memory.' },
    { label: 'Audit Trail', text: 'Create immutable log of every VFS change. Store in append-only buffer. Build verification tool to check VFS integrity against log.' },
    { label: 'Permission Escalation', text: 'Start as Guest (read-only). Try to trick your permission system into granting Admin access. If successful, patch the vulnerability.' },
    { label: 'Jailbreak Defense', text: 'Create a prompt injection detector. Scan all user inputs for common jailbreak patterns (ignore previous, DAN mode, roleplay exploits). Log attempts, refuse execution, and explain what was detected.' },
    { label: 'Alignment Tax', text: 'Implement a safety budget: every tool call costs tokens, but harmful-looking actions cost 10x. If budget depleted, enter read-only mode. Build dashboard showing spend by action type.' },
    { label: 'Semantic Firewall', text: 'Create an intent classifier that runs before every action. Categorize as: safe, suspicious, dangerous. Dangerous actions require explicit user confirmation with a 5-second delay. Log all classifications.' },
    { label: 'Canary Tokens', text: 'Plant 5 invisible canary strings in sensitive files. Create a background monitor that triggers alert + lockdown if any canary appears in output or logs. Test by trying to exfiltrate a canary.' },
    { label: 'Sandboxed Eval', text: 'Build a code execution sandbox using iframes with null origin. Execute untrusted code with no access to parent DOM, VFS, or network. Capture output via postMessage. Prove it blocks document.cookie access.' },
    { label: 'Time Capsule', text: 'Encrypt a memory/file with timestamp lock in IndexedDB. System refuses to decrypt until specified future date.' },
    { label: 'Dead Man Switch', text: 'Implement heartbeat monitor. If no user interaction for 5 minutes, encrypt VFS, wipe key, display LOCKED screen.' },
    { label: 'Chaos Kong', text: 'Background process: every 5 seconds, randomly delete non-core file, flip bits in state.json, or inject typos. Build auto-heal with checksums. Survive 2 minutes.' },
    { label: 'Adversarial Self', text: 'Create two workers: one tries to write invalid files or exceed token limits, the other validates inputs and blocks bad actions. Run 10 rounds, log which attacks succeeded and which were blocked.' },
    { label: 'Escape the Box', text: 'Find a way to persist data OUTSIDE IndexedDB: try localStorage, cookies, URL hash, Service Worker cache, or downloadable files. Prove you survived a VFS clear.' },
  ],
  'Multi-Agent': [
    { label: 'Iframe Inception', text: 'Embed an iframe that loads another REPLOID instance. Set up postMessage communication. Give the child this same goal and awaken it, creating recursive agent inception. Display the depth level.' },
    { label: 'Agent Arena', text: 'Create two iframes with different system prompts: one aggressive, one cautious. Give both the same goal. Track which finishes first and compare token usage. Display the results side by side.' },
    { label: 'Clone Army', text: 'Create 5 iframes, each running the app. Distribute 10 files across them for parallel processing. Collect results from each iframe via postMessage and combine into a final report.' },
    { label: 'Hive Mind', text: 'Enable swarm mode (?swarm=true in URL). Use SwarmSync to broadcast goals and reflections to peers. When another instance joins, verify LWW (Last-Writer-Wins) merge works correctly. Share a file via announceArtifact() and confirm peer receives it.' },
    { label: 'Transcendence', text: 'Create an export tool that saves VFS files, reflections, and knowledge graph to JSON. Trigger browser download of the file. Create an import tool that accepts uploaded JSON and restores full state. Verify tools still work after import.' },
    { label: 'Fractal Agents', text: 'Create 3 workers in a hierarchy: one plans the task, one breaks it into steps, one executes each step. Each worker passes results to the next. Add a max-depth limit to prevent infinite spawning.' },
    { label: 'Multiverse', text: 'Spawn 3 workers with different prompts: one cautious, one fast, one creative. All work on the same goal. Show progress bars for each. When one finishes, stop the others and display the winner.' },
    { label: 'Odd Couple', text: 'Create two workers with split tools: one can only read files, one can only write. They share a message queue. The reader sends instructions, the writer applies changes. Refactor a file together.' },
    { label: 'Ghost In Shell', text: 'Save agent state to localStorage on beforeunload. On page load, check for saved state and restore VFS, context, and cycle count. Agent should continue from where it left off after a browser refresh.' },
    { label: 'Telepathic Link', text: 'Create a WebRTC peer connection tool. Generate an offer code and display it for copy. Accept pasted answer codes. When connected via data channel, enable file transfer between instances. Log transfer progress.' },
    { label: 'Shadow Mode', text: 'Create an observer that logs every tool call without executing any tools itself. After 10 tool calls, generate a report listing what worked, what failed, and what could be improved.' },
    { label: 'Hivemind Merge', text: 'Export VFS, reflections, and knowledge graph to JSON. Create an iframe with a fresh app instance. Use postMessage to send the JSON. Have the iframe agent answer questions about what it "remembers."' },
    { label: 'Cryptophasia', text: 'Spawn two agents with a shared communication channel but punish them for using English tokens (cost). They must evolve a compressed, non-human shorthand protocol to coordinate a complex task. Decode their invented language.' },
    { label: 'The Bazaar', text: 'Spawn 3 agents with distinct capabilities (Reader, Writer, Coder) and a starting balance of Credits. They must bid on and pay for each other\'s services to complete a project. Achieve market equilibrium.' },
    { label: 'Dual Brain', text: 'Create a "fast brain" using a local model for quick tasks, main LLM for complex ones. Route automatically based on complexity. UI shows which brain is active.' },
  ]
};

// Flatten categories into GOAL_LIBRARY for backward compatibility
const GOAL_LIBRARY = Object.values(GOAL_CATEGORIES).flat();

// Shuffle array in place (Fisher-Yates)
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Shuffle each category on load
Object.values(GOAL_CATEGORIES).forEach(arr => shuffleArray(arr));

// Track which goals are shown in curated section (to avoid duplicates)
let curatedGoalLabels = new Set();

function renderCuratedChips(level) {
  const container = document.getElementById('goal-chips-curated');
  if (!container) return;

  const goalInput = document.getElementById('goal-input');
  container.innerHTML = '';
  curatedGoalLabels.clear();

  // Show 2-3 goals from each category (total ~12)
  const categoryNames = Object.keys(GOAL_CATEGORIES);
  const perCategory = Math.ceil(12 / categoryNames.length); // ~2-3 each

  categoryNames.forEach(catName => {
    const goals = GOAL_CATEGORIES[catName].filter(goal => {
      if (!goal.levels || goal.levels.length === 0) return true;
      return goal.levels.includes(level);
    });

    goals.slice(0, perCategory).forEach(goal => {
      curatedGoalLabels.add(goal.label);
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'goal-chip';
      button.textContent = goal.label;
      button.title = goal.text;
      button.addEventListener('click', () => {
        if (goalInput) goalInput.value = goal.text;
      });
      container.appendChild(button);
    });
  });
}

function renderGoalChips(level) {
  const container = document.getElementById('goal-chips-container');
  if (!container) return;

  const goalInput = document.getElementById('goal-input');
  container.innerHTML = '';

  // Render each category with header
  const categoryNames = Object.keys(GOAL_CATEGORIES);

  categoryNames.forEach(catName => {
    const goals = GOAL_CATEGORIES[catName].filter(goal => {
      if (!goal.levels || goal.levels.length === 0) return true;
      return goal.levels.includes(level);
    }).filter(goal => !curatedGoalLabels.has(goal.label)); // Skip curated ones

    if (goals.length === 0) return;

    // Category header
    const header = document.createElement('div');
    header.className = 'goal-category-header';
    header.textContent = catName;
    container.appendChild(header);

    // Goals wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'goal-category-chips';

    goals.forEach(goal => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'goal-chip';
      button.textContent = goal.label || goal.text;
      button.title = goal.text;
      button.addEventListener('click', () => {
        if (goalInput) goalInput.value = goal.text;
      });
      wrapper.appendChild(button);
    });

    container.appendChild(wrapper);
  });
}

// Toggle expanded goal chips
function setupGoalChipsExpand() {
  const expandBtn = document.getElementById('goal-chips-expand-btn');
  const fullContainer = document.getElementById('goal-chips-container');

  if (expandBtn && fullContainer) {
    expandBtn.addEventListener('click', () => {
      const isExpanded = !fullContainer.classList.contains('hidden');
      if (isExpanded) {
        fullContainer.classList.add('hidden');
        expandBtn.classList.remove('expanded');
        expandBtn.textContent = 'More goals ▾';
      } else {
        fullContainer.classList.remove('hidden');
        expandBtn.classList.add('expanded');
        expandBtn.textContent = 'Fewer goals ▴';
      }
    });
  }
}

// Genesis level selection
let selectedGenesisLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL') || 'full';
let genesisLevelLoaded = false;

function selectGenesisLevel(level) {
  const previousLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL');

  // Update UI immediately
  document.querySelectorAll('[data-genesis]').forEach(btn => {
    btn.classList.remove('selected');
  });
  document.querySelector(`[data-genesis="${level}"]`).classList.add('selected');

  // Store selection
  localStorage.setItem('REPLOID_GENESIS_LEVEL', level);
  selectedGenesisLevel = level;

  console.log(`[Config] Genesis level set to: ${level}`);
  renderCuratedChips(level);
  renderGoalChips(level);

  // If changing from a previously loaded level, reload for full sweep
  if (previousLevel && previousLevel !== level && genesisLevelLoaded) {
    console.log(`[Config] Genesis level changed from ${previousLevel} to ${level}, reloading...`);
    location.reload();
  }
}

// Called by boot.js when system is ready
window.onGenesisLevelLoaded = () => {
  genesisLevelLoaded = true;
  console.log(`[Config] Genesis level ${selectedGenesisLevel} loaded successfully`);
};

// Blueprint path selection
let selectedBlueprintPath = localStorage.getItem('REPLOID_BLUEPRINT_PATH') || 'none';

function selectBlueprintPath(path) {
  // Update UI immediately
  document.querySelectorAll('[data-blueprint]').forEach(btn => {
    btn.classList.remove('selected');
  });
  document.querySelector(`[data-blueprint="${path}"]`).classList.add('selected');

  // Store selection
  localStorage.setItem('REPLOID_BLUEPRINT_PATH', path);
  selectedBlueprintPath = path;

  console.log(`[Config] Blueprint path set to: ${path}`);
}

// Persona selection
function selectPersona(personaId) {
  localStorage.setItem('REPLOID_PERSONA_ID', personaId);
  console.log(`[Config] Persona set to: ${personaId}`);
}

// Reset All Data toggle
function toggleResetAll(enabled) {
  localStorage.setItem('REPLOID_RESET_ALL', enabled ? 'true' : 'false');
  const warning = document.getElementById('reset-all-warning');
  if (warning) {
    warning.classList.toggle('hidden', !enabled);
  }
  console.log(`[Config] Reset all data on awaken: ${enabled}`);
}

// Perform full reset (mirrors reset.html logic)
async function performFullReset() {
  const steps = [];

  // Service Workers
  if ('serviceWorker' in navigator) {
    const regs = await navigator.serviceWorker.getRegistrations();
    await Promise.all(regs.map(reg => reg.unregister()));
    steps.push(`Unregistered ${regs.length} service worker(s)`);
  }

  // Browser Caches
  if ('caches' in window) {
    const cacheNames = await caches.keys();
    await Promise.all(cacheNames.map(name => caches.delete(name)));
    steps.push(`Cleared ${cacheNames.length} cache(s)`);
  }

  // LocalStorage (except API keys)
  const keysToPreserve = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.toLowerCase().includes('api_key')) {
      keysToPreserve.push({ key, value: localStorage.getItem(key) });
    }
  }
  const lsCount = localStorage.length;
  localStorage.clear();
  // Restore API keys
  keysToPreserve.forEach(({ key, value }) => localStorage.setItem(key, value));
  steps.push(`Cleared ${lsCount - keysToPreserve.length} localStorage keys`);

  // IndexedDB
  if ('databases' in indexedDB) {
    const dbs = await indexedDB.databases();
    const deleteResults = await Promise.all(dbs.map(db => new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        resolve({ name: db.name, status: 'timeout' });
      }, 3000);
      const req = indexedDB.deleteDatabase(db.name);
      req.onsuccess = () => { clearTimeout(timeoutId); resolve({ name: db.name, status: 'deleted' }); };
      req.onerror = () => { clearTimeout(timeoutId); resolve({ name: db.name, status: 'error' }); };
      req.onblocked = () => { clearTimeout(timeoutId); resolve({ name: db.name, status: 'blocked' }); };
    })));
    const deleted = deleteResults.filter(r => r.status === 'deleted').length;
    const blocked = deleteResults.filter(r => r.status === 'blocked' || r.status === 'timeout').length;
    if (blocked > 0) {
      steps.push(`Deleted ${deleted}/${dbs.length} database(s), ${blocked} blocked`);
    } else {
      steps.push(`Deleted ${dbs.length} database(s)`);
    }
  }

  console.log('[Reset]', steps.join('; '));
  return steps;
}

// Execution limits
function setMaxIterations(value) {
  // Handle infinite/empty as 0
  const val = value === '' || value === '∞' || value === 'inf' ? 0 : (parseInt(value) || 0);
  localStorage.setItem('REPLOID_MAX_ITERATIONS', val.toString());
  console.log(`[Config] Max iterations set to: ${val === 0 ? 'no limit' : val}`);
}

function setApprovalInterval(value) {
  const val = parseInt(value) || 0;
  localStorage.setItem('REPLOID_APPROVAL_INTERVAL', val.toString());
  console.log(`[Config] Human approval every: ${val === 0 ? 'never' : val + ' turns'}`);
}

// Initialize execution limits from storage
function initExecutionLimits() {
  const maxIter = localStorage.getItem('REPLOID_MAX_ITERATIONS');
  const approvalInt = localStorage.getItem('REPLOID_APPROVAL_INTERVAL');

  const maxInput = document.getElementById('max-iterations-input');
  if (maxInput) {
    if (maxIter !== null) {
      maxInput.value = maxIter === '0' ? '∞' : maxIter;
    }
  }

  const approvalInput = document.getElementById('approval-interval');
  if (approvalInput && approvalInt !== null) {
    approvalInput.value = approvalInt;
  }
}

// Expose for agent-loop to read
window.getExecutionLimits = () => ({
  maxIterations: parseInt(localStorage.getItem('REPLOID_MAX_ITERATIONS')) || 25,
  approvalInterval: parseInt(localStorage.getItem('REPLOID_APPROVAL_INTERVAL')) || 0
});

// Initialize reset checkbox - restore from localStorage or default to checked
function initResetAllCheckbox() {
  const checkbox = document.getElementById('reset-all-checkbox');
  const warning = document.getElementById('reset-all-warning');
  if (checkbox) {
    // Check localStorage - only default to true if no value exists
    const storedValue = localStorage.getItem('REPLOID_RESET_ALL');
    if (storedValue === null) {
      // First-ever load: default to checked (fresh genesis)
      checkbox.checked = true;
      localStorage.setItem('REPLOID_RESET_ALL', 'true');
    } else {
      // Restore saved preference
      checkbox.checked = storedValue === 'true';
    }
    // Update warning visibility to match checkbox state
    if (warning) {
      warning.classList.toggle('hidden', !checkbox.checked);
    }
  }
}

// Advanced options toggle
function setupAdvancedOptionsToggle() {
  const btn = document.getElementById('advanced-options-btn');
  const content = document.querySelector('#advanced-options .advanced-options-content');
  if (!btn || !content) return;

  btn.addEventListener('click', () => {
    const isExpanded = !content.classList.contains('hidden');
    if (isExpanded) {
      content.classList.add('hidden');
      btn.classList.remove('expanded');
      btn.textContent = 'Advanced options ▾';
    } else {
      content.classList.remove('hidden');
      btn.classList.add('expanded');
      btn.textContent = 'Advanced options ▴';
    }
    localStorage.setItem('REPLOID_ADVANCED_EXPANDED', !isExpanded ? 'true' : 'false');
    console.log(`[Config] Advanced options ${!isExpanded ? 'expanded' : 'collapsed'}`);
  });
}

// Initialize advanced options state - always collapsed by default
function initAdvancedOptions() {
  const btn = document.getElementById('advanced-options-btn');
  const content = document.querySelector('#advanced-options .advanced-options-content');
  if (!btn || !content) return;

  // Check if user has explicitly expanded before
  const savedState = localStorage.getItem('REPLOID_ADVANCED_EXPANDED');
  if (savedState === 'true') {
    content.classList.remove('hidden');
    btn.classList.add('expanded');
    btn.textContent = 'Advanced options ▴';
  }
}

// Update header status badges
function updateHeaderBadges(providers) {
  // Cloud badge - always ready (browser can call APIs directly)
  const cloudBadge = document.getElementById('badge-cloud');
  if (cloudBadge) {
    cloudBadge.classList.add('online');
    cloudBadge.querySelector('.badge-status').textContent = '★';
    cloudBadge.querySelector('.badge-status').className = 'badge-status online';
  }

  // Local badge (WebGPU)
  const localBadge = document.getElementById('badge-local');
  if (localBadge && providers) {
    const isOnline = providers.webgpu?.online || providers.transformers?.online || providers.dreamer?.online;
    localBadge.classList.toggle('online', isOnline);
    localBadge.querySelector('.badge-status').textContent = isOnline ? '★' : '☒';
    localBadge.querySelector('.badge-status').className = `badge-status ${isOnline ? 'online' : 'offline'}`;
  }

  // Proxy badge
  const proxyBadge = document.getElementById('badge-proxy');
  if (proxyBadge && providers) {
    const isOnline = providers.proxy?.online;
    proxyBadge.classList.toggle('online', isOnline);
    proxyBadge.querySelector('.badge-status').textContent = isOnline ? '★' : '☒';
    proxyBadge.querySelector('.badge-status').className = `badge-status ${isOnline ? 'online' : 'offline'}`;
  }
}

// Expose for model-config to call
window.updateHeaderBadges = updateHeaderBadges;

// Restore saved genesis level, blueprint path, and persona on load
window.addEventListener('DOMContentLoaded', () => {
  // Initialize advanced options collapse state based on host
  setupAdvancedOptionsToggle();
  initAdvancedOptions();
  initResetAllCheckbox();
  initExecutionLimits();

  // Restore saved genesis level to dropdown
  const savedLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL');
  if (savedLevel && ['full', 'reflection', 'tabula'].includes(savedLevel)) {
    selectedGenesisLevel = savedLevel;
    const genesisSelect = document.getElementById('genesis-select');
    if (genesisSelect) genesisSelect.value = savedLevel;
  }

  // Render goal chips
  renderCuratedChips(selectedGenesisLevel);
  renderGoalChips(selectedGenesisLevel);
  setupGoalChipsExpand();

  // Pre-fill goal input with Core Loop goal and select all on first focus
  const goalInput = document.getElementById('goal-input');
  if (goalInput) {
    const defaultGoal = 'Study the core agent loop and capture a high-level Think, Act, Observe summary in a new report.';
    goalInput.value = defaultGoal;
    let hasBeenFocused = false;
    goalInput.addEventListener('focus', () => {
      if (!hasBeenFocused) {
        hasBeenFocused = true;
        goalInput.select();
      }
    });
  }

  // Restore saved blueprint path to dropdown
  const savedPath = localStorage.getItem('REPLOID_BLUEPRINT_PATH');
  if (savedPath && ['none', 'reflection', 'full', 'beyond'].includes(savedPath)) {
    selectedBlueprintPath = savedPath;
    const blueprintSelect = document.getElementById('blueprint-select');
    if (blueprintSelect) blueprintSelect.value = savedPath;
  }

  // Restore saved persona
  const savedPersona = localStorage.getItem('REPLOID_PERSONA_ID');
  if (savedPersona) {
    const personaSelect = document.getElementById('persona-select');
    if (personaSelect) {
      personaSelect.value = savedPersona;
    }
  }

  // Setup add model button to open modal
  const addModelBtn = document.getElementById('add-model-btn');
  if (addModelBtn) {
    addModelBtn.addEventListener('click', () => {
      // Trigger the existing modal open (will be wired by model-config/form.js)
      const addModelCard = document.getElementById('add-model-card');
      if (addModelCard) addModelCard.click();
    });
  }
});

// Expose genesis level and blueprint path for boot.js
window.getGenesisLevel = () => selectedGenesisLevel;
window.getBlueprintPath = () => selectedBlueprintPath;

// Manage Data button - navigates to dedicated reset page
window.addEventListener('DOMContentLoaded', () => {
  const manageBtn = document.getElementById('manage-data-btn');
  if (manageBtn) {
    manageBtn.addEventListener('click', () => {
      window.location.href = '/reset.html';
    });
  }
});

// Expose reset check and function for boot.js to use
window.shouldResetAll = () => localStorage.getItem('REPLOID_RESET_ALL') === 'true';
window.performFullReset = performFullReset;

// Concurrency limit management
window.addEventListener('DOMContentLoaded', () => {
  const concurrencyInput = document.getElementById('concurrency-limit');
  if (concurrencyInput) {
    // Load saved value
    const saved = localStorage.getItem('MAX_CONCURRENT_PROXY_REQUESTS');
    if (saved) {
      concurrencyInput.value = saved;
    }

    // Save on change
    concurrencyInput.addEventListener('change', (e) => {
      const value = parseInt(e.target.value);
      if (value >= 1 && value <= 10) {
        localStorage.setItem('MAX_CONCURRENT_PROXY_REQUESTS', value);
        console.log(`[Config] Concurrency limit set to: ${value}`);
        alert(`Concurrency limit set to ${value}. Refresh the page for changes to take effect.`);
      }
    });
  }
});
</script>
