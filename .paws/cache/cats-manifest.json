{
  "version": 1,
  "generatedAt": "2025-11-21T19:12:00.858Z",
  "entries": {
    "vitest.config.js": {
      "meta": {
        "mtimeMs": 1763677825556.2888,
        "size": 374,
        "binary": false
      },
      "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    include: ['tests/**/*.test.js'],\n    environment: 'happy-dom',\n    globals: true,\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'html'],\n      thresholds: {\n        lines: 60,\n        functions: 60,\n        branches: 60,\n        statements: 60\n      }\n    }\n  }\n});\n",
      "hash": "b249a2669f32c2c800175c85168c22275a3297f4a467335d1703eedab2b0de20"
    },
    "playwright.config.js": {
      "meta": {
        "mtimeMs": 1760620334378.805,
        "size": 1124,
        "binary": false
      },
      "content": "// Playwright E2E Test Configuration\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests/e2e',\n  fullyParallel: false, // Run tests sequentially for Sentinel Agent flow\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: 1, // Single worker for sequential execution\n  reporter: 'html',\n  timeout: 60000, // 60 seconds per test (default is 30s)\n  expect: {\n    timeout: 10000, // 10 seconds for assertions\n  },\n\n  use: {\n    baseURL: 'http://localhost:8000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n    actionTimeout: 15000, // 15 seconds for actions like click, fill\n    navigationTimeout: 30000, // 30 seconds for page navigations\n  },\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n  ],\n\n  // Start local dev server before tests\n  webServer: {\n    command: 'python3 -m http.server 8000',\n    url: 'http://localhost:8000',\n    reuseExistingServer: !process.env.CI,\n    timeout: 10000,\n    stderr: 'pipe',\n    stdout: 'pipe',\n  },\n});\n",
      "hash": "9e0d63522ce71c920ac7b769319ff1c5432078eb823fa9f2825cdbbecf4ab1de"
    },
    "boot.js": {
      "meta": {
        "mtimeMs": 1763734924949.5955,
        "size": 9882,
        "binary": false
      },
      "content": "/**\n * @fileoverview REPLOID Bootstrapper\n * Initializes the Dependency Injection container and starts the agent.\n */\n\nimport Utils from './core/utils.js';\nimport DIContainer from './infrastructure/di-container.js';\nimport EventBus from './infrastructure/event-bus.js';\nimport AuditLogger from './infrastructure/audit-logger.js';\nimport RateLimiter from './infrastructure/rate-limiter.js';\n\nimport VFS from './core/vfs.js';\nimport StateManager from './core/state-manager.js';\nimport StateHelpersPure from './core/state-helpers-pure.js';\n\nimport LLMClient from './core/llm-client.js';\nimport TransformersClient from './core/transformers-client.js';\nimport ResponseParser from './core/response-parser.js';\nimport ContextManager from './core/context-manager.js';\nimport VerificationManager from './core/verification-manager.js';\n\nimport ToolRunner from './core/tool-runner.js';\nimport ToolWriter from './core/tool-writer.js';\nimport MetaToolWriter from './core/meta-tool-writer.js';\n\nimport AgentLoop from './core/agent-loop.js';\nimport PersonaManager from './core/persona-manager.js';\nimport SubstrateLoader from './core/substrate-loader.js';\n\nimport ReflectionStore from './capabilities/reflection/reflection-store.js';\nimport ReflectionAnalyzer from './capabilities/reflection/reflection-analyzer.js';\nimport PerformanceMonitor from './capabilities/performance/performance-monitor.js';\nimport SelfTester from './capabilities/testing/self-tester.js';\n\n// Boot UI (model config, provider detection)\nimport { initModelConfig } from './ui/boot/model-config/index.js';\n\n// UI Imports (Dynamic to allow headless boot)\n// import Dashboard from './ui/dashboard.js';\n\n(async () => {\n  const logger = Utils.factory().logger;\n  logger.info('[Boot] Starting REPLOID System...');\n\n  // Initialize boot screen UI (provider detection, model selector)\n  initModelConfig();\n\n  try {\n    // 1. Load Configuration\n    const configResponse = await fetch('./config/genesis-levels.json');\n    if (!configResponse.ok) throw new Error('Failed to load genesis configuration');\n    const genesisConfig = await configResponse.json();\n\n    // 2. Initialize Infrastructure\n    const container = DIContainer.factory({ Utils: Utils.factory() });\n\n    // Get genesis level from localStorage (set by boot UI)\n    const genesisLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL') || genesisConfig.default;\n    const levelConfig = genesisConfig.levels[genesisLevel];\n\n    if (!levelConfig) {\n      throw new Error(`Unknown genesis level: ${genesisLevel}`);\n    }\n\n    logger.info(`[Boot] Genesis level: ${levelConfig.name}`);\n\n    // Module registry mapping names to imports\n    const moduleRegistry = {\n      Utils, EventBus, RateLimiter, VFS, StateHelpersPure, AuditLogger,\n      StateManager, LLMClient, TransformersClient, ResponseParser, ContextManager, VerificationManager,\n      ToolWriter, MetaToolWriter, ToolRunner, PersonaManager, ReflectionStore,\n      ReflectionAnalyzer, AgentLoop, SubstrateLoader, PerformanceMonitor, SelfTester\n    };\n\n    // Register modules based on genesis level config\n    const registerModules = (moduleNames, category) => {\n      for (const name of moduleNames) {\n        if (moduleRegistry[name]) {\n          container.register(moduleRegistry[name]);\n        } else {\n          logger.warn(`[Boot] Module not found in registry: ${name}`);\n        }\n      }\n      logger.info(`[Boot] Registered ${moduleNames.length} ${category} modules`);\n    };\n\n    // Register all module categories from config\n    registerModules(levelConfig.modules.foundation, 'foundation');\n    registerModules(levelConfig.modules.storage, 'storage');\n    registerModules(levelConfig.modules.services, 'services');\n    registerModules(levelConfig.modules.tools, 'tools');\n    registerModules(levelConfig.modules.agent, 'agent');\n\n    // Register capabilities (varies by genesis level)\n    if (levelConfig.modules.capabilities.length > 0) {\n      registerModules(levelConfig.modules.capabilities, 'capabilities');\n    } else {\n      logger.info('[Boot] No additional capabilities for this genesis level');\n    }\n\n    // 3. Boot Sequence\n    logger.info('[Boot] Resolving dependencies...');\n\n    // Force resolution of critical services to trigger their init()\n    const vfs = await container.resolve('VFS');\n\n    const seedCodeIntel = async () => {\n      const toolPath = '/tools/code_intel.js';\n      if (await vfs.exists(toolPath)) return;\n\n      logger.info('[Boot] Seeding code_intel tool...');\n      try {\n        const toolResp = await fetch('./tools/code_intel.js');\n        if (!toolResp.ok) {\n          logger.warn('[Boot] code_intel.js not found on server, skipping seed.');\n          return;\n        }\n        const toolCode = await toolResp.text();\n        await vfs.write(toolPath, toolCode);\n        logger.info('[Boot] Seeding complete: code_intel.js');\n      } catch (e) {\n        logger.error('[Boot] Failed to seed code_intel', e);\n      }\n    };\n\n    await seedCodeIntel();\n    await seedWorkspaceFiles(vfs, genesisConfig);\n\n    await container.resolve('StateManager');\n    await container.resolve('ToolRunner');\n\n    const agent = await container.resolve('AgentLoop');\n\n    // Expose global for debugging (and for dynamic tools to access system)\n    window.REPLOID = {\n      container,\n      agent,\n      utils: Utils.factory(),\n      vfs: await container.resolve('VFS')\n    };\n\n    logger.info('[Boot] Core System Ready.');\n\n    // Notify UI that genesis level is loaded\n    if (window.onGenesisLevelLoaded) {\n      window.onGenesisLevelLoaded();\n    }\n\n    // 4. UI Initialization - wait for user to click Awaken\n    const awakenBtn = document.getElementById('awaken-btn');\n    if (awakenBtn) {\n      // Enable the button now that system is ready\n      awakenBtn.disabled = false;\n      awakenBtn.textContent = 'Awaken Agent';\n\n      awakenBtn.addEventListener('click', async () => {\n        try {\n          // Save goal from boot screen\n          const goalInput = document.getElementById('goal-input');\n          const goal = goalInput?.value?.trim() || '';\n          if (goal) {\n            localStorage.setItem('REPLOID_GOAL', goal);\n          }\n\n          const { default: Dashboard } = await import('./ui/dashboard.js');\n          const dashboard = Dashboard.factory({\n            Utils: Utils.factory(),\n            EventBus: await container.resolve('EventBus'),\n            AgentLoop: agent,\n            StateManager: await container.resolve('StateManager')\n          });\n\n          // Remove boot screen before mounting dashboard\n          const bootContainer = document.getElementById('boot-container');\n          if (bootContainer) {\n            bootContainer.remove();\n          }\n\n          dashboard.mount(document.getElementById('app'));\n\n          // Pass VFS to dashboard for browser\n          dashboard.setVFS(vfs);\n\n          // Wire up refresh button\n          const refreshBtn = document.getElementById('vfs-refresh');\n          if (refreshBtn) {\n            refreshBtn.onclick = () => dashboard.refreshVFS();\n          }\n\n          logger.info('[Boot] UI Mounted.');\n\n          // Auto-start the agent if goal is set\n          if (goal) {\n            // Get model config from localStorage\n            const savedModels = localStorage.getItem('SELECTED_MODELS');\n            if (savedModels) {\n              const models = JSON.parse(savedModels);\n              if (models.length > 0) {\n                agent.setModel(models[0]);\n              }\n            }\n\n            logger.info('[Boot] Starting agent with goal: ' + goal);\n            agent.run(goal).catch(e => {\n              logger.error('[Boot] Agent error: ' + e.message);\n            });\n          }\n        } catch (e) {\n          logger.error('[Boot] UI failed to load', {\n            message: e.message,\n            stack: e.stack\n          });\n        }\n      });\n    } else {\n      // Headless mode - no awaken button\n      logger.warn('[Boot] Running in headless mode (no awaken button)');\n    }\n\n  } catch (err) {\n    const logger = Utils.factory().logger;\n    logger.error('[Boot] CRITICAL BOOT FAILURE', err);\n    document.body.innerHTML = `<div style=\"color:red; padding:20px;\">\n      <h1>System Crash</h1>\n      <pre>${err.stack || err.message}</pre>\n    </div>`;\n  }\n})();\n\nasync function seedWorkspaceFiles(vfs, genesisConfig) {\n  try {\n    const logger = Utils.factory().logger;\n    const filesToSeed = new Set(Object.values(genesisConfig?.moduleImports || {}));\n    filesToSeed.add('./boot.js');\n    filesToSeed.add('./index.html');\n    filesToSeed.add('./tools/code_intel.js');\n\n    for (const file of filesToSeed) {\n      const webPath = toWebPath(file);\n      const vfsPath = webPath.replace(/^\\.\\//, '/');\n      const needsHydration = await shouldHydrateFile(vfs, vfsPath);\n      if (!needsHydration) continue;\n\n      try {\n        const resp = await fetch(webPath);\n        if (!resp.ok) {\n          logger.warn(`[Boot] Failed to fetch ${webPath} (${resp.status})`);\n          continue;\n        }\n        const contents = await resp.text();\n        await vfs.write(vfsPath, contents);\n        logger.info(`[Boot] Hydrated ${vfsPath}`);\n      } catch (err) {\n        logger.warn(`[Boot] Failed to hydrate ${webPath}`, err);\n      }\n    }\n\n    // Helper ensures VFS path is considered\n    function toWebPath(path) {\n      if (path.startsWith('./')) return path;\n      if (path.startsWith('/')) return `.${path}`;\n      return `./${path}`;\n    }\n\n    async function shouldHydrateFile(vfs, path) {\n      if (!(await vfs.exists(path))) return true;\n      if (path !== '/tools/code_intel.js') return false;\n      try {\n        const code = await vfs.read(path);\n        return code.includes('import { z');\n      } catch {\n        return true;\n      }\n    }\n  } catch (err) {\n    const logger = Utils.factory().logger;\n    logger.warn('[Boot] Workspace hydration skipped', err);\n  }\n}\n",
      "hash": "f0eae71804345ac24667c5be2941cbc77f0841abd270e9f1e31692b50e628b79"
    },
    "server/signaling-server.js": {
      "meta": {
        "mtimeMs": 1760624216627.1802,
        "size": 9204,
        "binary": false
      },
      "content": "#!/usr/bin/env node\n\n/**\n * WebRTC Signaling Server for PAWS/REPLOID Swarm\n *\n * Enables peer-to-peer WebRTC connections across different origins\n * by providing a centralized signaling channel via WebSockets.\n *\n * Features:\n * - WebSocket-based signaling (replaces BroadcastChannel)\n * - Room-based peer discovery\n * - Automatic peer cleanup on disconnect\n * - Heartbeat monitoring\n * - CORS-aware for cross-origin support\n */\n\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { EventEmitter } from 'events';\n\nclass SignalingServer extends EventEmitter {\n  constructor(server, options = {}) {\n    super();\n\n    this.options = {\n      path: options.path || '/signaling',\n      heartbeatInterval: options.heartbeatInterval || 30000,\n      peerTimeout: options.peerTimeout || 60000,\n      ...options\n    };\n\n    // WebSocket server\n    this.wss = new WebSocketServer({\n      server,\n      path: this.options.path\n    });\n\n    // Room management\n    this.rooms = new Map(); // roomId -> Set<peerId>\n    this.peers = new Map(); // peerId -> { ws, metadata, lastSeen, roomId }\n\n    // Setup WebSocket handlers\n    this.wss.on('connection', (ws, req) => this.handleConnection(ws, req));\n\n    // Setup heartbeat monitoring\n    this.startHeartbeatMonitor();\n\n    console.log(`[SignalingServer] WebRTC signaling server started on ${this.options.path}`);\n  }\n\n  handleConnection(ws, req) {\n    console.log(`[SignalingServer] New connection from ${req.socket.remoteAddress}`);\n\n    let peerId = null;\n    let roomId = null;\n\n    // Handle incoming messages\n    ws.on('message', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.handleMessage(ws, message, { peerId, roomId });\n\n        // Update peerId and roomId if they changed\n        if (message.type === 'join') {\n          peerId = message.peerId;\n          roomId = message.roomId;\n        }\n      } catch (error) {\n        console.error('[SignalingServer] Failed to parse message:', error);\n        this.sendError(ws, 'Invalid message format');\n      }\n    });\n\n    // Handle disconnection\n    ws.on('close', () => {\n      if (peerId) {\n        console.log(`[SignalingServer] Peer ${peerId} disconnected`);\n        this.removePeer(peerId, roomId);\n      }\n    });\n\n    // Handle errors\n    ws.on('error', (error) => {\n      console.error(`[SignalingServer] WebSocket error for peer ${peerId}:`, error);\n    });\n\n    // Send welcome message\n    this.sendMessage(ws, {\n      type: 'welcome',\n      timestamp: Date.now()\n    });\n  }\n\n  handleMessage(ws, message, context) {\n    const { type } = message;\n\n    switch (type) {\n      case 'join':\n        this.handleJoin(ws, message);\n        break;\n\n      case 'leave':\n        this.handleLeave(message);\n        break;\n\n      case 'offer':\n      case 'answer':\n      case 'ice-candidate':\n        this.handleSignaling(message);\n        break;\n\n      case 'announce':\n        this.handleAnnounce(message);\n        break;\n\n      case 'heartbeat':\n        this.handleHeartbeat(message);\n        break;\n\n      case 'broadcast':\n        this.handleBroadcast(message);\n        break;\n\n      default:\n        console.warn(`[SignalingServer] Unknown message type: ${type}`);\n    }\n  }\n\n  handleJoin(ws, message) {\n    const { peerId, roomId, metadata } = message;\n\n    if (!peerId || !roomId) {\n      return this.sendError(ws, 'Missing peerId or roomId');\n    }\n\n    console.log(`[SignalingServer] Peer ${peerId} joining room ${roomId}`);\n\n    // Remove peer from old room if exists\n    if (this.peers.has(peerId)) {\n      const oldPeer = this.peers.get(peerId);\n      this.removePeerFromRoom(peerId, oldPeer.roomId);\n    }\n\n    // Add peer to new room\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId).add(peerId);\n\n    // Store peer info\n    this.peers.set(peerId, {\n      ws,\n      metadata: metadata || {},\n      lastSeen: Date.now(),\n      roomId\n    });\n\n    // Notify peer of successful join\n    this.sendMessage(ws, {\n      type: 'joined',\n      peerId,\n      roomId,\n      peers: Array.from(this.rooms.get(roomId)).filter(id => id !== peerId)\n    });\n\n    // Notify other peers in room\n    this.broadcastToRoom(roomId, {\n      type: 'peer-joined',\n      peerId,\n      metadata\n    }, peerId);\n\n    this.emit('peer-joined', { peerId, roomId, metadata });\n  }\n\n  handleLeave(message) {\n    const { peerId, roomId } = message;\n\n    if (!peerId || !roomId) {\n      return;\n    }\n\n    console.log(`[SignalingServer] Peer ${peerId} leaving room ${roomId}`);\n    this.removePeer(peerId, roomId);\n  }\n\n  handleSignaling(message) {\n    const { targetPeer, peerId } = message;\n\n    if (!targetPeer) {\n      console.warn('[SignalingServer] Signaling message missing targetPeer');\n      return;\n    }\n\n    const peer = this.peers.get(targetPeer);\n    if (!peer) {\n      console.warn(`[SignalingServer] Target peer ${targetPeer} not found`);\n      return;\n    }\n\n    // Forward signaling message to target peer\n    this.sendMessage(peer.ws, message);\n\n    // Update sender's last seen\n    if (peerId && this.peers.has(peerId)) {\n      this.peers.get(peerId).lastSeen = Date.now();\n    }\n  }\n\n  handleAnnounce(message) {\n    const { peerId, roomId, metadata } = message;\n\n    if (!peerId || !roomId) {\n      return;\n    }\n\n    // Update peer metadata\n    const peer = this.peers.get(peerId);\n    if (peer) {\n      peer.metadata = { ...peer.metadata, ...metadata };\n      peer.lastSeen = Date.now();\n\n      // Broadcast announcement to room\n      this.broadcastToRoom(roomId, {\n        type: 'peer-announced',\n        peerId,\n        metadata: peer.metadata\n      }, peerId);\n    }\n  }\n\n  handleHeartbeat(message) {\n    const { peerId } = message;\n\n    if (!peerId) {\n      return;\n    }\n\n    const peer = this.peers.get(peerId);\n    if (peer) {\n      peer.lastSeen = Date.now();\n    }\n  }\n\n  handleBroadcast(message) {\n    const { peerId, roomId, data } = message;\n\n    if (!peerId || !roomId || !data) {\n      return;\n    }\n\n    // Broadcast message to all peers in room except sender\n    this.broadcastToRoom(roomId, {\n      type: 'broadcast',\n      peerId,\n      data\n    }, peerId);\n  }\n\n  removePeer(peerId, roomId) {\n    const peer = this.peers.get(peerId);\n\n    if (peer) {\n      // Remove from room\n      this.removePeerFromRoom(peerId, roomId || peer.roomId);\n\n      // Remove peer entry\n      this.peers.delete(peerId);\n\n      this.emit('peer-left', { peerId, roomId: roomId || peer.roomId });\n    }\n  }\n\n  removePeerFromRoom(peerId, roomId) {\n    if (!roomId) return;\n\n    const room = this.rooms.get(roomId);\n    if (room) {\n      room.delete(peerId);\n\n      // Notify other peers\n      this.broadcastToRoom(roomId, {\n        type: 'peer-left',\n        peerId\n      });\n\n      // Clean up empty rooms\n      if (room.size === 0) {\n        this.rooms.delete(roomId);\n        console.log(`[SignalingServer] Room ${roomId} is now empty, removed`);\n      }\n    }\n  }\n\n  broadcastToRoom(roomId, message, excludePeerId = null) {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    let sent = 0;\n    room.forEach(peerId => {\n      if (peerId !== excludePeerId) {\n        const peer = this.peers.get(peerId);\n        if (peer && peer.ws.readyState === WebSocket.OPEN) {\n          this.sendMessage(peer.ws, message);\n          sent++;\n        }\n      }\n    });\n\n    return sent;\n  }\n\n  sendMessage(ws, message) {\n    if (ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(JSON.stringify(message));\n      } catch (error) {\n        console.error('[SignalingServer] Failed to send message:', error);\n      }\n    }\n  }\n\n  sendError(ws, errorMessage) {\n    this.sendMessage(ws, {\n      type: 'error',\n      error: errorMessage,\n      timestamp: Date.now()\n    });\n  }\n\n  startHeartbeatMonitor() {\n    setInterval(() => {\n      const now = Date.now();\n      const staleThreshold = now - this.options.peerTimeout;\n\n      // find and remove stale peers\n      const stalePeers = [];\n      this.peers.forEach((peer, peerId) => {\n        if (peer.lastSeen < staleThreshold) {\n          stalePeers.push({ peerId, roomId: peer.roomId });\n        }\n      });\n\n      stalePeers.forEach(({ peerId, roomId }) => {\n        console.log(`[SignalingServer] Peer ${peerId} is stale, removing`);\n        this.removePeer(peerId, roomId);\n      });\n\n      if (stalePeers.length > 0) {\n        console.log(`[SignalingServer] Removed ${stalePeers.length} stale peers`);\n      }\n    }, this.options.heartbeatInterval);\n  }\n\n  getStats() {\n    return {\n      totalRooms: this.rooms.size,\n      totalPeers: this.peers.size,\n      rooms: Array.from(this.rooms.entries()).map(([roomId, peers]) => ({\n        roomId,\n        peerCount: peers.size,\n        peers: Array.from(peers)\n      }))\n    };\n  }\n\n  close() {\n    console.log('[SignalingServer] Shutting down signaling server');\n\n    // Notify all peers\n    this.peers.forEach(peer => {\n      this.sendMessage(peer.ws, {\n        type: 'server-shutdown'\n      });\n      peer.ws.close();\n    });\n\n    // Close WebSocket server\n    this.wss.close();\n\n    // Clear data structures\n    this.rooms.clear();\n    this.peers.clear();\n  }\n}\n\nexport default SignalingServer;\n",
      "hash": "78a3ea75d241870d2ffc2742ed99d697c334c67221e382c3e364280995a9e31e"
    },
    "server/proxy.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 39213,
        "binary": false
      },
      "content": "#!/usr/bin/env node\n\nimport express from 'express';\nimport http from 'http';\nimport path from 'path';\nimport fs from 'fs';\nimport dotenv from 'dotenv';\nimport { fileURLToPath } from 'url';\nimport { spawn, exec } from 'child_process';\nimport { promisify } from 'util';\nimport SignalingServer from './signaling-server.js';\nimport AgentBridge from './agent-bridge.js';\n\nconst execPromise = promisify(exec);\n\n// ESM equivalent of __dirname\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Load environment variables\ndotenv.config();\n\n// Load unified configuration\nlet appConfig = null;\ntry {\n  const { getConfig } = await import('../utils/config-loader.js');\n  const configLoader = getConfig();\n  configLoader.load();\n  appConfig = configLoader.getAll();\n  console.log('[Proxy] Loaded configuration from:', configLoader.getConfigPath() || 'defaults');\n} catch (err) {\n  console.warn('[Proxy] Config loader not available, using environment variables');\n}\n\nconst app = express();\nconst PORT = appConfig?.server?.port || process.env.PORT || 8000;\nconst GEMINI_API_KEY = appConfig?.api?.geminiKey || process.env.GEMINI_API_KEY;\nconst LOCAL_MODEL_ENDPOINT = appConfig?.api?.localEndpoint || process.env.LOCAL_MODEL_ENDPOINT || 'http://localhost:11434';\nconst OPENAI_API_KEY = appConfig?.api?.openaiKey || process.env.OPENAI_API_KEY;\nconst ANTHROPIC_API_KEY = appConfig?.api?.anthropicKey || process.env.ANTHROPIC_API_KEY;\nconst HUGGINGFACE_API_KEY = appConfig?.api?.huggingfaceKey || process.env.HUGGINGFACE_API_KEY;\nconst CORS_ORIGINS = appConfig?.server?.corsOrigins || ['http://localhost:8080'];\nconst AUTO_START_OLLAMA = appConfig?.ollama?.autoStart || process.env.AUTO_START_OLLAMA === 'true';\nconst SSE_DONE = 'data: [DONE]';\n\nif (!GEMINI_API_KEY) {\n  console.error('âš ï¸  WARNING: GEMINI_API_KEY not found in .env file');\n  console.error('   The Gemini proxy endpoint will not work without it.');\n}\n\nconsole.log('ðŸ”§ Available API providers:');\nif (GEMINI_API_KEY) console.log('   âœ… Google Gemini');\nif (OPENAI_API_KEY) console.log('   âœ… OpenAI');\nif (ANTHROPIC_API_KEY) console.log('   âœ… Anthropic');\nif (HUGGINGFACE_API_KEY) console.log('   âœ… HuggingFace');\nconsole.log(`   ðŸ–¥ï¸  Local models at: ${LOCAL_MODEL_ENDPOINT}`);\n\nconst setupSse = (res) => {\n  if (res.headersSent) return;\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n};\n\nconst streamBufferedText = (res, text = '') => {\n  setupSse(res);\n  const chunkSize = 256;\n  if (!text) {\n    res.write('data: {\"response\":\"\"}\\n\\n');\n    res.write(`${SSE_DONE}\\n\\n`);\n    return res.end();\n  }\n  for (let i = 0; i < text.length; i += chunkSize) {\n    const chunk = text.slice(i, i + chunkSize);\n    res.write(`data: ${JSON.stringify({ response: chunk })}\\n\\n`);\n  }\n  res.write(`${SSE_DONE}\\n\\n`);\n  res.end();\n};\n\nconst streamOpenAIResponse = async (response, res) => {\n  setupSse(res);\n  if (!response.body) {\n    res.write(`${SSE_DONE}\\n\\n`);\n    return res.end();\n  }\n\n  const decoder = new TextDecoder();\n  let buffer = '';\n  for await (const chunk of response.body) {\n    buffer += decoder.decode(chunk, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() || '';\n    for (const rawLine of lines) {\n      const line = rawLine.trim();\n      if (!line || line.startsWith(':')) continue;\n      if (line === 'data: [DONE]') {\n        res.write(`${SSE_DONE}\\n\\n`);\n        return res.end();\n      }\n      if (line.startsWith('data:')) {\n        res.write(`${line}\\n\\n`);\n      }\n    }\n  }\n  res.write(`${SSE_DONE}\\n\\n`);\n  res.end();\n};\n\nconst streamAnthropicResponse = async (response, res) => {\n  setupSse(res);\n  if (!response.body) {\n    res.write(`${SSE_DONE}\\n\\n`);\n    return res.end();\n  }\n\n  const decoder = new TextDecoder();\n  let buffer = '';\n  for await (const chunk of response.body) {\n    buffer += decoder.decode(chunk, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() || '';\n    for (const rawLine of lines) {\n      const line = rawLine.trim();\n      if (!line || line.startsWith(':')) continue;\n      if (line === 'data: [DONE]') {\n        res.write(`${SSE_DONE}\\n\\n`);\n        return res.end();\n      }\n      if (!line.startsWith('data:')) continue;\n      const payload = line.slice(6).trim();\n      if (!payload) continue;\n\n      try {\n        const parsed = JSON.parse(payload);\n        if (parsed.type === 'content_block_delta' && parsed.delta?.text) {\n          const message = JSON.stringify({\n            choices: [{ delta: { content: parsed.delta.text } }]\n          });\n          res.write(`data: ${message}\\n\\n`);\n        }\n        if (parsed.type === 'message_stop') {\n          res.write(`${SSE_DONE}\\n\\n`);\n          return res.end();\n        }\n      } catch (err) {\n        res.write(`data: ${payload}\\n\\n`);\n      }\n    }\n  }\n  res.write(`${SSE_DONE}\\n\\n`);\n  res.end();\n};\n\nconst parseJsonResponse = async (response) => {\n  const text = await response.text();\n  try {\n    return { json: JSON.parse(text), raw: text };\n  } catch {\n    return { json: null, raw: text };\n  }\n};\n\n// Ollama process management\nlet ollamaProcess = null;\nlet ollamaStatus = 'unknown';\n\n// GPU monitoring process management\nlet gpuMonitorProcess = null;\nconst GPU_LOG_DIR = path.join(__dirname, 'logs');\nconst GPU_MONITOR_INTERVAL = 60000; // 60 seconds\n\nasync function checkOllamaRunning() {\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(`${LOCAL_MODEL_ENDPOINT}/api/tags`, {\n      method: 'GET',\n      signal: AbortSignal.timeout(2000)\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function updateOllamaStatus() {\n  const isRunning = await checkOllamaRunning();\n  ollamaStatus = isRunning ? 'running' : 'offline';\n}\n\n// Check if Ollama is installed\nasync function checkOllamaInstalled() {\n  try {\n    await execPromise('which ollama');\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Start Ollama server\nasync function startOllama() {\n  if (ollamaProcess) {\n    console.log('[Ollama] Process already running');\n    return;\n  }\n\n  const isInstalled = await checkOllamaInstalled();\n  if (!isInstalled) {\n    console.log('[Ollama] Not installed, skipping auto-start');\n    return;\n  }\n\n  console.log('[Ollama] Starting Ollama server...');\n  ollamaProcess = spawn('ollama', ['serve'], {\n    stdio: 'inherit',\n    detached: false\n  });\n\n  ollamaProcess.on('error', (error) => {\n    console.error('[Ollama] Failed to start:', error.message);\n    ollamaProcess = null;\n  });\n\n  ollamaProcess.on('exit', (code) => {\n    console.log(`[Ollama] Process exited with code ${code}`);\n    ollamaProcess = null;\n    updateOllamaStatus();\n  });\n\n  // Give Ollama a few seconds to start\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  await updateOllamaStatus();\n\n  if (ollamaStatus === 'running') {\n    console.log('[Ollama] Successfully started and running');\n  }\n}\n\n// Initialize Ollama (auto-start if configured)\nasync function initializeOllama() {\n  await updateOllamaStatus();\n\n  if (AUTO_START_OLLAMA && ollamaStatus !== 'running') {\n    console.log('[Ollama] Auto-start is enabled, attempting to start Ollama...');\n    await startOllama();\n  } else if (AUTO_START_OLLAMA) {\n    console.log('[Ollama] Auto-start enabled, but Ollama is already running');\n  } else {\n    console.log('[Ollama] Auto-start disabled, status:', ollamaStatus);\n  }\n}\n\n// GPU monitoring functions\nasync function getGPUInfo() {\n  const gpuInfo = {\n    timestamp: new Date().toISOString(),\n    ollama: {\n      status: ollamaStatus,\n      endpoint: LOCAL_MODEL_ENDPOINT\n    }\n  };\n\n  // Try to get ROCm GPU info\n  try {\n    const { stdout: rocmOutput } = await execPromise('rocm-smi --showmeminfo vram --json 2>/dev/null || rocm-smi --json 2>/dev/null || echo \"{}\"');\n    gpuInfo.rocm = JSON.parse(rocmOutput || '{}');\n  } catch (rocmError) {\n    gpuInfo.rocm = { available: false };\n  }\n\n  // Get recent Ollama GPU events from logs\n  try {\n    const { stdout: ollamaLogs } = await execPromise('journalctl -u ollama --since \"5 minutes ago\" --no-pager 2>/dev/null | grep -iE \"GPU|hang|memory|error\" | tail -10 || echo \"\"');\n    gpuInfo.recentEvents = ollamaLogs.split('\\n').filter(line => line.trim());\n  } catch (logError) {\n    gpuInfo.recentEvents = [];\n  }\n\n  return gpuInfo;\n}\n\nasync function logGPUStatus() {\n  try {\n    // Ensure log directory exists\n    if (!fs.existsSync(GPU_LOG_DIR)) {\n      fs.mkdirSync(GPU_LOG_DIR, { recursive: true });\n    }\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const logFile = path.join(GPU_LOG_DIR, `gpu-monitor-${timestamp}.log`);\n\n    const gpuInfo = await getGPUInfo();\n    const logContent = `=== GPU Status at ${gpuInfo.timestamp} ===\\n${JSON.stringify(gpuInfo, null, 2)}\\n\\n`;\n\n    fs.appendFileSync(logFile, logContent);\n\n    // Clean up old log files (keep last 100)\n    const logFiles = fs.readdirSync(GPU_LOG_DIR)\n      .filter(f => f.startsWith('gpu-monitor-'))\n      .sort()\n      .reverse();\n\n    if (logFiles.length > 100) {\n      logFiles.slice(100).forEach(f => {\n        try {\n          fs.unlinkSync(path.join(GPU_LOG_DIR, f));\n        } catch (err) {\n          // Ignore errors\n        }\n      });\n    }\n\n    console.log(`[GPU Monitor] Logged status to ${path.basename(logFile)}`);\n  } catch (error) {\n    console.error('[GPU Monitor] Failed to log GPU status:', error.message);\n  }\n}\n\nfunction startGPUMonitoring() {\n  if (gpuMonitorProcess) {\n    console.log('[GPU Monitor] Already running');\n    return;\n  }\n\n  console.log('[GPU Monitor] Starting GPU monitoring...');\n\n  // Log immediately\n  logGPUStatus();\n\n  // Then log every 60 seconds\n  gpuMonitorProcess = setInterval(logGPUStatus, GPU_MONITOR_INTERVAL);\n\n  console.log(`[GPU Monitor] Monitoring started (interval: ${GPU_MONITOR_INTERVAL / 1000}s)`);\n}\n\nfunction stopGPUMonitoring() {\n  if (gpuMonitorProcess) {\n    clearInterval(gpuMonitorProcess);\n    gpuMonitorProcess = null;\n    console.log('[GPU Monitor] Stopped');\n  }\n}\n\n// Initialize Ollama and check status periodically\ninitializeOllama();\nsetInterval(updateOllamaStatus, 10000); // Check every 10 seconds\n\n// Start GPU monitoring\nstartGPUMonitoring();\n\n// Middleware to parse JSON bodies\napp.use(express.json({ limit: '10mb' }));\n\n// CORS headers for API endpoints\napp.use((req, res, next) => {\n  if (req.path.startsWith('/api/')) {\n    const origin = req.headers.origin;\n    if (CORS_ORIGINS.includes('*') || CORS_ORIGINS.includes(origin)) {\n      res.header('Access-Control-Allow-Origin', origin || '*');\n    } else {\n      res.header('Access-Control-Allow-Origin', CORS_ORIGINS[0]);\n    }\n    res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Cache-Control');\n    if (req.method === 'OPTIONS') {\n      return res.sendStatus(200);\n    }\n  }\n  next();\n});\n\n// Health check endpoint\napp.get('/api/health', (req, res) => {\n  const providers = [];\n  if (GEMINI_API_KEY) providers.push('gemini');\n  if (OPENAI_API_KEY) providers.push('openai');\n  if (ANTHROPIC_API_KEY) providers.push('anthropic');\n  if (HUGGINGFACE_API_KEY) providers.push('huggingface');\n  providers.push('local');\n\n  res.json({\n    status: 'ok',\n    providers: providers,\n    primaryProvider: providers.includes('gemini') ? 'gemini' : providers[0],\n    ollama: {\n      status: ollamaStatus,\n      endpoint: LOCAL_MODEL_ENDPOINT\n    },\n    ollamaStatus: ollamaStatus,\n    timestamp: new Date().toISOString()\n  });\n});\n\n// Proxy endpoint for Gemini API\napp.post('/api/gemini/*', async (req, res) => {\n  if (!GEMINI_API_KEY) {\n    return res.status(500).json({\n      error: 'Server is not configured with Gemini API key'\n    });\n  }\n\n  // Extract the Gemini API path\n  const geminiPath = req.params[0];\n  const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/${geminiPath}?key=${GEMINI_API_KEY}`;\n\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(geminiUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(req.body)\n    });\n\n    const { json, raw } = await parseJsonResponse(response);\n\n    if (!json) {\n      return res.status(response.status || 500).json({\n        error: 'Invalid response from Gemini API',\n        status: response.status,\n        statusText: response.statusText,\n        details: raw.substring(0, 500)\n      });\n    }\n\n    if (!response.ok) {\n      console.error('Gemini API error:', json);\n      return res.status(response.status).json(json);\n    }\n\n    res.json(json);\n  } catch (error) {\n    console.error('Proxy error:', error);\n    res.status(500).json({\n      error: 'Failed to proxy request to Gemini API',\n      details: error.message\n    });\n  }\n});\n\n// Proxy endpoint for local models (Ollama, LM Studio, etc.)\napp.post('/api/local/*', async (req, res) => {\n  const requestId = Math.random().toString(36).substring(7);\n  const localPath = req.params[0];\n  const localUrl = `${LOCAL_MODEL_ENDPOINT}/${localPath}`;\n\n  console.log(`[API Local ${requestId}] Proxying request to ${localPath}`);\n\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(localUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(req.body)\n    });\n\n    console.log(`[API Local ${requestId}] Response status: ${response.status}`);\n    const { json, raw } = await parseJsonResponse(response);\n\n    if (!json) {\n      console.error(`[API Local ${requestId}] ERROR: Failed to parse response`);\n      return res.status(response.status || 500).json({\n        error: 'Invalid response from local model',\n        status: response.status,\n        statusText: response.statusText,\n        details: raw.substring(0, 500),\n        requestId\n      });\n    }\n\n    if (!response.ok) {\n      console.error(`[API Local ${requestId}] ERROR: Local model error:`, json);\n      return res.status(response.status).json(json);\n    }\n\n    console.log(`[API Local ${requestId}] SUCCESS: Returning response`);\n    res.json(json);\n  } catch (error) {\n    console.error(`[API Local ${requestId}] ERROR: Proxy error:`, error);\n    console.error(`[API Local ${requestId}] Stack trace:`, error.stack);\n    res.status(500).json({\n      error: 'Failed to proxy request to local model',\n      details: error.message,\n      endpoint: localUrl,\n      requestId: requestId\n    });\n  }\n});\n\n// Proxy endpoint for OpenAI API\napp.post('/api/openai/*', async (req, res) => {\n  if (!OPENAI_API_KEY) {\n    return res.status(500).json({\n      error: 'Server is not configured with OpenAI API key'\n    });\n  }\n\n  const openaiPath = req.params[0];\n  const openaiUrl = `https://api.openai.com/v1/${openaiPath}`;\n\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(openaiUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`\n      },\n      body: JSON.stringify(req.body)\n    });\n    const { json, raw } = await parseJsonResponse(response);\n\n    if (!json) {\n      return res.status(response.status || 500).json({\n        error: 'Invalid response from OpenAI API',\n        status: response.status,\n        statusText: response.statusText,\n        details: raw.substring(0, 500)\n      });\n    }\n\n    if (!response.ok) {\n      console.error('OpenAI API error:', json);\n      return res.status(response.status).json(json);\n    }\n\n    res.json(json);\n  } catch (error) {\n    console.error('OpenAI proxy error:', error);\n    res.status(500).json({\n      error: 'Failed to proxy request to OpenAI API',\n      details: error.message\n    });\n  }\n});\n\n// Proxy endpoint for Anthropic API\napp.post('/api/anthropic/*', async (req, res) => {\n  if (!ANTHROPIC_API_KEY) {\n    return res.status(500).json({\n      error: 'Server is not configured with Anthropic API key'\n    });\n  }\n\n  const anthropicPath = req.params[0];\n  const anthropicUrl = `https://api.anthropic.com/v1/${anthropicPath}`;\n\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(anthropicUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': ANTHROPIC_API_KEY,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify(req.body)\n    });\n\n    const { json, raw } = await parseJsonResponse(response);\n\n    if (!json) {\n      return res.status(response.status || 500).json({\n        error: 'Invalid response from Anthropic API',\n        status: response.status,\n        statusText: response.statusText,\n        details: raw.substring(0, 500)\n      });\n    }\n\n    if (!response.ok) {\n      console.error('Anthropic API error:', json);\n      return res.status(response.status).json(json);\n    }\n\n    res.json(json);\n  } catch (error) {\n    console.error('Anthropic proxy error:', error);\n    res.status(500).json({\n      error: 'Failed to proxy request to Anthropic API',\n      details: error.message\n    });\n  }\n});\n\n// Proxy endpoint for HuggingFace Inference API\napp.post('/api/huggingface/models/:model(*)', async (req, res) => {\n  if (!HUGGINGFACE_API_KEY) {\n    return res.status(500).json({\n      error: 'Server is not configured with HuggingFace API key'\n    });\n  }\n\n  const modelId = req.params.model;\n  const huggingfaceUrl = `https://api-inference.huggingface.co/models/${modelId}`;\n\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(huggingfaceUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${HUGGINGFACE_API_KEY}`\n      },\n      body: JSON.stringify(req.body)\n    });\n\n    const { json, raw } = await parseJsonResponse(response);\n\n    if (!json) {\n      return res.status(response.status || 500).json({\n        error: 'Invalid response from HuggingFace API',\n        status: response.status,\n        statusText: response.statusText,\n        details: raw.substring(0, 500)\n      });\n    }\n\n    if (!response.ok) {\n      console.error('HuggingFace API error:', json);\n      return res.status(response.status).json(json);\n    }\n\n    res.json(json);\n  } catch (error) {\n    console.error('HuggingFace proxy error:', error);\n    res.status(500).json({\n      error: 'Failed to proxy request to HuggingFace API',\n      details: error.message\n    });\n  }\n});\n\n// Unified chat endpoint (routes to appropriate provider)\napp.post('/api/chat', async (req, res) => {\n  const requestId = Math.random().toString(36).substring(7);\n  console.log(`[API Chat ${requestId}] Incoming request from ${req.headers['user-agent']?.substring(0, 50) || 'unknown'}`);\n  console.log(`[API Chat ${requestId}] Request body:`, JSON.stringify(req.body, null, 2).substring(0, 500));\n\n  try {\n    const { provider, model, messages } = req.body;\n    const shouldStream = !!req.body.stream;\n\n    if (!provider || !model || !messages) {\n      console.log(`[API Chat ${requestId}] ERROR: Missing required fields`);\n      return res.status(400).json({\n        error: 'Missing required fields: provider, model, messages'\n      });\n    }\n\n    console.log(`[API Chat ${requestId}] Routing to provider: ${provider}, model: ${model}`);\n    const fetch = (await import('node-fetch')).default;\n    let response, data;\n\n    switch (provider) {\n      case 'gemini':\n        console.log(`[API Chat ${requestId}] Handling Gemini request`);\n        if (!GEMINI_API_KEY) {\n          console.log(`[API Chat ${requestId}] ERROR: Gemini API key not configured`);\n          return res.status(500).json({ error: 'Gemini API key not configured' });\n        }\n        const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}`;\n        console.log(`[API Chat ${requestId}] Calling Gemini API: ${geminiUrl.split('?')[0]}`);\n        response = await fetch(geminiUrl, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            contents: messages.map(m => ({\n              role: m.role === 'assistant' ? 'model' : 'user',\n              parts: [{ text: m.content }]\n            }))\n          })\n        });\n        data = await response.json();\n        console.log(`[API Chat ${requestId}] Gemini response status: ${response.status}`);\n        if (!response.ok) {\n          console.log(`[API Chat ${requestId}] ERROR: Gemini API error:`, data);\n          return res.status(response.status).json(data);\n        }\n        console.log(`[API Chat ${requestId}] SUCCESS: Returning Gemini response`);\n        const text = (data.candidates?.[0]?.content?.parts || [])\n          .map(part => part.text || '')\n          .join('\\n');\n\n        if (shouldStream) {\n          streamBufferedText(res, text);\n          return;\n        }\n\n        return res.json({\n          content: text,\n          usage: data.usageMetadata\n        });\n\n      case 'openai':\n        console.log(`[API Chat ${requestId}] Handling OpenAI request`);\n        if (!OPENAI_API_KEY) {\n          console.log(`[API Chat ${requestId}] ERROR: OpenAI API key not configured`);\n          return res.status(500).json({ error: 'OpenAI API key not configured' });\n        }\n        console.log(`[API Chat ${requestId}] Calling OpenAI API`);\n        const openAiBody = { model, messages };\n        if (shouldStream) openAiBody.stream = true;\n        response = await fetch('https://api.openai.com/v1/chat/completions', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${OPENAI_API_KEY}`\n          },\n          body: JSON.stringify(openAiBody)\n        });\n        console.log(`[API Chat ${requestId}] OpenAI response status: ${response.status}`);\n        if (!response.ok) {\n          const responseText = await response.text();\n          try {\n            data = JSON.parse(responseText);\n          } catch {\n            data = { error: responseText };\n          }\n          console.log(`[API Chat ${requestId}] ERROR: OpenAI API error:`, data);\n          return res.status(response.status).json(data);\n        }\n\n        if (shouldStream) {\n          await streamOpenAIResponse(response, res);\n          return;\n        }\n\n        data = await response.json();\n        console.log(`[API Chat ${requestId}] SUCCESS: Returning OpenAI response`);\n        return res.json({\n          content: data.choices[0].message.content,\n          usage: data.usage\n        });\n\n      case 'anthropic':\n        console.log(`[API Chat ${requestId}] Handling Anthropic request`);\n        if (!ANTHROPIC_API_KEY) {\n          console.log(`[API Chat ${requestId}] ERROR: Anthropic API key not configured`);\n          return res.status(500).json({ error: 'Anthropic API key not configured' });\n        }\n        console.log(`[API Chat ${requestId}] Calling Anthropic API`);\n        const anthropicBody = {\n          model,\n          messages,\n          max_tokens: 4096\n        };\n        if (shouldStream) anthropicBody.stream = true;\n\n        response = await fetch('https://api.anthropic.com/v1/messages', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'x-api-key': ANTHROPIC_API_KEY,\n            'anthropic-version': '2023-06-01'\n          },\n          body: JSON.stringify(anthropicBody)\n        });\n        console.log(`[API Chat ${requestId}] Anthropic response status: ${response.status}`);\n        if (!response.ok) {\n          const responseText = await response.text();\n          try {\n            data = JSON.parse(responseText);\n          } catch {\n            data = { error: responseText };\n          }\n          console.log(`[API Chat ${requestId}] ERROR: Anthropic API error:`, data);\n          return res.status(response.status).json(data);\n        }\n\n        if (shouldStream) {\n          await streamAnthropicResponse(response, res);\n          return;\n        }\n\n        data = await response.json();\n        console.log(`[API Chat ${requestId}] SUCCESS: Returning Anthropic response`);\n        return res.json({\n          content: data.content[0].text,\n          usage: data.usage\n        });\n\n      case 'ollama':\n        console.log(`[API Chat ${requestId}] Handling Ollama request`);\n        const ollamaUrl = `${LOCAL_MODEL_ENDPOINT}/api/chat`;\n        console.log(`[API Chat ${requestId}] Calling Ollama at: ${ollamaUrl} with model: ${model}`);\n        console.log(`[API Chat ${requestId}] Ollama request payload:`, JSON.stringify({ model, messages: messages.length + ' messages', stream: shouldStream }));\n\n        // Unload any running models that aren't the requested one\n        try {\n          const psResponse = await fetch(`${LOCAL_MODEL_ENDPOINT}/api/ps`);\n          if (psResponse.ok) {\n            const psData = await psResponse.json();\n            if (psData.models && psData.models.length > 0) {\n              for (const runningModel of psData.models) {\n                if (runningModel.name !== model) {\n                  console.log(`[API Chat ${requestId}] Unloading ${runningModel.name} to make room for ${model}`);\n                  // Unload by sending empty generate with keep_alive: 0\n                  await fetch(`${LOCAL_MODEL_ENDPOINT}/api/generate`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                      model: runningModel.name,\n                      keep_alive: 0  // Immediately unload\n                    })\n                  });\n                }\n              }\n            }\n          }\n        } catch (unloadError) {\n          console.warn(`[API Chat ${requestId}] Failed to unload models:`, unloadError.message);\n          // Continue anyway - the model swap will happen automatically\n        }\n\n        try {\n          // Use a longer timeout for Ollama (large models can take time)\n          const controller = new AbortController();\n          const timeout = setTimeout(() => {\n            controller.abort();\n            console.log(`[API Chat ${requestId}] ERROR: Ollama request timed out after 120 seconds`);\n          }, 120000); // 120 second timeout for large models\n\n          try {\n            response = await fetch(ollamaUrl, {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ model, messages, stream: shouldStream }),\n              signal: controller.signal\n            });\n            clearTimeout(timeout);\n          } catch (fetchError) {\n            clearTimeout(timeout);\n            if (fetchError.name === 'AbortError') {\n              throw new Error(`Ollama request timed out after 120 seconds. Large models like ${model} may take longer than expected. Try a smaller model or check Ollama server logs.`);\n            }\n            throw fetchError;\n          }\n\n          console.log(`[API Chat ${requestId}] Ollama response status: ${response.status}`);\n\n          if (!response.ok) {\n            const responseText = await response.text();\n            try {\n              data = JSON.parse(responseText);\n            } catch {\n              data = { error: responseText };\n            }\n            console.log(`[API Chat ${requestId}] ERROR: Ollama API error:`, data);\n            // Add more helpful error messages\n            if (response.status === 404) {\n              data.helpfulMessage = `Model '${model}' not found in Ollama. Run 'ollama pull ${model}' to download it, or check 'ollama list' for available models.`;\n            } else if (response.status === 503) {\n              data.helpfulMessage = `Ollama service unavailable. Make sure Ollama is running at ${LOCAL_MODEL_ENDPOINT}`;\n            }\n            return res.status(response.status).json(data);\n          }\n\n          if (!shouldStream) {\n            const ollamaData = await response.json();\n            const content = ollamaData.message?.content || ollamaData.response || '';\n            return res.json({ content, usage: ollamaData.eval_count });\n          }\n\n          setupSse(res);\n          const reader = response.body;\n          let buffer = '';\n\n          for await (const chunk of reader) {\n            buffer += chunk.toString();\n            const lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n\n            for (const line of lines) {\n              if (!line.trim()) continue;\n              try {\n                const parsed = JSON.parse(line);\n                res.write(`data: ${line}\\n\\n`);\n                if (parsed.done) {\n                  console.log(`[API Chat ${requestId}] Stream completed`);\n                  res.write(`${SSE_DONE}\\n\\n`);\n                  res.end();\n                  return;\n                }\n              } catch (e) {\n                console.error(`[API Chat ${requestId}] Failed to parse chunk:`, line);\n              }\n            }\n          }\n\n          res.write(`${SSE_DONE}\\n\\n`);\n          res.end();\n          return;\n        } catch (ollamaError) {\n          console.log(`[API Chat ${requestId}] ERROR: Ollama request failed:`, ollamaError.message);\n          throw ollamaError;\n        }\n\n      default:\n        console.log(`[API Chat ${requestId}] ERROR: Unsupported provider: ${provider}`);\n        return res.status(400).json({ error: `Unsupported provider: ${provider}` });\n    }\n  } catch (error) {\n    console.error(`[API Chat ${requestId}] EXCEPTION:`, error);\n    console.error(`[API Chat ${requestId}] Stack trace:`, error.stack);\n    res.status(500).json({\n      error: 'Failed to process chat request',\n      details: error.message,\n      requestId: requestId\n    });\n  }\n});\n\n// Endpoint to check if proxy is available (for client detection)\napp.get('/api/proxy-status', (req, res) => {\n  res.json({\n    proxyAvailable: true,\n    hasApiKey: !!GEMINI_API_KEY, // For backwards compatibility with ApiClient\n    providers: {\n      gemini: !!GEMINI_API_KEY,\n      openai: !!OPENAI_API_KEY,\n      anthropic: !!ANTHROPIC_API_KEY,\n      huggingface: !!HUGGINGFACE_API_KEY,\n      local: true\n    },\n    localEndpoint: LOCAL_MODEL_ENDPOINT\n  });\n});\n\n// Endpoint to get available Ollama models\napp.get('/api/ollama/models', async (req, res) => {\n  try {\n    const fetch = (await import('node-fetch')).default;\n    const response = await fetch(`${LOCAL_MODEL_ENDPOINT}/api/tags`, {\n      method: 'GET',\n      signal: AbortSignal.timeout(5000)\n    });\n\n    if (!response.ok) {\n      return res.status(503).json({\n        error: 'Ollama not available',\n        models: []\n      });\n    }\n\n    const data = await response.json();\n    const models = data.models.map(model => ({\n      name: model.name,\n      size: model.size,\n      modified: model.modified_at,\n      digest: model.digest\n    }));\n\n    res.json({ models });\n  } catch (error) {\n    console.error('Failed to fetch Ollama models:', error.message);\n    res.status(503).json({\n      error: 'Failed to connect to Ollama',\n      models: []\n    });\n  }\n});\n\n// GPU monitoring endpoint\napp.get('/api/gpu/status', async (req, res) => {\n  try {\n    const gpuInfo = await getGPUInfo();\n    gpuInfo.monitoring = {\n      enabled: !!gpuMonitorProcess,\n      interval: GPU_MONITOR_INTERVAL / 1000,\n      logDirectory: GPU_LOG_DIR\n    };\n    res.json(gpuInfo);\n  } catch (error) {\n    console.error('Failed to fetch GPU status:', error.message);\n    res.status(500).json({\n      error: 'Failed to fetch GPU status',\n      details: error.message\n    });\n  }\n});\n\n// GPU monitoring logs endpoint\napp.get('/api/gpu/logs', (req, res) => {\n  try {\n    if (!fs.existsSync(GPU_LOG_DIR)) {\n      return res.json({ logs: [] });\n    }\n\n    const logFiles = fs.readdirSync(GPU_LOG_DIR)\n      .filter(f => f.startsWith('gpu-monitor-'))\n      .sort()\n      .reverse()\n      .slice(0, 10); // Last 10 log files\n\n    const logs = logFiles.map(filename => {\n      const content = fs.readFileSync(path.join(GPU_LOG_DIR, filename), 'utf8');\n      return {\n        filename,\n        content,\n        timestamp: filename.replace('gpu-monitor-', '').replace('.log', '')\n      };\n    });\n\n    res.json({ logs });\n  } catch (error) {\n    console.error('Failed to read GPU logs:', error.message);\n    res.status(500).json({\n      error: 'Failed to read GPU logs',\n      details: error.message\n    });\n  }\n});\n\n// --- VFS Persistence Endpoints ---\nconst VFS_BACKUP_PATH = path.join(__dirname, '..', 'vfs_backup.json');\n\n// Endpoint to check for VFS state\napp.get('/api/vfs/status', (req, res) => {\n  try {\n    const backupExists = fs.existsSync(VFS_BACKUP_PATH);\n    res.status(200).json({ backupExists });\n  } catch (error) {\n    console.error('Error checking VFS status:', error);\n    res.status(500).json({ error: 'Failed to check VFS status.' });\n  }\n});\n\n// Endpoint to save the VFS state\napp.post('/api/vfs/backup', (req, res) => {\n  try {\n    fs.writeFileSync(VFS_BACKUP_PATH, JSON.stringify(req.body, null, 2));\n    res.status(200).json({ message: 'VFS state saved successfully.' });\n  } catch (error) {\n    console.error('Error saving VFS state:', error);\n    res.status(500).json({ error: 'Failed to save VFS state.' });\n  }\n});\n\n// Endpoint to load the VFS state\napp.get('/api/vfs/restore', (req, res) => {\n  try {\n    if (fs.existsSync(VFS_BACKUP_PATH)) {\n      const vfsState = fs.readFileSync(VFS_BACKUP_PATH, 'utf8');\n      res.status(200).json(JSON.parse(vfsState));\n    } else {\n      res.status(404).json({ error: 'No VFS backup found.' });\n    }\n  } catch (error) {\n    console.error('Error loading VFS state:', error);\n    res.status(500).json({ error: 'Failed to load VFS state.' });\n  }\n});\n// --- End VFS Persistence Endpoints ---\n\n// --- Console Logging Endpoint ---\nconst CONSOLE_LOG_PATH = path.join(__dirname, '..', 'console.log');\n\n// Endpoint to receive browser console logs\napp.post('/api/console-logs', (req, res) => {\n  try {\n    const { logs } = req.body;\n    if (!logs || !Array.isArray(logs)) {\n      return res.status(400).json({ error: 'Invalid log format' });\n    }\n\n    // Append logs to file\n    const logLines = logs.map(log => {\n      return `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`;\n    }).join('\\n') + '\\n';\n\n    fs.appendFileSync(CONSOLE_LOG_PATH, logLines);\n    res.json({ success: true, logsReceived: logs.length });\n  } catch (error) {\n    console.error('Error saving console logs:', error);\n    res.status(500).json({ error: 'Failed to save logs' });\n  }\n});\n\n// Endpoint to read console logs\napp.get('/api/console-logs', (req, res) => {\n  try {\n    if (fs.existsSync(CONSOLE_LOG_PATH)) {\n      const logs = fs.readFileSync(CONSOLE_LOG_PATH, 'utf8');\n      const lines = logs.split('\\n').filter(line => line.trim()).slice(-100); // Last 100 lines\n      res.json({ logs: lines });\n    } else {\n      res.json({ logs: [] });\n    }\n  } catch (error) {\n    console.error('Error reading console logs:', error);\n    res.status(500).json({ error: 'Failed to read logs' });\n  }\n});\n// --- End Console Logging Endpoint ---\n\n// --- WebRTC Signaling Endpoints ---\nlet signalingServer = null;\n\n// Get signaling server stats\napp.get('/api/signaling/stats', (req, res) => {\n  if (!signalingServer) {\n    return res.status(503).json({ error: 'Signaling server not initialized' });\n  }\n\n  res.json(signalingServer.getStats());\n});\n// --- End WebRTC Signaling Endpoints ---\n\n// --- Agent Bridge Endpoints ---\nlet agentBridge = null;\n\n// Get Agent Bridge stats\napp.get('/api/agent-bridge/stats', (req, res) => {\n  if (!agentBridge) {\n    return res.status(503).json({ error: 'Agent Bridge not initialized' });\n  }\n\n  res.json(agentBridge.getStats());\n});\n// --- End Agent Bridge Endpoints ---\n\n// Serve static files from the project root\napp.use(express.static(path.join(__dirname, '..')));\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).send('File not found');\n});\n\n// Create HTTP server (needed for WebSocket)\nconst server = http.createServer(app);\n\n// Initialize WebRTC Signaling Server\ntry {\n  signalingServer = new SignalingServer(server, {\n    path: '/signaling',\n    heartbeatInterval: 30000,\n    peerTimeout: 60000\n  });\n\n  signalingServer.on('peer-joined', ({ peerId, roomId }) => {\n    console.log(`[Proxy] Peer ${peerId} joined room ${roomId}`);\n  });\n\n  signalingServer.on('peer-left', ({ peerId, roomId }) => {\n    console.log(`[Proxy] Peer ${peerId} left room ${roomId}`);\n  });\n\n  console.log('âœ… WebRTC signaling server initialized');\n} catch (error) {\n  console.error('âš ï¸  Failed to initialize signaling server:', error.message);\n}\n\n// Initialize Agent Bridge\ntry {\n  agentBridge = new AgentBridge(server, {\n    path: '/agent-bridge',\n    heartbeatInterval: 30000,\n    agentTimeout: 120000\n  });\n\n  agentBridge.on('agent-joined', ({ agentId, name }) => {\n    console.log(`[Proxy] Agent joined: ${name} (${agentId})`);\n  });\n\n  agentBridge.on('agent-left', ({ agentId }) => {\n    console.log(`[Proxy] Agent left: ${agentId}`);\n  });\n\n  console.log('âœ… Agent Bridge initialized');\n} catch (error) {\n  console.error('âš ï¸  Failed to initialize Agent Bridge:', error.message);\n}\n\n// Start server\nserver.listen(PORT, () => {\n  const providers = [];\n  if (GEMINI_API_KEY) providers.push('Gemini');\n  if (OPENAI_API_KEY) providers.push('OpenAI');\n  if (ANTHROPIC_API_KEY) providers.push('Anthropic');\n  if (HUGGINGFACE_API_KEY) providers.push('HuggingFace');\n  providers.push('Local');\n\n  console.log(`\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘                                                        â•‘\nâ•‘   REPLOID Multi-Provider Proxy Server                 â•‘\nâ•‘                                                        â•‘\nâ•‘   HTTP API: http://localhost:${PORT}                      â•‘\nâ•‘   WebRTC Signaling: ws://localhost:${PORT}/signaling      â•‘\nâ•‘   Providers: ${providers.join(', ').padEnd(25)}    â•‘\nâ•‘   Local endpoint: ${LOCAL_MODEL_ENDPOINT.padEnd(21)}â•‘\nâ•‘                                                        â•‘\nâ•‘   Press Ctrl+C to stop                                â•‘\nâ•‘                                                        â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  `);\n});\n\nconst gracefulShutdown = (signal) => {\n  console.log(`${signal} received, shutting down gracefully...`);\n\n  stopGPUMonitoring();\n\n  if (ollamaProcess) {\n    console.log('[Ollama] Stopping managed Ollama process...');\n    ollamaProcess.kill();\n  }\n\n  if (signalingServer) {\n    signalingServer.close();\n  }\n\n  if (agentBridge) {\n    agentBridge.close();\n  }\n\n  server.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n};\n\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n",
      "hash": "36f3c4772d452b93d4b40c2b9129f3c1e46f47ea541f2fbec304e928dc5bada5"
    },
    "server/agent-bridge.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 11885,
        "binary": false
      },
      "content": "#!/usr/bin/env node\n\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { EventEmitter } from 'events';\n\nclass AgentBridge extends EventEmitter {\n  constructor(server, options = {}) {\n    super();\n\n    this.options = {\n      path: options.path || '/claude-bridge',\n      heartbeatInterval: options.heartbeatInterval || 30000,\n      agentTimeout: options.agentTimeout || 120000,\n      ...options\n    };\n\n    // WebSocket server\n    this.wss = new WebSocketServer({\n      server,\n      path: this.options.path\n    });\n\n    // Agent management\n    this.agents = new Map(); // agentId -> { ws, metadata, lastSeen, capabilities }\n    this.tasks = new Map();   // taskId -> { assignedTo, status, created, updated }\n    this.sharedContext = new Map(); // contextKey -> value\n\n    // Setup WebSocket handlers\n    this.wss.on('connection', (ws, req) => this.handleConnection(ws, req));\n\n    // Setup heartbeat monitoring\n    this.startHeartbeatMonitor();\n\n    console.log(`[AgentBridge] Agent coordination server started on ${this.options.path}`);\n  }\n\n  handleConnection(ws, req) {\n    console.log('[AgentBridge] New connection from:', req.socket.remoteAddress);\n\n    let agentId = null;\n\n    ws.on('message', async (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n\n        if (!message.jsonrpc || message.jsonrpc !== '2.0') {\n          this.sendError(ws, null, -32600, 'Invalid Request: missing or invalid jsonrpc field');\n          return;\n        }\n\n        if (!message.method) {\n          this.sendError(ws, message.id, -32600, 'Invalid Request: missing method field');\n          return;\n        }\n\n        const result = await this.handleMethod(message.method, message.params || {}, agentId, ws);\n\n        // If this was a registration, update agentId\n        if (message.method === 'register' && result.agentId) {\n          agentId = result.agentId;\n        }\n\n        if (message.id !== undefined) {\n          this.sendResponse(ws, message.id, result);\n        }\n\n      } catch (error) {\n        console.error('[AgentBridge] Error handling message:', error);\n        this.sendError(ws, null, -32603, `Internal error: ${error.message}`);\n      }\n    });\n\n    ws.on('close', () => {\n      if (agentId) {\n        console.log(`[AgentBridge] Agent ${agentId} disconnected`);\n        this.agents.delete(agentId);\n        this.emit('agent-left', { agentId });\n      }\n    });\n\n    ws.on('error', (error) => {\n      console.error('[AgentBridge] WebSocket error:', error);\n    });\n  }\n\n  async handleMethod(method, params, agentId, ws) {\n    switch (method) {\n      case 'register':\n        return this.handleRegister(params, ws);\n\n      case 'broadcast':\n        return this.handleBroadcast(params, agentId);\n\n      case 'send_to':\n        return this.handleSendTo(params, agentId);\n\n      case 'query_agents':\n        return this.handleQueryAgents(params);\n\n      case 'delegate_task':\n        return this.handleDelegateTask(params, agentId);\n\n      case 'update_task_status':\n        return this.handleUpdateTaskStatus(params, agentId);\n\n      case 'get_shared_context':\n        return this.handleGetSharedContext(params);\n\n      case 'set_shared_context':\n        return this.handleSetSharedContext(params, agentId);\n\n      case 'heartbeat':\n        return this.handleHeartbeat(agentId);\n\n      default:\n        throw new Error(`Method not found: ${method}`);\n    }\n  }\n\n  handleRegister(params, ws) {\n    const { name, capabilities, metadata } = params;\n\n    if (!name) {\n      throw new Error('Agent name is required');\n    }\n\n    // Generate unique agent ID\n    const agentId = `claude-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    // Store agent info\n    this.agents.set(agentId, {\n      ws,\n      name,\n      capabilities: capabilities || [],\n      metadata: metadata || {},\n      lastSeen: Date.now(),\n      registered: Date.now()\n    });\n\n    console.log(`[AgentBridge] Agent registered: ${agentId} (${name})`);\n    this.emit('agent-joined', { agentId, name, capabilities });\n\n    // Notify other agents\n    this.broadcastToOthers(agentId, {\n      jsonrpc: '2.0',\n      method: 'agent_joined',\n      params: { agentId, name, capabilities, metadata }\n    });\n\n    return {\n      agentId,\n      message: 'Registered successfully',\n      activeAgents: Array.from(this.agents.entries()).map(([id, agent]) => ({\n        agentId: id,\n        name: agent.name,\n        capabilities: agent.capabilities,\n        metadata: agent.metadata\n      }))\n    };\n  }\n\n  handleBroadcast(params, agentId) {\n    const { message, type } = params;\n\n    if (!agentId) {\n      throw new Error('Agent must be registered to broadcast');\n    }\n\n    const agent = this.agents.get(agentId);\n    if (!agent) {\n      throw new Error('Agent not found');\n    }\n\n    // Broadcast to all other agents\n    this.broadcastToOthers(agentId, {\n      jsonrpc: '2.0',\n      method: 'broadcast_received',\n      params: {\n        from: agentId,\n        fromName: agent.name,\n        message,\n        type,\n        timestamp: Date.now()\n      }\n    });\n\n    return { success: true, recipientCount: this.agents.size - 1 };\n  }\n\n  handleSendTo(params, agentId) {\n    const { targetAgentId, message, type } = params;\n\n    if (!agentId) {\n      throw new Error('Agent must be registered to send messages');\n    }\n\n    const sender = this.agents.get(agentId);\n    if (!sender) {\n      throw new Error('Sender agent not found');\n    }\n\n    const recipient = this.agents.get(targetAgentId);\n    if (!recipient) {\n      throw new Error('Target agent not found');\n    }\n\n    // Send message to target agent\n    this.sendNotification(recipient.ws, 'message_received', {\n      from: agentId,\n      fromName: sender.name,\n      message,\n      type,\n      timestamp: Date.now()\n    });\n\n    return { success: true, delivered: true };\n  }\n\n  handleQueryAgents(params) {\n    const { capability } = params;\n\n    let agents = Array.from(this.agents.entries()).map(([id, agent]) => ({\n      agentId: id,\n      name: agent.name,\n      capabilities: agent.capabilities,\n      metadata: agent.metadata,\n      registered: agent.registered,\n      lastSeen: agent.lastSeen\n    }));\n\n    // Filter by capability if specified\n    if (capability) {\n      agents = agents.filter(agent =>\n        agent.capabilities.includes(capability)\n      );\n    }\n\n    return { agents, total: agents.length };\n  }\n\n  handleDelegateTask(params, agentId) {\n    const { task, targetAgentId, priority } = params;\n\n    if (!agentId) {\n      throw new Error('Agent must be registered to delegate tasks');\n    }\n\n    const delegator = this.agents.get(agentId);\n    if (!delegator) {\n      throw new Error('Delegator agent not found');\n    }\n\n    const target = targetAgentId ? this.agents.get(targetAgentId) : null;\n\n    // If no target specified, find available agent\n    const assignedAgent = target || this.findAvailableAgent(task.requiredCapabilities);\n\n    if (!assignedAgent) {\n      throw new Error('No available agent found for task');\n    }\n\n    // Create task\n    const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    this.tasks.set(taskId, {\n      taskId,\n      task,\n      assignedTo: targetAgentId || Array.from(this.agents.keys()).find(id => this.agents.get(id) === assignedAgent),\n      delegatedBy: agentId,\n      status: 'assigned',\n      priority: priority || 'normal',\n      created: Date.now(),\n      updated: Date.now()\n    });\n\n    // Notify assigned agent\n    this.sendNotification(assignedAgent.ws || assignedAgent, 'task_assigned', {\n      taskId,\n      task,\n      delegatedBy: agentId,\n      delegatorName: delegator.name,\n      priority\n    });\n\n    return { taskId, assignedTo: this.tasks.get(taskId).assignedTo, status: 'assigned' };\n  }\n\n  handleUpdateTaskStatus(params, agentId) {\n    const { taskId, status, result, error } = params;\n\n    if (!agentId) {\n      throw new Error('Agent must be registered to update tasks');\n    }\n\n    const task = this.tasks.get(taskId);\n    if (!task) {\n      throw new Error('Task not found');\n    }\n\n    if (task.assignedTo !== agentId) {\n      throw new Error('Only assigned agent can update task status');\n    }\n\n    // Update task\n    task.status = status;\n    task.updated = Date.now();\n    if (result !== undefined) task.result = result;\n    if (error !== undefined) task.error = error;\n\n    // Notify delegator\n    const delegator = this.agents.get(task.delegatedBy);\n    if (delegator) {\n      this.sendNotification(delegator.ws, 'task_updated', {\n        taskId,\n        status,\n        result,\n        error,\n        updatedBy: agentId\n      });\n    }\n\n    return { success: true, task };\n  }\n\n  handleGetSharedContext(params) {\n    const { key } = params;\n\n    if (key) {\n      return { key, value: this.sharedContext.get(key) };\n    }\n\n    // Return all context\n    return { context: Object.fromEntries(this.sharedContext) };\n  }\n\n  handleSetSharedContext(params, agentId) {\n    const { key, value } = params;\n\n    if (!key) {\n      throw new Error('Context key is required');\n    }\n\n    if (!agentId) {\n      throw new Error('Agent must be registered to set context');\n    }\n\n    this.sharedContext.set(key, {\n      value,\n      setBy: agentId,\n      timestamp: Date.now()\n    });\n\n    // Notify other agents of context change\n    this.broadcastToOthers(agentId, {\n      jsonrpc: '2.0',\n      method: 'context_updated',\n      params: { key, value, setBy: agentId, timestamp: Date.now() }\n    });\n\n    return { success: true, key };\n  }\n\n  handleHeartbeat(agentId) {\n    if (!agentId) {\n      throw new Error('Agent must be registered for heartbeat');\n    }\n\n    const agent = this.agents.get(agentId);\n    if (agent) {\n      agent.lastSeen = Date.now();\n      return { success: true, timestamp: agent.lastSeen };\n    }\n\n    throw new Error('Agent not found');\n  }\n\n  findAvailableAgent(requiredCapabilities) {\n    for (const [id, agent] of this.agents) {\n      if (!requiredCapabilities || requiredCapabilities.length === 0) {\n        return agent;\n      }\n\n      const hasAllCapabilities = requiredCapabilities.every(cap =>\n        agent.capabilities.includes(cap)\n      );\n\n      if (hasAllCapabilities) {\n        return agent;\n      }\n    }\n    return null;\n  }\n\n  broadcastToOthers(excludeAgentId, message) {\n    for (const [id, agent] of this.agents) {\n      if (id !== excludeAgentId && agent.ws.readyState === WebSocket.OPEN) {\n        agent.ws.send(JSON.stringify(message));\n      }\n    }\n  }\n\n  sendResponse(ws, id, result) {\n    this.sendRpc(ws, { id, result });\n  }\n\n  sendError(ws, id, code, message) {\n    this.sendRpc(ws, { id, error: { code, message } });\n  }\n\n  sendNotification(ws, method, params) {\n    this.sendRpc(ws, { method, params });\n  }\n\n  sendRpc(ws, payload) {\n    if (ws.readyState !== WebSocket.OPEN) return;\n    ws.send(JSON.stringify({ jsonrpc: '2.0', ...payload }));\n  }\n\n  startHeartbeatMonitor() {\n    setInterval(() => {\n      const now = Date.now();\n      for (const [agentId, agent] of this.agents) {\n        if (now - agent.lastSeen > this.options.agentTimeout) {\n          console.log(`[AgentBridge] Agent ${agentId} timed out`);\n          agent.ws.close();\n          this.agents.delete(agentId);\n          this.emit('agent-timeout', { agentId });\n        }\n      }\n    }, this.options.heartbeatInterval);\n  }\n\n  getStats() {\n    return {\n      activeAgents: this.agents.size,\n      activeTasks: this.tasks.size,\n      sharedContextSize: this.sharedContext.size,\n      agents: Array.from(this.agents.entries()).map(([id, agent]) => ({\n        agentId: id,\n        name: agent.name,\n        capabilities: agent.capabilities,\n        lastSeen: agent.lastSeen\n      })),\n      tasks: Array.from(this.tasks.values())\n    };\n  }\n\n  close() {\n    this.wss.close();\n    this.agents.clear();\n    this.tasks.clear();\n    this.sharedContext.clear();\n  }\n}\n\nexport default AgentBridge;\n",
      "hash": "162d3d8ec4f953b5a76287225fbeb21e5c70cc94aaf1d11392483bb8213f1ade"
    },
    "ui/dashboard.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 14834,
        "binary": false
      },
      "content": "/**\n * @fileoverview Dashboard UI\n * Main user interface for the agent.\n */\n\nconst Dashboard = {\n  factory: (deps) => {\n    const { Utils, EventBus, AgentLoop, StateManager } = deps;\n    const { logger, escapeHtml } = Utils;\n\n    // VFS reference for browser\n    let _vfs = null;\n\n    // --- DOM Elements ---\n    let _root = null;\n    let _reflectionsContainer = null;\n\n    // --- Event Handlers ---\n\n    const onReflection = (entry) => {\n      if (!_reflectionsContainer) return;\n      const div = document.createElement('div');\n      const isError = entry.type === 'error';\n      div.className = `reflection-entry ${isError ? 'reflection-error' : 'reflection-success'}`;\n\n      // Format reflection with full details\n      const tool = entry.context?.tool || 'unknown';\n      const cycle = entry.context?.cycle || '?';\n      const indicator = entry.context?.failureIndicator;\n      const args = entry.context?.args;\n\n      // Format args preview\n      let argsPreview = '';\n      if (args) {\n        if (args.path) argsPreview = args.path;\n        else if (args.name) argsPreview = args.name;\n        else {\n          const keys = Object.keys(args);\n          if (keys.length > 0) argsPreview = keys.join(', ');\n        }\n      }\n\n      // Build detailed display\n      const icon = isError ? 'âœ—' : 'âœ“';\n      const toolInfo = argsPreview ? `${tool}(${argsPreview})` : tool;\n\n      let detailText = '';\n      if (indicator) {\n        detailText = indicator;\n      } else if (entry.content) {\n        // Extract meaningful part of content\n        const content = entry.content.replace(`Tool ${tool}: `, '');\n        detailText = content.length > 60 ? content.substring(0, 60) + '...' : content;\n      }\n\n      div.innerHTML = `\n        <div class=\"reflection-header\">\n          <span class=\"reflection-icon\">${icon}</span>\n          <span class=\"reflection-tool\">${toolInfo}</span>\n          <span class=\"reflection-cycle\">#${cycle}</span>\n        </div>\n        ${detailText ? `<div class=\"reflection-detail\">${escapeHtml(detailText)}</div>` : ''}\n      `;\n\n      div.title = entry.content; // Full content on hover\n      _reflectionsContainer.appendChild(div);\n      _reflectionsContainer.scrollTop = _reflectionsContainer.scrollHeight;\n    };\n\n    const onStateChange = (state) => {\n      // Update status values in Agent Status card\n      const cycleEl = document.getElementById('agent-cycle');\n      const stateEl = document.getElementById('agent-state');\n      if (cycleEl) cycleEl.textContent = state.totalCycles || 0;\n      if (stateEl) stateEl.textContent = state.fsmState || 'IDLE';\n    };\n\n    // --- Render Logic ---\n\n    const render = () => {\n      const container = document.createElement('div');\n      container.className = 'app-shell';\n\n      // Get goal from boot screen\n      const goalFromBoot = localStorage.getItem('REPLOID_GOAL') || 'No goal set';\n\n      container.innerHTML = `\n        <!-- Sidebar Navigation -->\n        <nav class=\"sidebar\">\n          <button class=\"sidebar-btn active\" data-tab=\"history\" title=\"History\">&#x25B6;</button>\n          <button class=\"sidebar-btn\" data-tab=\"reflections\" title=\"Reflections\">&#x2731;</button>\n          <button class=\"sidebar-btn\" data-tab=\"status\" title=\"Status\">&#x2139;</button>\n          <div class=\"sidebar-spacer\"></div>\n          <button id=\"btn-toggle\" class=\"sidebar-btn\" title=\"Stop\">&#x25A0;</button>\n          <button id=\"btn-export\" class=\"sidebar-btn\" title=\"Export\">&#x2913;</button>\n        </nav>\n\n        <!-- Main Workspace -->\n        <main class=\"workspace\">\n          <div class=\"workspace-header\">\n            <div class=\"workspace-title\">\n              <span class=\"text-secondary\">Goal:</span>\n              <span id=\"agent-goal\">${escapeHtml(goalFromBoot)}</span>\n            </div>\n            <div class=\"workspace-status\">\n              <span class=\"status-dot status-dot-idle\" id=\"status-indicator\"></span>\n              <span id=\"agent-state\" class=\"text-muted\">IDLE</span>\n              <span class=\"text-muted\">|</span>\n              <span class=\"text-muted\">Cycle</span>\n              <span id=\"agent-cycle\">0</span>\n            </div>\n          </div>\n\n          <!-- Tab Panels -->\n          <div class=\"workspace-content\" id=\"tab-history\">\n            <div id=\"history-container\" class=\"history-stream\">\n              <div class=\"text-muted\">Thinking and actions will appear here.</div>\n            </div>\n          </div>\n\n          <div class=\"workspace-content hidden\" id=\"tab-reflections\">\n            <div id=\"reflections-container\" class=\"reflections-stream\">\n              <div class=\"text-muted\">Insights and learnings will appear here.</div>\n            </div>\n          </div>\n\n          <div class=\"workspace-content hidden\" id=\"tab-status\">\n            <div class=\"status-panel\">\n              <div class=\"status-item\">\n                <span class=\"status-label\">State</span>\n                <span id=\"agent-state-detail\" class=\"status-value\">IDLE</span>\n              </div>\n              <div class=\"status-item\">\n                <span class=\"status-label\">Activity</span>\n                <span id=\"agent-activity\" class=\"status-value\">Waiting to start</span>\n              </div>\n            </div>\n          </div>\n        </main>\n\n        <!-- Utility Panel (VFS Browser) -->\n        <aside class=\"utility-panel\">\n          <div class=\"utility-header\">\n            <span>VFS Browser</span>\n            <button id=\"vfs-refresh\" class=\"btn btn-sm btn-secondary\">Refresh</button>\n          </div>\n          <div id=\"vfs-tree\" class=\"vfs-tree mono\">\n            <div class=\"text-muted\">Loading...</div>\n          </div>\n          <div id=\"vfs-content\" class=\"vfs-content mono\">\n            <div class=\"text-muted\">Select a file to view contents</div>\n          </div>\n        </aside>\n      `;\n\n      // Bind Events\n      const btnToggle = container.querySelector('#btn-toggle');\n      const btnExport = container.querySelector('#btn-export');\n      let isRunning = true; // Agent starts automatically on awaken\n\n      // Tab switching\n      const tabButtons = container.querySelectorAll('.sidebar-btn[data-tab]');\n      tabButtons.forEach(btn => {\n        btn.onclick = () => {\n          const tabId = btn.dataset.tab;\n          // Update button states\n          tabButtons.forEach(b => b.classList.remove('active'));\n          btn.classList.add('active');\n          // Show/hide panels\n          container.querySelectorAll('.workspace-content').forEach(panel => {\n            panel.classList.toggle('hidden', panel.id !== `tab-${tabId}`);\n          });\n        };\n      });\n\n      // Set initial button state (Unicode stop symbol)\n      btnToggle.innerHTML = '&#x25A0;';\n      btnToggle.title = 'Stop';\n\n      btnToggle.onclick = async () => {\n        if (isRunning) {\n          // Stop\n          AgentLoop.stop();\n          isRunning = false;\n          btnToggle.innerHTML = '&#x25B6;'; // Play symbol\n          btnToggle.title = 'Resume';\n        } else {\n          // Resume\n          const goal = localStorage.getItem('REPLOID_GOAL');\n          if (!goal) return alert('No goal set. Return to boot screen to set a goal.');\n\n          isRunning = true;\n          btnToggle.innerHTML = '&#x25A0;'; // Stop symbol\n          btnToggle.title = 'Stop';\n\n          try {\n            await AgentLoop.run(goal);\n            // Agent finished naturally\n            isRunning = false;\n            btnToggle.innerHTML = '&#x21BB;'; // Restart symbol\n            btnToggle.title = 'Restart';\n          } catch (e) {\n            logger.error(`Agent Error: ${e.message}`);\n            isRunning = false;\n            btnToggle.innerHTML = '&#x21BB;'; // Restart symbol\n            btnToggle.title = 'Restart';\n          }\n        }\n      };\n\n      btnExport.onclick = async () => {\n        try {\n          const state = StateManager.getState();\n          const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });\n          const url = URL.createObjectURL(blob);\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = `reploid-state-${Date.now()}.json`;\n          a.click();\n          URL.revokeObjectURL(url);\n          logger.info('State exported');\n        } catch (e) {\n          logger.error(`Export failed: ${e.message}`);\n        }\n      };\n\n      _reflectionsContainer = container.querySelector('#reflections-container');\n\n      return container;\n    };\n\n    const mount = (target) => {\n      _root = target;\n      _root.innerHTML = '';\n      _root.appendChild(render());\n\n      // Load initial state\n      try {\n        const state = StateManager.getState();\n        onStateChange(state);\n      } catch (e) { /* State not ready */ }\n\n      // Subscribe to reflection events\n      EventBus.on('reflection:added', (entry) => {\n        onReflection(entry);\n      });\n\n      // Subscribe to agent status events\n      EventBus.on('agent:status', (status) => {\n        const stateEl = document.getElementById('agent-state');\n        const activityEl = document.getElementById('agent-activity');\n        const cycleEl = document.getElementById('agent-cycle');\n\n        if (stateEl && status.state) stateEl.textContent = status.state;\n        if (activityEl && status.activity) activityEl.textContent = status.activity;\n        if (cycleEl && status.cycle) cycleEl.textContent = status.cycle;\n      });\n\n      // Subscribe to streaming events for live feedback\n      let streamingEntry = null;\n      let streamStartTime = null;\n      let tokenCount = 0;\n\n      EventBus.on('agent:stream', (text) => {\n        const historyContainer = document.getElementById('history-container');\n        if (!historyContainer) return;\n\n        // Create or update streaming entry\n        if (!streamingEntry) {\n          streamingEntry = document.createElement('div');\n          streamingEntry.className = 'history-entry streaming';\n          streamingEntry.innerHTML = `\n            <div class=\"history-header\">Thinking... <span class=\"token-stats\">0 tokens</span></div>\n            <pre class=\"history-content\"></pre>\n          `;\n          historyContainer.appendChild(streamingEntry);\n          streamStartTime = Date.now();\n          tokenCount = 0;\n        }\n\n        // Estimate tokens (rough: ~4 chars per token)\n        tokenCount += Math.ceil(text.length / 4);\n\n        // Update stats\n        const elapsed = (Date.now() - streamStartTime) / 1000;\n        const tokensPerSec = elapsed > 0 ? (tokenCount / elapsed).toFixed(1) : 0;\n\n        const statsEl = streamingEntry.querySelector('.token-stats');\n        if (statsEl) {\n          statsEl.textContent = `${tokenCount} tokens â€¢ ${tokensPerSec} t/s`;\n        }\n\n        const content = streamingEntry.querySelector('.history-content');\n        content.textContent += text;\n        historyContainer.scrollTop = historyContainer.scrollHeight;\n      });\n\n      // Subscribe to history events\n      const historyContainer = document.getElementById('history-container');\n      EventBus.on('agent:history', (entry) => {\n        if (!historyContainer) return;\n\n        // Clear streaming entry when we get the full response\n        if (streamingEntry && entry.type === 'llm_response') {\n          streamingEntry.remove();\n          streamingEntry = null;\n          streamStartTime = null;\n          tokenCount = 0;\n        }\n\n        const div = document.createElement('div');\n        div.className = 'history-entry';\n\n        if (entry.type === 'llm_response') {\n          const content = entry.content || '(No response content)';\n          div.innerHTML = `\n            <div class=\"history-header\">Think #${entry.cycle}</div>\n            <pre class=\"history-content\">${escapeHtml(content)}</pre>\n          `;\n        } else if (entry.type === 'tool_result') {\n          const result = entry.result || '(No result)';\n          div.innerHTML = `\n            <div class=\"history-header\">Act #${entry.cycle} â†’ ${entry.tool}</div>\n            <pre class=\"history-content\">${escapeHtml(result)}</pre>\n          `;\n        }\n\n        historyContainer.appendChild(div);\n        historyContainer.scrollTop = historyContainer.scrollHeight;\n      });\n    };\n\n    // VFS Browser functions\n    const loadVFSTree = async () => {\n      const treeEl = document.getElementById('vfs-tree');\n      if (!treeEl) {\n        console.log('[VFS Browser] Tree element not found');\n        return;\n      }\n      if (!_vfs) {\n        console.log('[VFS Browser] VFS not set');\n        return;\n      }\n\n      try {\n        // Get all files by listing root - VFS list returns files with prefix\n        let files = await _vfs.list('/');\n        console.log('[VFS Browser] Found files:', files);\n\n        // If empty, try getting all keys directly\n        if (files.length === 0) {\n          // Try listing without the trailing slash requirement\n          const allFiles = [];\n          const tryPaths = ['/.system', '/.memory', '/.logs', '/tools'];\n          for (const path of tryPaths) {\n            try {\n              const subFiles = await _vfs.list(path);\n              allFiles.push(...subFiles);\n            } catch (e) { /* ignore */ }\n          }\n          files = allFiles;\n        }\n\n        if (files.length === 0) {\n          treeEl.innerHTML = '<div class=\"text-muted\">VFS is empty</div>';\n          return;\n        }\n\n        const listHtml = files\n          .sort()\n          .map(path => {\n            const safePath = escapeHtml(path);\n            return `<div class=\"vfs-file\" role=\"button\" data-path=\"${safePath}\">${safePath}</div>`;\n          })\n          .join('');\n\n        treeEl.innerHTML = listHtml || '<div class=\"text-muted\">VFS is empty</div>';\n\n        treeEl.querySelectorAll('.vfs-file').forEach(entry => {\n          entry.onclick = () => loadVFSFile(entry.dataset.path);\n        });\n      } catch (e) {\n        treeEl.innerHTML = `<div class=\"text-danger\">Error: ${e.message}</div>`;\n      }\n    };\n\n    const loadVFSFile = async (path) => {\n      const contentEl = document.getElementById('vfs-content');\n      if (!contentEl || !_vfs) return;\n\n      try {\n        const content = await _vfs.read(path);\n        let displayContent = content;\n\n        // Pretty print JSON\n        if (path.endsWith('.json')) {\n          try {\n            displayContent = JSON.stringify(JSON.parse(content), null, 2);\n          } catch (e) { /* not valid JSON */ }\n        }\n\n        contentEl.innerHTML = `<div class=\"vfs-file-path\">${path}</div><div>${escapeHtml(displayContent)}</div>`;\n      } catch (e) {\n        contentEl.innerHTML = `<div class=\"text-danger\">Error reading ${path}: ${e.message}</div>`;\n      }\n    };\n\n    // Set VFS reference\n    const setVFS = (vfs) => {\n      _vfs = vfs;\n      loadVFSTree();\n    };\n\n    return { mount, setVFS, refreshVFS: loadVFSTree };\n  }\n};\n\nexport default Dashboard;\n",
      "hash": "869f66852708b0762b14334fd3bc67f8b15d3894caca588ed6bd8cf6f9bc0e92"
    },
    "ui/chat.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 10599,
        "binary": false
      },
      "content": "// Agent Status Monitor UI for REPLOID Agent\n\nconst ChatUI = {\n  init: (agentLoop) => {\n    const container = document.getElementById('agent-container');\n    const messagesDiv = document.getElementById('agent-log');\n    const inputDiv = document.getElementById('chat-input-area');\n    const stopBtn = document.getElementById('stop-btn');\n    const pauseBtn = document.getElementById('pause-btn');\n    const contextMessagesSpan = document.getElementById('context-messages');\n    const contextTokensSpan = document.getElementById('context-tokens');\n\n    // Setup message callback\n    agentLoop.setMessageCallback((message) => {\n      addMessage(message);\n      // Update context stats after each message\n      updateContextStats();\n    });\n\n    // Update context stats display\n    const updateContextStats = () => {\n      const status = agentLoop.getStatus();\n      if (contextMessagesSpan) {\n        contextMessagesSpan.textContent = `${status.contextLength} msgs`;\n        // Color code based on size\n        if (status.contextLength > 30) {\n          contextMessagesSpan.style.color = '#fa0'; // Orange warning\n        } else {\n          contextMessagesSpan.style.color = '#888';\n        }\n      }\n      if (contextTokensSpan) {\n        contextTokensSpan.textContent = `~${status.contextTokens} tokens`;\n        // Color code based on token count\n        if (status.contextTokens > 10000) {\n          contextTokensSpan.style.color = '#f00'; // Red critical\n        } else if (status.contextTokens > 8000) {\n          contextTokensSpan.style.color = '#fa0'; // Orange warning\n        } else {\n          contextTokensSpan.style.color = '#888';\n        }\n      }\n    };\n\n    // Stop button\n    stopBtn.addEventListener('click', () => {\n      agentLoop.stop();\n      addMessage({ type: 'system', content: 'Agent stopped by user' });\n      inputDiv.style.display = 'block';\n      // Reset pause button if it was showing \"Resume\"\n      if (pauseBtn.classList.contains('resume-state')) {\n        pauseBtn.querySelector('.btn-icon').textContent = 'â¸';\n        pauseBtn.querySelector('.btn-text').textContent = 'Pause';\n        pauseBtn.classList.remove('resume-state');\n        isPaused = false;\n      }\n    });\n\n    // Pause/Resume button toggle\n    let isPaused = false;\n    pauseBtn.addEventListener('click', () => {\n      if (isPaused) {\n        // Resume\n        agentLoop.resume();\n        addMessage({ type: 'system', content: 'Agent resumed' });\n        pauseBtn.querySelector('.btn-icon').textContent = 'â¸';\n        pauseBtn.querySelector('.btn-text').textContent = 'Pause';\n        pauseBtn.classList.remove('resume-state');\n        isPaused = false;\n      } else {\n        // Pause\n        agentLoop.pause();\n        addMessage({ type: 'system', content: 'Agent paused' });\n        pauseBtn.querySelector('.btn-icon').textContent = 'â˜‡';\n        pauseBtn.querySelector('.btn-text').textContent = 'Resume';\n        pauseBtn.classList.add('resume-state');\n        isPaused = true;\n      }\n    });\n\n    // Export State button\n    const exportBtn = document.getElementById('export-btn');\n    if (exportBtn) {\n      exportBtn.addEventListener('click', async () => {\n        try {\n          addMessage({ type: 'system', content: 'Exporting REPLOID state...' });\n          await window.downloadREPLOID(`reploid-export-${Date.now()}.json`);\n          addMessage({ type: 'system', content: 'Export complete - downloaded JSON file' });\n        } catch (error) {\n          console.error('Export failed:', error);\n          addMessage({ type: 'error', content: `Export failed: ${error.message}` });\n        }\n      });\n    }\n\n    // Store reference to last thinking message for updates\n    let lastThinkingMessage = null;\n    let thinkingAnimationInterval = null;\n\n    // Store references for streaming messages (stats and content separately)\n    let lastStreamingStatsMessage = null;\n    let lastStreamingContentMessage = null;\n\n    // Animate thinking ellipsis\n    const startThinkingAnimation = (element) => {\n      if (thinkingAnimationInterval) {\n        clearInterval(thinkingAnimationInterval);\n      }\n\n      let dots = 0;\n      const baseMessage = 'Thinking';\n\n      thinkingAnimationInterval = setInterval(() => {\n        dots = (dots + 1) % 4; // Cycle through 0, 1, 2, 3 dots\n        element.textContent = baseMessage + '.'.repeat(dots);\n      }, 500); // Update every 500ms\n    };\n\n    const stopThinkingAnimation = () => {\n      if (thinkingAnimationInterval) {\n        clearInterval(thinkingAnimationInterval);\n        thinkingAnimationInterval = null;\n      }\n    };\n\n    // Add message to chat\n    const addMessage = (message) => {\n      // Handle thinking updates (update existing message)\n      if (message.type === 'thinking_update') {\n        if (lastThinkingMessage) {\n          const contentDiv = lastThinkingMessage.querySelector('.message-content');\n          if (contentDiv) {\n            // Stop animation when we have real content to show\n            stopThinkingAnimation();\n            contentDiv.textContent = message.content;\n            // Don't restart animation - we're showing live content now\n          }\n          return lastThinkingMessage;\n        }\n      }\n\n      // Handle streaming stats updates\n      if (message.type === 'streaming_stats_update') {\n        if (lastStreamingStatsMessage) {\n          const contentDiv = lastStreamingStatsMessage.querySelector('.message-content');\n          if (contentDiv) {\n            contentDiv.textContent = message.content;\n          }\n          return lastStreamingStatsMessage;\n        }\n      }\n\n      // Handle streaming content updates\n      if (message.type === 'streaming_content_update') {\n        if (lastStreamingContentMessage) {\n          const contentDiv = lastStreamingContentMessage.querySelector('.message-content');\n          if (contentDiv) {\n            contentDiv.textContent = message.content;\n          }\n          // Force scroll to bottom as content grows\n          void lastStreamingContentMessage.offsetHeight;\n          requestAnimationFrame(() => {\n            messagesDiv.scrollTop = messagesDiv.scrollHeight;\n          });\n          return lastStreamingContentMessage;\n        }\n      }\n\n      const msgDiv = document.createElement('div');\n      msgDiv.className = `chat-message ${message.type}`;\n\n      // Track thinking messages for updates\n      if (message.type === 'thinking') {\n        lastThinkingMessage = msgDiv;\n      } else if (message.type === 'streaming_stats') {\n        lastStreamingStatsMessage = msgDiv;\n      } else if (message.type === 'streaming_content') {\n        lastStreamingContentMessage = msgDiv;\n      } else if (message.type === 'assistant') {\n        // Clear thinking/streaming references when we get actual response\n        stopThinkingAnimation();\n        lastThinkingMessage = null;\n        lastStreamingStatsMessage = null;\n        lastStreamingContentMessage = null;\n      }\n\n      let icon = '';\n      switch (message.type) {\n        case 'agent':\n          icon = '[SYSTEM]';  // Meta messages about agent actions\n          break;\n        case 'assistant':\n          icon = '[REPLOID]';  // Actual LLM responses\n          break;\n        case 'tool':\n          icon = '[TOOL]';\n          break;\n        case 'tool_result':\n          icon = '[RESULT]';\n          break;\n        case 'tool_error':\n          icon = '[ERROR]';\n          break;\n        case 'thinking':\n        case 'thinking_update':\n          icon = '[THINKING]';\n          break;\n        case 'streaming_stats':\n        case 'streaming_stats_update':\n          icon = '[STATS]';\n          break;\n        case 'streaming_content':\n        case 'streaming_content_update':\n          icon = '[STREAMING]';\n          break;\n        case 'done':\n          icon = '[DONE]';\n          break;\n        case 'system':\n          icon = '[SYSTEM]';\n          break;\n        case 'error':\n          icon = '[ERROR]';\n          break;\n        case 'context_injected':\n        case 'context':\n          icon = '[CONTEXT]';\n          break;\n        case 'preview':\n          icon = '[PREVIEW]';\n          break;\n        case 'diff':\n          icon = '[DIFF]';\n          break;\n        case 'approval':\n          icon = '[APPROVAL]';\n          break;\n        default:\n          icon = '';\n      }\n\n      // Determine if message should be collapsible (long content)\n      // Don't collapse thinking messages or short system messages\n      const contentLength = message.content.length;\n      const isCollapsibleType = ['assistant', 'tool_result', 'context', 'preview'].includes(message.type);\n      const shouldCollapse = isCollapsibleType && contentLength > 200; // Collapse if > 200 chars\n\n      msgDiv.innerHTML = `\n        <div class=\"message-icon\">${icon}</div>\n        <div class=\"message-content ${shouldCollapse ? 'collapsed' : ''}\">${escapeHtml(message.content)}</div>\n      `;\n\n      // Add click handler for collapsible messages\n      if (shouldCollapse) {\n        const contentDiv = msgDiv.querySelector('.message-content');\n        contentDiv.style.cursor = 'pointer';\n        contentDiv.title = 'Click to expand/collapse';\n        contentDiv.addEventListener('click', () => {\n          contentDiv.classList.toggle('collapsed');\n        });\n      }\n\n      messagesDiv.appendChild(msgDiv);\n\n      // Start animation for thinking messages\n      if (message.type === 'thinking' || message.type === 'thinking_update') {\n        const contentDiv = msgDiv.querySelector('.message-content');\n        if (contentDiv) {\n          startThinkingAnimation(contentDiv);\n        }\n      }\n\n      // Force immediate render by triggering reflow before scroll\n      // This prevents browser batching of DOM updates\n      void msgDiv.offsetHeight;\n\n      // Auto-scroll to bottom with smooth behavior\n      requestAnimationFrame(() => {\n        messagesDiv.scrollTop = messagesDiv.scrollHeight;\n      });\n\n      return msgDiv; // Return element for updates\n    };\n\n    // Escape HTML\n    const escapeHtml = (text) => {\n      const helper = window.REPLOID?.utils?.escapeHtml;\n      if (helper) return helper(text);\n      const div = document.createElement('div');\n      div.textContent = text;\n      return div.innerHTML;\n    };\n\n    // Show chat UI\n    const show = () => {\n      container.style.display = 'flex';\n    };\n\n    // Hide chat UI\n    const hide = () => {\n      container.style.display = 'none';\n    };\n\n    // Clear messages\n    const clear = () => {\n      messagesDiv.innerHTML = '';\n    };\n\n    return {\n      show,\n      hide,\n      clear,\n      addMessage\n    };\n  }\n};\n\nexport default ChatUI;\n",
      "hash": "64e3b07bab787155981cc26496d4c9926b8b30b2846896c39ea9603aeb7b4c49"
    },
    "tools/code_intel.js": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 2903,
        "binary": false
      },
      "content": "/**\n * @fileoverview Code Intelligence Tool\n * Reads file structure (imports, exports, functions) without loading full content.\n * Saves tokens during RSI analysis phases.\n */\n\nconst inputSchema = {\n  type: 'object',\n  required: ['path'],\n  properties: {\n    path: {\n      type: 'string',\n      description: 'The VFS path to analyze (e.g. /core/agent-loop.js)'\n    }\n  }\n};\n\nconst validateInput = (input) => {\n  if (!input || typeof input.path !== 'string') {\n    return 'Parameter \"path\" is required';\n  }\n  if (!input.path.trim()) {\n    return 'Parameter \"path\" cannot be empty';\n  }\n  return null;\n};\n\nasync function call(input = {}, deps = {}) {\n  const validationError = validateInput(input);\n  if (validationError) {\n    return { success: false, error: validationError };\n  }\n\n  const path = input.path.trim();\n  const { VFS } = deps;\n  if (!VFS) {\n    return { success: false, error: 'VFS unavailable in this environment' };\n  }\n\n  if (!(await VFS.exists(path))) {\n    return { success: false, error: `File not found: ${path}` };\n  }\n\n  const content = await VFS.read(path);\n  const lines = content.split('\\n');\n\n  const structure = {\n    imports: [],\n    exports: [],\n    functions: [],\n    classes: [],\n    todos: [],\n    loc: lines.length\n  };\n\n  // Lightweight Regex Analysis (Fast, low token cost output)\n  lines.forEach((line, index) => {\n    const i = index + 1;\n    const trim = line.trim();\n\n    // Imports\n    if (trim.startsWith('import ')) {\n        structure.imports.push({ line: i, sig: trim });\n    }\n\n    // Exports\n    if (trim.startsWith('export ')) {\n        structure.exports.push({ line: i, sig: trim.split('{')[0].split('(')[0] });\n    }\n\n    // Functions (simple heuristic)\n    const funcMatch = line.match(/(async\\s+)?function\\s+([a-zA-Z0-9_]+)|const\\s+([a-zA-Z0-9_]+)\\s*=\\s*(async\\s*)?(\\([^)]*\\)|[a-z])\\s*=>/);\n    if (funcMatch) {\n        const name = funcMatch[2] || funcMatch[3];\n        // Ignore common noise\n        if (name && !['if', 'for', 'while', 'switch', 'catch'].includes(name)) {\n            structure.functions.push({ line: i, name });\n        }\n    }\n\n    // Classes\n    const classMatch = line.match(/class\\s+([a-zA-Z0-9_]+)/);\n    if (classMatch) {\n        structure.classes.push({ line: i, name: classMatch[1] });\n    }\n\n    // TODOs\n    if (trim.includes('TODO') || trim.includes('FIXME')) {\n        structure.todos.push({ line: i, comment: trim });\n    }\n  });\n\n  return {\n    success: true,\n    path,\n    summary: `Analyzed ${path} (${structure.loc} lines). Found ${structure.functions.length} functions, ${structure.classes.length} classes.`,\n    structure\n  };\n}\n\nexport const tool = {\n  name: \"code_intel\",\n  description: \"Analyzes a file's structure (functions, exports, imports) without reading the full content. Use this first to save tokens when exploring code.\",\n  inputSchema,\n  call\n};\n\nexport default call; // Support both export styles\n",
      "hash": "62f2438ffd364256b3028b773ee5366a0a9858cca4377fe98b484f981629fbaf"
    },
    "infrastructure/rate-limiter.js": {
      "meta": {
        "mtimeMs": 1763656572031.2285,
        "size": 1413,
        "binary": false
      },
      "content": "/**\n * @fileoverview Token Bucket Rate Limiter\n */\n\nconst RateLimiter = {\n  metadata: {\n    id: 'RateLimiter',\n    version: '2.0.0',\n    dependencies: ['Utils'],\n    type: 'infrastructure'\n  },\n\n  factory: (deps) => {\n    const { logger } = deps.Utils;\n\n    class TokenBucket {\n      constructor(capacity, refillRate) {\n        this.capacity = capacity;\n        this.tokens = capacity;\n        this.refillRate = refillRate; // tokens per second\n        this.lastRefill = Date.now();\n      }\n\n      _refill() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000;\n        if (elapsed > 0) {\n          const added = elapsed * this.refillRate;\n          this.tokens = Math.min(this.capacity, this.tokens + added);\n          this.lastRefill = now;\n        }\n      }\n\n      async waitForToken() {\n        this._refill();\n        if (this.tokens >= 1) {\n          this.tokens -= 1;\n          return true;\n        }\n\n        const needed = 1 - this.tokens;\n        const waitMs = (needed / this.refillRate) * 1000;\n        logger.debug(`[RateLimiter] Throttling for ${Math.ceil(waitMs)}ms`);\n        await new Promise(r => setTimeout(r, waitMs));\n\n        this.tokens = 0;\n        this.lastRefill = Date.now();\n        return true;\n      }\n    }\n\n    const createLimiter = (tpm = 60) => new TokenBucket(10, tpm / 60);\n\n    return { createLimiter };\n  }\n};\n\nexport default RateLimiter;\n",
      "hash": "75780124212f0a199e19ce51c05e909eda49a83cd01c75ba7fb8ebe7e0f9d336"
    },
    "infrastructure/event-bus.js": {
      "meta": {
        "mtimeMs": 1763656570399.2388,
        "size": 1302,
        "binary": false
      },
      "content": "/**\n * @fileoverview Event Bus\n * Pub/Sub system with subscription tracking.\n */\n\nconst EventBus = {\n  metadata: {\n    id: 'EventBus',\n    version: '2.0.0',\n    dependencies: ['Utils'],\n    type: 'infrastructure'\n  },\n\n  factory: (deps) => {\n    const { logger, createSubscriptionTracker } = deps.Utils;\n    const _listeners = new Map();\n    const _tracker = createSubscriptionTracker();\n\n    const on = (event, fn, ownerId = null) => {\n      if (!_listeners.has(event)) _listeners.set(event, new Set());\n      _listeners.get(event).add(fn);\n\n      const unsub = () => {\n        const set = _listeners.get(event);\n        if (set) set.delete(fn);\n      };\n\n      if (ownerId) _tracker.track(ownerId, unsub);\n      return unsub;\n    };\n\n    const emit = (event, data) => {\n      // logger.debug(`[Event] ${event}`, data); // Uncomment for verbose debugging\n      const set = _listeners.get(event);\n      if (set) {\n        for (const fn of set) {\n          try { fn(data); } catch (e) { logger.error(`[EventBus] Error in ${event}`, e); }\n        }\n      }\n    };\n\n    const unsubscribeModule = (moduleId) => {\n      _tracker.unsubscribeAll(moduleId);\n      logger.debug(`[EventBus] Unsubscribed module: ${moduleId}`);\n    };\n\n    return { on, emit, unsubscribeModule };\n  }\n};\n\nexport default EventBus;\n",
      "hash": "6525db44f6936d1cc8eb0d77ba63215c9f265c0cc707897b8877dbf68b82713f"
    },
    "infrastructure/di-container.js": {
      "meta": {
        "mtimeMs": 1763656570689.2368,
        "size": 1721,
        "binary": false
      },
      "content": "/**\n * @fileoverview Dependency Injection Container\n * Handles module registration, resolution, and lifecycle.\n */\n\nconst DIContainer = {\n  metadata: {\n    id: 'DIContainer',\n    version: '2.0.0',\n    dependencies: ['Utils'],\n    type: 'infrastructure'\n  },\n\n  factory: (deps) => {\n    const { logger } = deps.Utils;\n    const _modules = new Map();\n    const _instances = new Map();\n    const _stack = new Set(); // For circular dependency checks\n\n    const register = (mod) => {\n      if (!mod.metadata?.id) throw new Error('Invalid module registration');\n      _modules.set(mod.metadata.id, mod);\n    };\n\n    const resolve = async (id) => {\n      if (_instances.has(id)) return _instances.get(id);\n\n      const mod = _modules.get(id);\n      if (!mod) throw new Error(`Module not found: ${id}`);\n\n      if (_stack.has(id)) throw new Error(`Circular dependency: ${id}`);\n      _stack.add(id);\n\n      try {\n        const reqs = mod.metadata.dependencies || [];\n        const inj = {};\n\n        for (const req of reqs) {\n          const optional = req.endsWith('?');\n          const name = optional ? req.slice(0, -1) : req;\n          try {\n            inj[name] = await resolve(name);\n          } catch (e) {\n            if (!optional) throw e;\n            logger.warn(`[DI] Optional dep ${name} missing for ${id}`);\n          }\n        }\n\n        logger.info(`[DI] Initializing ${id}`);\n        const instance = mod.factory(inj);\n\n        if (mod.metadata.async && instance.init) {\n          await instance.init();\n        }\n\n        _instances.set(id, instance);\n        return instance;\n\n      } finally {\n        _stack.delete(id);\n      }\n    };\n\n    return { register, resolve };\n  }\n};\n\nexport default DIContainer;\n",
      "hash": "5c8fac2f3bfd8fabedba320f99125e13bc3bb108bbe76e2faac1fec1d7a80772"
    },
    "infrastructure/browser-apis.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 15214,
        "binary": false
      },
      "content": "// Browser-Native Web API Integration for REPLOID\n// Validates thesis that browser environment is superior to CLI for RSI\n\nconst BrowserAPIs = {\n  metadata: {\n    id: 'BrowserAPIs',\n    version: '1.0.0',\n    dependencies: ['Utils', 'EventBus', 'StateManager'],\n    async: true,\n    type: 'capability'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus, StateManager } = deps;\n    const { logger } = Utils;\n\n    let fileSystemHandle = null;\n    let notificationPermission = 'default';\n    const capabilities = {};\n\n    const DETECTORS = {\n      fileSystemAccess: () => 'showDirectoryPicker' in window,\n      notifications: () => 'Notification' in window,\n      clipboard: () => 'clipboard' in navigator && 'writeText' in navigator.clipboard,\n      webShare: () => 'share' in navigator,\n      storageEstimation: () => 'storage' in navigator && 'estimate' in navigator.storage,\n      wakeLock: () => 'wakeLock' in navigator\n    };\n\n    /**\n     * Initialize - detect available APIs\n     */\n    const init = async () => {\n      logger.info('[BrowserAPIs] Initializing web API integration...');\n\n      Object.entries(DETECTORS).forEach(([key, detector]) => {\n        capabilities[key] = detector();\n      });\n\n      if (capabilities.notifications) {\n        notificationPermission = Notification.permission;\n      }\n\n      logger.info('[BrowserAPIs] Capabilities detected:', capabilities);\n      EventBus.emit('browser-apis:initialized', capabilities);\n    };\n\n    /**\n     * Get all detected capabilities\n     * @returns {Object} Capability flags\n     */\n    const getCapabilities = () => {\n      return { ...capabilities };\n    };\n\n    // ===== FILE SYSTEM ACCESS API =====\n\n    /**\n     * Request directory access from user\n     * @param {string} mode - 'read' or 'readwrite'\n     * @returns {Promise<FileSystemDirectoryHandle|null>}\n     */\n    const requestDirectoryAccess = async (mode = 'readwrite') => {\n      if (!capabilities.fileSystemAccess) {\n        logger.error('[BrowserAPIs] File System Access API not available');\n        return null;\n      }\n\n      try {\n        logger.info('[BrowserAPIs] Requesting directory access...');\n        const handle = await window.showDirectoryPicker({ mode });\n        fileSystemHandle = handle;\n\n        logger.info(`[BrowserAPIs] Directory access granted: ${handle.name}`);\n        EventBus.emit('browser-apis:filesystem:granted', { name: handle.name, mode });\n\n        return handle;\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          logger.info('[BrowserAPIs] User cancelled directory picker');\n        } else {\n          logger.error('[BrowserAPIs] Failed to get directory access:', error);\n        }\n        return null;\n      }\n    };\n\n    /**\n     * Get current directory handle\n     * @returns {FileSystemDirectoryHandle|null}\n     */\n    const getDirectoryHandle = () => {\n      return fileSystemHandle;\n    };\n\n    /**\n     * Write file to filesystem\n     * @param {string} path - Relative path from directory root\n     * @param {string} content - File content\n     * @returns {Promise<boolean>} Success status\n     */\n    const writeFile = async (path, content) => {\n      if (!fileSystemHandle) {\n        logger.error('[BrowserAPIs] No directory handle available. Call requestDirectoryAccess() first.');\n        return false;\n      }\n\n      try {\n        // Navigate path segments\n        const segments = path.split('/').filter(s => s);\n        const fileName = segments.pop();\n        let currentHandle = fileSystemHandle;\n\n        // Create/navigate directories\n        for (const segment of segments) {\n          currentHandle = await currentHandle.getDirectoryHandle(segment, { create: true });\n        }\n\n        // Create/get file\n        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });\n        const writable = await fileHandle.createWritable();\n        await writable.write(content);\n        await writable.close();\n\n        logger.info(`[BrowserAPIs] File written: ${path}`);\n        EventBus.emit('browser-apis:filesystem:write', { path, size: content.length });\n\n        return true;\n      } catch (error) {\n        logger.error(`[BrowserAPIs] Failed to write file ${path}:`, error);\n        return false;\n      }\n    };\n\n    /**\n     * Read file from filesystem\n     * @param {string} path - Relative path from directory root\n     * @returns {Promise<string|null>} File content or null\n     */\n    const readFile = async (path) => {\n      if (!fileSystemHandle) {\n        logger.error('[BrowserAPIs] No directory handle available.');\n        return null;\n      }\n\n      try {\n        const segments = path.split('/').filter(s => s);\n        const fileName = segments.pop();\n        let currentHandle = fileSystemHandle;\n\n        // Navigate directories\n        for (const segment of segments) {\n          currentHandle = await currentHandle.getDirectoryHandle(segment);\n        }\n\n        // Read file\n        const fileHandle = await currentHandle.getFileHandle(fileName);\n        const file = await fileHandle.getFile();\n        const content = await file.text();\n\n        logger.info(`[BrowserAPIs] File read: ${path} (${content.length} bytes)`);\n        return content;\n      } catch (error) {\n        logger.error(`[BrowserAPIs] Failed to read file ${path}:`, error);\n        return null;\n      }\n    };\n\n    /**\n     * Sync VFS artifact to real filesystem\n     * @param {string} artifactPath - VFS path\n     * @returns {Promise<boolean>} Success status\n     */\n    const syncArtifactToFilesystem = async (artifactPath) => {\n      if (!fileSystemHandle) {\n        logger.error('[BrowserAPIs] No directory handle available.');\n        return false;\n      }\n\n      try {\n        const content = await StateManager.getArtifactContent(artifactPath);\n        if (!content) {\n          logger.error(`[BrowserAPIs] Artifact not found: ${artifactPath}`);\n          return false;\n        }\n\n        // Remove leading slash for relative path\n        const relativePath = artifactPath.startsWith('/') ? artifactPath.slice(1) : artifactPath;\n        return await writeFile(relativePath, content);\n      } catch (error) {\n        logger.error(`[BrowserAPIs] Failed to sync artifact ${artifactPath}:`, error);\n        return false;\n      }\n    };\n\n    // ===== NOTIFICATIONS API =====\n\n    /**\n     * Request notification permission\n     * @returns {Promise<string>} Permission state: 'granted', 'denied', or 'default'\n     */\n    const requestNotificationPermission = async () => {\n      if (!capabilities.notifications) {\n        logger.error('[BrowserAPIs] Notifications API not available');\n        return 'denied';\n      }\n\n      try {\n        notificationPermission = await Notification.requestPermission();\n        logger.info(`[BrowserAPIs] Notification permission: ${notificationPermission}`);\n        EventBus.emit('browser-apis:notifications:permission', notificationPermission);\n        return notificationPermission;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to request notification permission:', error);\n        return 'denied';\n      }\n    };\n\n    /**\n     * Show notification to user\n     * @param {string} title - Notification title\n     * @param {Object} options - Notification options\n     * @returns {Promise<boolean>} Success status\n     */\n    const showNotification = async (title, options = {}) => {\n      if (!capabilities.notifications) {\n        logger.error('[BrowserAPIs] Notifications API not available');\n        return false;\n      }\n\n      if (notificationPermission !== 'granted') {\n        logger.warn('[BrowserAPIs] Notification permission not granted');\n        return false;\n      }\n\n      try {\n        const notification = new Notification(title, {\n          icon: '/favicon.ico',\n          badge: '/favicon.ico',\n          ...options\n        });\n\n        logger.info(`[BrowserAPIs] Notification shown: ${title}`);\n        EventBus.emit('browser-apis:notifications:shown', { title, options });\n\n        return true;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to show notification:', error);\n        return false;\n      }\n    };\n\n    // ===== CLIPBOARD API =====\n\n    /**\n     * Write text to clipboard\n     * @param {string} text - Text to copy\n     * @returns {Promise<boolean>} Success status\n     */\n    const writeToClipboard = async (text) => {\n      if (!capabilities.clipboard) {\n        logger.error('[BrowserAPIs] Clipboard API not available');\n        return false;\n      }\n\n      try {\n        await navigator.clipboard.writeText(text);\n        logger.info(`[BrowserAPIs] Copied to clipboard: ${text.length} characters`);\n        EventBus.emit('browser-apis:clipboard:write', { length: text.length });\n        return true;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to write to clipboard:', error);\n        return false;\n      }\n    };\n\n    /**\n     * Read text from clipboard\n     * @returns {Promise<string|null>} Clipboard text or null\n     */\n    const readFromClipboard = async () => {\n      if (!capabilities.clipboard) {\n        logger.error('[BrowserAPIs] Clipboard API not available');\n        return null;\n      }\n\n      try {\n        const text = await navigator.clipboard.readText();\n        logger.info(`[BrowserAPIs] Read from clipboard: ${text.length} characters`);\n        return text;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to read from clipboard:', error);\n        return null;\n      }\n    };\n\n    // ===== WEB SHARE API =====\n\n    /**\n     * Share content using Web Share API\n     * @param {Object} data - Share data (title, text, url)\n     * @returns {Promise<boolean>} Success status\n     */\n    const share = async (data) => {\n      if (!capabilities.webShare) {\n        logger.error('[BrowserAPIs] Web Share API not available');\n        return false;\n      }\n\n      try {\n        await navigator.share(data);\n        logger.info('[BrowserAPIs] Content shared:', data);\n        EventBus.emit('browser-apis:share:success', data);\n        return true;\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          logger.info('[BrowserAPIs] User cancelled share');\n        } else {\n          logger.error('[BrowserAPIs] Failed to share:', error);\n        }\n        return false;\n      }\n    };\n\n    // ===== STORAGE ESTIMATION API =====\n\n    /**\n     * Get storage quota and usage\n     * @returns {Promise<Object|null>} Storage estimate or null\n     */\n    const getStorageEstimate = async () => {\n      if (!capabilities.storageEstimation) {\n        logger.error('[BrowserAPIs] Storage Estimation API not available');\n        return null;\n      }\n\n      try {\n        const estimate = await navigator.storage.estimate();\n        const usagePercent = (estimate.usage / estimate.quota) * 100;\n\n        const result = {\n          usage: estimate.usage,\n          quota: estimate.quota,\n          usagePercent,\n          usageMB: (estimate.usage / 1024 / 1024).toFixed(2),\n          quotaMB: (estimate.quota / 1024 / 1024).toFixed(2),\n          available: estimate.quota - estimate.usage,\n          availableMB: ((estimate.quota - estimate.usage) / 1024 / 1024).toFixed(2)\n        };\n\n        logger.info(`[BrowserAPIs] Storage: ${result.usageMB}MB / ${result.quotaMB}MB (${usagePercent.toFixed(1)}%)`);\n        EventBus.emit('browser-apis:storage:estimate', result);\n\n        return result;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to get storage estimate:', error);\n        return null;\n      }\n    };\n\n    /**\n     * Request persistent storage\n     * @returns {Promise<boolean>} Whether persistent storage is granted\n     */\n    const requestPersistentStorage = async () => {\n      if (!capabilities.storageEstimation || !navigator.storage.persist) {\n        logger.error('[BrowserAPIs] Persistent storage not available');\n        return false;\n      }\n\n      try {\n        const isPersisted = await navigator.storage.persist();\n        logger.info(`[BrowserAPIs] Persistent storage: ${isPersisted}`);\n        EventBus.emit('browser-apis:storage:persist', isPersisted);\n        return isPersisted;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to request persistent storage:', error);\n        return false;\n      }\n    };\n\n    // ===== WAKE LOCK API =====\n\n    let wakeLock = null;\n\n    /**\n     * Request wake lock to keep screen awake during long operations\n     * @returns {Promise<boolean>} Success status\n     */\n    const requestWakeLock = async () => {\n      if (!capabilities.wakeLock) {\n        logger.error('[BrowserAPIs] Wake Lock API not available');\n        return false;\n      }\n\n      try {\n        wakeLock = await navigator.wakeLock.request('screen');\n        logger.info('[BrowserAPIs] Wake lock acquired');\n        EventBus.emit('browser-apis:wakelock:acquired');\n\n        wakeLock.addEventListener('release', () => {\n          logger.info('[BrowserAPIs] Wake lock released');\n          EventBus.emit('browser-apis:wakelock:released');\n        });\n\n        return true;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to acquire wake lock:', error);\n        return false;\n      }\n    };\n\n    /**\n     * Release wake lock\n     * @returns {Promise<boolean>} Success status\n     */\n    const releaseWakeLock = async () => {\n      if (!wakeLock) {\n        return false;\n      }\n\n      try {\n        await wakeLock.release();\n        wakeLock = null;\n        return true;\n      } catch (error) {\n        logger.error('[BrowserAPIs] Failed to release wake lock:', error);\n        return false;\n      }\n    };\n\n    /**\n     * Generate capability report\n     * @returns {string} Markdown report\n     */\n    const generateReport = () => {\n      let md = '# Browser API Capabilities Report\\n\\n';\n      md += `**Generated:** ${new Date().toISOString()}\\n\\n`;\n\n      md += '## Available APIs\\n\\n';\n      for (const [api, available] of Object.entries(capabilities)) {\n        const icon = available ? 'âœ…' : 'âŒ';\n        md += `- ${icon} **${api}**: ${available ? 'Available' : 'Not Available'}\\n`;\n      }\n      md += '\\n';\n\n      if (capabilities.fileSystemAccess) {\n        md += '## File System Access\\n\\n';\n        md += `- **Directory Handle:** ${fileSystemHandle ? `âœ… ${fileSystemHandle.name}` : 'âŒ Not granted'}\\n`;\n        md += '- **Mode:** Read/Write\\n\\n';\n      }\n\n      if (capabilities.notifications) {\n        md += '## Notifications\\n\\n';\n        md += `- **Permission:** ${notificationPermission}\\n\\n`;\n      }\n\n      md += '---\\n\\n*Generated by REPLOID Browser APIs Module*\\n';\n      return md;\n    };\n\n    return {\n      init,\n      getCapabilities,\n      // File System Access\n      requestDirectoryAccess,\n      getDirectoryHandle,\n      writeFile,\n      readFile,\n      syncArtifactToFilesystem,\n      // Notifications\n      requestNotificationPermission,\n      showNotification,\n      // Clipboard\n      writeToClipboard,\n      readFromClipboard,\n      // Web Share\n      share,\n      // Storage\n      getStorageEstimate,\n      requestPersistentStorage,\n      // Wake Lock\n      requestWakeLock,\n      releaseWakeLock,\n      // Reporting\n      generateReport\n    };\n  }\n};\n\n// Export\nBrowserAPIs;\n",
      "hash": "e5cfcd9667a80210a5080874a7876dc1eac8b4a0afc307d91139334dc45bc932"
    },
    "infrastructure/audit-logger.js": {
      "meta": {
        "mtimeMs": 1763734898785.7883,
        "size": 2093,
        "binary": false
      },
      "content": "/**\n * @fileoverview Audit Logger\n * Security tracking. Writes to /.logs/audit/YYYY-MM-DD.jsonl\n */\n\nconst AuditLogger = {\n  metadata: {\n    id: 'AuditLogger',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS'],\n    async: true,\n    type: 'infrastructure'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS } = deps;\n    const { logger, generateId } = Utils;\n    const LOG_DIR = '/.logs/audit';\n\n    const init = async () => {\n      // Directory check implied by VFS structure\n      return true;\n    };\n\n    const logEvent = async (type, data, severity = 'INFO') => {\n      const entry = {\n        id: generateId('log'),\n        ts: new Date().toISOString(),\n        type,\n        severity,\n        data\n      };\n\n      // Echo security warnings to console\n      if (severity === 'ERROR' || severity === 'WARN') {\n        logger.warn(`[Audit] ${type}`, data);\n      }\n\n      const date = new Date().toISOString().split('T')[0];\n      const path = `${LOG_DIR}/${date}.jsonl`;\n\n      // Retry once on failure to ensure audit trail integrity\n      for (let attempt = 0; attempt < 2; attempt++) {\n        try {\n          let content = '';\n          if (await VFS.exists(path)) {\n            content = await VFS.read(path);\n          }\n          content += JSON.stringify(entry) + '\\n';\n          await VFS.write(path, content);\n          return; // Success\n        } catch (e) {\n          if (attempt === 0) {\n            logger.warn('[AuditLogger] Write failed, retrying...', e.message);\n            await new Promise(r => setTimeout(r, 50));\n          } else {\n            logger.error('[AuditLogger] Write failed after retry - audit event lost', {\n              error: e.message,\n              entry: { type, severity, id: entry.id }\n            });\n          }\n        }\n      }\n    };\n\n    return {\n      init,\n      logEvent,\n      // Convenience aliases\n      logAgentAction: (action, tool, args) => logEvent('AGENT_ACTION', { action, tool, args }),\n      logSecurity: (type, details) => logEvent('SECURITY', { type, ...details }, 'ERROR')\n    };\n  }\n};\n\nexport default AuditLogger;\n",
      "hash": "bccf233376a64830b51554c65f93d482a4f7a3b6a3672bd54686c764ecab6f9d"
    },
    "examples/substrate-modifier.js": {
      "meta": {
        "mtimeMs": 1763652196479.6208,
        "size": 6306,
        "binary": false
      },
      "content": "\n/**\n * Example: Substrate Optimizer\n * Level: 3 (Substrate Modification / Kernel Surgery)\n * \n * Demonstrates reading core agent source code, planning an architectural change,\n * and applying it via the meta-tool-writer.\n * \n * âš ï¸ DANGER: This modifies running code. Use dry_run=true to test safely.\n */\n\nexport default async function substrate_optimizer({\n  target_module = \"tool-runner\",\n  optimization_goal = \"Add performance logging to tool execution\",\n  dry_run = true\n}) {\n  console.log(`[Optimizer] Analyzing substrate module: ${target_module}`);\n  \n  // 1. Read the Substrate\n  const modulePath = `/core/${target_module}.js`;\n  let sourceCode;\n  try {\n    sourceCode = await window.REPLOID.vfs.read(modulePath);\n  } catch (e) {\n    return { success: false, error: `Core module not found: ${modulePath}` };\n  }\n\n  // 2. Visualize Current State\n  await updatePreview(target_module, \"Analyzing Substrate...\", null, dry_run);\n\n  // 3. Generate Optimized Code via LLM\n  const activeModel = getActiveModel();\n  const prompt = `\n    You are a Senior Architect optimization engine.\n    Target Module: ${target_module}.js\n    Goal: ${optimization_goal}\n    \n    Current Code:\n    \\`\\`\\`javascript\n    ${sourceCode}\n    \\`\\`\\`\n    \n    Return the FULL, VALID JavaScript code for the modified module.\n    - Maintain the existing factory pattern structure exactly.\n    - Only implement the requested optimization.\n    - Do not remove existing functionality.\n    - Output ONLY the code block.\n  `;\n\n  console.log('[Optimizer] Requesting architectural changes...');\n  const response = await window.REPLOID.llmClient.chat(\n    [{ role: 'user', content: prompt }],\n    activeModel\n  );\n\n  const newCode = response.content\n    .replace(/^```javascript\\n?|^```js\\n?|^```/g, '')\n    .replace(/```$/g, '')\n    .trim();\n\n  // 4. Calculate Diff stats (simple heuristic)\n  const oldLines = sourceCode.split('\\n').length;\n  const newLines = newCode.split('\\n').length;\n  const diffStat = newLines - oldLines;\n  const diffString = diffStat > 0 ? `+${diffStat}` : `${diffStat}`;\n\n  // 5. Apply or Simulate\n  let resultMessage;\n  \n  if (dry_run) {\n    console.log('[Optimizer] Dry Run: Changes generated but not applied.');\n    resultMessage = \"Dry Run Complete. Changes ready for review.\";\n    \n    // Visualize the proposal\n    await updatePreview(target_module, \"Proposal Generated\", {\n      diff: diffString,\n      preview: newCode.substring(0, 500) + \"\\n...[rest of code]...\"\n    }, dry_run);\n\n  } else {\n    console.log('[Optimizer] APPLYING CHANGES TO KERNEL...');\n    \n    // Call the Level 3 Meta-Tool\n    try {\n      const result = await window.REPLOID.toolRunner.execute('improve_core_module', {\n        module: target_module,\n        code: newCode\n      });\n      \n      resultMessage = \"Optimization Applied. Substrate updated.\";\n      await updatePreview(target_module, \"Success: Kernel Updated\", {\n        diff: diffString,\n        backup: result.backup\n      }, dry_run);\n      \n    } catch (err) {\n      return { success: false, error: `Kernel Update Failed: ${err.message}` };\n    }\n  }\n\n  return {\n    success: true,\n    module: target_module,\n    changes_lines: diffString,\n    mode: dry_run ? \"Simulation\" : \"Live Mutation\",\n    message: resultMessage\n  };\n}\n\n// Helper: Get Model\nfunction getActiveModel() {\n  try {\n    return JSON.parse(localStorage.getItem('SELECTED_MODELS') || '[]')[0];\n  } catch (e) { return null; }\n}\n\n// Helper: Visualization\nasync function updatePreview(moduleName, status, data, isDryRun) {\n  if (!window.REPLOID?.toolRunner) return;\n\n  const modeColor = isDryRun ? '#ffd700' : '#ff00ff'; // Gold for Sim, Magenta for Level 3\n  \n  let content = '';\n  if (data) {\n    content = `\n      <div style=\"background: rgba(0,0,0,0.3); padding: 15px; border-radius: 4px; margin-bottom: 15px;\">\n        <div style=\"display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;\">\n          <div>\n            <div style=\"color: #888; font-size: 10px;\">LINES CHANGED</div>\n            <div style=\"color: ${parseInt(data.diff) >= 0 ? '#0f0' : '#f00'}; font-size: 18px; font-weight: bold;\">${data.diff}</div>\n          </div>\n          <div>\n            <div style=\"color: #888; font-size: 10px;\">BACKUP CREATED</div>\n            <div style=\"color: #fff; font-size: 12px;\">${data.backup ? 'YES' : 'NO (Dry Run)'}</div>\n          </div>\n        </div>\n        ${data.preview ? `<pre style=\"color: #aaa; font-size: 10px; border: 1px solid #333; padding: 10px; overflow-x: auto;\">${data.preview}</pre>` : ''}\n      </div>\n    `;\n  }\n\n  const html = `\n    <div style=\"font-family: monospace; padding: 20px; color: #e0e0e0;\">\n      <h2 style=\"color: ${modeColor}; border-bottom: 1px solid #333; padding-bottom: 10px;\">\n        âš¡ Substrate Optimizer (Level 3)\n      </h2>\n      <div style=\"display: flex; justify-content: space-between; margin: 15px 0; font-size: 12px;\">\n        <span style=\"color: #fff;\">Target: <strong style=\"color: #4fc3f7\">/core/${moduleName}.js</strong></span>\n        <span style=\"border: 1px solid ${modeColor}; color: ${modeColor}; padding: 2px 6px; border-radius: 3px;\">\n          ${isDryRun ? 'DRY RUN' : 'LIVE MUTATION'}\n        </span>\n      </div>\n      \n      <div style=\"margin-bottom: 20px; color: #ccc; font-size: 14px; font-weight: bold;\">\n        ${status}\n      </div>\n      \n      ${content}\n      \n      <div style=\"font-size: 11px; color: #666; margin-top: 20px; border-top: 1px dashed #333; padding-top: 10px;\">\n        âš ï¸ Level 3 RSI involves modifying the agent's runtime code. \n        In non-dry-run mode, changes persist across reloads.\n        Use \"Safe Mode\" (boot menu) if the agent becomes unstable.\n      </div>\n    </div>\n  `;\n\n  await window.REPLOID.toolRunner.execute('update_preview', { html });\n}\n\n// Metadata\nsubstrate_optimizer.metadata = {\n  name: 'substrate_optimizer',\n  description: 'Reads and rewrites core modules to improve performance/functionality (Level 3 RSI)',\n  parameters: {\n    type: 'object',\n    properties: {\n      target_module: { type: 'string', description: 'Name of core module (e.g. \"tool-runner\")' },\n      optimization_goal: { type: 'string', description: 'What to improve' },\n      dry_run: { type: 'boolean', description: 'If true, only generates code without applying' }\n    }\n  }\n};\n",
      "hash": "baffd4350a5e533ec6620b022dbd56b2f088d6100af60fdc2ec018b65d1c2749"
    },
    "examples/self-play-prompt-improver.js": {
      "meta": {
        "mtimeMs": 1763651841809.845,
        "size": 4987,
        "binary": false
      },
      "content": "/**\n * Example: Self-Play Prompt Improver\n * Level: 2 (Meta-Cognition / Self-Improvement)\n * \n * Demonstrates using the LLM to critique and refine its own prompts iteratively.\n * Uses the Live Preview panel to visualize the evolution.\n */\n\nexport default async function self_play_prompt_improver({\n  initial_prompt = \"You are a helpful AI assistant.\",\n  iterations = 5,\n  model = null\n}) {\n  console.log('[SelfPlay] Starting prompt evolution...');\n\n  // 1. Resolve Model (Compatible with new boot.js architecture)\n  let activeModel = model;\n  if (!activeModel) {\n    try {\n      // Try to get from localStorage (saved by boot/model-config.js)\n      const savedModels = JSON.parse(localStorage.getItem('SELECTED_MODELS') || '[]');\n      if (savedModels.length > 0) {\n        activeModel = savedModels[0];\n      } else {\n        throw new Error(\"No active models found in configuration\");\n      }\n    } catch (e) {\n      return { success: false, error: \"Could not resolve a model to run this tool. Please configure a model in the boot screen.\" };\n    }\n  }\n\n  const evolution = [];\n  let current_prompt = initial_prompt;\n\n  // Store initial state\n  evolution.push({\n    iteration: 0,\n    prompt: initial_prompt,\n    weakness: \"N/A (initial seed)\",\n    improvement: \"N/A\"\n  });\n\n  // Update Preview immediately\n  await updatePreview(evolution);\n\n  for (let i = 0; i < iterations; i++) {\n    console.log(`[SelfPlay] Iteration ${i + 1}/${iterations}...`);\n\n    try {\n      // Step A: Critique (Identify Weakness)\n      const weaknessResp = await window.REPLOID.llmClient.chat(\n        [\n          { role: 'system', content: 'You are a harsh critic. Identify ONE specific weakness in the user provided prompt.' },\n          { role: 'user', content: `Prompt: \"${current_prompt}\"\\n\\nIdentify ONE specific, actionable weakness. Respond ONLY with the weakness description.` }\n        ],\n        activeModel\n      );\n      const weakness = weaknessResp.content.trim();\n\n      // Step B: Refine (Fix Weakness)\n      const improveResp = await window.REPLOID.llmClient.chat(\n        [\n          { role: 'system', content: 'You are an expert prompt engineer. Rewrite the prompt to fix the identified weakness.' },\n          { role: 'user', content: `Original: \"${current_prompt}\"\\nWeakness: ${weakness}\\n\\nRewrite the prompt to fix this. Output ONLY the new prompt.` }\n        ],\n        activeModel\n      );\n      \n      let improved_prompt = improveResp.content.trim().replace(/^[\"']|[\"']$/g, ''); // Strip quotes\n\n      // Record Step\n      evolution.push({\n        iteration: i + 1,\n        prompt: improved_prompt,\n        weakness: weakness,\n        improvement: `Fixed: ${weakness.substring(0, 50)}...`\n      });\n\n      current_prompt = improved_prompt;\n\n      // Update Visualization\n      await updatePreview(evolution);\n\n    } catch (error) {\n      console.error(`[SelfPlay] Error in iteration ${i + 1}:`, error);\n      evolution.push({ iteration: i + 1, prompt: current_prompt, weakness: `ERROR: ${error.message}`, improvement: \"Failed\" });\n      break; // Stop on error\n    }\n  }\n\n  return {\n    success: true,\n    final_prompt: current_prompt,\n    iterations_completed: evolution.length - 1,\n    message: \"Check Live Preview for evolution history.\"\n  };\n}\n\n// Helper to update the Live Preview panel via ToolRunner\nasync function updatePreview(evolution) {\n  if (!window.REPLOID?.toolRunner) return;\n\n  const html = `\n    <div style=\"font-family: monospace; padding: 20px; color: #e0e0e0;\">\n      <h2 style=\"color: #0ff; border-bottom: 1px solid #333; padding-bottom: 10px;\">ðŸ§¬ Prompt Evolution DNA</h2>\n      ${evolution.map(step => `\n        <div style=\"margin-bottom: 20px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 5px; border-left: 3px solid ${step.iteration === 0 ? '#888' : '#0f0'};\">\n          <div style=\"display:flex; justify-content:space-between; margin-bottom:5px;\">\n            <strong style=\"color: #0ff;\">Gen ${step.iteration}</strong>\n            <span style=\"color: #888; font-size: 0.8em;\">${step.prompt.length} chars</span>\n          </div>\n          <div style=\"color: #fff; margin-bottom: 10px; line-height: 1.4;\">${step.prompt}</div>\n          ${step.iteration > 0 ? `\n            <div style=\"font-size: 0.9em; color: #ff7b72;\">ðŸ”´ Critique: ${step.weakness}</div>\n            <div style=\"font-size: 0.9em; color: #7ee787;\">ðŸŸ¢ Action: ${step.improvement}</div>\n          ` : ''}\n        </div>\n      `).join('')}\n    </div>\n  `;\n\n  await window.REPLOID.toolRunner.execute('update_preview', { html });\n}\n\n// Metadata for Tool Registry\nself_play_prompt_improver.metadata = {\n  name: 'self_play_prompt_improver',\n  description: 'Evolves a prompt using iterative self-critique (Level 2 RSI Pattern)',\n  parameters: {\n    type: 'object',\n    properties: {\n      initial_prompt: { type: 'string', description: 'The seed prompt to start with' },\n      iterations: { type: 'number', description: 'How many evolution cycles to run' }\n    }\n  }\n};",
      "hash": "6e948642825bb1ce58debe2ab183be8defbeea9321e799afe6607fd508f7e4dd"
    },
    "examples/code-quality-auditor.js": {
      "meta": {
        "mtimeMs": 1763651978560.0046,
        "size": 5240,
        "binary": false
      },
      "content": "/**\n * Example: Code Quality Auditor\n * Level: 1 (Tool Usage / Domain Task)\n * \n * Demonstrates using the agent's read capabilities and LLM inference\n * to perform a specific job (auditing code) without modifying the agent itself.\n */\n\nexport default async function code_quality_auditor({\n  file_path = \"/core/agent-loop.js\",\n  focus_area = \"performance\" // security, readability, performance\n}) {\n  console.log(`[Auditor] Starting audit of ${file_path} focusing on ${focus_area}...`);\n\n  // 1. Validation & Setup\n  if (!window.REPLOID?.vfs) {\n    return { success: false, error: \"VFS not available\" };\n  }\n\n  // 2. Read Target File\n  let code;\n  try {\n    code = await window.REPLOID.vfs.read(file_path);\n    console.log(`[Auditor] Read ${code.length} bytes from ${file_path}`);\n  } catch (e) {\n    return { success: false, error: `File not found: ${file_path}` };\n  }\n\n  // 3. Update Preview (Loading State)\n  await updatePreview(file_path, \"Analyzing...\", null);\n\n  // 4. Perform Analysis (The \"Work\")\n  // We use the first available model configuration\n  const activeModel = getActiveModel();\n  \n  const prompt = `\n    Analyze the following JavaScript code specifically for ${focus_area}.\n    Code Snippet:\n    \\`\\`\\`javascript\n    ${code.substring(0, 5000)} ${code.length > 5000 ? '...(truncated)' : ''}\n    \\`\\`\\`\n    \n    Return a JSON object (no markdown formatting) with:\n    {\n      \"score\": (number 1-100),\n      \"summary\": (string, 1 sentence),\n      \"issues\": [\n        { \"line\": (number or null), \"severity\": \"high/medium/low\", \"description\": \"string\" }\n      ],\n      \"suggestion\": (string, specific code improvement)\n    }\n  `;\n\n  let report;\n  try {\n    const response = await window.REPLOID.llmClient.chat(\n      [{ role: 'user', content: prompt }],\n      activeModel\n    );\n    \n    // Sanitize and parse JSON\n    const jsonStr = response.content.replace(/```json\\n?|```/g, '').trim();\n    report = JSON.parse(jsonStr);\n    \n  } catch (error) {\n    console.error('[Auditor] Analysis failed:', error);\n    await updatePreview(file_path, \"Analysis Failed\", { error: error.message });\n    return { success: false, error: error.message };\n  }\n\n  // 5. Visualize Results\n  await updatePreview(file_path, \"Audit Complete\", report);\n\n  return {\n    success: true,\n    file: file_path,\n    score: report.score,\n    issue_count: report.issues.length\n  };\n}\n\n// Helper to get active model configuration\nfunction getActiveModel() {\n  try {\n    const savedModels = JSON.parse(localStorage.getItem('SELECTED_MODELS') || '[]');\n    return savedModels[0] || null;\n  } catch (e) { return null; }\n}\n\n// Helper to render visualization\nasync function updatePreview(path, status, report) {\n  if (!window.REPLOID?.toolRunner) return;\n\n  let detailsHtml = '';\n  if (report && !report.error) {\n    const color = report.score > 80 ? '#0f0' : report.score > 50 ? '#fb0' : '#f00';\n    \n    const issuesHtml = report.issues.map(issue => `\n      <div style=\"margin-bottom: 8px; border-left: 3px solid ${issue.severity === 'high' ? '#f00' : '#888'}; padding-left: 10px;\">\n        <span style=\"color: #fff; font-size: 0.9em;\">${issue.description}</span>\n      </div>\n    `).join('');\n\n    detailsHtml = `\n      <div style=\"display: flex; align-items: center; gap: 15px; margin-bottom: 20px;\">\n        <div style=\"\n          width: 60px; height: 60px; border-radius: 50%; \n          border: 4px solid ${color}; display: flex; \n          align-items: center; justify-content: center; \n          font-size: 24px; font-weight: bold; color: ${color};\">\n          ${report.score}\n        </div>\n        <div>\n          <div style=\"color: #888; font-size: 12px; text-transform: uppercase;\">Assessment</div>\n          <div style=\"color: #fff; font-size: 14px;\">${report.summary}</div>\n        </div>\n      </div>\n      <div style=\"background: rgba(255,255,255,0.05); padding: 15px; border-radius: 4px;\">\n        <h4 style=\"margin: 0 0 10px 0; color: #bbb;\">Detected Issues</h4>\n        ${issuesHtml}\n      </div>\n    `;\n  } else if (report && report.error) {\n    detailsHtml = `<div style=\"color: #f00; padding: 20px;\">Error: ${report.error}</div>`;\n  } else {\n    detailsHtml = `<div style=\"color: #888; padding: 20px; font-style: italic;\">Waiting for LLM...</div>`;\n  }\n\n  const html = `\n    <div style=\"font-family: monospace; padding: 20px; color: #e0e0e0;\">\n      <h2 style=\"color: #4fc3f7; border-bottom: 1px solid #333; padding-bottom: 10px; display: flex; justify-content: space-between;\">\n        <span>ðŸ” Code Auditor</span>\n        <span style=\"font-size: 0.6em; color: #666; padding-top: 10px;\">${status}</span>\n      </h2>\n      <div style=\"margin: 15px 0; font-size: 12px; color: #888;\">Target: ${path}</div>\n      ${detailsHtml}\n    </div>\n  `;\n\n  await window.REPLOID.toolRunner.execute('update_preview', { html });\n}\n\n// Metadata\ncode_quality_auditor.metadata = {\n  name: 'code_quality_auditor',\n  description: 'Analyzes VFS files for quality/security (Level 1 RSI Pattern)',\n  parameters: {\n    type: 'object',\n    properties: {\n      file_path: { type: 'string', description: 'Path to the file to analyze' },\n      focus_area: { type: 'string', enum: ['security', 'performance', 'readability'] }\n    },\n    required: ['file_path']\n  }\n};\n",
      "hash": "30becb9f8178d21037963aa7ab569d8b6fbdcfdfd04d84ab01de3d4140d425e9"
    },
    "core/vfs.js": {
      "meta": {
        "mtimeMs": 1763734866782.0244,
        "size": 5433,
        "binary": false
      },
      "content": "/**\n * @fileoverview Virtual File System (VFS)\n * IndexedDB-backed storage.\n *\n * BREAKING: Uses 'reploid-vfs-v2'. Previous v1 data is ignored.\n */\n\nconst VFS = {\n  metadata: {\n    id: 'VFS',\n    version: '2.0.0',\n    dependencies: ['Utils'],\n    async: true,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils } = deps;\n    const { logger, Errors } = Utils;\n\n    const DB_NAME = 'reploid-vfs-v2';\n    const STORE_FILES = 'files';\n    let db = null;\n\n    const openDB = () => {\n      return new Promise((resolve, reject) => {\n        if (db) return resolve(db);\n        const request = indexedDB.open(DB_NAME, 1);\n\n        request.onupgradeneeded = (event) => {\n          const d = event.target.result;\n          if (!d.objectStoreNames.contains(STORE_FILES)) {\n            d.createObjectStore(STORE_FILES, { keyPath: 'path' });\n          }\n        };\n\n        request.onsuccess = (e) => {\n          db = e.target.result;\n          logger.info('[VFS] Database connected');\n          resolve(db);\n        };\n        request.onerror = () => reject(new Errors.StateError('Failed to open VFS DB'));\n      });\n    };\n\n    const normalize = (path) => {\n      if (!path || typeof path !== 'string') throw new Errors.ValidationError('Invalid path');\n      let clean = path.trim().replace(/\\\\/g, '/');\n      return clean.startsWith('/') ? clean : '/' + clean;\n    };\n\n    // --- API ---\n\n    const init = async () => { await openDB(); return true; };\n\n    const write = async (path, content) => {\n      await openDB();\n      const cleanPath = normalize(path);\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction([STORE_FILES], 'readwrite');\n        const store = tx.objectStore(STORE_FILES);\n        const entry = {\n          path: cleanPath,\n          content,\n          size: content.length,\n          updated: Date.now(),\n          type: 'file'\n        };\n        store.put(entry).onsuccess = () => resolve(true);\n        tx.onerror = () => reject(new Errors.ArtifactError(`Write failed: ${cleanPath}`));\n      });\n    };\n\n    const read = async (path) => {\n      await openDB();\n      const cleanPath = normalize(path);\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction([STORE_FILES], 'readonly');\n        const req = tx.objectStore(STORE_FILES).get(cleanPath);\n        req.onsuccess = () => {\n          req.result ? resolve(req.result.content) : reject(new Errors.ArtifactError(`File not found: ${cleanPath}`));\n        };\n        req.onerror = () => reject(new Errors.ArtifactError(`Read failed: ${cleanPath}`));\n      });\n    };\n\n    const remove = async (path) => {\n      await openDB();\n      const cleanPath = normalize(path);\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction([STORE_FILES], 'readwrite');\n        const req = tx.objectStore(STORE_FILES).delete(cleanPath);\n        req.onsuccess = () => {\n          logger.info(`[VFS] Deleted ${cleanPath}`);\n          resolve(true);\n        };\n        req.onerror = () => {\n          logger.error(`[VFS] Delete failed: ${cleanPath}`);\n          reject(new Errors.ArtifactError(`Delete failed: ${cleanPath}`));\n        };\n      });\n    };\n\n    const list = async (dir = '/') => {\n      await openDB();\n      const cleanDir = normalize(dir);\n      const prefix = cleanDir.endsWith('/') ? cleanDir : cleanDir + '/';\n      return new Promise((resolve) => {\n        const tx = db.transaction([STORE_FILES], 'readonly');\n        const req = tx.objectStore(STORE_FILES).getAllKeys();\n        req.onsuccess = () => {\n          // Filter by prefix (simulating directory structure)\n          const all = req.result || [];\n          resolve(all.filter(p => p.startsWith(prefix)));\n        };\n      });\n    };\n\n    const stat = async (path) => {\n      await openDB();\n      const cleanPath = normalize(path);\n      return new Promise((resolve) => {\n        const tx = db.transaction([STORE_FILES], 'readonly');\n        const req = tx.objectStore(STORE_FILES).get(cleanPath);\n        req.onsuccess = () => {\n          if (req.result) {\n            resolve({\n              path: req.result.path,\n              size: req.result.size,\n              updated: req.result.updated,\n              type: req.result.type\n            });\n          } else {\n            resolve(null);\n          }\n        };\n      });\n    };\n\n    const exists = async (path) => {\n      const meta = await stat(path);\n      return !!meta;\n    };\n\n    const isEmpty = async () => {\n      await openDB();\n      return new Promise((resolve) => {\n        const tx = db.transaction([STORE_FILES], 'readonly');\n        const req = tx.objectStore(STORE_FILES).count();\n        req.onsuccess = () => resolve(req.result === 0);\n      });\n    };\n\n    // Virtual mkdir - VFS is flat, so this is mostly for API compatibility\n    // useful if we later add directory metadata\n    const mkdir = async (path) => {\n      logger.debug(`[VFS] mkdir ${path} (virtual)`);\n      return true;\n    };\n\n    const clear = async () => {\n      await openDB();\n      return new Promise((resolve) => {\n        const tx = db.transaction([STORE_FILES], 'readwrite');\n        tx.objectStore(STORE_FILES).clear().onsuccess = () => resolve(true);\n      });\n    };\n\n    return {\n      init,\n      read,\n      write,\n      delete: remove,\n      list,\n      stat,\n      exists,\n      isEmpty,\n      mkdir,\n      clear\n    };\n  }\n};\n\nexport default VFS;\n",
      "hash": "ad4af76471a73ec0e996e9d855e20fccf5a2ea07c85cdf5b62d47236b5a305bc"
    },
    "core/verification-worker.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 2503,
        "binary": false
      },
      "content": "/**\n * @fileoverview Verification Worker\n * Runs in a Web Worker sandbox to safely test code.\n * Includes Static Analysis and Security Heuristics.\n */\n\nself.onmessage = async (e) => {\n  const { type, snapshot } = e.data;\n\n  if (type === 'VERIFY') {\n    try {\n      const errors = [];\n      const warnings = [];\n\n      // 1. Static Analysis & Security Heuristics\n      for (const [path, code] of Object.entries(snapshot)) {\n        // Only check JS files that are being modified/added\n        if (!path.endsWith('.js')) continue;\n\n        // A. Syntax Check\n        try {\n          new Function(code);\n        } catch (err) {\n          errors.push(`Syntax Error in ${path}: ${err.message}`);\n          continue; // Skip further checks if syntax is invalid\n        }\n\n        // B. Dangerous Pattern Detection\n        const dangerousPatterns = [\n            { regex: /\\beval\\s*\\(/, message: \"Use of 'eval' is forbidden\" },\n            { regex: /\\bnew\\s+Function\\s*\\(/, message: \"Use of 'new Function' is forbidden (restricted modules only)\" },\n            { regex: /localStorage\\./, message: \"Direct localStorage access forbidden in tools (use StateManager)\" },\n            { regex: /document\\.cookie/, message: \"Cookie access is forbidden\" },\n            { regex: /while\\s*\\(\\s*true\\s*\\)/, message: \"Potential infinite loop 'while(true)' detected\" }\n        ];\n\n        // Whitelist core system modules that legitimately require dynamic evaluation\n        const isPrivileged = path.includes('/core/utils.js') || path.includes('/core/tool-writer.js');\n\n        if (!isPrivileged) {\n            for (const pattern of dangerousPatterns) {\n                if (pattern.regex.test(code)) {\n                    errors.push(`Security Violation in ${path}: ${pattern.message}`);\n                }\n            }\n        }\n\n        // C. Structural Analysis (Heuristics)\n        // Tools must export a specific shape\n        if (path.startsWith('/tools/')) {\n             if (!code.includes('export default') && !code.includes('export const tool')) {\n                 errors.push(`Tool ${path} must have a default export or named 'tool' export`);\n             }\n        }\n      }\n\n      if (errors.length > 0) {\n        self.postMessage({ passed: false, reason: 'Verification Failed', errors });\n        return;\n      }\n\n      // 3. Success\n      self.postMessage({ passed: true, warnings });\n    } catch (err) {\n      self.postMessage({ passed: false, reason: `Worker Logic Crash: ${err.message}` });\n    }\n  }\n};\n",
      "hash": "c0766a4e53783e8fe23b4ff72522ab299cc5c0441280ae4db7da73743aec94d2"
    },
    "core/verification-manager.js": {
      "meta": {
        "mtimeMs": 1763656781854.9001,
        "size": 1810,
        "binary": false
      },
      "content": "/**\n * @fileoverview Verification Manager\n * Pre-flight safety checks via Web Worker.\n */\n\nconst VerificationManager = {\n  metadata: {\n    id: 'VerificationManager',\n    version: '2.0.1',\n    dependencies: ['Utils', 'VFS'],\n    async: true,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { logger } = deps.Utils;\n    const { VFS } = deps;\n\n    const WORKER_PATH = '/core/verification-worker.js';\n\n    const createSnapshot = async () => {\n      const files = await VFS.list('/');\n      const snapshot = {};\n      for (const path of files) {\n        if (path.endsWith('.js') || path.endsWith('.json')) {\n          try { snapshot[path] = await VFS.read(path); } catch (e) {}\n        }\n      }\n      return snapshot;\n    };\n\n    const verifyProposal = async (changes) => {\n      logger.info('[Verifier] Snapshotting...');\n      const snapshot = await createSnapshot();\n\n      // Overlay changes\n      for (const c of changes) {\n        if (c.operation === 'DELETE') delete snapshot[c.file_path];\n        else snapshot[c.file_path] = c.new_content;\n      }\n\n      return new Promise((resolve) => {\n        const worker = new Worker(WORKER_PATH);\n\n        const timeout = setTimeout(() => {\n          worker.terminate();\n          resolve({ passed: false, reason: 'Timeout' });\n        }, 5000);\n\n        worker.onmessage = (e) => {\n          clearTimeout(timeout);\n          worker.terminate();\n          resolve(e.data);\n        };\n\n        worker.onerror = (e) => {\n          clearTimeout(timeout);\n          worker.terminate();\n          logger.error('[Verifier] Crash', e);\n          resolve({ passed: false, reason: 'Worker Error' });\n        };\n\n        worker.postMessage({ type: 'VERIFY', snapshot });\n      });\n    };\n\n    return { verifyProposal };\n  }\n};\n\nexport default VerificationManager;\n",
      "hash": "5a2c7683f32f703c6b049b7e7ef4c012c8750696d9713a805e312caf28da0a97"
    },
    "core/utils.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 4657,
        "binary": false
      },
      "content": "/**\n * @fileoverview Core Utilities Module\n * The foundational pure functions and error classes used across the system.\n */\n\nconst Utils = {\n  metadata: {\n    id: 'Utils',\n    version: '2.1.0',\n    dependencies: [],\n    type: 'pure'\n  },\n\n  factory: () => {\n    // --- Internal State ---\n    const _logStats = { debug: 0, info: 0, warn: 0, error: 0 };\n    const _recentLogs = [];\n    const MAX_LOG_HISTORY = 100;\n\n    // --- Error Handling System ---\n    class ApplicationError extends Error {\n      constructor(message, details = {}) {\n        super(message);\n        this.name = this.constructor.name;\n        this.details = details;\n        this.timestamp = Date.now();\n      }\n    }\n\n    class ApiError extends ApplicationError {\n      constructor(message, status, details) {\n        super(message, details);\n        this.status = status;\n      }\n    }\n\n    class StateError extends ApplicationError {}\n    class ArtifactError extends ApplicationError {}\n    class ValidationError extends ApplicationError {}\n    class AbortError extends ApplicationError {}\n    class ToolError extends ApplicationError {}\n    class ConfigError extends ApplicationError {}\n\n    const Errors = {\n      ApplicationError,\n      ApiError,\n      StateError,\n      ArtifactError,\n      ValidationError,\n      AbortError,\n      ToolError,\n      ConfigError\n    };\n\n    // --- Logging System ---\n    const logger = {\n      _write: (level, message, details) => {\n        _logStats[level]++;\n\n        const entry = {\n          ts: new Date().toISOString(),\n          level: level.toUpperCase(),\n          msg: message,\n          data: details\n        };\n\n        const method = console[level] || console.log;\n        const prefix = `[${entry.level}]`;\n        details ? method(prefix, message, details) : method(prefix, message);\n\n        _recentLogs.push(entry);\n        if (_recentLogs.length > MAX_LOG_HISTORY) _recentLogs.shift();\n      },\n\n      debug: (msg, data) => logger._write('debug', msg, data),\n      info: (msg, data) => logger._write('info', msg, data),\n      warn: (msg, data) => logger._write('warn', msg, data),\n      error: (msg, data) => logger._write('error', msg, data),\n\n      getStats: () => ({ ..._logStats }),\n      getHistory: () => [..._recentLogs],\n      clearHistory: () => { _recentLogs.length = 0; }\n    };\n\n    // --- Pure Helpers ---\n\n    const generateId = (prefix = 'id') => {\n      const random = Math.random().toString(36).substring(2, 10);\n      const ts = Date.now().toString(36);\n      return `${prefix}_${ts}_${random}`;\n    };\n\n    const trunc = (str, len) => {\n      if (!str) return '';\n      return str.length > len ? str.substring(0, len - 3) + '...' : str;\n    };\n\n    const kabobToCamel = (s) => s.replace(/-([a-z0-9])/gi, (_, c) => c.toUpperCase());\n\n    const escapeHtml = (unsafe) => {\n      if (!unsafe) return '';\n      return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n    };\n\n    const sanitizeLlmJsonRespPure = (text) => {\n      if (!text || typeof text !== 'string') return { json: \"{}\", method: \"empty\" };\n\n      try {\n        JSON.parse(text);\n        return { json: text, method: \"direct\" };\n      } catch (e) { /* continue */ }\n\n      const codeBlock = text.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/);\n      if (codeBlock) {\n        try {\n          JSON.parse(codeBlock[1]);\n          return { json: codeBlock[1], method: \"block\" };\n        } catch (e) { /* continue */ }\n      }\n\n      const firstOpen = text.indexOf('{');\n      const lastClose = text.lastIndexOf('}');\n      if (firstOpen > -1 && lastClose > firstOpen) {\n        const candidate = text.substring(firstOpen, lastClose + 1);\n        try {\n          JSON.parse(candidate);\n          return { json: candidate, method: \"heuristic\" };\n        } catch (e) { /* continue */ }\n      }\n\n      return { json: \"{}\", method: \"failed\" };\n    };\n\n    /**\n     * Tracker to prevent EventBus memory leaks\n     */\n    const createSubscriptionTracker = () => {\n      const subs = new Map();\n      return {\n        track: (id, unsubFn) => {\n          if (!subs.has(id)) subs.set(id, []);\n          subs.get(id).push(unsubFn);\n        },\n        unsubscribeAll: (id) => {\n          const list = subs.get(id);\n          if (list) {\n            list.forEach(fn => fn());\n            subs.delete(id);\n          }\n        }\n      };\n    };\n\n    return {\n      Errors,\n      logger,\n      generateId,\n      trunc,\n      kabobToCamel,\n      escapeHtml,\n      sanitizeLlmJsonRespPure,\n      createSubscriptionTracker\n    };\n  }\n};\n\nexport default Utils;\n",
      "hash": "02b5751d90a64832d683fdabce618e3ace4a348d9e204226d7416e301ceccdb6"
    },
    "core/transformers-client.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 8506,
        "binary": false
      },
      "content": "/**\n * @fileoverview Transformers.js Client\n * Browser-native inference using Hugging Face Transformers.js with WebGPU/WASM.\n * Supports newer models like Qwen3, Gemma3, DeepSeek-R1 that aren't in WebLLM.\n */\n\nconst TransformersClient = {\n  metadata: {\n    id: 'TransformersClient',\n    version: '1.1.0',\n    dependencies: ['Utils', 'EventBus'],\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus } = deps;\n    const { logger, Errors } = Utils;\n\n    // State\n    let _generator = null;\n    let _currentModelId = null;\n    let _loaderPromise = null;\n\n    // Model configurations for Transformers.js\n    const modelConfigs = {\n      // Qwen3 models\n      'qwen3-0.6b': {\n        hfId: 'onnx-community/Qwen3-0.6B-ONNX',\n        dtype: 'q4',\n        device: 'webgpu'\n      },\n      'qwen3-1.7b': {\n        hfId: 'onnx-community/Qwen3-1.7B-ONNX',\n        dtype: 'q4',\n        device: 'webgpu'\n      },\n      // Gemma3 models\n      'gemma3-1b': {\n        hfId: 'onnx-community/gemma-3-1b-it-ONNX',\n        dtype: 'q4',\n        device: 'webgpu'\n      },\n      // SmolLM2\n      'smollm2-360m': {\n        hfId: 'HuggingFaceTB/SmolLM2-360M-Instruct',\n        dtype: 'fp16',\n        device: 'webgpu'\n      },\n      'smollm2-1.7b': {\n        hfId: 'HuggingFaceTB/SmolLM2-1.7B-Instruct',\n        dtype: 'q4',\n        device: 'webgpu'\n      },\n      // DeepSeek-R1 distilled\n      'deepseek-r1-1.5b': {\n        hfId: 'onnx-community/DeepSeek-R1-Distill-Qwen-1.5B-ONNX',\n        dtype: 'q4',\n        device: 'webgpu'\n      },\n      // Phi-4-mini\n      'phi4-mini': {\n        hfId: 'onnx-community/Phi-4-mini-instruct-ONNX',\n        dtype: 'q4',\n        device: 'webgpu'\n      }\n    };\n\n    const ensureTransformersReady = async () => {\n      if (typeof window === 'undefined') {\n        throw new Errors.ConfigError('Transformers.js is only available in browser environments');\n      }\n\n      if (window.transformers) return window.transformers;\n      if (_loaderPromise) return _loaderPromise;\n\n      _loaderPromise = import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3')\n        .then(mod => {\n          window.transformers = {\n            pipeline: mod.pipeline,\n            env: mod.env\n          };\n          // Configure for WebGPU\n          mod.env.backends.onnx.wasm.proxy = false;\n          return window.transformers;\n        })\n        .catch((err) => {\n          _loaderPromise = null;\n          logger.error('[Transformers] Failed to load runtime', err);\n          throw new Errors.ConfigError('Failed to load Transformers.js runtime');\n        });\n\n      return _loaderPromise;\n    };\n\n    const loadModel = async (modelId) => {\n      await ensureTransformersReady();\n\n      const config = modelConfigs[modelId];\n      if (!config) {\n        throw new Errors.ConfigError(`Unknown Transformers.js model: ${modelId}`);\n      }\n\n      if (_currentModelId === modelId && _generator) {\n        logger.info(`[Transformers] Model ${modelId} already loaded`);\n        return;\n      }\n\n      logger.info(`[Transformers] Loading model: ${config.hfId}`);\n\n      // Throttle progress updates - only emit on 5% changes\n      let lastReportedPercent = -1;\n\n      try {\n        // Dispose previous generator if exists\n        if (_generator && _generator.dispose) {\n          await _generator.dispose();\n        }\n\n        // Emit downloading state\n        EventBus.emit('agent:status', {\n          state: 'DOWNLOADING',\n          activity: `Downloading model: ${modelId}`,\n          progress: 0\n        });\n\n        _generator = await window.transformers.pipeline(\n          'text-generation',\n          config.hfId,\n          {\n            device: config.device,\n            dtype: config.dtype,\n            progress_callback: (progress) => {\n              if (progress.status === 'progress' && progress.total > 0) {\n                const percent = Math.round((progress.loaded / progress.total) * 100);\n                // Only emit if percent changed by 5% or more\n                if (percent - lastReportedPercent >= 5 || percent === 100) {\n                  lastReportedPercent = percent;\n                  const shortFile = progress.file?.split('/').pop() || 'model';\n                  EventBus.emit('agent:status', {\n                    state: 'DOWNLOADING',\n                    activity: `Downloading ${shortFile}: ${percent}%`,\n                    progress: percent\n                  });\n                }\n              }\n            }\n          }\n        );\n\n        _currentModelId = modelId;\n        logger.info(`[Transformers] Model ${modelId} loaded successfully`);\n      } catch (err) {\n        logger.error(`[Transformers] Failed to load model ${modelId}`, err);\n        _generator = null;\n        _currentModelId = null;\n        const reason = err?.message || err?.cause?.message || err?.toString() || 'Unknown error';\n        throw new Errors.ApiError(`Failed to load model: ${reason}`, 500);\n      }\n    };\n\n    const chat = async (messages, modelConfig, onUpdate) => {\n      const modelId = modelConfig.transformersModelId || modelConfig.id;\n\n      await loadModel(modelId);\n\n      // Format messages for text generation\n      // Transformers.js text-generation expects a single prompt string\n      const prompt = formatMessagesForGeneration(messages);\n\n      logger.info(`[Transformers] Generating response for ${modelId}`);\n\n      try {\n        let fullContent = '';\n\n        if (onUpdate) {\n          // Streaming mode using callback\n          const streamer = {\n            put: (tokens) => {\n              const text = _generator.tokenizer.decode(tokens, { skip_special_tokens: true });\n              if (text) {\n                fullContent += text;\n                onUpdate(text);\n              }\n            },\n            end: () => {}\n          };\n\n          await _generator(prompt, {\n            max_new_tokens: 2048,\n            temperature: 0.7,\n            do_sample: true,\n            streamer\n          });\n        } else {\n          // Non-streaming mode\n          const output = await _generator(prompt, {\n            max_new_tokens: 2048,\n            temperature: 0.7,\n            do_sample: true,\n            return_full_text: false\n          });\n\n          fullContent = output[0].generated_text;\n        }\n\n        return {\n          requestId: Utils.generateId('tfjs'),\n          content: stripThoughts(fullContent),\n          raw: fullContent,\n          model: modelId,\n          timestamp: Date.now(),\n          provider: 'transformers'\n        };\n\n      } catch (err) {\n        logger.error('[Transformers] Generation error', err);\n        const reason = err?.message || err?.cause?.message || err?.toString() || 'Unknown error';\n        throw new Errors.ApiError(`Transformers.js generation failed: ${reason}`, 500);\n      }\n    };\n\n    const formatMessagesForGeneration = (messages) => {\n      // Convert chat messages to a single prompt string\n      // Using ChatML-like format that most models understand\n      let prompt = '';\n\n      for (const msg of messages) {\n        if (msg.role === 'system') {\n          prompt += `<|system|>\\n${msg.content}\\n`;\n        } else if (msg.role === 'user') {\n          prompt += `<|user|>\\n${msg.content}\\n`;\n        } else if (msg.role === 'assistant') {\n          prompt += `<|assistant|>\\n${msg.content}\\n`;\n        }\n      }\n\n      // Add final assistant tag to prompt generation\n      prompt += '<|assistant|>\\n';\n\n      return prompt;\n    };\n\n    const stripThoughts = (text) => {\n      return text\n        .replace(/<think>[\\s\\S]*?<\\/think>/gi, '')\n        .replace(/<thinking>[\\s\\S]*?<\\/thinking>/gi, '')\n        .trim();\n    };\n\n    const getStatus = () => {\n      return {\n        loaded: !!_generator,\n        model: _currentModelId,\n        available: typeof window !== 'undefined' && !!navigator.gpu\n      };\n    };\n\n    const getAvailableModels = () => {\n      return Object.entries(modelConfigs).map(([id, config]) => ({\n        id,\n        hfId: config.hfId,\n        dtype: config.dtype\n      }));\n    };\n\n    const unload = async () => {\n      if (_generator && _generator.dispose) {\n        await _generator.dispose();\n      }\n      _generator = null;\n      _currentModelId = null;\n      logger.info('[Transformers] Model unloaded');\n    };\n\n    return {\n      chat,\n      loadModel,\n      getStatus,\n      getAvailableModels,\n      unload,\n      isTransformersModel: (id) => id in modelConfigs || id.startsWith('transformers:')\n    };\n  }\n};\n\nexport default TransformersClient;\n",
      "hash": "d6c7bedcb6c2e6ba173827af2ce1fb1e46a398aa36cf9761af0706a313a39450"
    },
    "core/tool-writer.js": {
      "meta": {
        "mtimeMs": 1763656841571.5215,
        "size": 1226,
        "binary": false
      },
      "content": "/**\n * @fileoverview Tool Writer\n * Manages creation and validation of dynamic tools.\n */\n\nconst ToolWriter = {\n  metadata: {\n    id: 'ToolWriter',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS'],\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS } = deps;\n    const { logger, Errors } = Utils;\n\n    const validateCode = (code) => {\n      // Basic sanity check\n      if (!code.includes('export default') || !code.includes('async function')) {\n        throw new Errors.ValidationError('Tool must export a default async function');\n      }\n      try {\n        // Syntax check via Function constructor\n        new Function(code);\n      } catch (e) {\n        throw new Errors.ValidationError(`Syntax Error: ${e.message}`);\n      }\n    };\n\n    const create = async (name, code) => {\n      if (!/^[a-z_][a-z0-9_]*$/.test(name)) {\n        throw new Errors.ValidationError('Invalid tool name format');\n      }\n\n      validateCode(code);\n\n      const path = `/tools/${name}.js`;\n\n      // Persist\n      await VFS.write(path, code);\n\n      logger.info(`[ToolWriter] Created tool: ${name}`);\n      return `Tool ${name} created at ${path}`;\n    };\n\n    return { create };\n  }\n};\n\nexport default ToolWriter;\n",
      "hash": "a9910b3fab2518cf2fc9a3eac9439bb16e20317dbe4a75229ffab854f7467df3"
    },
    "core/tool-runner.js": {
      "meta": {
        "mtimeMs": 1763734866648.0254,
        "size": 4886,
        "binary": false
      },
      "content": "/**\n * @fileoverview Tool Runner\n * Execution engine for built-in and dynamic tools.\n */\n\nconst ToolRunner = {\n  metadata: {\n    id: 'ToolRunner',\n    version: '2.1.1',\n    dependencies: ['Utils', 'VFS', 'ToolWriter', 'MetaToolWriter', 'SubstrateLoader?'],\n    async: true,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS, ToolWriter, MetaToolWriter, SubstrateLoader } = deps;\n    const { logger, Errors } = Utils;\n\n    const _tools = new Map();\n    const _dynamicTools = new Set();\n\n    // --- Built-in Tools (VFS & System) ---\n\n    const builtIns = {\n      // VFS Ops\n      ReadFile: async ({ path }) => {\n        if (!path) throw new Errors.ValidationError('Missing path');\n        return await VFS.read(path);\n      },\n      WriteFile: async ({ path, content }) => {\n        if (!path || content === undefined) throw new Errors.ValidationError('Missing args');\n        await VFS.write(path, content);\n        return `Wrote ${path} (${content.length} bytes)`;\n      },\n      ListFiles: async ({ path }) => {\n        return await VFS.list(path || '/');\n      },\n      DeleteFile: async ({ path }) => {\n        await VFS.delete(path);\n        return `Deleted ${path}`;\n      },\n\n      // Tool Management (Level 1 RSI)\n      CreateTool: async ({ name, code }) => {\n        return await ToolWriter.create(name, code);\n      },\n\n      // Core Modification (Level 2 RSI)\n      improve_core_module: async ({ module, code }) => {\n        return await MetaToolWriter.improveCore(module, code);\n      }\n    };\n\n    // L3 Capability: Substrate Loader\n    if (SubstrateLoader) {\n        builtIns.LoadModule = async ({ path }) => {\n            await SubstrateLoader.loadModule(path);\n            return `Hot-reloaded module from ${path}`;\n        };\n    }\n\n    // Register built-ins\n    Object.entries(builtIns).forEach(([name, fn]) => _tools.set(name, fn));\n\n    const loadToolModule = async (path, forcedName = null) => {\n      try {\n        const code = await VFS.read(path);\n        const blob = new Blob([code], { type: 'text/javascript' });\n        const url = URL.createObjectURL(blob);\n\n        try {\n          const mod = await import(url);\n          const handler = typeof mod.default === 'function'\n            ? mod.default\n            : typeof mod.tool?.call === 'function'\n              ? mod.tool.call\n              : null;\n\n          if (!handler) {\n            logger.warn(`[ToolRunner] ${path} missing default export`);\n            return false;\n          }\n\n          const name = forcedName || path.split('/').pop().replace('.js', '');\n          _tools.set(name, handler);\n          _dynamicTools.add(name);\n          logger.info(`[ToolRunner] Loaded dynamic tool: ${name}`);\n          return true;\n        } finally {\n          URL.revokeObjectURL(url);\n        }\n      } catch (e) {\n        logger.error(`[ToolRunner] Failed to load ${path}`, e);\n        return false;\n      }\n    };\n\n    const unloadDynamicTools = () => {\n      for (const name of _dynamicTools) {\n        _tools.delete(name);\n      }\n      _dynamicTools.clear();\n    };\n\n    // --- Dynamic Tool Loading ---\n\n    const loadDynamicTools = async () => {\n      unloadDynamicTools();\n\n      let files = [];\n      try {\n        files = await VFS.list('/tools/');\n      } catch (err) {\n        logger.warn('[ToolRunner] Failed to list /tools directory', err);\n        return true;\n      }\n\n      for (const file of files) {\n        if (!file.endsWith('.js')) continue;\n        await loadToolModule(file);\n      }\n      return true;\n    };\n\n    const ensureToolLoaded = async (name) => {\n      if (_tools.has(name)) return true;\n      const path = `/tools/${name}.js`;\n      if (await VFS.exists(path)) {\n        return await loadToolModule(path, name);\n      }\n      return false;\n    };\n\n    // --- Public API ---\n\n    const execute = async (name, args = {}) => {\n      if (!_tools.has(name)) {\n        const loaded = await ensureToolLoaded(name);\n        if (!loaded) {\n          throw new Errors.ToolError(`Tool not found: ${name}`);\n        }\n      }\n\n      const toolFn = _tools.get(name);\n      if (!toolFn) {\n        throw new Errors.ToolError(`Tool not found: ${name}`);\n      }\n\n      logger.info(`[ToolRunner] Executing ${name}`);\n\n      try {\n        const result = await toolFn(args, { VFS }); // Inject VFS for tools like code_intel\n        return result;\n      } catch (err) {\n        logger.error(`[ToolRunner] Error in ${name}`, err);\n        const errorWithContext = new Errors.ToolError(err.message, { tool: name, args });\n        errorWithContext.stack = err.stack; // Preserve original stack trace\n        throw errorWithContext;\n      }\n    };\n\n    return {\n      init: loadDynamicTools,\n      execute,\n      refresh: loadDynamicTools,\n      list: () => Array.from(_tools.keys()),\n      has: (name) => _tools.has(name)\n    };\n  }\n};\n\nexport default ToolRunner;\n",
      "hash": "08eff63cdcc76cb1f81c1700fc3efcc7b6f686be09a06d2df2ca19c2f10a5ab0"
    },
    "core/substrate-loader.js": {
      "meta": {
        "mtimeMs": 1763657031061.319,
        "size": 1434,
        "binary": false
      },
      "content": "/**\n * @fileoverview Substrate Loader\n * Dynamically loads modules and widgets from VFS.\n */\n\nconst SubstrateLoader = {\n  metadata: {\n    id: 'SubstrateLoader',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS'],\n    type: 'core'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS } = deps;\n    const { logger } = Utils;\n\n    const loadModule = async (path) => {\n      if (!(await VFS.exists(path))) throw new Error(`Module not found: ${path}`);\n\n      const code = await VFS.read(path);\n      const blob = new Blob([code], { type: 'text/javascript' });\n      const url = URL.createObjectURL(blob);\n\n      try {\n        const module = await import(url);\n        logger.info(`[Substrate] Loaded module: ${path}`);\n        return module;\n      } finally {\n        URL.revokeObjectURL(url);\n      }\n    };\n\n    const loadWidget = async (path, containerId) => {\n      const module = await loadModule(path);\n      if (!module.default || !module.default.render) {\n        throw new Error('Invalid widget: missing render()');\n      }\n\n      const container = document.getElementById(containerId);\n      if (container) {\n        container.innerHTML = ''; // Clear previous\n        const element = module.default.render();\n        container.appendChild(element);\n        logger.info(`[Substrate] Rendered widget ${path} to ${containerId}`);\n      }\n    };\n\n    return { loadModule, loadWidget };\n  }\n};\n\nexport default SubstrateLoader;\n",
      "hash": "feea9a7672f106e0aed64d2d457dcd5d04a5c7fc0987eb721777d74ef0c14dda"
    },
    "core/state-manager.js": {
      "meta": {
        "mtimeMs": 1763734886427.8796,
        "size": 2918,
        "binary": false
      },
      "content": "/**\n * @fileoverview State Manager\n * Manages high-level agent state and persistence.\n */\n\nconst StateManager = {\n  metadata: {\n    id: 'StateManager',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS', 'StateHelpersPure', 'AuditLogger?'], // Optional AuditLogger\n    async: true,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS, StateHelpersPure, AuditLogger } = deps;\n    const { logger, Errors, generateId } = Utils;\n\n    const STATE_PATH = '/.system/state.json';\n    let _state = null;\n\n    const load = async () => {\n      try {\n        const content = await VFS.read(STATE_PATH);\n        const rawState = JSON.parse(content);\n\n        const errors = StateHelpersPure.validateState(rawState);\n        if (errors) {\n          logger.warn('[StateManager] Validation failed, resetting', errors);\n          _state = StateHelpersPure.createInitialState();\n        } else {\n          _state = StateHelpersPure.createInitialState(rawState); // Merge safely\n          logger.info(`[StateManager] Loaded state (Cycle: ${_state.totalCycles})`);\n        }\n      } catch (err) {\n        // If file missing, init fresh\n        logger.info('[StateManager] Initializing fresh state.');\n        _state = StateHelpersPure.createInitialState();\n        await save();\n      }\n      return _state;\n    };\n\n    const save = async (retries = 2) => {\n      if (!_state) return;\n      try {\n        const content = JSON.stringify(_state, null, 2);\n        await VFS.write(STATE_PATH, content);\n      } catch (err) {\n        if (retries > 0) {\n          logger.warn(`[StateManager] Save failed, retrying (${retries} left)`, err.message);\n          await new Promise(r => setTimeout(r, 100));\n          return save(retries - 1);\n        }\n        logger.error('[StateManager] Save failed after retries', err);\n      }\n    };\n\n    // --- Public API ---\n\n    const getState = () => {\n      if (!_state) throw new Errors.StateError('StateManager not initialized');\n      return JSON.parse(JSON.stringify(_state));\n    };\n\n    const updateState = async (updates) => {\n      if (!_state) await load();\n      Object.assign(_state, updates);\n      await save();\n      return getState();\n    };\n\n    const setGoal = async (goalText) => {\n      if (!_state) await load();\n\n      // Use pure helper to maintain goal history\n      _state = StateHelpersPure.pushGoal(_state, goalText);\n\n      await save();\n\n      if (AuditLogger && AuditLogger.logAgentAction) {\n        AuditLogger.logAgentAction('SET_GOAL', 'StateManager', { goal: goalText });\n      }\n\n      logger.info(`[StateManager] Goal set: \"${goalText.substring(0, 50)}...\"`);\n    };\n\n    const incrementCycle = async () => {\n      if (!_state) await load();\n      _state.totalCycles++;\n      await save();\n    };\n\n    return {\n      init: load,\n      getState,\n      updateState,\n      setGoal,\n      incrementCycle\n    };\n  }\n};\n\nexport default StateManager;\n",
      "hash": "492a619eb88366034751ab1867e7a2c74074da4b96a47d5df249ccaa6a5de2e4"
    },
    "core/state-helpers-pure.js": {
      "meta": {
        "mtimeMs": 1763656536885.4504,
        "size": 1874,
        "binary": false
      },
      "content": "/**\n * @fileoverview Pure State Helpers\n * Logic-only functions for state validation and default values.\n */\n\nconst StateHelpersPure = {\n  metadata: {\n    id: 'StateHelpersPure',\n    version: '2.0.0',\n    dependencies: [],\n    type: 'pure'\n  },\n\n  factory: () => {\n\n    const DEFAULT_STATE = {\n      version: '2.0.0',\n      totalCycles: 0,\n      currentGoal: null,\n      session: {\n        id: null,\n        startTime: null,\n        status: 'idle'\n      },\n      artifactMetadata: {}, // Tracks file modification times/cycles\n      stats: {\n        apiCalls: 0,\n        errors: 0\n      }\n    };\n\n    const createInitialState = (overrides = {}) => {\n      return {\n        ...DEFAULT_STATE,\n        ...overrides,\n        session: { ...DEFAULT_STATE.session, ...(overrides.session || {}) }\n      };\n    };\n\n    const validateState = (state) => {\n      const errors = [];\n      if (!state || typeof state !== 'object') return ['State is not an object'];\n      if (typeof state.totalCycles !== 'number') errors.push('Invalid totalCycles');\n      return errors.length > 0 ? errors : null;\n    };\n\n    /**\n     * Push a new goal onto the goal stack\n     */\n    const pushGoal = (state, newGoalText) => {\n      const newState = JSON.parse(JSON.stringify(state));\n\n      if (!newState.currentGoal) {\n        newState.currentGoal = {\n          id: Date.now().toString(),\n          text: newGoalText,\n          created: Date.now(),\n          subgoals: []\n        };\n      } else {\n        // Add as subgoal to current\n        newState.currentGoal.subgoals.push({\n          id: Date.now().toString(),\n          text: newGoalText,\n          created: Date.now(),\n          status: 'pending'\n        });\n      }\n\n      return newState;\n    };\n\n    return {\n      createInitialState,\n      validateState,\n      pushGoal,\n      DEFAULT_STATE\n    };\n  }\n};\n\nexport default StateHelpersPure;\n",
      "hash": "857611df9313524d4db0eb17e97e95b23006cc10b77968cd9b61cbb5b4bda647"
    },
    "core/response-parser.js": {
      "meta": {
        "mtimeMs": 1763734879729.929,
        "size": 2841,
        "binary": false
      },
      "content": "/**\n * @fileoverview Response Parser\n * Extracts tool calls from LLM text using Robust Regex.\n */\n\nconst ResponseParser = {\n  metadata: {\n    id: 'ResponseParser',\n    version: '2.1.0', // Simplified\n    dependencies: ['Utils'],\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { logger, sanitizeLlmJsonRespPure } = deps.Utils;\n\n    const parseToolCalls = (text) => {\n      if (!text) return [];\n      const calls = [];\n\n      // Standard Format:\n      // TOOL_CALL: name\n      // ARGS: { ... }\n      // find each TOOL_CALL and extract JSON with brace counting\n      const toolCallRegex = /TOOL_CALL:\\s*([a-zA-Z0-9_]+)\\s*\\nARGS:\\s*/g;\n\n      let match;\n      while ((match = toolCallRegex.exec(text)) !== null) {\n        const name = match[1].trim();\n        let startIdx = match.index + match[0].length;\n\n        while (startIdx < text.length && /\\s/.test(text[startIdx])) startIdx++;\n        if (text[startIdx] !== '{') {\n          logger.warn(`[ResponseParser] Expected JSON object for ${name}`);\n          calls.push({ name, args: {}, error: 'Invalid JSON block' });\n          continue;\n        }\n\n        let braceCount = 0;\n        let inString = false;\n        let escape = false;\n        let endIdx = startIdx;\n\n        for (let i = startIdx; i < text.length; i++) {\n          const char = text[i];\n\n          if (escape) {\n            escape = false;\n            continue;\n          }\n\n          if (char === '\\\\' && inString) {\n            escape = true;\n            continue;\n          }\n\n          if (char === '\"') {\n            inString = !inString;\n            continue;\n          }\n\n          if (!inString) {\n            if (char === '{') {\n              braceCount++;\n            } else if (char === '}') {\n              braceCount--;\n              if (braceCount === 0) {\n                endIdx = i + 1;\n                break;\n              }\n            }\n          }\n        }\n\n        const rawArgs = text.slice(startIdx, endIdx);\n\n        const { json } = sanitizeLlmJsonRespPure(rawArgs);\n        try {\n          const args = JSON.parse(json);\n          calls.push({ name, args });\n        } catch (e) {\n          logger.warn(`[ResponseParser] Bad args for ${name}`, {\n            error: e.message,\n            rawLength: rawArgs.length,\n            rawPreview: rawArgs.slice(0, 200),\n            rawEnd: rawArgs.length > 200 ? rawArgs.slice(-50) : ''\n          });\n          calls.push({ name, args: {}, error: `JSON Parse Error: ${e.message}` });\n        }\n      }\n\n      return calls;\n    };\n\n    // Check if the model explicitly stated it is done\n    const isDone = (text) => {\n        if (!text) return false;\n        return text.includes('GOAL_ACHIEVED') || text.includes('GOAL_COMPLETE') || text.includes('DONE');\n    };\n\n    return { parseToolCalls, isDone };\n  }\n};\n\nexport default ResponseParser;\n",
      "hash": "c71b2312c474887113922c032420843ee3ee11b3d87abadb6e645d4b87c623e9"
    },
    "core/persona-manager.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 1764,
        "binary": false
      },
      "content": "/**\n * @fileoverview Persona Manager\n * dynamic system prompt construction based on config.\n */\n\nconst PersonaManager = {\n  metadata: {\n    id: 'PersonaManager',\n    version: '2.1.0', // Upgraded to read config\n    dependencies: ['VFS', 'Utils'],\n    async: true,\n    type: 'core'\n  },\n\n  factory: (deps) => {\n    const { VFS, Utils } = deps;\n    const { logger } = Utils;\n\n    const CONFIG_PATH = '/config.json';\n\n    // Fallback if config is missing\n    const BASE_PERSONA = `You are REPLOID, an autonomous, self-improving AI agent.\nYour code lives in a browser-based VFS. You can read, write, and modify your own source code.\nYou are persistent, careful, and rigorous.`;\n\n    const getSystemPrompt = async () => {\n      try {\n        // 1. Load Config\n        if (!(await VFS.exists(CONFIG_PATH))) {\n            return BASE_PERSONA;\n        }\n        const configStr = await VFS.read(CONFIG_PATH);\n        const config = JSON.parse(configStr);\n\n        // 2. Get User Selection (set by Boot UI)\n        const selectedId = localStorage.getItem('REPLOID_PERSONA_ID') || 'default';\n\n        // 3. find Definition\n        const personaDef = config.personas?.find(p => p.id === selectedId);\n\n        if (!personaDef) {\n            return BASE_PERSONA;\n        }\n\n        logger.info(`[PersonaManager] Active Persona: ${personaDef.name}`);\n\n        // 4. Construct Prompt\n        return `\n## IDENTITY: ${personaDef.name}\n${personaDef.description}\n\n## BEHAVIORAL GUIDELINES\n${personaDef.instructions || \"Focus on high-quality, maintainable code changes.\"}\n`;\n\n      } catch (err) {\n        logger.error('[PersonaManager] Failed to load persona', err);\n        return BASE_PERSONA;\n      }\n    };\n\n    return { getSystemPrompt };\n  }\n};\n\nexport default PersonaManager;\n",
      "hash": "177c357d043f788c62a5e157f75a442667acd8e1a996268a88b0ead4bd675f8f"
    },
    "core/parser-utils.js": {
      "meta": {
        "mtimeMs": 1763656535162.4614,
        "size": 3656,
        "binary": false
      },
      "content": "/**\n * @fileoverview Protocol Parser Module\n * Standardized parsing for CATS (Context) and DOGS (Diff/Change) bundles.\n */\n\nconst ParserUtils = {\n  metadata: {\n    id: 'ParserUtils',\n    version: '2.0.0',\n    dependencies: [],\n    type: 'pure'\n  },\n\n  factory: () => {\n\n    // --- CATS Protocol (Context Bundle) ---\n\n    const parseCatsBundle = (content) => {\n      const files = [];\n      if (!content) return { reason: 'Empty content', files: [] };\n\n      // Split by file markers\n      const blocks = content.split(/```vfs-file\\s*\\n/);\n\n      const reasonMatch = content.match(/\\*\\*Reason:\\*\\*\\s*(.+)/);\n      const reason = reasonMatch ? reasonMatch[1].trim() : 'Context bundle';\n\n      // Skip index 0 (preamble)\n      for (let i = 1; i < blocks.length; i++) {\n        const block = blocks[i];\n\n        // Strict path extraction\n        const pathMatch = block.match(/^path:\\s*(.+?)\\s*\\n```/);\n        if (!pathMatch) continue;\n\n        const filePath = pathMatch[1].trim();\n\n        // Content extraction: Look for the next code block\n        const contentStartRegex = /```\\n([\\s\\S]*?)\\n```/;\n        const contentMatch = block.substring(pathMatch[0].length).match(contentStartRegex);\n\n        if (contentMatch) {\n          files.push({\n            path: filePath,\n            content: contentMatch[1]\n          });\n        }\n      }\n\n      return { reason, files };\n    };\n\n    const generateCatsBundle = (files, reason = 'Context Export') => {\n      const date = new Date().toISOString();\n      let out = `## PAWS Context Bundle (cats.md)\\n**Generated:** ${date}\\n**Reason:** ${reason}\\n**Files:** ${files.length}\\n\\n---\\n\\n`;\n\n      for (const f of files) {\n        out += `\\`\\`\\`vfs-file\\npath: ${f.path}\\n\\`\\`\\`\\n`;\n        out += `\\`\\`\\`\\n${f.content}\\n\\`\\`\\`\\n\\n---\\n\\n`;\n      }\n      return out;\n    };\n\n    // --- DOGS Protocol (Change Proposal) ---\n\n    const parseDogsBundle = (content) => {\n      const changes = [];\n      if (!content) return changes;\n\n      const blocks = content.split(/```paws-change\\s*\\n/);\n\n      for (let i = 1; i < blocks.length; i++) {\n        const block = blocks[i];\n\n        const metaEndIdx = block.indexOf('```');\n        if (metaEndIdx === -1) continue;\n\n        const metaSection = block.substring(0, metaEndIdx);\n        const opMatch = metaSection.match(/operation:\\s*(CREATE|MODIFY|DELETE)/i);\n        const pathMatch = metaSection.match(/file_path:\\s*(.+)/);\n\n        if (!opMatch || !pathMatch) continue;\n\n        const operation = opMatch[1].toUpperCase();\n        const filePath = pathMatch[1].trim();\n        let newContent = null;\n\n        if (operation !== 'DELETE') {\n          // Look for content block after the meta block\n          const contentSection = block.substring(metaEndIdx + 3);\n          const contentMatch = contentSection.match(/```\\n([\\s\\S]*?)\\n```/);\n          newContent = contentMatch ? contentMatch[1] : '';\n        }\n\n        changes.push({ operation, file_path: filePath, new_content: newContent });\n      }\n\n      return changes;\n    };\n\n    const generateDogsBundle = (changes, summary = 'Code Modification') => {\n      let out = `## PAWS Change Proposal (dogs.md)\\n**Summary:** ${summary}\\n**Changes:** ${changes.length}\\n\\n---\\n\\n`;\n\n      for (const c of changes) {\n        out += `\\`\\`\\`paws-change\\noperation: ${c.operation}\\nfile_path: ${c.file_path}\\n\\`\\`\\`\\n`;\n        if (c.operation !== 'DELETE') {\n          out += `\\`\\`\\`\\n${c.new_content || ''}\\n\\`\\`\\`\\n\\n`;\n        }\n      }\n      return out;\n    };\n\n    return {\n      parseCatsBundle,\n      generateCatsBundle,\n      parseDogsBundle,\n      generateDogsBundle\n    };\n  }\n};\n\nexport default ParserUtils;\n",
      "hash": "772b5c1706a866708fdbe349231d4778ead2b573ea01ba6d042ec4f1843b3a1c"
    },
    "core/multi-model-coordinator.js": {
      "meta": {
        "mtimeMs": 1761940263338.341,
        "size": 11927,
        "binary": false
      },
      "content": "// Multi-Model Coordinator - Unified multi-model execution for REPLOID\n// Combines Arena, Consensus, and Swarm patterns into one simple module\n\nconst MultiModelCoordinator = {\n  metadata: {\n    name: 'MultiModelCoordinator',\n    version: '1.0.0'\n  },\n\n  factory: (deps) => {\n    const { llmClient, toolRunner, vfs } = deps;\n\n    // Helper: Estimate token count from text\n    const estimateTokens = (text) => {\n      if (!text || typeof text !== 'string') return 0;\n      const words = text.split(/\\s+/).filter(w => w.length > 0).length;\n      return Math.ceil(words / 0.7); // 0.7 words per token\n    };\n\n    // Helper: Extract code from markdown response\n    const extractCode = (content) => {\n      if (!content) return '';\n      const codeMatch = content.match(/```(?:javascript|js)?\\s*([\\s\\S]*?)```/);\n      return codeMatch ? codeMatch[1].trim() : content;\n    };\n\n    // Helper: Assess code quality with heuristics\n    const assessCodeQuality = (code) => {\n      if (!code) return 0;\n      let score = 0.5;\n\n      // Positive indicators\n      if (code.includes('/**')) score += 0.1;\n      if (code.includes('try') && code.includes('catch')) score += 0.1;\n      if (code.match(/const |let /g)?.length > 0) score += 0.1;\n      if (code.includes('async') || code.includes('await')) score += 0.05;\n      if (code.match(/\\n/g)?.length > 20) score += 0.05;\n\n      // Negative indicators\n      if (code.includes('eval(')) score -= 0.2;\n      if (code.includes('TODO') || code.includes('FIXME')) score -= 0.1;\n      if (code.length < 100) score -= 0.2;\n\n      return Math.max(0, Math.min(1, score));\n    };\n\n    /**\n     * ARENA MODE: Models compete, best wins\n     * All models get same prompt, generate solutions, best scored solution wins\n     */\n    const runArena = async (messages, models, onUpdate) => {\n      console.log(`[MultiModel] Arena mode: ${models.length} models competing`);\n\n      if (onUpdate) {\n        onUpdate({\n          mode: 'arena',\n          phase: 'generation',\n          total: models.length,\n          completed: 0\n        });\n      }\n\n      // Phase 1: Generate solutions in parallel\n      const solutions = await Promise.all(\n        models.map(async (model, idx) => {\n          try {\n            const response = await llmClient.chat(messages, model);\n            const code = extractCode(response.content);\n\n            if (onUpdate) {\n              onUpdate({\n                mode: 'arena',\n                phase: 'generation',\n                total: models.length,\n                completed: idx + 1\n              });\n            }\n\n            return {\n              model: model.id,\n              content: response.content,\n              code,\n              quality: assessCodeQuality(code),\n              tokens: estimateTokens(response.content),\n              failed: false\n            };\n          } catch (error) {\n            console.error(`[MultiModel] Model ${model.id} failed:`, error);\n            return {\n              model: model.id,\n              error: error.message,\n              failed: true\n            };\n          }\n        })\n      );\n\n      // Phase 2: Score solutions\n      if (onUpdate) {\n        onUpdate({\n          mode: 'arena',\n          phase: 'scoring',\n          total: solutions.length,\n          completed: 0\n        });\n      }\n\n      const validSolutions = solutions.filter(s => !s.failed);\n\n      if (validSolutions.length === 0) {\n        throw new Error('All models failed in arena');\n      }\n\n      // Score = quality (60%) + length (20%) + no errors (20%)\n      const scoredSolutions = validSolutions.map(sol => {\n        let score = sol.quality * 0.6;\n\n        // Length score: prefer substantial solutions\n        const lengthScore = Math.min(1, sol.code.length / 500);\n        score += lengthScore * 0.2;\n\n        // Error indicators\n        const hasErrors = sol.content.toLowerCase().includes('error') ||\n                         sol.content.toLowerCase().includes('failed');\n        if (!hasErrors) score += 0.2;\n\n        return { ...sol, score };\n      });\n\n      // Select winner (highest score)\n      const winner = scoredSolutions.sort((a, b) => b.score - a.score)[0];\n\n      console.log(`[MultiModel] Arena winner: ${winner.model} (score: ${winner.score.toFixed(2)})`);\n\n      return {\n        mode: 'arena',\n        winner,\n        solutions: scoredSolutions,\n        result: {\n          content: winner.content,\n          usage: { tokens: winner.tokens }\n        }\n      };\n    };\n\n    /**\n     * SWARM MODE: Parallel execution, merge results\n     * Models work on same task in parallel, results are merged\n     */\n    const runSwarm = async (messages, models, onUpdate) => {\n      console.log(`[MultiModel] Swarm mode: ${models.length} models in parallel`);\n\n      if (onUpdate) {\n        onUpdate({\n          mode: 'swarm',\n          phase: 'execution',\n          total: models.length,\n          completed: 0\n        });\n      }\n\n      // Execute all models in parallel\n      const results = await Promise.all(\n        models.map(async (model, idx) => {\n          try {\n            const response = await llmClient.chat(messages, model);\n\n            if (onUpdate) {\n              onUpdate({\n                mode: 'swarm',\n                phase: 'execution',\n                total: models.length,\n                completed: idx + 1\n              });\n            }\n\n            return {\n              model: model.id,\n              content: response.content,\n              tokens: estimateTokens(response.content),\n              failed: false\n            };\n          } catch (error) {\n            console.error(`[MultiModel] Model ${model.id} failed:`, error);\n            return {\n              model: model.id,\n              error: error.message,\n              failed: true\n            };\n          }\n        })\n      );\n\n      const validResults = results.filter(r => !r.failed);\n\n      if (validResults.length === 0) {\n        throw new Error('All models failed in swarm');\n      }\n\n      // Phase 2: Merge results\n      if (onUpdate) {\n        onUpdate({\n          mode: 'swarm',\n          phase: 'merging',\n          total: 1,\n          completed: 0\n        });\n      }\n\n      // Simple merge: concatenate all responses with headers\n      const merged = validResults.map(r =>\n        `[${r.model}]\\n${r.content}`\n      ).join('\\n\\n---\\n\\n');\n\n      const totalTokens = validResults.reduce((sum, r) => sum + r.tokens, 0);\n\n      console.log(`[MultiModel] Swarm complete: ${validResults.length} models succeeded`);\n\n      return {\n        mode: 'swarm',\n        results: validResults,\n        merged,\n        result: {\n          content: merged,\n          usage: { tokens: totalTokens }\n        }\n      };\n    };\n\n    /**\n     * CONSENSUS MODE: Models vote on decisions\n     * Each model generates response, then all models vote on best\n     */\n    const runConsensus = async (messages, models, onUpdate) => {\n      console.log(`[MultiModel] Consensus mode: ${models.length} models voting`);\n\n      if (onUpdate) {\n        onUpdate({\n          mode: 'consensus',\n          phase: 'generation',\n          total: models.length,\n          completed: 0\n        });\n      }\n\n      // Phase 1: Generate solutions\n      const solutions = await Promise.all(\n        models.map(async (model, idx) => {\n          try {\n            const response = await llmClient.chat(messages, model);\n\n            if (onUpdate) {\n              onUpdate({\n                mode: 'consensus',\n                phase: 'generation',\n                total: models.length,\n                completed: idx + 1\n              });\n            }\n\n            return {\n              model: model.id,\n              content: response.content,\n              tokens: estimateTokens(response.content),\n              failed: false\n            };\n          } catch (error) {\n            console.error(`[MultiModel] Model ${model.id} failed:`, error);\n            return {\n              model: model.id,\n              error: error.message,\n              failed: true\n            };\n          }\n        })\n      );\n\n      const validSolutions = solutions.filter(s => !s.failed);\n\n      if (validSolutions.length === 0) {\n        throw new Error('All models failed in consensus');\n      }\n\n      // Phase 2: Voting round - each model rates all solutions\n      if (onUpdate) {\n        onUpdate({\n          mode: 'consensus',\n          phase: 'voting',\n          total: validSolutions.length * models.length,\n          completed: 0\n        });\n      }\n\n      const votes = [];\n      let voteCount = 0;\n\n      for (const voter of models) {\n        for (const solution of validSolutions) {\n          try {\n            const votePrompt = `Rate this solution on a scale of 0-10 (0=completely wrong, 10=perfect).\n\nOriginal task: ${messages[messages.length - 1].content}\n\nSolution from ${solution.model}:\n${solution.content.substring(0, 500)}...\n\nRespond with ONLY a number from 0-10.\nSCORE:`;\n\n            const voteResponse = await llmClient.chat(\n              [{ role: 'user', content: votePrompt }],\n              voter\n            );\n\n            const scoreMatch = voteResponse.content.match(/(\\d+(?:\\.\\d+)?)/);\n            const score = scoreMatch ? parseFloat(scoreMatch[1]) : 5.0;\n            const normalizedScore = Math.max(0, Math.min(10, score)) / 10;\n\n            votes.push({\n              voter: voter.id,\n              solution: solution.model,\n              score: normalizedScore\n            });\n\n            voteCount++;\n            if (onUpdate) {\n              onUpdate({\n                mode: 'consensus',\n                phase: 'voting',\n                total: validSolutions.length * models.length,\n                completed: voteCount\n              });\n            }\n          } catch (error) {\n            console.error(`[MultiModel] Vote failed:`, error);\n            // Use neutral score on error\n            votes.push({\n              voter: voter.id,\n              solution: solution.model,\n              score: 0.5,\n              error: true\n            });\n          }\n        }\n      }\n\n      // Phase 3: Tally votes\n      const tallies = {};\n      validSolutions.forEach(sol => {\n        const solVotes = votes.filter(v => v.solution === sol.model);\n        const avgScore = solVotes.reduce((sum, v) => sum + v.score, 0) / solVotes.length;\n        tallies[sol.model] = { solution: sol, avgScore, votes: solVotes };\n      });\n\n      // Select winner by average score\n      const winner = Object.values(tallies).sort((a, b) => b.avgScore - a.avgScore)[0];\n\n      console.log(`[MultiModel] Consensus winner: ${winner.solution.model} (score: ${winner.avgScore.toFixed(2)})`);\n\n      return {\n        mode: 'consensus',\n        winner: winner.solution,\n        tallies,\n        votes,\n        result: {\n          content: winner.solution.content,\n          usage: { tokens: winner.solution.tokens }\n        }\n      };\n    };\n\n    /**\n     * Main execution function\n     * Routes to appropriate mode based on config\n     */\n    const execute = async (messages, config, onUpdate) => {\n      const mode = config.mode || 'arena'; // arena, swarm, consensus\n      const models = config.models || [];\n\n      if (models.length < 2) {\n        throw new Error('Multi-model mode requires at least 2 models');\n      }\n\n      console.log(`[MultiModel] Executing in ${mode} mode with ${models.length} models`);\n\n      switch (mode) {\n        case 'arena':\n          return await runArena(messages, models, onUpdate);\n        case 'swarm':\n          return await runSwarm(messages, models, onUpdate);\n        case 'consensus':\n          return await runConsensus(messages, models, onUpdate);\n        default:\n          throw new Error(`Unknown multi-model mode: ${mode}`);\n      }\n    };\n\n    return {\n      execute,\n      // Individual modes exposed for direct use\n      runArena,\n      runSwarm,\n      runConsensus\n    };\n  }\n};\n\nexport default MultiModelCoordinator;\n",
      "hash": "d997ad3ddf79ce21ea40fe00d665154e4446ed0ec65d9e32f29885bb269b55b5"
    },
    "core/meta-tool-writer.js": {
      "meta": {
        "mtimeMs": 1763656842406.516,
        "size": 1422,
        "binary": false
      },
      "content": "/**\n * @fileoverview Meta Tool Writer\n * Safe core module modification using VerificationManager.\n */\n\nconst MetaToolWriter = {\n  metadata: {\n    id: 'MetaToolWriter',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS', 'VerificationManager'],\n    async: true,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS, VerificationManager } = deps;\n    const { logger, Errors } = Utils;\n\n    const improveCore = async (moduleName, newCode) => {\n      const path = `/core/${moduleName}.js`;\n\n      if (!(await VFS.exists(path))) {\n        throw new Errors.ArtifactError(`Module not found: ${path}`);\n      }\n\n      logger.info(`[Meta] Proposing update to ${moduleName}...`);\n\n      // 1. Verify\n      const change = {\n        operation: 'MODIFY',\n        file_path: path,\n        new_content: newCode\n      };\n\n      const verifyResult = await VerificationManager.verifyProposal([change]);\n\n      if (!verifyResult.passed) {\n        throw new Errors.ValidationError(`Verification Failed: ${verifyResult.reason}`);\n      }\n\n      // 2. Backup\n      const oldCode = await VFS.read(path);\n      await VFS.write(`${path}.bak`, oldCode);\n\n      // 3. Apply\n      await VFS.write(path, newCode);\n      logger.warn(`[Meta] UPDATED CORE MODULE: ${moduleName}`);\n\n      return `Successfully updated ${moduleName}. Backup saved to .bak`;\n    };\n\n    return { improveCore };\n  }\n};\n\nexport default MetaToolWriter;\n",
      "hash": "985888508ceba3ac4889fa30a6827e12cc0fe72a55db2b83206210836cd94ee8"
    },
    "core/llm-client.js": {
      "meta": {
        "mtimeMs": 1763734913697.6785,
        "size": 10736,
        "binary": false
      },
      "content": "/**\n * @fileoverview LLM Client\n * Unified interface for model inference.\n * Supports both Proxy (HTTP) and Browser-Native (WebLLM/WebGPU) execution.\n */\n\nconst LLMClient = {\n  metadata: {\n    id: 'LLMClient',\n    version: '3.1.0',\n    dependencies: ['Utils', 'RateLimiter', 'TransformersClient?'],\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { Utils, RateLimiter, TransformersClient } = deps;\n    const { logger, Errors } = Utils;\n\n    const _limiter = RateLimiter.createLimiter(60);\n    const _activeRequests = new Map();\n\n    // WebLLM State\n    let _webLlmEngine = null;\n    let _currentWebModelId = null;\n    let _webLlmLoaderPromise = null;\n\n    const ensureWebLlmReady = async () => {\n      if (typeof window === 'undefined') {\n        throw new Errors.ConfigError('WebLLM is only available in browser environments');\n      }\n\n      if (window.webllm) return window.webllm;\n      if (_webLlmLoaderPromise) return _webLlmLoaderPromise;\n\n      _webLlmLoaderPromise = import('https://esm.run/@mlc-ai/web-llm')\n        .then(mod => {\n          window.webllm = window.webllm || mod;\n          return window.webllm;\n        })\n        .catch((err) => {\n          _webLlmLoaderPromise = null;\n          logger.error('[LLM] Failed to load WebLLM runtime', err);\n          throw new Errors.ConfigError('Failed to load WebLLM runtime');\n        });\n\n      return _webLlmLoaderPromise;\n    };\n\n    // --- Helper: Stream Parser (Proxy Mode) ---\n    const parseProxyStreamChunk = (chunk, buffer) => {\n      const text = buffer + chunk;\n      const lines = text.split('\\n');\n      const remaining = lines.pop() || '';\n      const updates = [];\n\n      for (const line of lines) {\n        const clean = line.trim();\n        if (!clean || clean === 'data: [DONE]') continue;\n        if (clean.startsWith('data: ')) {\n          try {\n            const jsonStr = clean.substring(6);\n            if (!jsonStr.startsWith('{')) continue; // Skip malformed chunks\n            const json = JSON.parse(jsonStr);\n            const content = json.choices?.[0]?.delta?.content\n              || json.message?.content\n              || json.response\n              || '';\n            if (content) updates.push(content);\n          } catch (e) {\n            // Log malformed chunks at debug level\n            logger.debug('[LLM] Malformed stream chunk:', clean.substring(6, 50));\n          }\n        }\n      }\n      return { updates, remaining };\n    };\n\n    // --- Helper: Clean Thoughts ---\n    const stripThoughts = (text) => {\n        return text\n            .replace(/<think>[\\s\\S]*?<\\/think>/gi, '')\n            .replace(/<thinking>[\\s\\S]*?<\\/thinking>/gi, '')\n            .trim();\n    };\n\n    // --- Mode: Browser-Native (WebLLM) ---\n    const _chatBrowser = async (messages, modelConfig, onUpdate, requestId) => {\n        logger.info(`[LLM] Browser-Native Request to ${modelConfig.id}`);\n\n        await ensureWebLlmReady();\n\n        try {\n            // Initialize Engine if needed or model changed\n            if (!_webLlmEngine || _currentWebModelId !== modelConfig.id) {\n                logger.info(`[LLM] Initializing WebLLM Engine for ${modelConfig.id}...`);\n\n                let lastReportedProgress = -5; // Track last reported progress for 5% increments\n\n                _webLlmEngine = await window.webllm.CreateMLCEngine(\n                    modelConfig.id,\n                    {\n                        initProgressCallback: (report) => {\n                            logger.debug(`[WebLLM] Loading: ${report.text}`);\n\n                            if (onUpdate) {\n                                // Extract progress percentage if available\n                                const progressMatch = report.text.match(/(\\d+(?:\\.\\d+)?)\\s*%/);\n                                if (progressMatch) {\n                                    const progress = Math.floor(parseFloat(progressMatch[1]));\n                                    // Only update at 5% increments\n                                    if (progress >= lastReportedProgress + 5) {\n                                        lastReportedProgress = Math.floor(progress / 5) * 5;\n                                        onUpdate(`[System: Downloading model... ${lastReportedProgress}%]\\n`);\n                                    }\n                                } else if (report.text.toLowerCase().includes('download')) {\n                                    onUpdate(`[System: Downloading model...]\\n`);\n                                } else if (report.text.toLowerCase().includes('loading')) {\n                                    onUpdate(`[System: Loading model into GPU...]\\n`);\n                                }\n                            }\n                        }\n                    }\n                );\n                _currentWebModelId = modelConfig.id;\n            }\n\n            const chatMessages = messages.map(m => ({\n                role: m.role,\n                content: m.content\n            }));\n\n            if (chatMessages[0]?.role !== 'system') {\n                logger.warn('[LLM] Missing system prompt at context start. Repairing context for WebLLM.');\n                chatMessages.unshift({\n                    role: 'system',\n                    content: 'You are REPLOID, a careful browser-based AI agent.'\n                });\n            }\n\n            let fullContent = \"\";\n\n            if (onUpdate) {\n                const chunks = await _webLlmEngine.chat.completions.create({\n                    messages: chatMessages,\n                    stream: true,\n                    temperature: 0.7\n                });\n\n                for await (const chunk of chunks) {\n                    const delta = chunk.choices[0]?.delta?.content || \"\";\n                    if (delta) {\n                        fullContent += delta;\n                        onUpdate(delta);\n                    }\n                }\n            } else {\n                const reply = await _webLlmEngine.chat.completions.create({\n                    messages: chatMessages,\n                    stream: false,\n                    temperature: 0.7\n                });\n                fullContent = reply.choices[0].message.content;\n            }\n\n            return {\n                requestId,\n                content: stripThoughts(fullContent),\n                raw: fullContent,\n                model: modelConfig.id,\n                timestamp: Date.now(),\n                provider: 'webllm'\n            };\n\n        } catch (err) {\n            logger.error('[LLM] WebLLM Error', err);\n            if (err.message.includes('device') || err.message.includes('memory')) {\n                _webLlmEngine = null;\n                _currentWebModelId = null;\n            }\n            throw new Errors.ApiError(`WebLLM Execution Failed: ${err.message}`, 500);\n        }\n    };\n\n    // --- Mode: Proxy (HTTP) ---\n    const _chatProxy = async (messages, modelConfig, onUpdate, requestId) => {\n      const endpoint = modelConfig.endpoint || '/api/chat';\n      const controller = new AbortController();\n      _activeRequests.set(requestId, controller);\n\n      try {\n        const requestBody = {\n            model: modelConfig.id,\n            provider: modelConfig.provider,\n            messages: messages,\n            stream: !!onUpdate,\n            apiKey: modelConfig.apiKey\n        };\n\n        if (modelConfig.provider === 'ollama') {\n            requestBody.options = { temperature: 0.7 };\n        }\n\n        const response = await fetch(endpoint, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(requestBody),\n          signal: controller.signal\n        });\n\n        if (!response.ok) {\n          throw new Errors.ApiError(`API Error ${response.status}`, response.status);\n        }\n\n        let fullContent = '';\n\n        if (onUpdate && response.body) {\n          const reader = response.body.getReader();\n          const decoder = new TextDecoder();\n          let buffer = '';\n\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n\n            const chunk = decoder.decode(value, { stream: true });\n            const { updates, remaining } = parseProxyStreamChunk(chunk, buffer);\n            buffer = remaining;\n\n            for (const text of updates) {\n              fullContent += text;\n              onUpdate(text);\n            }\n          }\n        } else {\n          const data = await response.json();\n          fullContent = data.content || data.choices?.[0]?.message?.content || '';\n        }\n\n        return {\n          requestId,\n          content: stripThoughts(fullContent),\n          raw: fullContent,\n          model: modelConfig.id,\n          timestamp: Date.now(),\n          provider: modelConfig.provider\n        };\n\n      } finally {\n        _activeRequests.delete(requestId);\n      }\n    };\n\n    // --- Mode: Transformers.js ---\n    const _chatTransformers = async (messages, modelConfig, onUpdate, requestId) => {\n      if (!TransformersClient) {\n        throw new Errors.ConfigError('TransformersClient not available');\n      }\n\n      logger.info(`[LLM] Transformers.js Request to ${modelConfig.id}`);\n\n      const response = await TransformersClient.chat(messages, modelConfig, onUpdate);\n      return {\n        ...response,\n        requestId\n      };\n    };\n\n    const chat = async (messages, modelConfig, onUpdate = null) => {\n      await _limiter.waitForToken();\n\n      const requestId = Utils.generateId('req');\n\n      // Route to appropriate backend\n      if (modelConfig.provider === 'transformers' ||\n          (TransformersClient && TransformersClient.isTransformersModel && TransformersClient.isTransformersModel(modelConfig.id))) {\n          return await _chatTransformers(messages, modelConfig, onUpdate, requestId);\n      } else if (modelConfig.queryMethod === 'browser' || modelConfig.provider === 'webllm') {\n          return await _chatBrowser(messages, modelConfig, onUpdate, requestId);\n      } else {\n          return await _chatProxy(messages, modelConfig, onUpdate, requestId);\n      }\n    };\n\n    const abortRequest = (requestId) => {\n      const controller = _activeRequests.get(requestId);\n      if (controller) {\n        controller.abort();\n        return true;\n      }\n      return false;\n    };\n\n    const getWebLLMStatus = () => {\n        return {\n            loaded: !!_webLlmEngine,\n            model: _currentWebModelId\n        };\n    };\n\n    const getTransformersStatus = () => {\n        if (!TransformersClient) return { available: false };\n        return TransformersClient.getStatus();\n    };\n\n    return { chat, abortRequest, getWebLLMStatus, getTransformersStatus };\n  }\n};\n\nexport default LLMClient;\n",
      "hash": "a9ccec50ee5c8d1d3a60cbb47ac4ee41f5c2909107a55424272cc0e2fc2828f6"
    },
    "core/genesis-factory.js": {
      "meta": {
        "mtimeMs": 1763650973262.0654,
        "size": 1630,
        "binary": false
      },
      "content": "// Genesis Factory - Creates immutable recovery substrate\n// Run this once via tool to generate your lifeboat\n\nconst GenesisFactory = {\n  metadata: {\n    id: 'GenesisFactory',\n    version: '1.0.0',\n    description: 'Freezes current substrate modules into immutable recovery kernel',\n    dependencies: ['vfs'],\n    type: 'system'\n  },\n\n  factory: (deps) => {\n    const { vfs } = deps;\n\n    const freezeKernel = async () => {\n      // The critical path modules required to boot the UI and VFS\n      const corePaths = [\n        '/core/vfs.js',\n        '/core/utils.js',\n        '/infrastructure/event-bus.js',\n        '/core/state-manager.js',\n        '/core/response-parser.js',\n        '/core/context-manager.js',\n        '/core/llm-client.js',\n        '/core/agent-loop.js',\n        '/core/tool-runner.js'\n      ];\n\n      const kernel = {};\n      let missing = [];\n\n      for (const path of corePaths) {\n        try {\n          kernel[path] = await vfs.read(path);\n        } catch (e) {\n          missing.push(path);\n        }\n      }\n\n      if (missing.length > 0) {\n        throw new Error(`Cannot freeze kernel. Missing modules: ${missing.join(', ')}`);\n      }\n\n      const fileContent = `// GENESIS KERNEL - IMMUTABLE RECOVERY SUBSTRATE\n// Generated: ${new Date().toISOString()}\n// DO NOT EDIT THIS FILE. IT IS YOUR LIFEBOAT.\n\nexport const GENESIS_MODULES = ${JSON.stringify(kernel, null, 2)};\n`;\n\n      await vfs.write('/core/genesis-kernel.js', fileContent);\n      return { success: true, message: \"Genesis Kernel frozen. Safe Mode available.\" };\n    };\n\n    return { freezeKernel };\n  }\n};\n\nexport default GenesisFactory;\n",
      "hash": "7566bcdd07c2ec9435a0e72c520e6c793d69d0bc215113c8e80a856332000b72"
    },
    "core/context-manager.js": {
      "meta": {
        "mtimeMs": 1763734851420.1377,
        "size": 1808,
        "binary": false
      },
      "content": "/**\n * @fileoverview Context Manager\n * Manages token budget and context window compaction.\n */\n\nconst ContextManager = {\n  metadata: {\n    id: 'ContextManager',\n    version: '2.0.1',\n    dependencies: ['Utils', 'LLMClient'],\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    const { logger } = deps.Utils;\n    const { LLMClient } = deps;\n\n    const countTokens = (context) => {\n      const text = context.map(m => m.content).join('');\n      return Math.ceil(text.length * 0.25); // ~4 chars per token\n    };\n\n    const shouldCompact = (context) => countTokens(context) > 12000;\n\n    const compact = async (context, modelConfig) => {\n      if (!shouldCompact(context)) return context;\n      if (!modelConfig) {\n        logger.warn('[ContextManager] No model config provided, skipping compaction');\n        return context;\n      }\n\n      logger.info('[ContextManager] Compacting...');\n      const start = context.slice(0, 2); // System + First User\n      const end = context.slice(-5);     // Last 5\n      const middle = context.slice(2, -5);\n\n      if (middle.length === 0) return context;\n\n      const text = middle.map(m => `${m.role}: ${m.content}`).join('\\n');\n\n      try {\n        const res = await LLMClient.chat([{\n          role: 'user',\n          content: `Summarize this conversation, keeping key technical details and tool results:\\n${text}`\n        }], modelConfig);\n\n        const summary = res?.content || '[Summary unavailable]';\n        return [...start, { role: 'system', content: `[SUMMARY]: ${summary}` }, ...end];\n      } catch (e) {\n        logger.error('[ContextManager] Compaction failed', e);\n        return [...start, { role: 'system', content: '[DATA PRUNED]' }, ...end];\n      }\n    };\n\n    return { countTokens, shouldCompact, compact };\n  }\n};\n\nexport default ContextManager;\n",
      "hash": "bc3463868cbb611fedb028d57a2aa04d46024363819f681e2662b6d3fae22a03"
    },
    "core/agent-loop.js": {
      "meta": {
        "mtimeMs": 1763734857412.0935,
        "size": 8304,
        "binary": false
      },
      "content": "/**\n * @fileoverview Agent Loop\n * The main cognitive cycle: Think -> Act -> Observe.\n */\n\nconst AgentLoop = {\n  metadata: {\n    id: 'AgentLoop',\n    version: '2.4.1',\n    dependencies: [\n      'Utils', 'EventBus', 'LLMClient', 'ToolRunner', 'ContextManager',\n      'ResponseParser', 'StateManager', 'PersonaManager', 'ReflectionStore?', 'ReflectionAnalyzer?'\n    ],\n    type: 'core'\n  },\n\n  factory: (deps) => {\n    const {\n      Utils, EventBus, LLMClient, ToolRunner, ContextManager,\n      ResponseParser, StateManager, PersonaManager, ReflectionStore, ReflectionAnalyzer\n    } = deps;\n\n    const { logger, Errors } = Utils;\n\n    const MAX_ITERATIONS = 50;\n    const MAX_TOOL_CALLS_PER_ITERATION = 3;\n    let _isRunning = false;\n    let _abortController = null;\n    let _modelConfig = null;\n\n    const run = async (goal) => {\n      if (_isRunning) throw new Errors.StateError('Agent already running');\n      if (!_modelConfig) throw new Errors.ConfigError('No model configured');\n\n      _isRunning = true;\n      _abortController = new AbortController();\n\n      logger.info(`[Agent] Starting cycle. Goal: \"${goal}\"`);\n      EventBus.emit('agent:status', { state: 'STARTING', activity: 'Initializing...' });\n\n      await StateManager.setGoal(goal);\n      let context = await _buildInitialContext(goal);\n      let iteration = 0;\n\n      try {\n        while (_isRunning && iteration < MAX_ITERATIONS) {\n          if (_abortController.signal.aborted) break;\n\n          iteration++;\n          await StateManager.incrementCycle();\n          logger.info(`[Agent] Iteration ${iteration}`);\n\n          // 2. Insights / Reflection Injection\n          let insights = null;\n          try {\n            if (ReflectionAnalyzer && ReflectionAnalyzer.api) {\n              const failurePatterns = await ReflectionAnalyzer.api.detectFailurePatterns();\n              if (failurePatterns.length > 0) {\n                insights = failurePatterns.slice(0, 2).map(p => p.indicator);\n              }\n            }\n          } catch (e) {\n            logger.debug('[Agent] Failed to get reflection insights:', e.message);\n          }\n\n          if (insights && insights.length > 0) {\n            // Append memory as user message to maintain proper message ordering\n            context.push({ role: 'user', content: `[MEMORY] Watch out for these past failure patterns: ${insights.join(', ')}` });\n          }\n\n          EventBus.emit('agent:status', { state: 'THINKING', activity: `Cycle ${iteration} - Calling LLM...`, cycle: iteration });\n\n          context = await ContextManager.compact(context, _modelConfig);\n\n          let llmResponseText = '';\n          const streamCallback = (text) => {\n            EventBus.emit('agent:stream', text);\n            llmResponseText += text;\n          };\n\n          const response = await LLMClient.chat(context, _modelConfig, streamCallback);\n\n          EventBus.emit('agent:history', {\n            type: 'llm_response',\n            cycle: iteration,\n            content: response.content\n          });\n\n          const responseContent = response?.content || '';\n          const toolCalls = ResponseParser.parseToolCalls(responseContent);\n          context.push({ role: 'assistant', content: responseContent });\n\n          if (toolCalls.length > 0) {\n            let executedTools = 0;\n            for (const call of toolCalls) {\n              if (executedTools >= MAX_TOOL_CALLS_PER_ITERATION) {\n                const limitMsg = `Tool call limit (${MAX_TOOL_CALLS_PER_ITERATION}) reached for this iteration. Finish current thoughts or continue next turn.`;\n                logger.warn('[Agent] ' + limitMsg);\n                context.push({ role: 'system', content: limitMsg });\n                break;\n              }\n\n              if (_abortController.signal.aborted) break;\n\n              logger.info(`[Agent] Tool Call: ${call.name}`);\n              EventBus.emit('agent:status', { state: 'ACTING', activity: `Executing tool: ${call.name}` });\n\n              let result;\n              try {\n                const rawResult = await ToolRunner.execute(call.name, call.args);\n                result = typeof rawResult === 'string' ? rawResult : JSON.stringify(rawResult, null, 2);\n              } catch (err) {\n                logger.error(`[Agent] Tool Error: ${call.name}`, err);\n                result = `Error: ${err.message}`;\n              }\n\n              // Smart truncation\n              if (result.length > 5000 && call.name !== 'ReadFile') {\n                  result = result.substring(0, 5000) + \"\\n... [OUTPUT TRUNCATED. USE code_intel OR ReadFile FOR DETAILS] ...\";\n              }\n\n              context.push({\n                role: 'user',\n                content: `TOOL_RESULT (${call.name}):\\n${result}`\n              });\n\n              EventBus.emit('agent:history', {\n                type: 'tool_result',\n                cycle: iteration,\n                tool: call.name,\n                args: call.args,\n                result: result\n              });\n\n              _logReflection(call, result, iteration);\n              executedTools++;\n            }\n          } else {\n            if (ResponseParser.isDone(response.content)) {\n              logger.info('[Agent] Goal achieved.');\n              break;\n            }\n            // WebLLM requires last message to be user/tool - add continuation prompt\n            let continuationMsg = 'Continue with your task. Use a tool or declare completion with \"DONE\".';\n            if (iteration > 5) {\n              continuationMsg = 'You are chattering without acting. Please use a tool or declare completion with \"DONE\".';\n            }\n            context.push({ role: 'user', content: continuationMsg });\n          }\n        }\n      } catch (err) {\n        if (err instanceof Errors.AbortError) {\n          logger.info('[Agent] Cycle aborted.');\n        } else {\n          logger.error('[Agent] Critical Error', err);\n          throw err;\n        }\n      } finally {\n        _isRunning = false;\n        _abortController = null;\n        EventBus.emit('agent:status', { state: 'IDLE', activity: 'Stopped' });\n      }\n    };\n\n    const _logReflection = async (call, result, iteration) => {\n         if (!ReflectionStore) return;\n         const isError = result.startsWith('Error:');\n         try {\n            await ReflectionStore.add({\n                type: isError ? 'error' : 'success',\n                content: `Tool ${call.name}`,\n                context: { cycle: iteration, tool: call.name, args: call.args, outcome: isError ? 'failed' : 'successful' }\n            });\n         } catch (e) {\n            logger.debug('[Agent] Failed to log reflection:', e.message);\n         }\n    };\n\n    const _buildInitialContext = async (goal) => {\n      const personaPrompt = await PersonaManager.getSystemPrompt();\n\n      const systemPrompt = `\n${personaPrompt}\n\n## Core Tools\n- code_intel: Analyze file structure (imports, exports, functions). *USE THIS FIRST* to save tokens before reading large files. Args: { \"path\": \"/path/to/file\" }\n- ReadFile: Read file content. Args: { \"path\": \"/path/to/file\" }\n- WriteFile: Create/Overwrite file. Args: { \"path\": \"/path/to/file\", \"content\": \"...\" }\n- DeleteFile: Remove a file. Args: { \"path\": \"/path/to/file\" }\n- ListFiles: List directory. Args: { \"path\": \"/\" }\n- CreateTool: Create new tool (RSI L1). Args: { \"name\": \"x\", \"code\": \"...\" }\n- improve_core_module: Rewrite core module (RSI L2). Args: { \"module\": \"x\", \"code\": \"...\" }\n${ToolRunner.has('LoadModule') ? '- LoadModule: Hot-reload module (RSI L3). Args: { \"path\": \"/path/to/module.js\" }' : ''}\n\n## Protocol\n1. **THINK**: Plan your next step.\n2. **ACT**: Use tools via format:\nTOOL_CALL: tool_name\nARGS: { ... }\n3. Always inspect the VFS with ListFiles before reading. Only read paths that actually exist (e.g., /core/..., /tools/...). If a file is missing, create it instead of repeatedly requesting it.\n\n## Goal\n${goal}\n`;\n\n      return [\n        { role: 'system', content: systemPrompt.trim() },\n        { role: 'user', content: `Start. Goal: ${goal}` }\n      ];\n    };\n\n    return {\n      run,\n      stop: () => { if (_abortController) _abortController.abort(); _isRunning = false; },\n      setModel: (c) => { _modelConfig = c; },\n      isRunning: () => _isRunning\n    };\n  }\n};\n\nexport default AgentLoop;\n",
      "hash": "cb9042d1aa2f3fa4c23eacefb4515ebd5f55ff425c1277e959c32f59c9336f71"
    },
    "core/agent-bridge-client.js": {
      "meta": {
        "mtimeMs": 1762203475796.9102,
        "size": 7413,
        "binary": false
      },
      "content": "// Browser-compatible Agent Bridge Client\n// Allows Reploid browser agent to connect to Agent Bridge\n\nconst AgentBridgeClient = {\n  metadata: {\n    name: 'AgentBridgeClient',\n    version: '1.0.0',\n    description: 'Connect Reploid agent to Agent Bridge for multi-agent coordination',\n    dependencies: [],\n    async: false,\n    type: 'service'\n  },\n\n  factory: (deps) => {\n    let ws = null;\n    let agentId = null;\n    let requestId = 0;\n    let pendingRequests = new Map();\n    let connected = false;\n    let eventHandlers = new Map();\n    let heartbeatInterval = null;\n\n    // Get bridge URL dynamically (same origin)\n    const getBridgeUrl = () => {\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const host = window.location.host;\n      return `${protocol}//${host}/claude-bridge`;\n    };\n\n    /**\n     * Connect to Agent Bridge\n     */\n    const connect = async (options = {}) => {\n      const { name = 'Reploid-Agent', capabilities = [], metadata = {} } = options;\n\n      return new Promise((resolve, reject) => {\n        const url = getBridgeUrl();\n        console.log(`[AgentBridge] Connecting to ${url}...`);\n\n        ws = new WebSocket(url);\n\n        ws.onopen = async () => {\n          console.log('[AgentBridge] Connected to bridge');\n\n          try {\n            // Register with the bridge\n            const result = await sendRequest('register', {\n              name,\n              capabilities,\n              metadata: {\n                ...metadata,\n                type: 'reploid-browser-agent',\n                vfs: true, // Indicate this agent has VFS\n                location: window.location.href\n              }\n            });\n\n            agentId = result.agentId;\n            connected = true;\n\n            console.log(`[AgentBridge] Registered as ${name} (${agentId})`);\n            console.log(`[AgentBridge] Active agents:`, result.activeAgents.length);\n\n            // Trigger event\n            trigger('connected', { agentId, activeAgents: result.activeAgents });\n\n            resolve(result);\n\n          } catch (error) {\n            reject(error);\n          }\n        };\n\n        ws.onmessage = (event) => {\n          try {\n            const message = JSON.parse(event.data);\n            handleMessage(message);\n          } catch (error) {\n            console.error('[AgentBridge] Error parsing message:', error);\n          }\n        };\n\n        ws.onclose = () => {\n          console.log('[AgentBridge] Disconnected from bridge');\n          connected = false;\n          trigger('disconnected');\n        };\n\n        ws.onerror = (error) => {\n          console.error('[AgentBridge] WebSocket error:', error);\n          trigger('error', error);\n          reject(error);\n        };\n      });\n    };\n\n    /**\n     * Handle incoming messages\n     */\n    const handleMessage = (message) => {\n      // Response to a request\n      if (message.id !== undefined) {\n        const pending = pendingRequests.get(message.id);\n        if (pending) {\n          pendingRequests.delete(message.id);\n\n          if (message.error) {\n            pending.reject(new Error(`${message.error.code}: ${message.error.message}`));\n          } else {\n            pending.resolve(message.result);\n          }\n        }\n        return;\n      }\n\n      // Notification (method without id)\n      if (message.method) {\n        trigger(message.method, message.params);\n      }\n    };\n\n    /**\n     * Send a JSON-RPC request\n     */\n    const sendRequest = (method, params = {}) => {\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        return Promise.reject(new Error('Not connected to bridge'));\n      }\n\n      const id = ++requestId;\n\n      return new Promise((resolve, reject) => {\n        // Store pending request\n        pendingRequests.set(id, { resolve, reject, timestamp: Date.now() });\n\n        // Send request\n        ws.send(JSON.stringify({\n          jsonrpc: '2.0',\n          id,\n          method,\n          params\n        }));\n\n        // Timeout after 30 seconds\n        setTimeout(() => {\n          if (pendingRequests.has(id)) {\n            pendingRequests.delete(id);\n            reject(new Error(`Request timeout: ${method}`));\n          }\n        }, 30000);\n      });\n    };\n\n    /**\n     * Event system\n     */\n    const on = (event, handler) => {\n      if (!eventHandlers.has(event)) {\n        eventHandlers.set(event, []);\n      }\n      eventHandlers.get(event).push(handler);\n    };\n\n    const off = (event, handler) => {\n      if (eventHandlers.has(event)) {\n        const handlers = eventHandlers.get(event);\n        const index = handlers.indexOf(handler);\n        if (index > -1) {\n          handlers.splice(index, 1);\n        }\n      }\n    };\n\n    const trigger = (event, data) => {\n      if (eventHandlers.has(event)) {\n        for (const handler of eventHandlers.get(event)) {\n          try {\n            handler(data);\n          } catch (error) {\n            console.error(`[AgentBridge] Error in ${event} handler:`, error);\n          }\n        }\n      }\n    };\n\n    /**\n     * API Methods\n     */\n    const broadcast = async (message, type = 'message') => {\n      return sendRequest('broadcast', { message, type });\n    };\n\n    const sendTo = async (targetAgentId, message, type = 'message') => {\n      return sendRequest('send_to', { targetAgentId, message, type });\n    };\n\n    const queryAgents = async (capability = null) => {\n      return sendRequest('query_agents', { capability });\n    };\n\n    const delegateTask = async (task, targetAgentId = null, priority = 'normal') => {\n      return sendRequest('delegate_task', {\n        task,\n        targetAgentId,\n        priority\n      });\n    };\n\n    const updateTaskStatus = async (taskId, status, result = null, error = null) => {\n      return sendRequest('update_task_status', {\n        taskId,\n        status,\n        result,\n        error\n      });\n    };\n\n    const getSharedContext = async (key = null) => {\n      return sendRequest('get_shared_context', { key });\n    };\n\n    const setSharedContext = async (key, value) => {\n      return sendRequest('set_shared_context', { key, value });\n    };\n\n    const heartbeat = async () => {\n      return sendRequest('heartbeat');\n    };\n\n    const startHeartbeat = (interval = 30000) => {\n      if (heartbeatInterval) {\n        clearInterval(heartbeatInterval);\n      }\n\n      heartbeatInterval = setInterval(() => {\n        if (connected) {\n          heartbeat().catch(err => {\n            console.error('[AgentBridge] Heartbeat failed:', err.message);\n          });\n        }\n      }, interval);\n    };\n\n    const stopHeartbeat = () => {\n      if (heartbeatInterval) {\n        clearInterval(heartbeatInterval);\n        heartbeatInterval = null;\n      }\n    };\n\n    const disconnect = () => {\n      stopHeartbeat();\n      if (ws) {\n        ws.close();\n        ws = null;\n      }\n      connected = false;\n      agentId = null;\n    };\n\n    // Return public API\n    return {\n      connect,\n      disconnect,\n      on,\n      off,\n      broadcast,\n      sendTo,\n      queryAgents,\n      delegateTask,\n      updateTaskStatus,\n      getSharedContext,\n      setSharedContext,\n      heartbeat,\n      startHeartbeat,\n      stopHeartbeat,\n      getAgentId: () => agentId,\n      isConnected: () => connected\n    };\n  }\n};\n\n// Export for module system\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = AgentBridgeClient;\n}\n",
      "hash": "e1fe1414aaecaea83fb0d3fa35bdd0d106bbcfe2c7d24fd15422084fa32fca5e"
    },
    "ui/panels/vfs-panel.js": {
      "meta": {
        "mtimeMs": 1763648602341.3396,
        "size": 887,
        "binary": false
      },
      "content": "const VFSPanel = {\n  metadata: {\n    id: 'VFSPanel',\n    version: '1.0.0',\n    dependencies: ['Utils', 'VFSExplorer'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFSExplorer } = deps;\n    const { logger } = Utils;\n\n    const init = async (containerId) => {\n      const container = document.getElementById(containerId);\n      if (!container) return;\n\n      if (!VFSExplorer?.init) {\n        container.innerHTML = '<div class=\"error\">VFS Explorer unavailable</div>';\n        return;\n      }\n\n      try {\n        await VFSExplorer.init(containerId);\n        logger.info('[VFSPanel] Explorer initialized');\n      } catch (error) {\n        logger.error('[VFSPanel] Initialization failed:', error);\n        container.innerHTML = '<div class=\"error\">Failed to load VFS Explorer</div>';\n      }\n    };\n\n    return { init };\n  }\n};\n\nexport default VFSPanel;\n",
      "hash": "6b9c4935c4e56cda7c8449675953f18d87afd36ef555de6e166a3ce0b4640eeb"
    },
    "ui/panels/python-repl-panel.js": {
      "meta": {
        "mtimeMs": 1763677825556.2888,
        "size": 4902,
        "binary": false
      },
      "content": "const PythonReplPanel = {\n  metadata: {\n    id: 'PythonReplPanel',\n    version: '1.0.0',\n    dependencies: ['Utils', 'EventBus', 'PyodideRuntime?', 'ToastNotifications?'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus, PyodideRuntime, ToastNotifications } = deps;\n    const { logger } = Utils;\n\n    let container = null;\n    let outputContainer = null;\n    let codeInput = null;\n\n    const init = (containerId) => {\n      container = document.getElementById(containerId);\n      if (!container) return;\n\n      outputContainer = document.getElementById('python-output');\n      codeInput = document.getElementById('python-code-input');\n      const statusIcon = document.getElementById('pyodide-status-icon');\n      const statusText = document.getElementById('pyodide-status-text');\n\n      const updateStatus = () => {\n        if (!PyodideRuntime) return;\n        const isReady = PyodideRuntime.isReady?.();\n        const error = PyodideRuntime.getError?.();\n\n        if (error) {\n          if (statusIcon) statusIcon.textContent = 'ðŸ”´';\n          if (statusText) statusText.textContent = `Error: ${error.message}`;\n        } else if (isReady) {\n          if (statusIcon) statusIcon.textContent = 'ðŸŸ¢';\n          if (statusText) statusText.textContent = 'Ready';\n        } else {\n          if (statusIcon) statusIcon.textContent = 'ðŸŸ¡';\n          if (statusText) statusText.textContent = 'Initializing...';\n        }\n      };\n\n      EventBus.on('pyodide:ready', updateStatus);\n      EventBus.on('pyodide:error', updateStatus);\n      EventBus.on('pyodide:initialized', updateStatus);\n\n      setupButtons();\n      updateStatus();\n      logger.info('[PythonReplPanel] Initialized');\n    };\n\n    const setupButtons = () => {\n      const executeBtn = document.getElementById('python-execute-btn');\n      const clearBtn = document.getElementById('repl-clear-btn');\n      const packagesBtn = document.getElementById('repl-packages-btn');\n      const syncBtn = document.getElementById('repl-sync-btn');\n      const syncCheck = document.getElementById('python-sync-workspace-check');\n\n      if (executeBtn) {\n        executeBtn.onclick = async () => {\n          const code = codeInput?.value;\n          if (!code?.trim()) return;\n\n          executeBtn.disabled = true;\n          executeBtn.textContent = 'â³ Running...';\n\n          try {\n            if (syncCheck?.checked && PyodideRuntime?.syncWorkspace) {\n              await PyodideRuntime.syncWorkspace();\n            }\n            const result = await PyodideRuntime.execute(code, { async: false });\n            appendOutput(result);\n          } catch (error) {\n            appendOutput({ success: false, error: error.message });\n            if (ToastNotifications) {\n              ToastNotifications.error(`Python error: ${error.message}`);\n            }\n          } finally {\n            executeBtn.disabled = false;\n            executeBtn.textContent = 'â˜‡ï¸ Run';\n          }\n        };\n      }\n\n      if (clearBtn) {\n        clearBtn.onclick = () => {\n          if (outputContainer) outputContainer.innerHTML = '';\n        };\n      }\n\n      if (packagesBtn && PyodideRuntime?.openPackageManager) {\n        packagesBtn.onclick = () => PyodideRuntime.openPackageManager();\n      }\n\n      if (syncBtn && PyodideRuntime?.syncWorkspace) {\n        syncBtn.onclick = async () => {\n          syncBtn.disabled = true;\n          syncBtn.textContent = 'Syncing...';\n          try {\n            await PyodideRuntime.syncWorkspace();\n            if (ToastNotifications) ToastNotifications.success('Workspace synced');\n          } catch (err) {\n            logger.error('[PythonReplPanel] Sync failed:', err);\n          } finally {\n            syncBtn.disabled = false;\n            syncBtn.textContent = 'ðŸ” Sync FS';\n          }\n        };\n      }\n    };\n\n    const appendOutput = (result) => {\n      if (!outputContainer) return;\n\n      const div = document.createElement('div');\n      div.className = `repl-result ${result.success ? 'repl-result-success' : 'repl-result-error'}`;\n\n      let content = `<div class=\"repl-result-header\">--- ${new Date().toLocaleTimeString()} ---</div>`;\n      if (result.stdout) content += `<div class=\"repl-stdout\">${Utils.escapeHtml(result.stdout)}</div>`;\n      if (result.stderr) content += `<div class=\"repl-stderr\">${Utils.escapeHtml(result.stderr)}</div>`;\n      if (result.success && result.result !== undefined) {\n        content += `<div class=\"repl-return-value\">=> ${Utils.escapeHtml(JSON.stringify(result.result))}</div>`;\n      }\n      if (!result.success) {\n        content += `<div class=\"repl-error\">Error: ${Utils.escapeHtml(result.error)}</div>`;\n      }\n\n      div.innerHTML = content;\n      outputContainer.appendChild(div);\n      outputContainer.scrollTop = outputContainer.scrollHeight;\n    };\n\n    return { init };\n  }\n};\n\nexport default PythonReplPanel;\n",
      "hash": "fe95e52f41cff67e196e5734959bd8933fbbdff40ffdc3fa9683f2a41a1cbe71"
    },
    "ui/panels/metrics-panel.js": {
      "meta": {
        "mtimeMs": 1763648608411.881,
        "size": 1316,
        "binary": false
      },
      "content": "const MetricsPanel = {\n  metadata: {\n    id: 'MetricsPanel',\n    version: '1.0.0',\n    dependencies: ['Utils', 'MetricsDashboard', 'PerformanceMonitor', 'ToastNotifications?'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, MetricsDashboard, PerformanceMonitor, ToastNotifications } = deps;\n    const { logger, exportAsMarkdown } = Utils;\n\n    const init = (containerId) => {\n      const container = document.getElementById(containerId);\n      if (!container) return;\n\n      if (MetricsDashboard?.init) {\n        MetricsDashboard.init(container);\n      }\n\n      const refreshBtn = document.getElementById('perf-refresh-btn');\n      const exportBtn = document.getElementById('perf-export-btn');\n\n      if (refreshBtn) {\n        refreshBtn.onclick = () => {\n          MetricsDashboard?.updateCharts?.();\n        };\n      }\n\n      if (exportBtn) {\n        exportBtn.onclick = () => {\n          const report = PerformanceMonitor?.generateReport?.();\n          if (report) {\n            exportAsMarkdown(`performance-${Date.now()}.md`, report);\n            if (ToastNotifications) ToastNotifications.success('Performance report exported');\n          }\n        };\n      }\n\n      logger.info('[MetricsPanel] Initialized');\n    };\n\n    return { init };\n  }\n};\n\nexport default MetricsPanel;\n",
      "hash": "e5c844cbb9e5340d17e185b37f5f08911c3e9a06429ea2c678903ba0fedf68e5"
    },
    "ui/panels/llm-config-panel.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 3146,
        "binary": false
      },
      "content": "const LLMConfigPanel = {\n  metadata: {\n    id: 'LLMConfigPanel',\n    version: '1.1.0', // Updated to use LLMClient\n    dependencies: ['Utils', 'EventBus', 'LLMClient', 'ToastNotifications?'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus, LLMClient, ToastNotifications } = deps;\n    const { logger } = Utils;\n\n    const init = async (containerId) => {\n      const container = document.getElementById(containerId);\n      if (!container) return;\n\n      const statusIcon = document.getElementById('llm-status-icon');\n      const statusText = document.getElementById('llm-status-text');\n      const modelLabel = document.getElementById('llm-current-model');\n      const loadBtn = document.getElementById('llm-load-btn');\n      const modelSelect = document.getElementById('llm-model-select');\n\n      // Update status using LLMClient\n      const updateStatus = () => {\n        if (!LLMClient) return;\n\n        // Check WebLLM status via the new API\n        const status = LLMClient.getWebLLMStatus ? LLMClient.getWebLLMStatus() : { loaded: false };\n\n        if (status.loaded) {\n          if (statusIcon) statusIcon.textContent = '\\u{1F7E2}'; // green circle\n          if (statusText) statusText.textContent = 'Ready (WebGPU)';\n          if (modelLabel) modelLabel.textContent = status.model || 'Loaded';\n        } else {\n          if (statusIcon) statusIcon.textContent = '\\u26AA'; // white circle\n          if (statusText) statusText.textContent = 'Not loaded';\n        }\n      };\n\n      // Check WebGPU support\n      const gpuStatusEl = document.getElementById('llm-webgpu-status');\n      if (gpuStatusEl && navigator.gpu) {\n         gpuStatusEl.innerHTML = '\\u2705 WebGPU available';\n         gpuStatusEl.style.color = '#0f0';\n      } else if (gpuStatusEl) {\n         gpuStatusEl.textContent = '\\u26A0\\uFE0F WebGPU not supported in this browser';\n         gpuStatusEl.style.color = '#f90';\n      }\n\n      // Load Model Handler\n      if (loadBtn) {\n        loadBtn.onclick = async () => {\n          const modelId = modelSelect?.value;\n          if (!modelId) return;\n\n          loadBtn.disabled = true;\n          loadBtn.textContent = 'Initializing...';\n\n          try {\n            // Trigger initialization via a dummy chat request or explicit init if added later\n            // For now, we rely on the lazy-init in LLMClient.chat, but we can force a check\n            // by sending a system prompt.\n            if (ToastNotifications) ToastNotifications.info('Model will initialize on first message.');\n\n            // Visual feedback only since LLMClient is lazy-loaded\n            if (modelLabel) modelLabel.textContent = `${modelId} (Selected)`;\n\n          } catch (error) {\n            logger.error('[LLMConfigPanel] Setup failed:', error);\n            if (ToastNotifications) ToastNotifications.error(error.message);\n          } finally {\n            loadBtn.disabled = false;\n            loadBtn.textContent = 'Set Model';\n          }\n        };\n      }\n\n      updateStatus();\n      logger.info('[LLMConfigPanel] Initialized');\n    };\n\n    return { init };\n  }\n};\n\nexport default LLMConfigPanel;\n",
      "hash": "fa42fb27b9e55aa7a8834cab378ae6a3f0e2f727c69bef059b5c82c43a647ffe"
    },
    "ui/panels/code-panel.js": {
      "meta": {
        "mtimeMs": 1763648619848.4216,
        "size": 569,
        "binary": false
      },
      "content": "const CodePanel = {\n  metadata: {\n    id: 'CodePanel',\n    version: '1.0.0',\n    dependencies: ['Utils', 'CodeViewer?'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, CodeViewer } = deps;\n    const { logger } = Utils;\n\n    const init = (containerId) => {\n      const container = document.getElementById(containerId);\n      if (!container) return;\n\n      if (CodeViewer?.init) {\n        CodeViewer.init(containerId);\n      }\n\n      logger.info('[CodePanel] Initialized');\n    };\n\n    return { init };\n  }\n};\n\nexport default CodePanel;\n",
      "hash": "cd2edfce7a52e45ee21b4ae10aacb8f6e62579a4d66cd866eb783412be6c052e"
    },
    "ui/panels/chat-panel.js": {
      "meta": {
        "mtimeMs": 1763648614485.835,
        "size": 483,
        "binary": false
      },
      "content": "const ChatPanel = {\n  metadata: {\n    id: 'ChatPanel',\n    version: '1.0.0',\n    dependencies: ['Utils', 'ChatUI?'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils } = deps;\n    const { logger } = Utils;\n\n    const init = (containerId) => {\n      const container = document.getElementById(containerId);\n      if (!container) return;\n      logger.info('[ChatPanel] Ready (layout only)');\n    };\n\n    return { init };\n  }\n};\n\nexport default ChatPanel;\n",
      "hash": "c28ebcfe50398fd0b221ce4cb172ad07cd3c88cce2984d0da0ee1acb1b5ddb6e"
    },
    "ui/dashboard/vfs-explorer.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 18237,
        "binary": false
      },
      "content": "// VFS Explorer Module for REPLOID\n// Enhanced file tree with search, expand/collapse, and file viewer\n\nconst VFSExplorer = {\n  metadata: {\n    id: 'VFSExplorer',\n    version: '1.1.0',\n    dependencies: ['Utils', 'EventBus', 'StateManager', 'ToastNotifications'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus, StateManager, ToastNotifications } = deps;\n    const { logger, escapeHtml } = Utils;\n\n    class Explorer {\n      constructor() {\n        this.expanded = new Set(['/vfs']); // Track expanded folders\n        this.selectedFile = null;\n        this.searchTerm = '';\n        this.container = null;\n        this.fileViewerModal = null;\n      }\n\n      async init(containerId) {\n        this.container = document.getElementById(containerId);\n        if (!this.container) {\n          logger.error(`[VFSExplorer] Container not found: ${containerId}`);\n          return;\n        }\n\n        await this.render();\n\n        // Listen for VFS changes\n        EventBus.on('vfs:updated', () => this.render());\n        EventBus.on('artifact:created', () => this.render());\n        EventBus.on('artifact:updated', () => this.render());\n        EventBus.on('artifact:deleted', () => this.render());\n      }\n\n      async render() {\n        if (!this.container) return;\n\n        const allMeta = await StateManager.getAllArtifactMetadata();\n        const tree = this.buildTree(allMeta);\n\n        this.container.innerHTML = `\n          <div class=\"vfs-explorer\">\n            <div class=\"vfs-toolbar\" role=\"toolbar\" aria-label=\"File explorer controls\">\n              <input type=\"text\"\n                     class=\"vfs-search\"\n                     placeholder=\"ðŸ” Search files...\"\n                     value=\"${escapeHtml(this.searchTerm)}\"\n                     aria-label=\"Search files\"\n                     role=\"searchbox\">\n              <button class=\"vfs-refresh\" title=\"Refresh\" aria-label=\"Refresh file tree\">â†»</button>\n              <button class=\"vfs-collapse-all\" title=\"Collapse All\" aria-label=\"Collapse all folders\">âŠŸ</button>\n              <button class=\"vfs-expand-all\" title=\"Expand All\" aria-label=\"Expand all folders\">âŠž</button>\n            </div>\n            <div class=\"vfs-tree\" role=\"tree\" aria-label=\"File tree\">${this.renderTree(tree)}</div>\n            <div class=\"vfs-stats\" role=\"status\" aria-live=\"polite\">\n              ${Object.keys(allMeta).length} files\n            </div>\n          </div>\n        `;\n\n        this.attachEventListeners();\n      }\n\n      buildTree(allMeta) {\n        const tree = {\n          name: 'root',\n          path: '',\n          type: 'folder',\n          children: []\n        };\n\n        for (const path in allMeta) {\n          const parts = path.split('/').filter(p => p);\n          let current = tree;\n\n          parts.forEach((part, index) => {\n            const isLast = index === parts.length - 1;\n\n            if (isLast) {\n              // File node\n              current.children.push({\n                name: part,\n                path: path,\n                type: 'file',\n                size: allMeta[path].size || 0,\n                metadata: allMeta[path]\n              });\n            } else {\n              // Folder node\n              let folder = current.children.find(c => c.name === part && c.type === 'folder');\n              if (!folder) {\n                folder = {\n                  name: part,\n                  path: parts.slice(0, index + 1).join('/'),\n                  type: 'folder',\n                  children: []\n                };\n                current.children.push(folder);\n              }\n              current = folder;\n            }\n          });\n        }\n\n        // Sort: folders first, then files, alphabetically\n        const sortChildren = (node) => {\n          if (node.children) {\n            node.children.sort((a, b) => {\n              if (a.type !== b.type) {\n                return a.type === 'folder' ? -1 : 1;\n              }\n              return a.name.localeCompare(b.name);\n            });\n            node.children.forEach(sortChildren);\n          }\n        };\n        sortChildren(tree);\n\n        return tree;\n      }\n\n      renderTree(node, depth = 0) {\n        if (!node.children || node.children.length === 0) {\n          return '';\n        }\n\n        const filteredChildren = this.searchTerm\n          ? node.children.filter(child => this.matchesSearch(child))\n          : node.children;\n\n        return filteredChildren.map(child => {\n          if (child.type === 'file') {\n            return this.renderFile(child, depth);\n          } else {\n            return this.renderFolder(child, depth);\n          }\n        }).join('');\n      }\n\n      renderFile(node, depth) {\n        const icon = this.getFileIcon(node.path);\n        const selected = node.path === this.selectedFile ? 'selected' : '';\n        const highlight = this.searchTerm && node.name.toLowerCase().includes(this.searchTerm.toLowerCase())\n          ? 'highlight' : '';\n\n        return `\n          <div class=\"vfs-item vfs-file ${selected} ${highlight}\"\n               data-path=\"${escapeHtml(node.path)}\"\n               data-type=\"file\"\n               role=\"treeitem\"\n               aria-selected=\"${selected ? 'true' : 'false'}\"\n               aria-label=\"${escapeHtml(node.name)} (${this.formatSize(node.size)})\"\n               tabindex=\"${selected ? '0' : '-1'}\"\n               style=\"padding-left:${depth * 20 + 20}px\">\n            <span class=\"vfs-icon\" aria-hidden=\"true\">${icon}</span>\n            <span class=\"vfs-name\">${escapeHtml(node.name)}</span>\n            <span class=\"vfs-size\">${this.formatSize(node.size)}</span>\n          </div>\n        `;\n      }\n\n      renderFolder(node, depth) {\n        const isExpanded = this.expanded.has(node.path) || this.searchTerm !== '';\n        const icon = isExpanded ? 'ðŸ“‚' : 'ðŸ“';\n        const expandIcon = isExpanded ? 'â–¼' : 'â˜‡';\n\n        const childrenHtml = isExpanded ? this.renderTree(node, depth + 1) : '';\n        const fileCount = this.countFiles(node);\n\n        return `\n          <div class=\"vfs-folder\" role=\"group\">\n            <div class=\"vfs-item vfs-folder-header\"\n                 data-path=\"${escapeHtml(node.path)}\"\n                 data-type=\"folder\"\n                 role=\"treeitem\"\n                 aria-expanded=\"${isExpanded}\"\n                 aria-label=\"${escapeHtml(node.name)} folder (${fileCount} items)\"\n                 tabindex=\"0\"\n                 style=\"padding-left:${depth * 20 + 20}px\">\n              <span class=\"vfs-expand\" aria-hidden=\"true\">${expandIcon}</span>\n              <span class=\"vfs-icon\" aria-hidden=\"true\">${icon}</span>\n              <span class=\"vfs-name\">${escapeHtml(node.name)}</span>\n              <span class=\"vfs-count\" aria-hidden=\"true\">(${fileCount})</span>\n            </div>\n            <div class=\"vfs-children ${isExpanded ? 'expanded' : 'collapsed'}\" role=\"group\">\n              ${childrenHtml}\n            </div>\n          </div>\n        `;\n      }\n\n      countFiles(node) {\n        if (node.type === 'file') return 1;\n        if (!node.children) return 0;\n        return node.children.reduce((sum, child) => sum + this.countFiles(child), 0);\n      }\n\n      getFileIcon(path) {\n        const ext = path.split('.').pop().toLowerCase();\n        const iconMap = {\n          'js': 'ðŸ“œ',\n          'json': 'ðŸ“‹',\n          'md': 'ðŸ“',\n          'css': 'ðŸŽ¨',\n          'html': 'ðŸŒ',\n          'txt': 'ðŸ“„',\n          'yml': 'âš™ï¸',\n          'yaml': 'âš™ï¸',\n          'xml': 'ðŸ“°',\n          'svg': 'ðŸ–¼ï¸',\n          'png': 'ðŸ–¼ï¸',\n          'jpg': 'ðŸ–¼ï¸',\n          'jpeg': 'ðŸ–¼ï¸',\n          'gif': 'ðŸ–¼ï¸',\n          'pdf': 'ðŸ“•',\n          'zip': 'ðŸ“¦',\n          'tar': 'ðŸ“¦',\n          'gz': 'ðŸ“¦'\n        };\n        return iconMap[ext] || 'ðŸ“„';\n      }\n\n      formatSize(bytes) {\n        if (!bytes || bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];\n      }\n\n      matchesSearch(node) {\n        if (!this.searchTerm) return true;\n        const term = this.searchTerm.toLowerCase();\n\n        // Search in name and path\n        if (node.name.toLowerCase().includes(term)) return true;\n        if (node.path.toLowerCase().includes(term)) return true;\n\n        // Search in children\n        if (node.children) {\n          return node.children.some(child => this.matchesSearch(child));\n        }\n\n        return false;\n      }\n\n      attachEventListeners() {\n        // Search input\n        const searchInput = this.container.querySelector('.vfs-search');\n        if (searchInput) {\n          searchInput.addEventListener('input', (e) => {\n            this.searchTerm = e.target.value;\n            this.render();\n          });\n\n          // Keyboard shortcuts: Ctrl+F or Cmd+F to focus search\n          document.addEventListener('keydown', (e) => {\n            if ((e.ctrlKey || e.metaKey) && e.key === 'f' && !e.shiftKey) {\n              const explorerVisible = this.container && this.container.offsetParent !== null;\n              if (explorerVisible) {\n                e.preventDefault();\n                searchInput.focus();\n              }\n            }\n            // ESC to clear search\n            if (e.key === 'Escape' && document.activeElement === searchInput && this.searchTerm) {\n              e.preventDefault();\n              this.searchTerm = '';\n              searchInput.value = '';\n              this.render();\n            }\n          });\n        }\n\n        // Refresh button\n        const refreshBtn = this.container.querySelector('.vfs-refresh');\n        if (refreshBtn) {\n          refreshBtn.addEventListener('click', () => {\n            this.render();\n            if (ToastNotifications) ToastNotifications.success('File tree refreshed');\n            logger.info('[VFSExplorer] Refreshed');\n          });\n        }\n\n        // Collapse all button\n        const collapseBtn = this.container.querySelector('.vfs-collapse-all');\n        if (collapseBtn) {\n          collapseBtn.addEventListener('click', () => {\n            this.expanded.clear();\n            this.render();\n          });\n        }\n\n        // Expand all button\n        const expandBtn = this.container.querySelector('.vfs-expand-all');\n        if (expandBtn) {\n          expandBtn.addEventListener('click', async () => {\n            const allMeta = await StateManager.getAllArtifactMetadata();\n            const tree = this.buildTree(allMeta);\n            this.expandAll(tree);\n            this.render();\n          });\n        }\n\n        // Folder click handlers\n        this.container.querySelectorAll('.vfs-folder-header').forEach(header => {\n          header.addEventListener('click', (e) => {\n            e.stopPropagation();\n            const path = header.dataset.path;\n            if (this.expanded.has(path)) {\n              this.expanded.delete(path);\n            } else {\n              this.expanded.add(path);\n            }\n            this.render();\n          });\n\n          // Keyboard navigation: Enter/Space to toggle folder\n          header.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter' || e.key === ' ') {\n              e.preventDefault();\n              const path = header.dataset.path;\n              if (this.expanded.has(path)) {\n                this.expanded.delete(path);\n              } else {\n                this.expanded.add(path);\n              }\n              this.render();\n            }\n          });\n        });\n\n        // File click handlers\n        this.container.querySelectorAll('.vfs-file').forEach(fileItem => {\n          fileItem.addEventListener('click', async (e) => {\n            e.stopPropagation();\n            const path = fileItem.dataset.path;\n            this.selectedFile = path;\n            await this.showFileViewer(path);\n            this.render();\n          });\n\n          // Keyboard navigation: Enter to open file\n          fileItem.addEventListener('keydown', async (e) => {\n            if (e.key === 'Enter') {\n              e.preventDefault();\n              const path = fileItem.dataset.path;\n              this.selectedFile = path;\n              await this.showFileViewer(path);\n              this.render();\n            }\n          });\n        });\n      }\n\n      expandAll(node) {\n        if (node.type === 'folder') {\n          this.expanded.add(node.path);\n          if (node.children) {\n            node.children.forEach(child => this.expandAll(child));\n          }\n        }\n      }\n\n      async showFileViewer(path) {\n        try {\n          const content = await StateManager.getArtifactContent(path);\n          const metadata = await StateManager.getArtifactMetadata(path);\n\n          // Create modal if it doesn't exist\n          if (!this.fileViewerModal) {\n            this.fileViewerModal = document.createElement('div');\n            this.fileViewerModal.className = 'vfs-file-viewer-modal';\n            document.body.appendChild(this.fileViewerModal);\n          }\n\n          const language = this.getLanguageFromPath(path);\n\n          this.fileViewerModal.innerHTML = `\n            <div class=\"vfs-file-viewer-overlay\"></div>\n            <div class=\"vfs-file-viewer-content\">\n              <div class=\"vfs-file-viewer-header\">\n                <div class=\"vfs-file-viewer-title\">\n                  <span class=\"vfs-icon\">${this.getFileIcon(path)}</span>\n                  <span>${escapeHtml(path)}</span>\n                </div>\n                <button class=\"vfs-file-viewer-close\">â˜©</button>\n              </div>\n              <div class=\"vfs-file-viewer-meta\">\n                Type: ${metadata?.type || 'unknown'} |\n                Size: ${this.formatSize(content?.length || 0)} |\n                Lines: ${(content || '').split('\\n').length}\n              </div>\n              <div class=\"vfs-file-viewer-body\">\n                <pre><code class=\"language-${language}\">${escapeHtml(content || '')}</code></pre>\n              </div>\n              <div class=\"vfs-file-viewer-footer\">\n                <button class=\"vfs-file-viewer-copy\">ðŸ“‹ Copy</button>\n                <button class=\"vfs-file-viewer-history\">ðŸ“œ History</button>\n                <button class=\"vfs-file-viewer-edit\">âœï¸ edit</button>\n              </div>\n            </div>\n          `;\n\n          this.fileViewerModal.style.display = 'flex';\n\n          // Attach modal event listeners\n          this.fileViewerModal.querySelector('.vfs-file-viewer-close').addEventListener('click', () => {\n            this.fileViewerModal.style.display = 'none';\n          });\n\n          this.fileViewerModal.querySelector('.vfs-file-viewer-overlay').addEventListener('click', () => {\n            this.fileViewerModal.style.display = 'none';\n          });\n\n          this.fileViewerModal.querySelector('.vfs-file-viewer-copy').addEventListener('click', async (e) => {\n            try {\n              await navigator.clipboard.writeText(content);\n              logger.info(`[VFSExplorer] Copied ${path} to clipboard`);\n\n              // Visual feedback\n              const btn = e.target;\n              const originalText = btn.innerHTML;\n              btn.innerHTML = 'âœ“ Copied!';\n              btn.style.background = 'rgba(76, 175, 80, 0.3)';\n              setTimeout(() => {\n                btn.innerHTML = originalText;\n                btn.style.background = '';\n              }, 2000);\n            } catch (err) {\n              logger.error(`[VFSExplorer] Failed to copy to clipboard:`, err);\n              if (ToastNotifications) ToastNotifications.error('Failed to copy to clipboard');\n            }\n          });\n\n          this.fileViewerModal.querySelector('.vfs-file-viewer-history').addEventListener('click', async () => {\n            const history = await StateManager.getArtifactHistory?.(path) || [];\n            logger.info(`[VFSExplorer] History for ${path}:`, history);\n            if (ToastNotifications) ToastNotifications.info(`History: ${history.length} versions available`);\n          });\n\n          this.fileViewerModal.querySelector('.vfs-file-viewer-edit').addEventListener('click', () => {\n            EventBus.emit('vfs:edit-file', { path, content });\n            this.fileViewerModal.style.display = 'none';\n          });\n\n          // ESC key to close\n          const handleEsc = (e) => {\n            if (e.key === 'Escape' && this.fileViewerModal.style.display === 'flex') {\n              this.fileViewerModal.style.display = 'none';\n              document.removeEventListener('keydown', handleEsc);\n            }\n          };\n          document.addEventListener('keydown', handleEsc);\n\n        } catch (error) {\n          logger.error(`[VFSExplorer] Failed to load file ${path}:`, error);\n          if (ToastNotifications) ToastNotifications.error(`Failed to load file: ${error.message}`);\n        }\n      }\n\n      getLanguageFromPath(path) {\n        const ext = path.split('.').pop().toLowerCase();\n        const langMap = {\n          'js': 'javascript',\n          'json': 'json',\n          'md': 'markdown',\n          'css': 'css',\n          'html': 'html',\n          'txt': 'text',\n          'yml': 'yaml',\n          'yaml': 'yaml',\n          'xml': 'xml',\n          'py': 'python',\n          'rb': 'ruby',\n          'java': 'java',\n          'go': 'go',\n          'rs': 'rust',\n          'c': 'c',\n          'cpp': 'cpp',\n          'sh': 'bash'\n        };\n        return langMap[ext] || 'text';\n      }\n\n    }\n\n    const explorer = new Explorer();\n\n    return {\n      api: {\n        init: (containerId) => explorer.init(containerId),\n        render: () => explorer.render(),\n        setSearchTerm: (term) => {\n          explorer.searchTerm = term;\n          explorer.render();\n        },\n        expandPath: (path) => {\n          explorer.expanded.add(path);\n          explorer.render();\n        },\n        collapsePath: (path) => {\n          explorer.expanded.delete(path);\n          explorer.render();\n        },\n        selectFile: (path) => {\n          explorer.selectedFile = path;\n          explorer.showFileViewer(path);\n        }\n      }\n    };\n  }\n};\n\n// Export\nVFSExplorer;\n",
      "hash": "d36712027a024bfa4d09bd15a27488271e547ca095aa2838594a24cd37356d6b"
    },
    "ui/dashboard/ui-manager.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 3639,
        "binary": false
      },
      "content": "// UIManager - Thin orchestrator for UI panels\n// Version 4.1.0: Removed legacy visualizer dependencies\n\nconst UIManager = {\n  metadata: {\n    id: 'UIManager',\n    version: '4.1.0',\n    description: 'Orchestrates UI panels via DI Container',\n    dependencies: [\n      'Utils', 'EventBus', 'StateManager',\n      'PythonReplPanel', 'LLMConfigPanel', 'VFSPanel',\n      'MetricsPanel', 'ChatPanel', 'CodePanel'\n    ],\n    async: true,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus } = deps;\n    const { logger } = Utils;\n\n    const panels = {};\n    let logToggleBtn = null;\n    let activePanelId = 'thought-panel';\n    const PANEL_STORAGE_KEY = 'reploid_active_panel';\n\n    const init = async () => {\n      logger.info('[UIManager] Initializing UI Orchestrator...');\n\n      logToggleBtn = document.getElementById('log-toggle-btn');\n\n      // Simplified panel map (removed broken visualizers)\n      const panelMap = [\n        { id: 'python-repl-panel', module: deps.PythonReplPanel },\n        { id: 'local-llm-panel', module: deps.LLMConfigPanel },\n        { id: 'vfs-tree', module: deps.VFSPanel },\n        { id: 'performance-panel', module: deps.MetricsPanel },\n        { id: 'agent-container', module: deps.ChatPanel },\n        { id: 'code-panel', module: deps.CodePanel }\n      ];\n\n      for (const item of panelMap) {\n        if (!item.module?.init) continue;\n        try {\n          await item.module.init(item.id);\n          panels[item.id] = item.module;\n        } catch (error) {\n          logger.error(`[UIManager] Failed to initialize panel ${item.id}:`, error);\n        }\n      }\n\n      setupNavigation();\n      if (!restoreState()) {\n        showPanel(activePanelId);\n      }\n\n      logger.info('[UIManager] UI Ready');\n    };\n\n    const setupNavigation = () => {\n      if (logToggleBtn) {\n        logToggleBtn.addEventListener('click', cyclePanels);\n      }\n\n      EventBus.on('panel:switch', ({ panel }) => {\n        if (panel) showPanel(panel);\n      });\n    };\n\n    const cyclePanels = () => {\n      // Removed visualizers from cycle\n      const sequence = [\n        'thought-panel',\n        'performance-panel',\n        'introspection-panel',\n        'python-repl-panel',\n        'local-llm-panel'\n      ];\n\n      const currentIndex = sequence.indexOf(activePanelId);\n      const nextIndex = (currentIndex + 1) % sequence.length;\n      showPanel(sequence[nextIndex]);\n    };\n\n    const showPanel = (panelId) => {\n      const advancedPanels = document.querySelectorAll('.advanced-panel');\n      advancedPanels.forEach(panel => panel.classList.add('hidden'));\n\n      const target = document.getElementById(panelId);\n      if (target) {\n        target.classList.remove('hidden');\n        activePanelId = panelId;\n        if (logToggleBtn) {\n          logToggleBtn.textContent = `Show: ${formatPanelName(panelId)}`;\n        }\n        saveState();\n      }\n    };\n\n    const formatPanelName = (id) => {\n      return id.replace('-panel', '').replace(/-/g, ' ').replace(/\\b\\w/g, (c) => c.toUpperCase());\n    };\n\n    const saveState = () => {\n      try {\n        localStorage.setItem(PANEL_STORAGE_KEY, activePanelId);\n      } catch (error) {\n        logger.warn('[UIManager] Failed to save panel state:', error);\n      }\n    };\n\n    const restoreState = () => {\n      try {\n        const saved = localStorage.getItem(PANEL_STORAGE_KEY);\n        if (saved) {\n          showPanel(saved);\n          return true;\n        }\n      } catch (error) {\n        logger.warn('[UIManager] Failed to restore panel state:', error);\n      }\n      return false;\n    };\n\n    return { init };\n  }\n};\n\nexport default UIManager;\n",
      "hash": "457b1ad67649b2fbcc89457d712b9eb2f6de6975b112a97990221ed90d7f1ce4"
    },
    "ui/dashboard/metrics-dashboard.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 9046,
        "binary": false
      },
      "content": "/**\n * @fileoverview Metrics Dashboard - Visual performance metrics with Chart.js\n * Extends PerformanceMonitor with interactive charts and visualizations\n *\n * @module MetricsDashboard\n * @version 1.0.0\n * @category ui\n * @requires Chart.js (loaded via CDN in HTML)\n */\n\nconst MetricsDashboard = {\n  metadata: {\n    id: 'MetricsDashboard',\n    version: '1.0.0',\n    dependencies: ['Utils', 'PerformanceMonitor'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, PerformanceMonitor } = deps;\n    const { logger } = Utils;\n\n    // Chart instances\n    let memoryChart = null;\n    let toolsChart = null;\n    let tokensChart = null;\n\n    /**\n     * Initialize metrics dashboard with Chart.js\n     * @param {HTMLElement} container - Container element for charts\n     */\n    const init = (container) => {\n      if (!container) {\n        logger.warn('[MetricsDashboard] No container provided');\n        return;\n      }\n\n      // Check if Chart.js is loaded\n      if (typeof Chart === 'undefined') {\n        logger.error('[MetricsDashboard] Chart.js not loaded');\n        return;\n      }\n\n      logger.info('[MetricsDashboard] Initializing metrics dashboard');\n\n      // Create chart canvases\n      const chartsHTML = `\n        <div class=\"charts-grid\">\n          <div class=\"chart-container\">\n            <h4>Memory Usage Over Time</h4>\n            <canvas id=\"memory-chart\"></canvas>\n          </div>\n          <div class=\"chart-container\">\n            <h4>Tool Usage</h4>\n            <canvas id=\"tools-chart\"></canvas>\n          </div>\n          <div class=\"chart-container\">\n            <h4>LLM Token Usage</h4>\n            <canvas id=\"tokens-chart\"></canvas>\n          </div>\n        </div>\n      `;\n\n      container.insertAdjacentHTML('beforeend', chartsHTML);\n\n      // Initialize charts\n      initMemoryChart();\n      initToolsChart();\n      initTokensChart();\n\n      // Auto-refresh every 5 seconds\n      setInterval(() => {\n        updateCharts();\n      }, 5000);\n    };\n\n    const buildChart = (canvasId, configFactory) => {\n      const canvas = document.getElementById(canvasId);\n      if (!canvas) return null;\n      return new Chart(canvas.getContext('2d'), configFactory());\n    };\n\n    const baseOptions = (overrides = {}) => ({\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: { legend: { labels: { color: '#e0e0e0' } } },\n      scales: {\n        y: {\n          beginAtZero: true,\n          ticks: { color: '#aaa' },\n          grid: { color: 'rgba(255, 255, 255, 0.1)' }\n        },\n        x: {\n          ticks: { color: '#aaa' },\n          grid: { color: 'rgba(255, 255, 255, 0.1)' }\n        }\n      },\n      ...overrides\n    });\n\n    const initMemoryChart = () => {\n      const memStats = PerformanceMonitor.getMemoryStats();\n\n      if (!memStats || !memStats.history) {\n        logger.warn('[MetricsDashboard] No memory history available');\n        return;\n      }\n\n      // Prepare data from history\n      const labels = memStats.history.map((_, i) => `${i * 30}s`);\n      const data = memStats.history.map(s => (s.usedJSHeapSize / 1024 / 1024).toFixed(2));\n\n      memoryChart = buildChart('memory-chart', () => ({\n        type: 'line',\n        data: {\n          labels,\n          datasets: [{\n            label: 'Memory Usage (MB)',\n            data,\n            borderColor: 'rgba(0, 255, 255, 0.8)',\n            backgroundColor: 'rgba(0, 255, 255, 0.1)',\n            tension: 0.4,\n            fill: true\n          }]\n        },\n        options: baseOptions()\n      }));\n    };\n\n    /**\n     * Initialize tool usage bar chart\n     */\n    const initToolsChart = () => {\n      const metrics = PerformanceMonitor.getMetrics();\n\n      // Get top 10 tools by call count\n      const toolData = Object.entries(metrics.tools)\n        .map(([name, data]) => ({\n          name: name.length > 20 ? name.substring(0, 20) + '...' : name,\n          calls: data.calls\n        }))\n        .sort((a, b) => b.calls - a.calls)\n        .slice(0, 10);\n\n      toolsChart = buildChart('tools-chart', () => ({\n        type: 'bar',\n        data: {\n          labels: toolData.map(t => t.name),\n          datasets: [{\n            label: 'Call Count',\n            data: toolData.map(t => t.calls),\n            backgroundColor: 'rgba(0, 255, 255, 0.6)',\n            borderColor: 'rgba(0, 255, 255, 1)',\n            borderWidth: 1\n          }]\n        },\n        options: baseOptions({\n          scales: {\n            y: baseOptions().scales.y,\n            x: {\n              ticks: { color: '#aaa', maxRotation: 45, minRotation: 45 },\n              grid: { color: 'rgba(255, 255, 255, 0.1)' }\n            }\n          }\n        })\n      }));\n    };\n\n    /**\n     * Initialize LLM token usage doughnut chart\n     */\n    const initTokensChart = () => {\n      const llmStats = PerformanceMonitor.getLLMStats();\n\n      tokensChart = buildChart('tokens-chart', () => ({\n        type: 'doughnut',\n        data: {\n          labels: ['Input Tokens', 'Output Tokens'],\n          datasets: [{\n            data: [llmStats.tokens.input, llmStats.tokens.output],\n            backgroundColor: [\n              'rgba(0, 255, 255, 0.6)',\n              'rgba(255, 0, 255, 0.6)'\n            ],\n            borderColor: [\n              'rgba(0, 255, 255, 1)',\n              'rgba(255, 0, 255, 1)'\n            ],\n            borderWidth: 1\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              position: 'bottom',\n              labels: { color: '#e0e0e0' }\n            }\n          }\n        }\n      }));\n    };\n\n    /**\n     * Update all charts with latest data\n     */\n    const updateCharts = () => {\n      const metrics = PerformanceMonitor.getMetrics();\n      const memStats = PerformanceMonitor.getMemoryStats();\n      const llmStats = PerformanceMonitor.getLLMStats();\n\n      // Update memory chart\n      if (memoryChart && memStats && memStats.history) {\n        const labels = memStats.history.map((_, i) => `${i * 30}s`);\n        const data = memStats.history.map(s => (s.usedJSHeapSize / 1024 / 1024).toFixed(2));\n\n        memoryChart.data.labels = labels;\n        memoryChart.data.datasets[0].data = data;\n        memoryChart.update('none'); // No animation for performance\n      }\n\n      // Update tools chart\n      if (toolsChart) {\n        const toolData = Object.entries(metrics.tools)\n          .map(([name, data]) => ({\n            name: name.length > 20 ? name.substring(0, 20) + '...' : name,\n            calls: data.calls\n          }))\n          .sort((a, b) => b.calls - a.calls)\n          .slice(0, 10);\n\n        toolsChart.data.labels = toolData.map(t => t.name);\n        toolsChart.data.datasets[0].data = toolData.map(t => t.calls);\n        toolsChart.update('none');\n      }\n\n      // Update tokens chart\n      if (tokensChart) {\n        tokensChart.data.datasets[0].data = [llmStats.tokens.input, llmStats.tokens.output];\n        tokensChart.update('none');\n      }\n\n      logger.debug('[MetricsDashboard] Charts updated');\n    };\n\n    /**\n     * Destroy all charts and clean up\n     */\n    const destroy = () => {\n      if (memoryChart) {\n        memoryChart.destroy();\n        memoryChart = null;\n      }\n      if (toolsChart) {\n        toolsChart.destroy();\n        toolsChart = null;\n      }\n      if (tokensChart) {\n        tokensChart.destroy();\n        tokensChart = null;\n      }\n      logger.info('[MetricsDashboard] Destroyed');\n    };\n\n    /**\n     * Generate metrics dashboard summary\n     * @returns {string} Markdown summary\n     */\n    const generateSummary = () => {\n      const metrics = PerformanceMonitor.getMetrics();\n      const llmStats = PerformanceMonitor.getLLMStats();\n      const memStats = PerformanceMonitor.getMemoryStats();\n\n      const uptime = metrics.session.uptime;\n      const uptimeMin = Math.floor(uptime / 60000);\n      const uptimeSec = Math.floor((uptime % 60000) / 1000);\n\n      return `\n# Metrics Dashboard Summary\n\n**Session Uptime:** ${uptimeMin}m ${uptimeSec}s\n\n## LLM Usage\n- **Total Calls:** ${llmStats.calls}\n- **Total Tokens:** ${llmStats.tokens.total.toLocaleString()}\n- **Avg Latency:** ${llmStats.avgLatency.toFixed(0)}ms\n- **Error Rate:** ${(llmStats.errorRate * 100).toFixed(1)}%\n\n## Memory\n- **Current:** ${(memStats.current.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB\n- **Peak:** ${(memStats.max / 1024 / 1024).toFixed(2)} MB\n- **Limit:** ${(memStats.current.jsHeapSizeLimit / 1024 / 1024).toFixed(0)} MB\n\n## Top Tools\n${Object.entries(metrics.tools)\n  .sort((a, b) => b[1].calls - a[1].calls)\n  .slice(0, 5)\n  .map(([name, data]) => `- **${name}:** ${data.calls} calls (${(data.totalTime / data.calls).toFixed(1)}ms avg)`)\n  .join('\\n')}\n      `.trim();\n    };\n\n    return {\n      api: {\n        init,\n        updateCharts,\n        destroy,\n        generateSummary\n      }\n    };\n  }\n};\n\n// Export for module loader\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = MetricsDashboard;\n}\nMetricsDashboard;\n",
      "hash": "6b2355edaef2a1b0580e01b7732c2d81416e47d2ab41b70607246aa738ebd087"
    },
    "ui/components/toast-notifications.js": {
      "meta": {
        "mtimeMs": 1763564495261.1572,
        "size": 4285,
        "binary": false
      },
      "content": "// Toast Notification System - Non-blocking user feedback\n// Replaces alert() calls with elegant toast notifications\n\nconst ToastNotifications = {\n  metadata: {\n    id: 'ToastNotifications',\n    version: '1.0.0',\n    description: 'Non-blocking toast notification system for user feedback',\n    dependencies: ['Utils'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils } = deps;\n    const { logger } = Utils;\n\n    let container = null;\n    let toastQueue = [];\n    let activeToasts = [];\n\n    // Toast types\n    const TOAST_TYPES = {\n      success: { icon: 'âœ“', color: '#4ec9b0', bg: 'rgba(76, 175, 80, 0.9)' },\n      error: { icon: 'â˜©', color: '#f48771', bg: 'rgba(244, 135, 113, 0.9)' },\n      warning: { icon: 'âš ', color: '#ffd700', bg: 'rgba(255, 215, 0, 0.9)' },\n      info: { icon: 'â„¹', color: '#4fc3f7', bg: 'rgba(79, 195, 247, 0.9)' }\n    };\n\n    // Initialize toast container\n    const init = () => {\n      if (container) return;\n\n      container = document.createElement('div');\n      container.id = 'toast-container';\n      container.style.cssText = `\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        z-index: 10001;\n        display: flex;\n        flex-direction: column;\n        gap: 12px;\n        pointer-events: none;\n      `;\n      document.body.appendChild(container);\n      logger.info('[ToastNotifications] Initialized');\n    };\n\n    // Show toast notification\n    const show = (message, type = 'info', duration = 4000) => {\n      init(); // Ensure container exists\n\n      const config = TOAST_TYPES[type] || TOAST_TYPES.info;\n\n      // Create toast element\n      const toast = document.createElement('div');\n      toast.className = `toast toast-${type}`;\n      toast.style.cssText = `\n        background: ${config.bg};\n        color: white;\n        padding: 12px 16px;\n        border-radius: 4px;\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        min-width: 280px;\n        max-width: 400px;\n        font-size: 14px;\n        opacity: 0;\n        transform: translateX(400px);\n        transition: all 0.3s ease-out;\n        pointer-events: auto;\n        cursor: pointer;\n        border-left: 4px solid ${config.color};\n      `;\n\n      toast.innerHTML = `\n        <span style=\"font-size: 18px; font-weight: bold;\">${config.icon}</span>\n        <span style=\"flex: 1;\">${message}</span>\n        <span style=\"font-size: 12px; color: rgba(255, 255, 255, 0.7); cursor: pointer;\">â˜©</span>\n      `;\n\n      // Add to container\n      container.appendChild(toast);\n      activeToasts.push(toast);\n\n      // Animate in\n      setTimeout(() => {\n        toast.style.opacity = '1';\n        toast.style.transform = 'translateX(0)';\n      }, 10);\n\n      // Auto-remove after duration\n      const removeToast = () => {\n        toast.style.opacity = '0';\n        toast.style.transform = 'translateX(400px)';\n        setTimeout(() => {\n          if (container && container.contains(toast)) {\n            container.removeChild(toast);\n          }\n          activeToasts = activeToasts.filter(t => t !== toast);\n        }, 300);\n      };\n\n      // Click to dismiss\n      toast.addEventListener('click', removeToast);\n\n      // Auto-dismiss\n      if (duration > 0) {\n        setTimeout(removeToast, duration);\n      }\n\n      return toast;\n    };\n\n    // Convenience methods\n    const success = (message, duration) => show(message, 'success', duration);\n    const error = (message, duration) => show(message, 'error', duration);\n    const warning = (message, duration) => show(message, 'warning', duration);\n    const info = (message, duration) => show(message, 'info', duration);\n\n    // Clear all toasts\n    const clearAll = () => {\n      activeToasts.forEach(toast => {\n        if (container && container.contains(toast)) {\n          container.removeChild(toast);\n        }\n      });\n      activeToasts = [];\n    };\n\n    return {\n      init,\n      show,\n      success,\n      error,\n      warning,\n      info,\n      clearAll\n    };\n  }\n};\n\n// Register module if running in REPLOID environment\nif (typeof window !== 'undefined' && window.ModuleRegistry) {\n  window.ModuleRegistry.register(ToastNotifications);\n}\n\nexport default ToastNotifications;\n",
      "hash": "0982aaae8d71a97516b62a9b100a1ee297fc4d40f522b7c96600900c6d9dda07"
    },
    "ui/components/diff-viewer-ui.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 21666,
        "binary": false
      },
      "content": "// Interactive Diff Viewer UI Component for REPLOID Sentinel\n// Provides rich diff visualization and interactive approval controls\n// PX-3 Enhanced: Prism.js syntax highlighting + detailed statistics\n// PHASE 3 UPDATE: Added Event-Driven Rollback capability\n\nimport ParserUtils from '../../core/parser-utils.js';\n\nconst DiffViewerUI = {\n  metadata: {\n    id: 'DiffViewerUI',\n    version: '2.2.0', // Bumped for Phase 3\n    description: 'Enhanced diff viewer with Prism.js highlighting, stats, and rollback events',\n    features: [\n      'Prism.js syntax highlighting for 10+ languages',\n      'Side-by-side diff with color-coded changes',\n      'Detailed per-file statistics (added/removed/modified lines)',\n      'Language detection from file extensions',\n      'Export to markdown, clipboard, and Web Share API',\n      'Event-driven Rollback trigger'\n    ],\n    dependencies: ['Utils', 'StateManager', 'EventBus', 'ConfirmationModal?'],\n    externalDeps: ['Prism'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils, StateManager, EventBus, ConfirmationModal } = deps;\n    const { logger, escapeHtml } = Utils;\n\n    // Initialize substrate parser for protocol compliance\n    const parserUtils = ParserUtils.factory({});\n\n    let container = null;\n    let currentDiff = null;\n\n    // Track event listeners for cleanup\n    const eventListeners = {\n      showDiff: null,\n      clearDiff: null\n    };\n\n    // Cleanup function to remove event listeners\n    const cleanup = () => {\n      if (eventListeners.showDiff) {\n        EventBus.off('diff:show', eventListeners.showDiff);\n        eventListeners.showDiff = null;\n      }\n      if (eventListeners.clearDiff) {\n        EventBus.off('diff:clear', eventListeners.clearDiff);\n        eventListeners.clearDiff = null;\n      }\n    };\n\n    // Initialize the diff viewer\n    const init = (containerId) => {\n      // Clean up any existing listeners first\n      cleanup();\n\n      container = document.getElementById(containerId);\n      if (!container) {\n        logger.error('[DiffViewerUI] Container not found:', containerId);\n        return;\n      }\n\n      // Register event listeners and store references\n      eventListeners.showDiff = handleShowDiff;\n      eventListeners.clearDiff = clearDiff;\n      EventBus.on('diff:show', eventListeners.showDiff);\n      EventBus.on('diff:clear', eventListeners.clearDiff);\n\n      logger.info('[DiffViewerUI] Initialized');\n    };\n\n    // Handle showing a diff\n    const handleShowDiff = async (data) => {\n      const { dogs_path, session_id, turn } = data;\n\n      try {\n        // Load and parse the dogs bundle\n        const dogsContent = await StateManager.getArtifactContent(dogs_path);\n        if (!dogsContent) {\n          showError('Dogs bundle not found');\n          return;\n        }\n\n        const changes = await parseDogsBundle(dogsContent);\n        currentDiff = { changes, dogs_path, session_id, turn };\n\n        renderDiff(changes);\n\n      } catch (error) {\n        logger.error('[DiffViewerUI] Error showing diff:', error);\n        showError('Failed to load diff');\n      }\n    };\n\n    // Parse dogs bundle using substrate parser for protocol compliance\n    const parseDogsBundle = async (content) => {\n      // Use canonical parser from substrate\n      const baseChanges = parserUtils.parseDogsBundle(content);\n\n      // Enrich with old content and UI state\n      const enrichedChanges = [];\n      for (const change of baseChanges) {\n        let oldContent = '';\n\n        // For MODIFY and DELETE operations, fetch current content\n        if (change.operation === 'MODIFY' || change.operation === 'DELETE') {\n          try {\n            oldContent = await StateManager.getArtifactContent(change.file_path) || '';\n          } catch (err) {\n            console.error(`Failed to fetch old content for ${change.file_path}:`, err);\n            oldContent = '// Error loading original content';\n          }\n        }\n\n        enrichedChanges.push({\n          ...change,\n          old_content: oldContent,\n          approved: true // Default to approved for smoother workflow\n        });\n      }\n\n      return enrichedChanges;\n    };\n\n    let actionClickHandler = null;\n\n    // Render the diff viewer\n    const renderDiff = (changes) => {\n      if (!container) return;\n\n      const html = `\n        <div class=\"diff-viewer\">\n          <div class=\"diff-header\">\n            <h3>Review Proposed Changes</h3>\n            <div class=\"diff-stats\">\n              ${getChangeStats(changes)}\n            </div>\n          </div>\n\n          <div class=\"diff-actions\" role=\"toolbar\" aria-label=\"Diff actions\">\n            <button class=\"btn-approve-all\" data-action=\"approve-all\" aria-label=\"Approve all changes\">\n              âœ“ Approve All\n            </button>\n            <button class=\"btn-reject-all\" data-action=\"reject-all\" aria-label=\"Reject all changes\">\n              âœ— Reject All\n            </button>\n            <button class=\"btn-edit\" data-action=\"edit\" aria-label=\"edit proposal\">\n              âœŽ edit Proposal\n            </button>\n            <button class=\"btn-export\" data-action=\"copy\" title=\"Copy diff to clipboard\">\n              ðŸ“‹ Copy\n            </button>\n            <button class=\"btn-export\" data-action=\"export\" title=\"Export as Markdown\">\n              ðŸ’¾ Export\n            </button>\n          </div>\n\n          <div class=\"diff-files\">\n            ${changes.map((change, index) => renderFileChange(change, index)).join('')}\n          </div>\n\n          <div class=\"diff-footer\" role=\"group\" aria-label=\"Apply or cancel changes\">\n             <button class=\"btn-rollback\" data-action=\"rollback\" aria-label=\"Emergency Rollback\" title=\"Revert file system to pre-proposal state\">\n              â†© Emergency Rollback\n            </button>\n            <div class=\"spacer\" style=\"flex: 1;\"></div>\n            <button class=\"btn-cancel\" data-action=\"cancel\" aria-label=\"Cancel and close\">\n              Cancel\n            </button>\n            <button class=\"btn-apply\" data-action=\"apply\" aria-label=\"Apply approved changes\">\n              Apply Approved Changes\n            </button>\n          </div>\n      </div>\n    `;\n\n      container.innerHTML = html;\n      bindDiffEvents();\n\n      // Initialize diff rendering for each file\n      changes.forEach((change, index) => {\n        if (change.operation === 'MODIFY') {\n          renderFileDiff(change, index);\n        }\n      });\n    };\n\n    const bindDiffEvents = () => {\n      if (!container) return;\n\n      if (actionClickHandler) {\n        container.removeEventListener('click', actionClickHandler);\n      }\n\n      actionClickHandler = handleActionClick;\n      container.addEventListener('click', actionClickHandler);\n\n      const diffFiles = container.querySelector('.diff-files');\n      if (diffFiles) {\n        diffFiles.addEventListener('click', handleDiffFileClick);\n        diffFiles.addEventListener('change', handleApprovalChangeEvent);\n      }\n    };\n\n    const handleActionClick = (event) => {\n      const target = event.target.closest('[data-action]');\n      if (!target) return;\n      const actionMap = {\n        'approve-all': approveAll,\n        'reject-all': rejectAll,\n        'edit': editProposal,\n        'copy': () => copyToClipboard(target),\n        'export': exportMarkdown,\n        'rollback': rollback,\n        'cancel': cancel,\n        'apply': applyApproved\n      };\n      const handler = actionMap[target.dataset.action];\n      if (handler) {\n        handler();\n      }\n    };\n\n    const handleDiffFileClick = (event) => {\n      const expandBtn = event.target.closest('[data-expand]');\n      if (!expandBtn) return;\n      const index = parseInt(expandBtn.dataset.expand, 10);\n      if (!Number.isNaN(index)) {\n        toggleExpand(index);\n      }\n    };\n\n    const handleApprovalChangeEvent = (event) => {\n      if (!event.target.classList.contains('approve-checkbox')) return;\n      const index = parseInt(event.target.dataset.index, 10);\n      if (!Number.isNaN(index)) {\n        toggleApproval(index, event.target.checked);\n      }\n    };\n\n    // Get change statistics\n    const getChangeStats = (changes) => {\n      const stats = { CREATE: 0, MODIFY: 0, DELETE: 0 };\n      changes.forEach(c => stats[c.operation]++);\n\n      return `\n        <span class=\"stat-create\">+${stats.CREATE} new</span>\n        <span class=\"stat-modify\">~${stats.MODIFY} modified</span>\n        <span class=\"stat-delete\">-${stats.DELETE} deleted</span>\n      `;\n    };\n\n    // Render a single file change\n    const renderFileChange = (change, index) => {\n      const icon = {\n        CREATE: 'âž•',\n        MODIFY: 'âœï¸',\n        DELETE: 'ðŸ—‘ï¸'\n      }[change.operation];\n\n      return `\n        <div class=\"diff-file\" data-index=\"${index}\" role=\"article\">\n          <div class=\"diff-file-header\" id=\"diff-header-${index}\">\n            <div class=\"diff-file-info\">\n              <span class=\"diff-icon\" aria-hidden=\"true\">${icon}</span>\n              <span class=\"diff-path\">${change.file_path}</span>\n              <span class=\"diff-operation ${change.operation.toLowerCase()}\">${change.operation}</span>\n            </div>\n            <div class=\"diff-file-actions\">\n              <label class=\"checkbox-wrapper\">\n                <input type=\"checkbox\"\n                       class=\"approve-checkbox\"\n                       data-index=\"${index}\"\n                       ${change.approved ? 'checked' : ''}>\n                <span>Approve</span>\n              </label>\n              <button class=\"btn-expand\" data-expand=\"${index}\">\n                ${change.operation === 'DELETE' ? 'View' : 'Expand'}\n              </button>\n            </div>\n          </div>\n          <div class=\"diff-file-content\" id=\"diff-content-${index}\" style=\"display: none;\">\n            ${renderChangeContent(change, index)}\n          </div>\n        </div>\n      `;\n    };\n\n    // Render the content of a change\n    const renderChangeContent = (change, index) => {\n      const language = detectLanguage(change.file_path);\n\n      if (change.operation === 'CREATE') {\n        const highlightedCode = highlightCode(change.new_content, language);\n        const lines = change.new_content.split('\\n').length;\n        return `\n          <div class=\"diff-create\">\n            <div class=\"diff-stats-summary\">\n              <span class=\"diff-stat-item added\">+${lines} lines</span>\n            </div>\n            <pre class=\"code-block language-${language}\"><code>${highlightedCode}</code></pre>\n          </div>\n        `;\n      } else if (change.operation === 'DELETE') {\n        const content = change.old_content || 'File will be deleted';\n        const highlightedCode = change.old_content ? highlightCode(content, language) : content;\n        const lines = change.old_content ? change.old_content.split('\\n').length : 0;\n        return `\n          <div class=\"diff-delete\">\n            <div class=\"diff-stats-summary\">\n              <span class=\"diff-stat-item removed\">-${lines} lines</span>\n            </div>\n            <pre class=\"code-block language-${language}\"><code>${highlightedCode}</code></pre>\n          </div>\n        `;\n      } else if (change.operation === 'MODIFY') {\n        return `<div class=\"diff-modify\" id=\"diff-modify-${index}\">Loading diff...</div>`;\n      }\n    };\n\n    // Render a file diff for MODIFY operations\n    const renderFileDiff = async (change, index) => {\n      const container = document.getElementById(`diff-modify-${index}`);\n      if (!container) return;\n\n      try {\n        const oldContent = await StateManager.getArtifactContent(change.file_path) || '';\n        const newContent = change.new_content;\n        const diffHtml = generateSideBySideDiff(oldContent, newContent, change.file_path);\n        container.innerHTML = diffHtml;\n      } catch (error) {\n        container.innerHTML = '<div class=\"error\">Failed to load diff</div>';\n      }\n    };\n\n    // Detect language from file path\n    const detectLanguage = (filePath) => {\n      const ext = filePath.split('.').pop().toLowerCase();\n      const langMap = {\n        'js': 'javascript', 'ts': 'typescript', 'json': 'json', 'css': 'css', 'html': 'markup', 'py': 'python', 'md': 'markdown'\n      };\n      return langMap[ext] || 'javascript';\n    };\n\n    // Apply syntax highlighting\n    const highlightCode = (code, language) => {\n      if (typeof Prism === 'undefined' || !Prism.languages[language]) {\n        return escapeHtml(code);\n      }\n      try {\n        return Prism.highlight(code, Prism.languages[language], language);\n      } catch (err) {\n        return escapeHtml(code);\n      }\n    };\n\n    // Calculate detailed diff statistics\n    const calculateDiffStats = (oldContent, newContent) => {\n      const oldLines = oldContent.split('\\n');\n      const newLines = newContent.split('\\n');\n      let added = 0, removed = 0, modified = 0, unchanged = 0;\n      const maxLines = Math.max(oldLines.length, newLines.length);\n\n      for (let i = 0; i < maxLines; i++) {\n        const oldLine = oldLines[i];\n        const newLine = newLines[i];\n\n        if (oldLine === undefined) added++;\n        else if (newLine === undefined) removed++;\n        else if (oldLine !== newLine) modified++;\n        else unchanged++;\n      }\n\n      return { added, removed, modified, unchanged, total: maxLines };\n    };\n\n    // Generate side-by-side diff HTML\n    const generateSideBySideDiff = (oldContent, newContent, filePath = '') => {\n      const oldLines = oldContent.split('\\n');\n      const newLines = newContent.split('\\n');\n      const maxLines = Math.max(oldLines.length, newLines.length);\n      const language = detectLanguage(filePath);\n      const stats = calculateDiffStats(oldContent, newContent);\n\n      let html = '<div class=\"diff-stats-summary\">';\n      html += `<span class=\"diff-stat-item added\">+${stats.added}</span>`;\n      html += `<span class=\"diff-stat-item removed\">-${stats.removed}</span>`;\n      html += `<span class=\"diff-stat-item modified\">~${stats.modified}</span>`;\n      html += '</div>';\n\n      html += '<div class=\"side-by-side-diff\">';\n      html += '<div class=\"diff-pane diff-old\"><div class=\"diff-pane-header\">Original</div><div class=\"diff-lines\">';\n\n      for (let i = 0; i < maxLines; i++) {\n        const oldLine = oldLines[i];\n        const newLine = newLines[i];\n        let lineClass = '';\n\n        if (oldLine === undefined) lineClass = 'empty';\n        else if (newLine === undefined) lineClass = 'removed';\n        else if (oldLine !== newLine) lineClass = 'changed';\n\n        if (oldLine !== undefined) {\n          html += `<div class=\"diff-line ${lineClass}\"><span class=\"line-number\">${i + 1}</span><span class=\"line-content\">${highlightCode(oldLine, language)}</span></div>`;\n        } else {\n          html += '<div class=\"diff-line empty\"><span class=\"line-number\"></span><span class=\"line-content\">&nbsp;</span></div>';\n        }\n      }\n      html += '</div></div>';\n\n      html += '<div class=\"diff-pane diff-new\"><div class=\"diff-pane-header\">Modified</div><div class=\"diff-lines\">';\n      for (let i = 0; i < maxLines; i++) {\n        const oldLine = oldLines[i];\n        const newLine = newLines[i];\n        let lineClass = '';\n\n        if (newLine === undefined) lineClass = 'empty';\n        else if (oldLine === undefined) lineClass = 'added';\n        else if (oldLine !== newLine) lineClass = 'changed';\n\n        if (newLine !== undefined) {\n          html += `<div class=\"diff-line ${lineClass}\"><span class=\"line-number\">${i + 1}</span><span class=\"line-content\">${highlightCode(newLine, language)}</span></div>`;\n        } else {\n          html += '<div class=\"diff-line empty\"><span class=\"line-number\"></span><span class=\"line-content\">&nbsp;</span></div>';\n        }\n      }\n      html += '</div></div></div>';\n\n      return html;\n    };\n\n    // Toggle file content expansion\n    const toggleExpand = (index) => {\n      const content = document.getElementById(`diff-content-${index}`);\n      if (content) {\n        const isExpanded = content.style.display !== 'none';\n        content.style.display = isExpanded ? 'none' : 'block';\n      }\n    };\n\n    // Toggle approval for a change\n    const toggleApproval = (index, state = null) => {\n      if (currentDiff && currentDiff.changes[index]) {\n        currentDiff.changes[index].approved = state === null\n          ? !currentDiff.changes[index].approved\n          : state;\n        updateApprovalStats();\n      }\n    };\n\n    // Approve all changes\n    const approveAll = () => {\n      if (currentDiff) {\n        currentDiff.changes.forEach(c => c.approved = true);\n        document.querySelectorAll('.approve-checkbox').forEach(cb => cb.checked = true);\n        updateApprovalStats();\n      }\n    };\n\n    // Reject all changes\n    const rejectAll = () => {\n      if (currentDiff) {\n        currentDiff.changes.forEach(c => c.approved = false);\n        document.querySelectorAll('.approve-checkbox').forEach(cb => cb.checked = false);\n        updateApprovalStats();\n      }\n    };\n\n    // Update approval statistics\n    const updateApprovalStats = () => {\n      const approved = currentDiff.changes.filter(c => c.approved).length;\n      const total = currentDiff.changes.length;\n      const applyBtn = document.querySelector('.btn-apply');\n      if (applyBtn) {\n        applyBtn.textContent = `Apply ${approved}/${total} Approved Changes`;\n        applyBtn.disabled = approved === 0;\n      }\n    };\n\n    // Apply approved changes\n    const applyApproved = async () => {\n      if (!currentDiff) return;\n\n      const approvedChanges = currentDiff.changes.filter(c => c.approved);\n      if (approvedChanges.length === 0) {\n        showError('No changes approved');\n        return;\n      }\n\n      // Show confirmation dialog\n      const changeDetails = approvedChanges.map(c => `${c.operation}: ${c.file_path}`).join('\\n');\n      \n      const confirmed = ConfirmationModal\n        ? await ConfirmationModal.confirm({\n            title: 'Apply Changes',\n            message: `Apply ${approvedChanges.length} approved change${approvedChanges.length > 1 ? 's' : ''}? This will modify your files.`,\n            confirmText: 'Apply Changes',\n            cancelText: 'Cancel',\n            danger: true,\n            details: changeDetails\n          })\n        : confirm(`Apply ${approvedChanges.length} change(s)?\\n\\n${changeDetails}`);\n\n      if (!confirmed) return;\n\n      const filteredDogsPath = currentDiff.dogs_path.replace('.md', '-filtered.md');\n\n      EventBus.emit('proposal:approved', {\n        original_dogs_path: currentDiff.dogs_path,\n        filtered_dogs_path: filteredDogsPath,\n        approved_changes: approvedChanges,\n        session_id: currentDiff.session_id,\n        turn: currentDiff.turn\n      });\n\n      clearDiff();\n    };\n\n    // edit the proposal\n    const editProposal = () => {\n      if (!currentDiff) return;\n      EventBus.emit('proposal:edit', {\n        dogs_path: currentDiff.dogs_path,\n        changes: currentDiff.changes\n      });\n    };\n\n    // Trigger Rollback via EventBus (Decoupled from FSM)\n    const rollback = async () => {\n        const confirmed = ConfirmationModal\n        ? await ConfirmationModal.confirm({\n            title: 'Emergency Rollback',\n            message: 'Are you sure you want to revert the file system to the state before these changes were proposed?',\n            confirmText: 'Rollback',\n            cancelText: 'Abort',\n            danger: true\n          })\n        : confirm('Emergency Rollback: Revert file system?');\n\n        if (confirmed) {\n            logger.warn('[DiffViewerUI] Triggering manual rollback');\n            EventBus.emit('proposal:rollback');\n            clearDiff();\n        }\n    };\n\n    // Cancel the diff viewer\n    const cancel = () => {\n      EventBus.emit('proposal:cancelled');\n      clearDiff();\n    };\n\n    // Clear the diff viewer\n    const clearDiff = () => {\n      if (container) container.innerHTML = '';\n      currentDiff = null;\n    };\n\n    // Show an error message\n    const showError = (message) => {\n      if (container) {\n        container.innerHTML = `<div class=\"diff-error\"><p>âŒ ${message}</p></div>`;\n      }\n    };\n\n    // Copy diff to clipboard\n    const copyToClipboard = async (btn) => {\n      if (!currentDiff) return;\n      try {\n        const markdown = generateDiffMarkdown();\n        await navigator.clipboard.writeText(markdown);\n        if (btn) {\n          const originalText = btn.innerHTML;\n          btn.innerHTML = 'âœ“ Copied!';\n          setTimeout(() => { btn.innerHTML = originalText; }, 2000);\n        }\n      } catch (err) {\n        logger.error('[DiffViewerUI] Copy failed:', err);\n      }\n    };\n\n    // Generate diff summary markdown\n    const generateDiffMarkdown = () => {\n      if (!currentDiff) return '';\n      const { changes, dogs_path } = currentDiff;\n      let md = `# Diff Summary\\nSource: ${dogs_path}\\n\\n`;\n      changes.forEach((change, i) => {\n         md += `### ${i+1}. ${change.operation}: ${change.file_path}\\n`;\n      });\n      return md;\n    };\n\n    // Export as markdown file\n    const exportMarkdown = () => {\n      if (!currentDiff) return;\n      const markdown = generateDiffMarkdown();\n      const blob = new Blob([markdown], { type: 'text/markdown' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `diff-${Date.now()}.md`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    };\n\n    // Export public API\n    const publicApi = {\n      init,\n      showDiff: handleShowDiff,\n      clearDiff\n    };\n\n    return publicApi;\n  }\n};\n\nexport default DiffViewerUI;\n",
      "hash": "ed3f1686fa4fa94d18975db44c6c7dd428f8308b5ece60d20e8ce3cbe7086fc0"
    },
    "ui/components/confirmation-modal.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 3211,
        "binary": false
      },
      "content": "// Confirmation Modal Component for REPLOID\n\nconst ConfirmationModal = {\n  metadata: {\n    id: 'ConfirmationModal',\n    version: '1.1.0',\n    dependencies: ['Utils'],\n    async: false,\n    type: 'ui'\n  },\n\n  factory: (deps) => {\n    const { Utils } = deps;\n    const { logger, escapeHtml } = Utils;\n\n    let activeModal = null;\n\n    const attachHandlers = (overlay, handlers) => {\n      overlay.querySelector('.modal-btn-confirm').addEventListener('click', handlers.confirm);\n      overlay.querySelector('.modal-btn-cancel').addEventListener('click', handlers.cancel);\n      overlay.querySelector('.modal-close').addEventListener('click', handlers.cancel);\n      document.addEventListener('keydown', handlers.escape);\n      overlay.addEventListener('click', handlers.overlayClick);\n    };\n\n    const confirm = (options = {}) => {\n      const {\n        title = 'Confirm Action',\n        message = 'Are you sure you want to proceed?',\n        confirmText = 'Confirm',\n        cancelText = 'Cancel',\n        danger = false,\n        details = null\n      } = options;\n\n      return new Promise((resolve) => {\n        closeModal();\n\n        const overlay = document.createElement('div');\n        overlay.className = 'modal-overlay';\n        overlay.innerHTML = `\n          <div class=\"modal-content ${danger ? 'modal-danger' : ''}\">\n            <div class=\"modal-header\">\n              <h3 class=\"modal-title\">${escapeHtml(title)}</h3>\n              <button class=\"modal-close\" aria-label=\"Close\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n              <p class=\"modal-message\">${escapeHtml(message)}</p>\n              ${details ? `<div class=\"modal-details\">${escapeHtml(details)}</div>` : ''}\n            </div>\n            <div class=\"modal-actions\">\n              <button class=\"btn btn-secondary modal-btn-cancel\">${escapeHtml(cancelText)}</button>\n              <button class=\"btn ${danger ? 'btn-danger' : 'btn-primary'} modal-btn-confirm\">${escapeHtml(confirmText)}</button>\n            </div>\n          </div>\n        `;\n\n        const handlers = {\n          confirm: () => {\n            closeModal();\n            resolve(true);\n          },\n          cancel: () => {\n            closeModal();\n            resolve(false);\n          },\n          escape: (event) => {\n            if (event.key === 'Escape') handlers.cancel();\n          },\n          overlayClick: (event) => {\n            if (event.target === overlay) handlers.cancel();\n          }\n        };\n\n        document.body.appendChild(overlay);\n        attachHandlers(overlay, handlers);\n\n        activeModal = { overlay, handlers };\n        logger.info('[ConfirmationModal] Modal shown:', title);\n      });\n    };\n\n    const closeModal = () => {\n      if (!activeModal) return;\n      const { overlay, handlers } = activeModal;\n\n      document.removeEventListener('keydown', handlers.escape);\n      overlay.removeEventListener('click', handlers.overlayClick);\n\n      if (overlay.parentNode) {\n        overlay.parentNode.removeChild(overlay);\n      }\n\n      activeModal = null;\n      logger.info('[ConfirmationModal] Modal closed');\n    };\n\n    return { confirm, closeModal };\n  }\n};\n\nexport default ConfirmationModal;\n",
      "hash": "7514ef19cc4be9ea7fd229e45d7adbacd8b5b520bbc5e2712b6163f9b6c63a0b"
    },
    "ui/boot/ui.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 3123,
        "binary": false
      },
      "content": "// UI management functions\nimport { state, elements } from './state.js';\n\nexport function showBootMessage(message, type = 'info') {\n    console.log(`[Boot] ${type.toUpperCase()}: ${message}`);\n}\n\nexport function switchModalTab(tabName) {\n    // Hide all tab contents\n    document.querySelectorAll('.modal-tab-content').forEach(content => {\n        content.classList.remove('active');\n    });\n\n    // Remove active from all tabs\n    document.querySelectorAll('.modal-tab').forEach(tab => {\n        tab.classList.remove('active');\n    });\n\n    // Show selected tab\n    const selectedContent = document.getElementById(`modal-${tabName}-tab`);\n    if (selectedContent) {\n        selectedContent.classList.add('active');\n    }\n\n    // Activate selected tab button\n    const selectedTab = document.querySelector(`.modal-tab[data-modal-tab=\"${tabName}\"]`);\n    if (selectedTab) {\n        selectedTab.classList.add('active');\n    }\n}\n\nexport function openHelpPopover(content, anchorEl) {\n    if (!elements.helpPopover) return;\n\n    const helpBody = document.getElementById('help-popover-body');\n    if (helpBody) {\n        helpBody.innerHTML = content;\n    }\n\n    elements.helpPopover.classList.remove('hidden');\n    elements.helpPopover.setAttribute('aria-hidden', 'false');\n\n    // Position popover near the anchor element\n    if (anchorEl) {\n        const rect = anchorEl.getBoundingClientRect();\n        elements.helpPopover.style.position = 'absolute';\n        elements.helpPopover.style.top = `${rect.bottom + 10}px`;\n        elements.helpPopover.style.left = `${rect.left}px`;\n    }\n\n    state.activePopover = { anchorEl };\n}\n\nexport function closeHelpPopover() {\n    if (!elements.helpPopover) return;\n\n    elements.helpPopover.classList.add('hidden');\n    elements.helpPopover.setAttribute('aria-hidden', 'true');\n    state.activePopover = null;\n}\n\nexport async function showModeRecommendation() {\n    const recommendation = document.getElementById('mode-recommendation');\n    const recommendationText = document.getElementById('recommendation-text');\n\n    if (!recommendation || !recommendationText) return;\n\n    let message = '';\n\n    if (state.detectedEnv.hasServer && state.detectedEnv.hasOllama) {\n        message = 'You have the proxy server and Ollama running. We recommend the <strong>Local (Ollama)</strong> or <strong>Hybrid</strong> mode for a free, privacy-focused setup.';\n    } else if (state.detectedEnv.hasServer) {\n        message = 'You have the proxy server running. We recommend <strong>Cloud Provider</strong> mode to use powerful AI models via API keys.';\n    } else if (state.detectedEnv.hasWebGPU) {\n        message = 'Your browser supports WebGPU. We recommend <strong>Web LLM</strong> mode for client-side AI inference.';\n    } else {\n        message = 'We recommend <strong>Cloud Provider</strong> mode with an API key, or install Ollama for free local models.';\n    }\n\n    recommendationText.innerHTML = message;\n    recommendation.classList.remove('hidden');\n}\n\nexport function closeConfigModal() {\n    if (elements.configModal) {\n        elements.configModal.classList.add('hidden');\n    }\n}\n",
      "hash": "78ecfccff7545641747affd5e92f585acff949532191017127acd1860ff2bd96"
    },
    "ui/boot/state.js": {
      "meta": {
        "mtimeMs": 1761144551655.2732,
        "size": 1425,
        "binary": false
      },
      "content": "// State management for boot process\nexport const state = {\n    selectedMode: null,\n    selectedProvider: null,\n    detectedEnv: {\n        hasServer: false,\n        hasOllama: false,\n        hasWebGPU: false,\n        providers: []\n    },\n    activePopover: null,\n    // New: Available models from ModelRegistry\n    availableModels: {\n        cloud: [],\n        ollama: [],\n        webllm: [],\n        metadata: {}\n    },\n    // New: User-selected models configuration\n    selectedModels: [],\n    // New: Consensus strategy (if multiple models)\n    consensusStrategy: 'arena',\n    // New: Provider API keys tracking (for reuse)\n    configuredKeys: {\n        gemini: null,\n        openai: null,\n        anthropic: null\n    }\n};\n\nexport const elements = {\n    configBtn: document.getElementById('config-btn'),\n    configModal: document.getElementById('config-modal'),\n    closeModal: document.getElementById('close-modal'),\n    providerStatus: document.getElementById('provider-status'),\n    providerStatusDetail: document.getElementById('provider-status-detail'),\n    proxyChip: document.getElementById('agent-chip-proxy'),\n    providerChip: document.getElementById('agent-chip-provider'),\n    helpPopover: document.getElementById('help-popover'),\n    helpPopoverClose: document.querySelector('.help-popover-close'),\n    goalInput: document.getElementById('goal-input'),\n    awakenBtn: document.getElementById('awaken-btn')\n};\n",
      "hash": "68d4170a2906de4c68ce60a122f2d091d1612fc5459a5382ba6884ccc3b07af0"
    },
    "ui/boot/api.js": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 14504,
        "binary": false
      },
      "content": "// API status checking and model population\nimport { state, elements } from './state.js';\n\nconst logInfo = (...args) => console.info('[BootAPI]', ...args);\nconst logWarn = (...args) => console.warn('[BootAPI]', ...args);\n\n// Use the same origin as the current page, or fallback to localhost for local dev\nconst PROXY_BASE_URL = window.location.origin.includes('file://')\n    ? 'http://localhost:8000'\n    : window.location.origin;\n\n// ModelRegistry integration - discovery of available models\nexport async function discoverAvailableModels() {\n    logInfo('Discovering available models via ModelRegistry...');\n\n    // Wait for ModelRegistry to be loaded\n    let retries = 0;\n    while (!window.ModelRegistry && retries < 50) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        retries++;\n    }\n\n    if (!window.ModelRegistry) {\n        logWarn('ModelRegistry not available, falling back to basic detection');\n        return await fallbackModelDiscovery();\n    }\n\n    try {\n        const registry = await window.ModelRegistry.api.discoverModels(true); // force refresh\n        logInfo('[ModelRegistry] Providers discovered', Object.keys(registry || {}).length);\n\n        state.availableModels = {\n            cloud: [\n                ...(registry.gemini || []),\n                ...(registry.openai || []),\n                ...(registry.anthropic || [])\n            ],\n            ollama: registry.ollama || [],\n            webllm: registry.webllm || [],\n            metadata: registry.metadata || {}\n        };\n\n        return state.availableModels;\n    } catch (error) {\n        logWarn('ModelRegistry discovery failed:', error);\n        return await fallbackModelDiscovery();\n    }\n}\n\n// Fallback model discovery if ModelRegistry not available\nasync function fallbackModelDiscovery() {\n    const models = {\n        cloud: [],\n        ollama: [],\n        webllm: [],\n        metadata: { providers: [], timestamp: Date.now() }\n    };\n\n    // Check cloud models via proxy status\n    try {\n        const response = await fetch(`${PROXY_BASE_URL}/api/proxy-status`, {\n            method: 'GET',\n            signal: AbortSignal.timeout(3000)\n        });\n\n        if (response.ok) {\n            const data = await response.json();\n            const providers = data.providers || {};\n\n            // Add cloud models based on available providers\n            if (providers.gemini) {\n                models.cloud.push(\n                    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite', provider: 'gemini', tier: 'fast', available: true },\n                    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: 'gemini', tier: 'balanced', available: true }\n                );\n                models.metadata.providers.push('gemini');\n            }\n            if (providers.openai) {\n                models.cloud.push(\n                    { id: 'gpt-5-2025-08-07-mini', name: 'GPT-5 Mini', provider: 'openai', tier: 'fast', available: true },\n                    { id: 'gpt-5-2025-08-07', name: 'GPT-5', provider: 'openai', tier: 'advanced', available: true }\n                );\n                models.metadata.providers.push('openai');\n            }\n            if (providers.anthropic) {\n                models.cloud.push(\n                    { id: 'claude-4-5-haiku', name: 'Claude 4.5 Haiku', provider: 'anthropic', tier: 'fast', available: true },\n                    { id: 'claude-4-5-sonnet', name: 'Claude 4.5 Sonnet', provider: 'anthropic', tier: 'balanced', available: true }\n                );\n                models.metadata.providers.push('anthropic');\n            }\n        }\n    } catch (error) {\n        logWarn('Proxy status check failed:', error);\n\n        // Check localStorage for browser-direct keys\n        const localStorageKeys = {\n            gemini: !!localStorage.getItem('GEMINI_API_KEY'),\n            openai: !!localStorage.getItem('OPENAI_API_KEY'),\n            anthropic: !!localStorage.getItem('ANTHROPIC_API_KEY')\n        };\n\n        if (localStorageKeys.gemini) {\n            models.cloud.push(\n                { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite', provider: 'gemini', tier: 'fast', available: true },\n                { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: 'gemini', tier: 'balanced', available: true }\n            );\n            models.metadata.providers.push('gemini');\n        }\n        if (localStorageKeys.openai) {\n            models.cloud.push(\n                { id: 'gpt-5-2025-08-07-mini', name: 'GPT-5 Mini', provider: 'openai', tier: 'fast', available: true },\n                { id: 'gpt-5-2025-08-07', name: 'GPT-5', provider: 'openai', tier: 'advanced', available: true }\n            );\n            models.metadata.providers.push('openai');\n        }\n        if (localStorageKeys.anthropic) {\n            models.cloud.push(\n                { id: 'claude-4-5-haiku', name: 'Claude 4.5 Haiku', provider: 'anthropic', tier: 'fast', available: true },\n                { id: 'claude-4-5-sonnet', name: 'Claude 4.5 Sonnet', provider: 'anthropic', tier: 'balanced', available: true }\n            );\n            models.metadata.providers.push('anthropic');\n        }\n    }\n\n    // Check Ollama models\n    if (state.detectedEnv.hasServer) {\n        try {\n            const response = await fetch(`${PROXY_BASE_URL}/api/ollama/models`, {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n\n            if (response.ok) {\n                const data = await response.json();\n                models.ollama = (data.models || []).map(model => ({\n                    id: model.name,\n                    name: model.name,\n                    provider: 'ollama',\n                    tier: 'local',\n                    size: model.size,\n                    modified: model.modified,\n                    available: true\n                }));\n            }\n        } catch (error) {\n            logWarn('Ollama check failed:', error);\n        }\n    }\n\n    // Check WebLLM/WebGPU\n    if (navigator.gpu) {\n        models.webllm = [\n            { id: 'Qwen2.5-1.5B-Instruct', name: 'Qwen2.5-1.5B-Instruct', provider: 'webllm', tier: 'browser', size: '1.5GB', available: true },\n            { id: 'Phi-3.5-mini-instruct', name: 'Phi-3.5-mini-instruct', provider: 'webllm', tier: 'browser', size: '2.3GB', available: true },\n            { id: 'Llama-3.2-1B-Instruct', name: 'Llama-3.2-1B-Instruct', provider: 'webllm', tier: 'browser', size: '1.2GB', available: true }\n        ];\n    }\n\n    state.availableModels = models;\n    return models;\n}\n\nexport async function checkAPIStatus() {\n    logInfo('Checking server status...');\n\n    // Check if proxy server is available\n    try {\n        const response = await fetch(`${PROXY_BASE_URL}/api/health`, {\n            method: 'GET',\n            signal: AbortSignal.timeout(3000)\n        });\n\n        if (response.ok) {\n            const data = await response.json();\n            logInfo('Server online');\n\n            state.detectedEnv.hasServer = true;\n            state.detectedEnv.providers = data.providers || [];\n\n            // Update proxy chip - always show as online if we got here\n            if (elements.proxyChip) {\n                elements.proxyChip.className = 'status-chip status-chip--active';\n                elements.proxyChip.textContent = 'Proxy Online';\n            }\n\n            // Update provider chip based on what's available\n            if (elements.providerChip) {\n                const providers = data.providers || [];\n                if (providers.length > 0) {\n                    // Show the primary provider\n                    const primaryProvider = data.primaryProvider || providers[0];\n                    const providerName = primaryProvider.charAt(0).toUpperCase() + primaryProvider.slice(1);\n\n                    elements.providerChip.className = 'status-chip status-chip--active';\n\n                    if (providers.length === 1) {\n                        elements.providerChip.textContent = `${providerName} Ready`;\n                    } else {\n                        elements.providerChip.textContent = `${providerName} +${providers.length - 1}`;\n                    }\n                } else {\n                    elements.providerChip.className = 'status-chip status-chip--warning';\n                    elements.providerChip.textContent = 'No API Keys';\n                }\n            }\n\n            // Store Ollama status for mode selection\n            if (data.ollamaStatus === 'running') {\n                state.detectedEnv.hasOllama = true;\n            }\n\n            // Update provider status display\n            if (data.primaryProvider && elements.providerStatus) {\n                const savedModel = localStorage.getItem('SELECTED_MODEL');\n                if (!savedModel) {\n                    const providerName = data.primaryProvider.charAt(0).toUpperCase() + data.primaryProvider.slice(1);\n                    elements.providerStatus.textContent = `${providerName} via Proxy`;\n\n                    // Update features list\n                    const providerDetail = document.getElementById('provider-status-detail');\n                    if (providerDetail) {\n                        providerDetail.textContent = `Using ${providerName} API`;\n                    }\n\n                    const feature2 = document.getElementById('feature-2-text');\n                    if (feature2) {\n                        feature2.textContent = `${data.providers.length} provider${data.providers.length > 1 ? 's' : ''} available`;\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        logWarn('Server offline:', error.message);\n        state.detectedEnv.hasServer = false;\n\n        if (elements.proxyChip) {\n            elements.proxyChip.className = 'status-chip status-chip--inactive';\n            elements.proxyChip.textContent = 'Proxy Offline';\n        }\n\n        if (elements.providerChip) {\n            elements.providerChip.className = 'status-chip status-chip--inactive';\n            elements.providerChip.textContent = 'Web LLM Only';\n        }\n\n        if (elements.providerStatus) {\n            elements.providerStatus.textContent = 'Proxy Offline';\n            elements.providerStatusDetail.textContent = 'Run: npm start';\n        }\n    }\n\n    // Check WebGPU availability\n    if (navigator.gpu) {\n        state.detectedEnv.hasWebGPU = true;\n        logInfo('WebGPU available');\n}\n\n    // Update mode card availability\n    updateModeAvailability();\n}\n\nexport function updateModeAvailability() {\n    const env = state.detectedEnv;\n\n    // Disable modes based on availability\n    const modeCards = {\n        cloud: document.querySelector('.mode-card[data-mode=\"cloud\"]'),\n        local: document.querySelector('.mode-card[data-mode=\"local\"]'),\n        'web-llm': document.querySelector('.mode-card[data-mode=\"web-llm\"]'),\n        hybrid: document.querySelector('.mode-card[data-mode=\"hybrid\"]'),\n        multi: document.querySelector('.mode-card[data-mode=\"multi\"]'),\n        custom: document.querySelector('.mode-card[data-mode=\"custom\"]')\n    };\n\n    // Cloud mode - requires proxy server with at least one provider\n    if (modeCards.cloud) {\n        if (!env.hasServer || !env.providers || env.providers.length === 0) {\n            modeCards.cloud.classList.add('disabled');\n        } else {\n            modeCards.cloud.classList.remove('disabled');\n        }\n    }\n\n    // Local mode - requires proxy server and Ollama\n    if (modeCards.local) {\n        if (!env.hasServer || !env.hasOllama) {\n            modeCards.local.classList.add('disabled');\n        } else {\n            modeCards.local.classList.remove('disabled');\n        }\n    }\n\n    // Web LLM - requires WebGPU\n    if (modeCards['web-llm']) {\n        if (!env.hasWebGPU) {\n            modeCards['web-llm'].classList.add('disabled');\n        } else {\n            modeCards['web-llm'].classList.remove('disabled');\n        }\n    }\n\n    // Hybrid - requires proxy, Ollama, and at least one cloud provider\n    if (modeCards.hybrid) {\n        if (!env.hasServer || !env.hasOllama || !env.providers || env.providers.length === 0) {\n            modeCards.hybrid.classList.add('disabled');\n        } else {\n            modeCards.hybrid.classList.remove('disabled');\n        }\n    }\n\n    // Multi - requires proxy and multiple providers\n    if (modeCards.multi) {\n        if (!env.hasServer || !env.providers || env.providers.length < 2) {\n            modeCards.multi.classList.add('disabled');\n        } else {\n            modeCards.multi.classList.remove('disabled');\n        }\n    }\n\n    // Custom - always available (user provides endpoint)\n    if (modeCards.custom) {\n        modeCards.custom.classList.remove('disabled');\n    }\n}\n\nexport async function populateOllamaModels() {\n    if (!state.detectedEnv.hasServer || !state.detectedEnv.hasOllama) {\n        console.log('[API] Skipping Ollama model population (server or Ollama not available)');\n        return;\n    }\n\n    try {\n        const response = await fetch(`${PROXY_BASE_URL}/api/ollama/models`, {\n            method: 'GET',\n            signal: AbortSignal.timeout(5000)\n        });\n\n        if (response.ok) {\n            const data = await response.json();\n            console.log('[API] Ollama models:', data.models);\n\n            // Add Ollama models to the dropdown\n            const modelSelect = document.getElementById('model-select');\n            if (modelSelect && data.models && data.models.length > 0) {\n                const localOptgroup = modelSelect.querySelector('optgroup[label*=\"Local\"]');\n                if (localOptgroup) {\n                    // Clear existing Ollama options\n                    const existingOptions = Array.from(localOptgroup.querySelectorAll('option[data-provider=\"local\"]'));\n                    existingOptions.forEach(opt => opt.remove());\n\n                    // Add new Ollama models\n                    data.models.forEach(model => {\n                        const option = document.createElement('option');\n                        option.value = model.name;\n                        option.textContent = `${model.name} (Ollama)`;\n                        option.dataset.provider = 'local';\n                        localOptgroup.insertBefore(option, localOptgroup.firstChild);\n                    });\n                }\n            }\n        }\n    } catch (error) {\n        console.warn('[API] Failed to fetch Ollama models:', error.message);\n    }\n}\n",
      "hash": "27912817ee9d71492117242d53b3cd35224461b2dd37950b983b4054df141d5f"
    },
    "tools/python/python-tool.js": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 4297,
        "binary": false
      },
      "content": "/**\n * @fileoverview Python Tool for REPLOID Agent\n * Provides a tool interface for executing Python code via Pyodide.\n */\n\nconst PythonTool = {\n  metadata: {\n    id: 'PythonTool',\n    version: '1.0.1',\n    dependencies: ['Utils', 'PyodideRuntime?'],\n    async: true,\n    type: 'tool'\n  },\n\n  factory: (deps) => {\n    const { Utils, PyodideRuntime } = deps;\n    const { logger } = Utils;\n\n    const toolDeclaration = {\n      name: 'execute_python',\n      description: 'Execute Python code in a secure WebAssembly sandbox. Includes NumPy, Pandas.',\n      parameters: {\n        type: 'object',\n        properties: {\n          code: { type: 'string', description: 'The Python code to execute' },\n          install_packages: { type: 'array', items: { type: 'string' }, description: 'Packages to install' },\n          sync_workspace: { type: 'boolean', description: 'Sync VFS to Python env first' }\n        },\n        required: ['code']\n      }\n    };\n\n    const executePython = async (args) => {\n      if (!PyodideRuntime) return { success: false, error: 'Pyodide runtime not available' };\n\n      try {\n        const { code, install_packages = [], sync_workspace = false } = args;\n\n        logger.info('[PythonTool] Executing Python code');\n\n        if (!PyodideRuntime.isReady()) {\n          return { success: false, error: 'Python runtime not initialized.' };\n        }\n\n        for (const pkg of install_packages) {\n          await PyodideRuntime.installPackage(pkg);\n        }\n\n        if (sync_workspace) {\n          await PyodideRuntime.syncWorkspace();\n        }\n\n        const result = await PyodideRuntime.execute(code);\n\n        if (result.success) {\n          return {\n            success: true,\n            result: result.result,\n            stdout: result.stdout,\n            stderr: result.stderr\n          };\n        } else {\n          return {\n            success: false,\n            error: result.error,\n            traceback: result.traceback,\n            stderr: result.stderr\n          };\n        }\n\n      } catch (error) {\n        logger.error('[PythonTool] Execution failed:', error);\n        return { success: false, error: error.message };\n      }\n    };\n\n    const installPackageTool = async (args) => {\n      if (!PyodideRuntime) return { success: false, error: 'Pyodide runtime not available' };\n      try {\n        if (!PyodideRuntime.isReady()) return { success: false, error: 'Python runtime not initialized' };\n        return await PyodideRuntime.installPackage(args.package);\n      } catch (error) {\n        return { success: false, error: error.message };\n      }\n    };\n\n    const listPackagesTool = async () => {\n      if (!PyodideRuntime) return { success: false, error: 'Pyodide runtime not available' };\n      try {\n        if (!PyodideRuntime.isReady()) return { success: false, error: 'Python runtime not initialized' };\n        return await PyodideRuntime.getPackages();\n      } catch (error) {\n        return { success: false, error: error.message };\n      }\n    };\n\n    const getToolDeclarations = () => {\n      return [\n        toolDeclaration,\n        {\n          name: 'install_python_package',\n          description: 'Install a Python package using micropip.',\n          parameters: {\n            type: 'object',\n            properties: { package: { type: 'string' } },\n            required: ['package']\n          }\n        },\n        {\n          name: 'list_python_packages',\n          description: 'List installed Python packages',\n          parameters: { type: 'object', properties: {} }\n        }\n      ];\n    };\n\n    const executeTool = async (toolName, args) => {\n      switch (toolName) {\n        case 'execute_python': return await executePython(args);\n        case 'install_python_package': return await installPackageTool(args);\n        case 'list_python_packages': return await listPackagesTool();\n        default: return { success: false, error: `Unknown tool: ${toolName}` };\n      }\n    };\n\n    return {\n      init: async () => {\n        logger.info('[PythonTool] Python tool initialized');\n        return true;\n      },\n      api: {\n        getToolDeclarations,\n        executeTool,\n        executePython,\n        installPackage: installPackageTool,\n        listPackages: listPackagesTool\n      }\n    };\n  }\n};\n\nexport default PythonTool;\n",
      "hash": "a806d51b9210d798ed84a4a35d55b56a31eb924661d6b392597f33c0cb886e84"
    },
    "tools/python/pyodide-worker.js": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 4764,
        "binary": false
      },
      "content": "/**\n * @fileoverview Pyodide Web Worker\n */\n\nimportScripts('https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js');\n\nlet pyodide = null;\nlet isReady = false;\nlet initError = null;\n\nasync function initializePyodide() {\n  try {\n    pyodide = await loadPyodide({\n      indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.4/full/',\n      stdout: (msg) => self.postMessage({ type: 'stdout', data: msg }),\n      stderr: (msg) => self.postMessage({ type: 'stderr', data: msg })\n    });\n\n    await pyodide.loadPackage('micropip');\n\n    await pyodide.runPythonAsync(`\nimport sys\nimport io\nfrom js import Object\nsys.stdout = io.StringIO()\nsys.stderr = io.StringIO()\n    `);\n\n    isReady = true;\n    self.postMessage({ type: 'ready', data: { version: pyodide.version } });\n\n  } catch (error) {\n    initError = error;\n    self.postMessage({ type: 'error', data: { message: error.message } });\n  }\n}\n\nasync function executePython(code, options = {}) {\n  if (!isReady) throw new Error('Pyodide not initialized');\n\n  try {\n    const startTime = Date.now();\n    await pyodide.runPythonAsync(`sys.stdout = io.StringIO(); sys.stderr = io.StringIO()`);\n\n    let result;\n    if (options.async) {\n      result = await pyodide.runPythonAsync(code);\n    } else {\n      result = pyodide.runPython(code);\n    }\n\n    const stdout = await pyodide.runPythonAsync('sys.stdout.getvalue()');\n    const stderr = await pyodide.runPythonAsync('sys.stderr.getvalue()');\n    const executionTime = Date.now() - startTime;\n\n    let jsResult;\n    if (result && typeof result.toJs === 'function') {\n      jsResult = result.toJs({ dict_converter: Object.fromEntries });\n    } else {\n      jsResult = result;\n    }\n\n    return { success: true, result: jsResult, stdout: stdout || '', stderr: stderr || '', executionTime };\n\n  } catch (error) {\n    let stderr = '';\n    try { stderr = await pyodide.runPythonAsync('sys.stderr.getvalue()'); } catch (e) {}\n    return { success: false, error: error.message, traceback: error.stack, stderr };\n  }\n}\n\nasync function installPackage(packageName) {\n  if (!isReady) throw new Error('Pyodide not initialized');\n  try {\n    await pyodide.runPythonAsync(`import micropip; await micropip.install('${packageName}')`);\n    return { success: true, package: packageName };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n\nasync function writeFile(path, content) {\n  if (!isReady) throw new Error('Pyodide not initialized');\n  try {\n    const dirPath = path.substring(0, path.lastIndexOf('/'));\n    if (dirPath) {\n      await pyodide.runPythonAsync(`import os; os.makedirs('${dirPath}', exist_ok=True)`);\n    }\n    pyodide.FS.writeFile(path, content);\n    return { success: true, path };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n\nasync function readFile(path) {\n  if (!isReady) throw new Error('Pyodide not initialized');\n  try {\n    const content = pyodide.FS.readFile(path, { encoding: 'utf8' });\n    return { success: true, content, path };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n\nasync function listDir(path = '/') {\n  if (!isReady) throw new Error('Pyodide not initialized');\n  try {\n    const files = pyodide.FS.readdir(path);\n    return { success: true, files: files.filter(f => f !== '.' && f !== '..'), path };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n\nasync function getInstalledPackages() {\n  if (!isReady) throw new Error('Pyodide not initialized');\n  try {\n    const packages = await pyodide.runPythonAsync(`import micropip; list(micropip.list().keys())`);\n    return { success: true, packages: packages.toJs() };\n  } catch (error) {\n    return { success: false, error: error.message };\n  }\n}\n\nself.onmessage = async (event) => {\n  const { id, type, data } = event.data;\n  try {\n    let result;\n    switch (type) {\n      case 'init': await initializePyodide(); result = { initialized: true }; break;\n      case 'execute': result = await executePython(data.code, data.options || {}); break;\n      case 'install': result = await installPackage(data.package); break;\n      case 'writeFile': result = await writeFile(data.path, data.content); break;\n      case 'readFile': result = await readFile(data.path); break;\n      case 'listDir': result = await listDir(data.path); break;\n      case 'getPackages': result = await getInstalledPackages(); break;\n      case 'getStatus': result = { ready: isReady, error: initError ? initError.message : null }; break;\n      default: throw new Error(`Unknown message type: ${type}`);\n    }\n    self.postMessage({ id, type: 'response', data: result });\n  } catch (error) {\n    self.postMessage({ id, type: 'error', data: { message: error.message, stack: error.stack } });\n  }\n};\n",
      "hash": "5ccc31f981dc31d368151136c1d45e7d3661f14f96723799b42a23cf720b9f68"
    },
    "tools/python/pyodide-runtime.js": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 4463,
        "binary": false
      },
      "content": "/**\n * @fileoverview Pyodide Runtime Module for REPLOID\n */\n\nconst PyodideRuntime = {\n  metadata: {\n    id: 'PyodideRuntime',\n    version: '1.0.2',\n    dependencies: ['Utils', 'EventBus', 'StateManager'],\n    async: true,\n    type: 'runtime'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus, StateManager } = deps;\n    const { logger } = Utils;\n\n    let worker = null;\n    let isReady = false;\n    let initError = null;\n    let messageId = 0;\n    let pendingMessages = new Map();\n\n    const createWorker = () => {\n      try {\n        worker = new Worker('/tools/python/pyodide-worker.js');\n        worker.onmessage = handleWorkerMessage;\n        worker.onerror = (error) => {\n          logger.error('[PyodideRuntime] Worker error:', error);\n          initError = error;\n          EventBus.emit('pyodide:error', { error });\n        };\n        logger.info('[PyodideRuntime] Worker created');\n        return worker;\n      } catch (error) {\n        logger.error('[PyodideRuntime] Failed to create worker:', error);\n        throw error;\n      }\n    };\n\n    const handleWorkerMessage = (event) => {\n      const { id, type, data } = event.data;\n\n      if (type === 'ready') {\n        isReady = true;\n        logger.info('[PyodideRuntime] Pyodide initialized', data);\n        EventBus.emit('pyodide:ready', data);\n        return;\n      }\n      if (type === 'stdout') return EventBus.emit('pyodide:stdout', { output: data });\n      if (type === 'stderr') return EventBus.emit('pyodide:stderr', { output: data });\n\n      if (id && pendingMessages.has(id)) {\n        const { resolve, reject } = pendingMessages.get(id);\n        pendingMessages.delete(id);\n        if (type === 'error') reject(new Error(data.message || 'Worker error'));\n        else resolve(data);\n      }\n    };\n\n    const sendMessage = (type, data = {}) => {\n      return new Promise((resolve, reject) => {\n        if (!worker) return reject(new Error('Worker not initialized'));\n        const id = ++messageId;\n        pendingMessages.set(id, { resolve, reject });\n        setTimeout(() => {\n          if (pendingMessages.has(id)) {\n            pendingMessages.delete(id);\n            reject(new Error(`Message timeout: ${type}`));\n          }\n        }, 30000);\n        worker.postMessage({ id, type, data });\n      });\n    };\n\n    const init = async () => {\n      try {\n        logger.info('[PyodideRuntime] Initializing...');\n        createWorker();\n        await sendMessage('init');\n        logger.info('[PyodideRuntime] Ready');\n        EventBus.emit('pyodide:initialized', { ready: true });\n        return true;\n      } catch (error) {\n        logger.error('[PyodideRuntime] Initialization failed:', error);\n        initError = error;\n        throw error;\n      }\n    };\n\n    const execute = async (code, options = {}) => {\n      if (!isReady) throw new Error('Pyodide not ready');\n      const result = await sendMessage('execute', { code, options: { async: options.async !== false, ...options } });\n      EventBus.emit('pyodide:executed', { success: result.success, executionTime: result.executionTime });\n      return result;\n    };\n\n    const installPackage = async (pkg) => {\n      if (!isReady) throw new Error('Pyodide not ready');\n      const result = await sendMessage('install', { package: pkg });\n      if (result.success) EventBus.emit('pyodide:package-installed', { package: pkg });\n      return result;\n    };\n\n    const syncWorkspace = async () => {\n      if (!isReady) throw new Error('Pyodide not ready');\n      const state = StateManager.getState();\n      const artifacts = state.artifactMetadata || {};\n      let synced = 0;\n\n      for (const [path, metadata] of Object.entries(artifacts)) {\n          // This is tricky because we need content, but metadata only has... metadata.\n          // We need a way to get content. StateManager.getArtifactContent would be better here.\n          // For now, we skip implementation detail to avoid bloating this file, assuming calling\n          // code handles specific file syncs if needed, or we rely on future StateManager methods.\n      }\n      return { success: true, synced };\n    };\n\n    return {\n      init,\n      api: {\n        execute,\n        installPackage,\n        syncWorkspace,\n        isReady: () => isReady,\n        getError: () => initError,\n        getPackages: () => sendMessage('getPackages'),\n        listFiles: (path) => sendMessage('listDir', { path })\n      }\n    };\n  }\n};\n\nexport default PyodideRuntime;\n",
      "hash": "9b16c2a9204f34588fd96e9fff8da24a58de75a53c412b9eac3360f77ef585ba"
    },
    "capabilities/testing/self-tester.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 1540,
        "binary": false
      },
      "content": "/**\n * @fileoverview Self Tester\n * Diagnostics for system health.\n */\n\nconst SelfTester = {\n  metadata: {\n    id: 'SelfTester',\n    version: '2.0.0',\n    dependencies: ['Utils', 'VFS', 'LLMClient'],\n    async: true,\n    type: 'capability'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS, LLMClient } = deps;\n    const { logger } = Utils;\n\n    const runDiagnostics = async () => {\n      const report = {\n        timestamp: new Date().toISOString(),\n        checks: []\n      };\n\n      // 1. Check VFS\n      try {\n        await VFS.list('/');\n        report.checks.push({ name: 'VFS', status: 'OK' });\n      } catch (e) {\n        report.checks.push({ name: 'VFS', status: 'FAIL', error: e.message });\n      }\n\n      // 2. Check LLM Configuration\n      if (LLMClient) {\n        report.checks.push({ name: 'LLMClient', status: 'OK' });\n      } else {\n        report.checks.push({ name: 'LLMClient', status: 'FAIL' });\n      }\n\n      // 3. Storage Quota\n      if (navigator.storage && navigator.storage.estimate) {\n        try {\n            const quota = await navigator.storage.estimate();\n            const usedMB = (quota.usage / 1024 / 1024).toFixed(2);\n            report.checks.push({ name: 'Storage', status: 'OK', details: `${usedMB}MB used` });\n        } catch (e) {\n            report.checks.push({ name: 'Storage', status: 'WARN', error: e.message });\n        }\n      }\n\n      logger.info('[SelfTester] Diagnostics complete', report);\n      return report;\n    };\n\n    return { runDiagnostics };\n  }\n};\n\nexport default SelfTester;\n",
      "hash": "8f3a5548ca48b36e922ac79107e65c613f782d23d0e0c0a257a398967ee27780"
    },
    "capabilities/performance/performance-monitor.js": {
      "meta": {
        "mtimeMs": 1763657157805.5825,
        "size": 1483,
        "binary": false
      },
      "content": "/**\n * @fileoverview Performance Monitor\n * Tracks system metrics and tool execution stats.\n */\n\nconst PerformanceMonitor = {\n  metadata: {\n    id: 'PerformanceMonitor',\n    version: '2.0.0',\n    dependencies: ['Utils', 'EventBus'],\n    type: 'capability'\n  },\n\n  factory: (deps) => {\n    const { Utils, EventBus } = deps;\n    const { logger } = Utils;\n\n    const metrics = {\n      toolCalls: 0,\n      apiTokens: 0,\n      apiLatency: [],\n      errors: 0,\n      startTime: Date.now()\n    };\n\n    const init = () => {\n      // Listen to system events\n      EventBus.on('agent:tool:start', () => metrics.toolCalls++);\n      EventBus.on('agent:error', () => metrics.errors++);\n\n      // Listen for LLM stats (emitted by LLMClient if configured)\n      EventBus.on('llm:complete', (data) => {\n        if (data.tokens) metrics.apiTokens += data.tokens;\n        if (data.latency) metrics.apiLatency.push(data.latency);\n      });\n\n      logger.info('[PerfMon] Monitoring started');\n    };\n\n    const getReport = () => {\n      const uptime = (Date.now() - metrics.startTime) / 1000;\n      const avgLatency = metrics.apiLatency.reduce((a, b) => a + b, 0) / (metrics.apiLatency.length || 1);\n\n      return {\n        uptime: `${uptime.toFixed(0)}s`,\n        toolsUsed: metrics.toolCalls,\n        tokens: metrics.apiTokens,\n        errors: metrics.errors,\n        avgLatency: `${avgLatency.toFixed(0)}ms`\n      };\n    };\n\n    return { init, getReport };\n  }\n};\n\nexport default PerformanceMonitor;\n",
      "hash": "0b9b552e067dab30feb2c9316540384d684d15ca5fc73ee9555b5af239703089"
    },
    "capabilities/reflection/reflection-store.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 2247,
        "binary": false
      },
      "content": "/**\n * @fileoverview Reflection Store\n * Persists insights, errors, and success patterns to VFS.\n */\n\nconst ReflectionStore = {\n  metadata: {\n    id: 'ReflectionStore',\n    version: '2.1.1',\n    dependencies: ['Utils', 'VFS', 'EventBus'],\n    async: true,\n    type: 'capability'\n  },\n\n  factory: (deps) => {\n    const { Utils, VFS, EventBus } = deps;\n    const { logger, generateId } = Utils;\n\n    const STORE_PATH = '/.memory/reflections.json';\n    let _cache = [];\n\n    const init = async () => {\n      if (await VFS.exists(STORE_PATH)) {\n        try {\n          const content = await VFS.read(STORE_PATH);\n          _cache = JSON.parse(content);\n        } catch (e) {\n          logger.error('[Reflection] Corrupt store, resetting.', e);\n          _cache = [];\n        }\n      }\n      return true;\n    };\n\n    const add = async (entry) => {\n      const reflection = {\n        id: generateId('ref'),\n        ts: Date.now(),\n        type: entry.type || 'insight', // 'insight', 'error', 'success'\n        content: entry.content,\n        context: entry.context || {},\n        // Enriched fields for Analyzer\n        tags: entry.tags || [],\n        description: entry.description || entry.content\n      };\n\n      _cache.push(reflection);\n\n      // Simple persistence (no debouncing in core to avoid async complexity)\n      await _save();\n\n      EventBus.emit('reflection:added', reflection);\n      logger.info(`[Reflection] Added: ${entry.type}`);\n      return reflection.id;\n    };\n\n    const query = (filterFn) => {\n      return _cache.filter(filterFn);\n    };\n\n    const getReflections = async (options = {}) => {\n      let results = [..._cache];\n\n      if (options.outcome) {\n        results = results.filter(r => r.context?.outcome === options.outcome);\n      }\n\n      results.sort((a, b) => b.ts - a.ts);\n\n      if (options.limit) {\n        results = results.slice(0, options.limit);\n      }\n\n      return results;\n    };\n\n    const _save = async () => {\n      // Ensure directory exists\n      if (!await VFS.exists('/.memory')) {\n          await VFS.mkdir('/.memory');\n      }\n      await VFS.write(STORE_PATH, JSON.stringify(_cache, null, 2));\n    };\n\n    return { init, add, query, getReflections };\n  }\n};\n\nexport default ReflectionStore;\n",
      "hash": "f64e7ca48bc1aab93716c48bcc25103dd25af4551afea9ad57e548e9089ac6e5"
    },
    "capabilities/reflection/reflection-analyzer.js": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 1773,
        "binary": false
      },
      "content": "/**\n * @fileoverview Reflection Analyzer\n * Analyzes patterns in reflections to enable learning from past experiences.\n */\n\nconst ReflectionAnalyzer = {\n  metadata: {\n    id: 'ReflectionAnalyzer',\n    version: '1.0.1',\n    dependencies: ['ReflectionStore', 'Utils'],\n    async: true,\n    type: 'intelligence'\n  },\n\n  factory: (deps) => {\n    const { ReflectionStore, Utils } = deps;\n    const { logger } = Utils;\n\n    const getKeywords = (text) => {\n      if (!text) return [];\n      return text.toLowerCase()\n        .split(/\\W+/)\n        .filter(w => w.length > 3)\n        .slice(0, 10);\n    };\n\n    // Simple failure pattern detection\n    const detectFailurePatterns = async () => {\n      const failed = await ReflectionStore.getReflections({\n        outcome: 'failed',\n        limit: 50\n      });\n\n      const counts = {};\n      const examples = {};\n\n      for (const r of failed) {\n          // Heuristic: Error message is usually in content or context\n          const msg = r.content || \"Unknown error\";\n          const errorType = msg.split(':')[0] || \"GenericError\";\n\n          counts[errorType] = (counts[errorType] || 0) + 1;\n          if (!examples[errorType]) examples[errorType] = msg;\n      }\n\n      // Convert to array\n      return Object.entries(counts)\n          .filter(([_, count]) => count >= 2) // Threshold\n          .map(([indicator, count]) => ({\n              indicator: indicator,\n              count: count,\n              example: examples[indicator]\n          }))\n          .sort((a, b) => b.count - a.count);\n    };\n\n    return {\n      init: async () => {\n        logger.info('[ReflectionAnalyzer] Initialized');\n        return true;\n      },\n      api: {\n        detectFailurePatterns\n      }\n    };\n  }\n};\n\nexport default ReflectionAnalyzer;\n",
      "hash": "829a5b394f20d77ebef67258a65bc7be428b8a2e19bed55975556854d76684cc"
    },
    "ui/boot/model-config/state.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 3509,
        "binary": false
      },
      "content": "// Model Configuration State Management\n// Handles selected models, storage, and constants\n\nexport const MAX_MODELS = 4;\n\nexport const CONNECTION_TYPE_LABELS = {\n    'proxy-local': 'Proxy â†’ Local (Ollama)',\n    'browser-local': 'Browser (WebLLM)',\n    'proxy-cloud': 'Proxy â†’ Cloud',\n    'browser-cloud': 'Browser â†’ Cloud'\n};\n\nexport const HOST_TYPE_LABELS = {\n    'browser-cloud': 'Browser â†’ Cloud',\n    'proxy-cloud': 'Proxy â†’ Cloud',\n    'browser-local': 'Browser â†’ Local',\n    'proxy-local': 'Proxy â†’ Local',\n    // Legacy mappings\n    'cloud-browser': 'Browser â†’ Cloud',\n    'ollama-proxy': 'Proxy â†’ Local',\n    'webgpu-browser': 'Browser â†’ Local',\n    'proxy': 'Proxy â†’ Cloud'\n};\n\n// State\nlet selectedModels = [];\nlet availableProviders = {\n    ollama: { online: false, models: [] },\n    webgpu: { online: false, models: [] },\n    transformers: { online: false, models: [] },\n    proxy: { online: false }\n};\n\n// Getters\nexport function getSelectedModels() {\n    return selectedModels;\n}\n\nexport function setSelectedModels(models) {\n    selectedModels = models;\n}\n\nexport function getAvailableProviders() {\n    return availableProviders;\n}\n\nexport function setAvailableProviders(providers) {\n    availableProviders = providers;\n}\n\nexport function hasModelsConfigured() {\n    return selectedModels.length > 0;\n}\n\n// Storage operations\nexport function saveToStorage() {\n    try {\n        localStorage.setItem('SELECTED_MODELS', JSON.stringify(selectedModels));\n\n        const consensus = document.getElementById('consensus-strategy')?.value || 'arena';\n        localStorage.setItem('CONSENSUS_TYPE', consensus);\n\n        // Legacy compatibility\n        if (selectedModels.length > 0) {\n            const primaryModel = selectedModels[0];\n            localStorage.setItem('SELECTED_MODEL', primaryModel.id);\n            localStorage.setItem('AI_PROVIDER', primaryModel.provider);\n        }\n\n        console.log('[ModelConfig] Configuration saved');\n    } catch (error) {\n        console.error('[ModelConfig] Failed to save:', error);\n    }\n}\n\nexport function loadSavedModels() {\n    try {\n        const saved = localStorage.getItem('SELECTED_MODELS');\n        if (saved) {\n            selectedModels = JSON.parse(saved);\n            console.log('[ModelConfig] Loaded saved models:', selectedModels);\n\n            // Warn about potentially invalid models\n            const invalidModels = selectedModels.filter(model =>\n                model.provider === 'webllm' &&\n                model.id &&\n                model.id.includes('Qwen2.5-Coder-7B')\n            );\n\n            if (invalidModels.length > 0) {\n                console.warn('[ModelConfig] Found potentially invalid WebLLM models:',\n                    invalidModels.map(m => m.id));\n            }\n        }\n    } catch (error) {\n        console.error('[ModelConfig] Failed to load saved models:', error);\n    }\n}\n\n// Model operations\nexport function addModel(model) {\n    if (selectedModels.length >= MAX_MODELS) {\n        return false;\n    }\n    selectedModels.push(model);\n    return true;\n}\n\nexport function updateModel(index, model) {\n    if (index >= 0 && index < selectedModels.length) {\n        selectedModels[index] = model;\n        return true;\n    }\n    return false;\n}\n\nexport function removeModel(index) {\n    if (index >= 0 && index < selectedModels.length) {\n        selectedModels.splice(index, 1);\n        return true;\n    }\n    return false;\n}\n\nexport function clearModels() {\n    selectedModels = [];\n}\n",
      "hash": "e2bfb53f700afedbc13c10f3537b44c6176d98de50b3b273e8e52d4ea4d6be63"
    },
    "ui/boot/model-config/providers.js": {
      "meta": {
        "mtimeMs": 1763734913896.677,
        "size": 9003,
        "binary": false
      },
      "content": "// Provider Detection and Model Catalogs\nimport { getAvailableProviders, setAvailableProviders } from './state.js';\n\n// Transformers.js models (browser-native with WebGPU)\nexport const transformersModels = [\n    { id: 'qwen3-0.6b', name: 'Qwen3 0.6B', vram: 800, context: 32768 },\n    { id: 'qwen3-1.7b', name: 'Qwen3 1.7B', vram: 2000, context: 32768 },\n    { id: 'gemma3-1b', name: 'Gemma3 1B', vram: 1500, context: 8192 },\n    { id: 'smollm2-360m', name: 'SmolLM2 360M', vram: 400, context: 8192 },\n    { id: 'smollm2-1.7b', name: 'SmolLM2 1.7B', vram: 2000, context: 8192 },\n    { id: 'deepseek-r1-1.5b', name: 'DeepSeek-R1 1.5B', vram: 2000, context: 32768 },\n    { id: 'phi4-mini', name: 'Phi-4 Mini', vram: 4000, context: 16384 }\n];\n\n// Cloud provider model catalogs\nexport const cloudProviders = {\n    gemini: {\n        name: 'Gemini',\n        models: [\n            { id: 'gemini-2.5-flash-lite', name: 'Flash Lite' },\n            { id: 'gemini-2.5-flash', name: 'Flash' },\n            { id: 'gemini-2.5-pro', name: 'Pro' }\n        ],\n        requiresKey: true,\n        hostType: 'browser-cloud'\n    },\n    openai: {\n        name: 'OpenAI',\n        models: [\n            { id: 'gpt-5-2025-08-07-mini', name: 'GPT-5 Mini' },\n            { id: 'gpt-5-2025-08-07', name: 'GPT-5' },\n            { id: 'o1-2025-12-17', name: 'O1' }\n        ],\n        requiresKey: true,\n        hostType: 'browser-cloud'\n    },\n    anthropic: {\n        name: 'Anthropic',\n        models: [\n            { id: 'claude-4-5-haiku', name: 'Haiku 4.5' },\n            { id: 'claude-4-5-sonnet', name: 'Sonnet 4.5' },\n            { id: 'claude-opus-4-5-20250514', name: 'Opus 4.5' }\n        ],\n        requiresKey: true,\n        hostType: 'browser-cloud'\n    }\n};\n\n// Fallback WebLLM models (f32 for broader compatibility)\nconst fallbackWebLLMModels = [\n    { id: 'Llama-3.2-1B-Instruct-q4f32_1-MLC', name: 'Llama 3.2 1B', vram: 1500, context: 131072 },\n    { id: 'Llama-3.2-3B-Instruct-q4f32_1-MLC', name: 'Llama 3.2 3B', vram: 3000, context: 131072 },\n    { id: 'Qwen2.5-0.5B-Instruct-q4f32_1-MLC', name: 'Qwen 0.5B', vram: 600, context: 32768 },\n    { id: 'SmolLM2-360M-Instruct-q4f32_1-MLC', name: 'SmolLM2 360M', vram: 400, context: 8192 },\n    { id: 'TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC', name: 'TinyLlama 1.1B', vram: 1100, context: 2048 }\n].sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));\n\n// Additional models not in WebLLM 0.2.79 prebuilt config\nconst additionalWebLLMModels = [\n    // Qwen3 models (May 2025)\n    { model_id: 'Qwen3-0.6B-q4f32_1-MLC', vram_required_MB: 800, context_window_size: 32768 },\n    { model_id: 'Qwen3-1.7B-q4f32_1-MLC', vram_required_MB: 2000, context_window_size: 32768 },\n    { model_id: 'Qwen3-4B-q4f32_1-MLC', vram_required_MB: 4000, context_window_size: 32768 },\n    { model_id: 'Qwen3-8B-q4f32_1-MLC', vram_required_MB: 6000, context_window_size: 32768 },\n    { model_id: 'Qwen3-0.6B-q4f16_1-MLC', vram_required_MB: 600, context_window_size: 32768 },\n    { model_id: 'Qwen3-1.7B-q4f16_1-MLC', vram_required_MB: 1500, context_window_size: 32768 },\n    { model_id: 'Qwen3-4B-q4f16_1-MLC', vram_required_MB: 3000, context_window_size: 32768 },\n    { model_id: 'Qwen3-8B-q4f16_1-MLC', vram_required_MB: 5000, context_window_size: 32768 },\n];\n\n// Get WebLLM models from runtime config\nasync function getWebLLMModels() {\n    // Wait for WebLLM to load with timeout\n    const maxWaitMs = 5000;\n    const startTime = Date.now();\n    let retries = 0;\n\n    while (!window.webllm && (Date.now() - startTime) < maxWaitMs) {\n        await new Promise(r => setTimeout(r, 100));\n        retries++;\n    }\n\n    if (!window.webllm?.prebuiltAppConfig?.model_list) {\n        const elapsed = Date.now() - startTime;\n        console.warn(`[ModelConfig] WebLLM prebuiltAppConfig not available after ${retries} retries (${elapsed}ms)`);\n        return [];\n    }\n\n    // Merge prebuilt models with additional newer models\n    const prebuiltList = window.webllm.prebuiltAppConfig.model_list;\n    const existingIds = new Set(prebuiltList.map(m => m.model_id));\n    const newModels = additionalWebLLMModels.filter(m => !existingIds.has(m.model_id));\n    const modelList = [...prebuiltList, ...newModels];\n\n    console.log(`[ModelConfig] Found ${prebuiltList.length} prebuilt + ${newModels.length} additional models`);\n\n    return modelList\n        .filter(m => {\n            const hasValidId = m.model_id && typeof m.model_id === 'string';\n            const vramMB = m.vram_required_MB || 0;\n            const isTooLarge = vramMB > 10000;\n            return hasValidId && !isTooLarge;\n        })\n        .map(m => {\n            let displayName = m.model_id;\n            const quantMatch = m.model_id.match(/q\\d+f\\d+/i);\n            const quant = quantMatch ? quantMatch[0] : '';\n\n            displayName = displayName.replace(/-q\\w+[-_]\\d+-MLC$/i, '');\n            displayName = displayName.replace(/-MLC$/i, '');\n            displayName = displayName.replace(/[-_]/g, ' ');\n\n            if (quant) {\n                displayName = `${displayName} [${quant}]`;\n            }\n\n            return {\n                id: m.model_id,\n                name: displayName,\n                vram: m.vram_required_MB || 0,\n                context: m.context_window_size || 4096\n            };\n        })\n        .sort((a, b) => a.vram - b.vram);\n}\n\n// Check availability of all providers\nexport async function checkAvailability() {\n    const providers = getAvailableProviders();\n    const proxyUrl = window.location.origin.includes('file://')\n        ? 'http://localhost:8000'\n        : window.location.origin;\n\n    // Check Ollama\n    try {\n        const response = await fetch(`${proxyUrl}/api/ollama/models`, {\n            signal: AbortSignal.timeout(3000)\n        });\n        if (response.ok) {\n            const data = await response.json();\n            providers.ollama.online = true;\n            providers.ollama.models = (data.models || []).map(m => ({\n                id: m.name || m.model,\n                name: m.name || m.model\n            }));\n        } else {\n            console.log(`[ModelConfig] Ollama API returned ${response.status} - this is normal if running without local proxy`);\n        }\n    } catch (error) {\n        console.log('[ModelConfig] Ollama not available (expected when hosted):', error.message);\n    }\n\n    // Check WebGPU\n    providers.webgpu.online = !!navigator.gpu;\n    if (providers.webgpu.online) {\n        try {\n            const webllmModels = await getWebLLMModels();\n            if (webllmModels.length > 0) {\n                providers.webgpu.models = webllmModels;\n                console.log(`[ModelConfig] Loaded ${webllmModels.length} models from WebLLM catalog`);\n            } else {\n                throw new Error('No models in WebLLM catalog');\n            }\n        } catch (error) {\n            console.warn('[ModelConfig] Could not load WebLLM catalog, using fallback list:', error.message);\n            providers.webgpu.models = fallbackWebLLMModels;\n        }\n\n        // Also enable Transformers.js since it uses WebGPU\n        providers.transformers.online = true;\n        providers.transformers.models = transformersModels;\n        console.log(`[ModelConfig] Transformers.js available with ${transformersModels.length} models`);\n    }\n\n    // Check Proxy\n    try {\n        const response = await fetch(`${proxyUrl}/api/health`, {\n            signal: AbortSignal.timeout(3000)\n        });\n        if (response.ok) {\n            providers.proxy.online = true;\n        } else {\n            console.log(`[ModelConfig] Proxy health check returned ${response.status} - this is normal if running without local proxy`);\n            providers.proxy.online = false;\n        }\n    } catch (error) {\n        console.log('[ModelConfig] Proxy not available (expected when hosted):', error.message);\n    }\n\n    setAvailableProviders(providers);\n}\n\n// Get models for a specific provider\nexport function getModelsForProvider(provider) {\n    const providers = getAvailableProviders();\n\n    if (provider === 'ollama') {\n        return providers.ollama.models;\n    } else if (provider === 'webllm') {\n        return providers.webgpu.models;\n    } else if (provider === 'transformers') {\n        return providers.transformers.models;\n    } else if (cloudProviders[provider]) {\n        return cloudProviders[provider].models;\n    }\n    return [];\n}\n\n// Get connection options for a provider\nexport function getConnectionOptions(provider) {\n    const providers = getAvailableProviders();\n    const options = [];\n\n    if (provider === 'ollama') {\n        options.push('proxy-local');\n    } else if (provider === 'webllm') {\n        options.push('browser-local');\n    } else if (provider === 'transformers') {\n        options.push('browser-local');\n    } else if (cloudProviders[provider]) {\n        if (providers.proxy.online) {\n            options.push('proxy-cloud');\n        }\n        options.push('browser-cloud');\n    }\n\n    return options;\n}\n",
      "hash": "a1d2ef8ec209bdb48ede41a411c0ab5e445403521fd2f6e394696d66227a1603"
    },
    "ui/boot/model-config/index.js": {
      "meta": {
        "mtimeMs": 1763734822440.3513,
        "size": 1225,
        "binary": false
      },
      "content": "// Model Configuration - Public API\n// Main entry point for the model configuration module\n\nimport { getSelectedModels, hasModelsConfigured, loadSavedModels } from './state.js';\nimport { checkAvailability } from './providers.js';\nimport { setupFormListeners } from './form.js';\nimport { renderModelCards, updateStatusDots, updateGoalInputState, autoPopulateDefaultModels, setupCardListeners } from './cards.js';\n\n// Initialize model configuration\nexport async function initModelConfig() {\n    console.log('[ModelConfig] Initializing card-based model selector...');\n\n    // Check what's available\n    try {\n        await checkAvailability();\n    } catch (error) {\n        console.error('[ModelConfig] Failed to check provider availability:', error.message);\n        // Continue with defaults - don't block boot\n    }\n\n    // Load saved models\n    loadSavedModels();\n\n    // Auto-populate default models if none configured\n    autoPopulateDefaultModels();\n\n    // Setup event listeners\n    setupFormListeners();\n    setupCardListeners();\n\n    // Render initial state\n    renderModelCards();\n    updateStatusDots();\n    updateGoalInputState();\n}\n\n// Re-export public functions\nexport { getSelectedModels, hasModelsConfigured };\n",
      "hash": "0b41f15f1e6021c304f83fd3ec05aab41cb14142c45187aa404464a3430eacf3"
    },
    "ui/boot/model-config/form.js": {
      "meta": {
        "mtimeMs": 1763677825555.9446,
        "size": 10532,
        "binary": false
      },
      "content": "// Add/edit Model Form Logic\nimport {\n    MAX_MODELS,\n    CONNECTION_TYPE_LABELS,\n    getSelectedModels,\n    getAvailableProviders,\n    saveToStorage,\n    addModel,\n    updateModel\n} from './state.js';\nimport { cloudProviders, getModelsForProvider, getConnectionOptions } from './providers.js';\nimport { renderModelCards, updateGoalInputState } from './cards.js';\n\n// Open inline form for adding/editing\nexport function openInlineForm(editingIndex = null) {\n    const form = document.getElementById('model-form-inline');\n    const formTitle = document.getElementById('model-form-title');\n    const saveBtn = document.getElementById('save-model-btn');\n\n    form.classList.remove('hidden');\n    formTitle.textContent = editingIndex !== null ? 'edit Model' : 'Add Model';\n    saveBtn.textContent = editingIndex !== null ? 'Save Changes' : 'Add Model';\n    saveBtn.dataset.editingIndex = editingIndex !== null ? editingIndex : '';\n\n    populateProviderSelect();\n    resetInlineForm();\n\n    if (editingIndex !== null) {\n        const model = getSelectedModels()[editingIndex];\n        populateeditForm(model);\n    }\n}\n\n// Close inline form\nexport function closeInlineForm() {\n    const form = document.getElementById('model-form-inline');\n    form.classList.add('hidden');\n    resetInlineForm();\n}\n\n// Populate provider select dropdown\nfunction populateProviderSelect() {\n    const providerSelect = document.getElementById('provider-select');\n    const providers = getAvailableProviders();\n    const options = ['<option value=\"\">Select provider...</option>'];\n\n    if (providers.ollama.online && providers.ollama.models.length > 0) {\n        options.push('<option value=\"ollama\">Ollama (Local)</option>');\n    }\n\n    if (providers.webgpu.online) {\n        options.push('<option value=\"webllm\">WebLLM (Browser)</option>');\n    }\n\n    if (providers.transformers?.online) {\n        options.push('<option value=\"transformers\">Transformers.js (Browser)</option>');\n    }\n\n    if (providers.proxy.online) {\n        options.push('<option value=\"gemini\">Gemini (Proxy/Cloud)</option>');\n        options.push('<option value=\"openai\">OpenAI (Proxy/Cloud)</option>');\n        options.push('<option value=\"anthropic\">Anthropic (Proxy/Cloud)</option>');\n    }\n\n    providerSelect.innerHTML = options.join('');\n}\n\n// Handle provider selection change\nexport function onProviderChange(e) {\n    const provider = e.target.value;\n    const modelSelectGroup = document.getElementById('model-select-group');\n    const modelSelect = document.getElementById('model-select-dropdown');\n    const apiKeyGroup = document.getElementById('api-key-group');\n    const connectionTypeGroup = document.getElementById('connection-type-group');\n    const saveBtn = document.getElementById('save-model-btn');\n\n    modelSelectGroup.classList.add('hidden');\n    apiKeyGroup.classList.add('hidden');\n    connectionTypeGroup.classList.add('hidden');\n    saveBtn.disabled = true;\n\n    if (!provider) return;\n\n    const models = getModelsForProvider(provider);\n    const connectionOptions = getConnectionOptions(provider);\n    const autoConnectionType = connectionOptions[0] || '';\n\n    // Show model select\n    modelSelectGroup.classList.remove('hidden');\n    modelSelect.innerHTML = '<option value=\"\">Select model...</option>' +\n        models.map(m => {\n            const vramInfo = m.vram ? ` (${(m.vram / 1024).toFixed(1)}GB)` : '';\n            return `<option value=\"${m.id}\">${m.name}${vramInfo}</option>`;\n        }).join('');\n\n    // Connection type dropdown\n    applyConnectionTypeOptions(connectionOptions, autoConnectionType);\n    if (connectionOptions.length > 1) {\n        connectionTypeGroup.classList.remove('hidden');\n    }\n    onConnectionTypeChange({ target: { value: autoConnectionType } });\n}\n\nfunction applyConnectionTypeOptions(connectionOptions, selectedType) {\n    const connectionTypeSelect = document.getElementById('connection-type-select');\n    const options = ['<option value=\"\">Select connection type...</option>'];\n\n    connectionOptions.forEach(type => {\n        const label = CONNECTION_TYPE_LABELS[type] || type;\n        options.push(`<option value=\"${type}\">${label}</option>`);\n    });\n\n    connectionTypeSelect.innerHTML = options.join('');\n    connectionTypeSelect.value = selectedType || '';\n}\n\n// Handle connection type change\nexport function onConnectionTypeChange(e) {\n    const connectionType = e.target.value;\n    const provider = document.getElementById('provider-select').value;\n    const apiKeyGroup = document.getElementById('api-key-group');\n\n    if (connectionType === 'browser-cloud') {\n        apiKeyGroup.classList.remove('hidden');\n        const savedKey = localStorage.getItem(`${provider.toUpperCase()}_API_KEY`);\n        if (savedKey) {\n            document.getElementById('model-api-key').value = savedKey;\n        }\n    } else {\n        apiKeyGroup.classList.add('hidden');\n        document.getElementById('model-api-key').value = '';\n    }\n\n    validateForm();\n}\n\n// Handle model selection change\nexport function onModelChange() {\n    validateForm();\n}\n\n// Validate form and enable/disable save button\nfunction validateForm() {\n    const saveBtn = document.getElementById('save-model-btn');\n    const provider = document.getElementById('provider-select').value;\n    const modelId = document.getElementById('model-select-dropdown').value;\n    const connectionType = document.getElementById('connection-type-select').value;\n\n    if (!provider || !modelId || !connectionType) {\n        saveBtn.disabled = true;\n        return;\n    }\n\n    if (connectionType === 'browser-cloud') {\n        const apiKey = document.getElementById('model-api-key').value.trim();\n        saveBtn.disabled = !apiKey;\n    } else {\n        saveBtn.disabled = false;\n    }\n}\n\n// Save model (add or edit)\nexport function saveModel() {\n    const provider = document.getElementById('provider-select').value;\n    const modelId = document.getElementById('model-select-dropdown').value;\n    const modelName = document.getElementById('model-select-dropdown').selectedOptions[0]?.text;\n    const connectionType = document.getElementById('connection-type-select').value;\n    const apiKey = document.getElementById('model-api-key').value.trim();\n    const editingIndex = document.getElementById('save-model-btn').dataset.editingIndex;\n\n    if (!provider || !modelId || !connectionType) {\n        alert('Please select a provider, model, and connection type');\n        return;\n    }\n\n    const queryMethod = connectionType.startsWith('proxy-') ? 'proxy' : 'browser';\n\n    // Save API key if provided\n    if (apiKey && connectionType === 'browser-cloud') {\n        localStorage.setItem(`${provider.toUpperCase()}_API_KEY`, apiKey);\n    }\n\n    // Determine key source\n    let keySource = 'none';\n    let keyId = null;\n    if (connectionType === 'browser-cloud') {\n        keySource = 'localStorage';\n        keyId = `${provider.toUpperCase()}_API_KEY`;\n    } else if (connectionType === 'proxy-cloud') {\n        keySource = 'proxy-env';\n    }\n\n    const modelConfig = {\n        id: modelId,\n        name: modelName,\n        provider: provider,\n        hostType: connectionType,\n        queryMethod: queryMethod,\n        keySource: keySource,\n        keyId: keyId\n    };\n\n    if (editingIndex !== '') {\n        updateModel(parseInt(editingIndex), modelConfig);\n    } else {\n        if (!addModel(modelConfig)) {\n            alert(`Maximum ${MAX_MODELS} models allowed`);\n            return;\n        }\n    }\n\n    renderModelCards();\n    saveToStorage();\n    updateGoalInputState();\n    closeInlineForm();\n\n    console.log('[ModelConfig] Model saved:', modelConfig);\n}\n\n// Reset inline form\nfunction resetInlineForm() {\n    document.getElementById('provider-select').value = '';\n    document.getElementById('model-select-dropdown').innerHTML = '<option value=\"\">Select model...</option>';\n    document.getElementById('connection-type-select').innerHTML = '<option value=\"\">Select connection type...</option>';\n    document.getElementById('model-api-key').value = '';\n    document.getElementById('model-select-group').classList.add('hidden');\n    document.getElementById('connection-type-group').classList.add('hidden');\n    document.getElementById('api-key-group').classList.add('hidden');\n    document.getElementById('save-model-btn').disabled = true;\n}\n\n// Populate edit form\nfunction populateeditForm(model) {\n    document.getElementById('provider-select').value = model.provider;\n    onProviderChange({ target: { value: model.provider } });\n\n    setTimeout(() => {\n        document.getElementById('model-select-dropdown').value = model.id;\n        const connectionSelect = document.getElementById('connection-type-select');\n        const hasOption = Array.from(connectionSelect.options).some(opt => opt.value === model.hostType);\n        if (!hasOption && model.hostType) {\n            const option = document.createElement('option');\n            option.value = model.hostType;\n            option.textContent = CONNECTION_TYPE_LABELS[model.hostType] || model.hostType;\n            connectionSelect.appendChild(option);\n        }\n        connectionSelect.value = model.hostType;\n        onConnectionTypeChange({ target: { value: model.hostType } });\n    }, 100);\n}\n\n// Setup event listeners for form elements\nexport function setupFormListeners() {\n    const closeBtn = document.getElementById('close-model-form');\n    if (closeBtn) {\n        closeBtn.addEventListener('click', closeInlineForm);\n    }\n\n    const cancelBtn = document.getElementById('cancel-model-btn');\n    if (cancelBtn) {\n        cancelBtn.addEventListener('click', closeInlineForm);\n    }\n\n    const saveBtnEl = document.getElementById('save-model-btn');\n    if (saveBtnEl) {\n        saveBtnEl.addEventListener('click', saveModel);\n    }\n\n    const providerSelect = document.getElementById('provider-select');\n    if (providerSelect) {\n        providerSelect.addEventListener('change', onProviderChange);\n    }\n\n    const modelSelect = document.getElementById('model-select-dropdown');\n    if (modelSelect) {\n        modelSelect.addEventListener('change', onModelChange);\n    }\n\n    const connectionTypeSelect = document.getElementById('connection-type-select');\n    if (connectionTypeSelect) {\n        connectionTypeSelect.addEventListener('change', onConnectionTypeChange);\n    }\n\n    const consensusSelect = document.getElementById('consensus-strategy');\n    if (consensusSelect) {\n        consensusSelect.addEventListener('change', () => {\n            saveToStorage();\n        });\n    }\n}\n",
      "hash": "d2f25393e90e742a8ebb6948a2376084faa5b935869869ffc4f1273b95823c8e"
    },
    "ui/boot/model-config/cards.js": {
      "meta": {
        "mtimeMs": 1763678271635.9182,
        "size": 9099,
        "binary": false
      },
      "content": "// Card Rendering and UI Updates\nimport {\n    MAX_MODELS,\n    HOST_TYPE_LABELS,\n    getSelectedModels,\n    getAvailableProviders,\n    setSelectedModels,\n    saveToStorage,\n    removeModel as removeModelFromState,\n    clearModels\n} from './state.js';\nimport { openInlineForm } from './form.js';\n\n// Render model cards\nexport function renderModelCards() {\n    const container = document.getElementById('model-cards-list');\n    const addCard = document.getElementById('add-model-card');\n    const consensusSection = document.getElementById('consensus-section');\n    const selectedModels = getSelectedModels();\n\n    container.innerHTML = '';\n\n    selectedModels.forEach((model, index) => {\n        const card = createModelCard(model, index);\n        container.appendChild(card);\n    });\n\n    container.appendChild(addCard);\n\n    if (consensusSection) {\n        if (selectedModels.length >= 2) {\n            consensusSection.classList.remove('hidden');\n        } else {\n            consensusSection.classList.add('hidden');\n        }\n    }\n}\n\n// Create model card element\nfunction createModelCard(model, index) {\n    const card = document.createElement('div');\n    card.className = 'model-card';\n    card.innerHTML = `\n        <div class=\"model-card-provider\">${model.provider}</div>\n        <div class=\"model-card-name\">${model.name}</div>\n        <div class=\"model-card-connection\">${HOST_TYPE_LABELS[model.hostType] || model.hostType}</div>\n        <div class=\"model-card-actions\">\n            <button class=\"model-card-btn edit\" data-index=\"${index}\">edit</button>\n            <button class=\"model-card-btn remove\" data-index=\"${index}\">Remove</button>\n        </div>\n    `;\n\n    card.querySelector('.edit').addEventListener('click', () => {\n        openInlineForm(index);\n    });\n\n    card.querySelector('.remove').addEventListener('click', () => {\n        removeModel(index);\n    });\n\n    return card;\n}\n\n// Remove model\nfunction removeModel(index) {\n    if (confirm('Remove this model?')) {\n        removeModelFromState(index);\n        renderModelCards();\n        saveToStorage();\n        updateGoalInputState();\n    }\n}\n\n// Update status indicators\nexport function updateStatusDots() {\n    const providers = getAvailableProviders();\n\n    // Browser â†’ Cloud (always ready)\n    const browserCloudIcon = document.getElementById('browser-cloud-icon');\n    const browserCloudText = document.getElementById('browser-cloud-text');\n    if (browserCloudIcon && browserCloudText) {\n        browserCloudIcon.className = 'provider-status-icon online';\n        browserCloudText.className = 'provider-status-value online';\n        browserCloudText.textContent = 'Ready';\n    }\n\n    // Proxy â†’ Cloud\n    const proxyCloudIcon = document.getElementById('proxy-cloud-icon');\n    const proxyCloudText = document.getElementById('proxy-cloud-text');\n    if (proxyCloudIcon && proxyCloudText) {\n        if (providers.proxy.online) {\n            proxyCloudIcon.className = 'provider-status-icon online';\n            proxyCloudText.className = 'provider-status-value online';\n            proxyCloudText.textContent = 'Available';\n        } else {\n            proxyCloudIcon.className = 'provider-status-icon offline';\n            proxyCloudText.className = 'provider-status-value offline';\n            proxyCloudText.textContent = 'Unavailable';\n        }\n    }\n\n    // Browser â†’ Local (WebGPU)\n    const browserLocalIcon = document.getElementById('browser-local-icon');\n    const browserLocalText = document.getElementById('browser-local-text');\n    if (browserLocalIcon && browserLocalText) {\n        if (providers.webgpu.online) {\n            browserLocalIcon.className = 'provider-status-icon online';\n            browserLocalText.className = 'provider-status-value online';\n            browserLocalText.textContent = 'WebGPU Available';\n        } else {\n            browserLocalIcon.className = 'provider-status-icon offline';\n            browserLocalText.className = 'provider-status-value offline';\n            browserLocalText.textContent = 'WebGPU Unavailable';\n        }\n    }\n\n    // Proxy â†’ Local (Ollama)\n    const proxyLocalIcon = document.getElementById('proxy-local-icon');\n    const proxyLocalText = document.getElementById('proxy-local-text');\n    if (proxyLocalIcon && proxyLocalText) {\n        if (providers.ollama.online) {\n            proxyLocalIcon.className = 'provider-status-icon online';\n            proxyLocalText.className = 'provider-status-value online';\n            proxyLocalText.textContent = `Ollama (${providers.ollama.models.length} models)`;\n        } else {\n            proxyLocalIcon.className = 'provider-status-icon offline';\n            proxyLocalText.className = 'provider-status-value offline';\n            proxyLocalText.textContent = 'Ollama Offline';\n        }\n    }\n}\n\n// Update goal input state\nexport function updateGoalInputState() {\n    const goalInput = document.getElementById('goal-input');\n    const awakenBtn = document.getElementById('awaken-btn');\n    const selectedModels = getSelectedModels();\n\n    if (goalInput) {\n        if (selectedModels.length === 0) {\n            goalInput.disabled = true;\n            goalInput.placeholder = 'â–º Select at least one model to continue';\n            if (awakenBtn) awakenBtn.disabled = true;\n        } else {\n            goalInput.disabled = false;\n            goalInput.placeholder = 'Describe your goal...';\n            if (awakenBtn) awakenBtn.disabled = false;\n        }\n    }\n}\n\n// Auto-populate default models\nexport function autoPopulateDefaultModels() {\n    const selectedModels = getSelectedModels();\n    const providers = getAvailableProviders();\n\n    if (selectedModels.length > 0) {\n        console.log('[ModelConfig] Models already configured, skipping auto-population');\n        return;\n    }\n\n    console.log('[ModelConfig] No models configured, checking for defaults...');\n\n    // Priority 1: Ollama\n    if (providers.ollama.online && providers.ollama.models.length > 0) {\n        const powerfulModel = providers.ollama.models.find(m =>\n            m.id.includes('qwen3-coder') || m.id.includes('coder')\n        ) || providers.ollama.models.find(m =>\n            m.id.includes('70b') || m.id.includes('32b') || m.id.includes('30b')\n        ) || providers.ollama.models[0];\n\n        const defaultModel = {\n            id: powerfulModel.id,\n            name: powerfulModel.name,\n            provider: 'ollama',\n            hostType: 'proxy-local',\n            queryMethod: 'proxy',\n            keySource: 'none'\n        };\n        setSelectedModels([defaultModel]);\n        saveToStorage();\n        console.log('[ModelConfig] Auto-added Ollama default model:', defaultModel);\n        return;\n    }\n\n    // Priority 2: Cloud proxy\n    if (providers.proxy.online) {\n        const defaultModel = {\n            id: 'gemini-2.5-flash',\n            name: 'Flash',\n            provider: 'gemini',\n            hostType: 'proxy-cloud',\n            queryMethod: 'proxy',\n            keySource: 'proxy-env'\n        };\n        setSelectedModels([defaultModel]);\n        saveToStorage();\n        console.log('[ModelConfig] Auto-added cloud proxy default model:', defaultModel);\n        return;\n    }\n\n    console.log('[ModelConfig] No default models available');\n}\n\n// Setup card-related event listeners\nexport function setupCardListeners() {\n    const providers = getAvailableProviders();\n\n    // Quick WebLLM Demo button\n    const quickDemoBtn = document.getElementById('quick-webllm-demo-btn');\n    if (quickDemoBtn) {\n        quickDemoBtn.addEventListener('click', async () => {\n            if (!navigator.gpu) {\n                alert('WebGPU not supported in this browser. Use Chrome 113+ or Edge 113+.');\n                return;\n            }\n\n            const demoModel = {\n                id: 'Llama-3.2-1B-Instruct-q4f32_1-MLC',\n                name: 'Llama 3.2 1B',\n                provider: 'webllm',\n                hostType: 'browser-local',\n                queryMethod: 'browser',\n                keySource: 'none'\n            };\n\n            setSelectedModels([demoModel]);\n            renderModelCards();\n            saveToStorage();\n            updateGoalInputState();\n\n            console.log('[ModelConfig] Quick demo model added:', demoModel);\n\n            // Set a default goal for the demo\n            const goalInput = document.getElementById('goal-input');\n            if (goalInput && !goalInput.value.trim()) {\n                goalInput.value = 'Analyze and improve your own system prompt';\n            }\n\n            const awakenBtn = document.getElementById('awaken-btn');\n            if (awakenBtn && !awakenBtn.disabled) {\n                awakenBtn.click();\n            }\n        });\n    }\n\n    // Add Model card click\n    const addModelCard = document.getElementById('add-model-card');\n    if (addModelCard) {\n        addModelCard.addEventListener('click', () => {\n            if (getSelectedModels().length >= MAX_MODELS) {\n                alert(`Maximum ${MAX_MODELS} models allowed`);\n                return;\n            }\n            openInlineForm();\n        });\n    }\n}\n",
      "hash": "5038e45a17560a1aede41b4d402dba54c86817035a0b19905616f161fea92aaa"
    },
    "index.html": {
      "meta": {
        "mtimeMs": 1763677825554.2888,
        "size": 39221,
        "binary": false
      },
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes\" />\n    <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%230ff;'/><stop offset='100%25' style='stop-color:%23ffd700;'/></linearGradient></defs><text fill='url(%23g)' y='.99em' font-size='90' font-weight='bold'>R</text></svg>\" />\n    <title>REPLOID - AI Assistant</title>\n    <link rel=\"stylesheet\" href=\"styles/theme.css\">\n    <link rel=\"stylesheet\" href=\"styles/boot.css\">\n    <link rel=\"stylesheet\" href=\"styles/dashboard.css\">\n\n    <!-- Load WebLLM and expose to window for llm-client.js -->\n    <script type=\"module\">\n        import * as webllm from \"https://esm.run/@mlc-ai/web-llm\";\n        window.webllm = webllm;\n        console.log(\"[System] WebLLM Loaded\");\n    </script>\n\n    <!-- Load Transformers.js for newer models (Qwen3, Gemma3, etc.) -->\n    <script type=\"module\">\n        import { pipeline, env } from \"https://cdn.jsdelivr.net/npm/@huggingface/transformers@3\";\n        // Configure for WebGPU\n        env.backends.onnx.wasm.proxy = false;\n        window.transformers = { pipeline, env };\n        console.log(\"[System] Transformers.js Loaded\");\n    </script>\n\n    <!-- Firebase Analytics -->\n    <script type=\"module\">\n      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';\n      import { getAnalytics } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js';\n\n      const firebaseConfig = {\n        apiKey: \"AIzaSyBNjEuGLafsUde3ws_9_Zi-PUlKkWt-CWM\",\n        authDomain: \"reploid.firebaseapp.com\",\n        projectId: \"reploid\",\n        storageBucket: \"reploid.firebasestorage.app\",\n        messagingSenderId: \"506730551098\",\n        appId: \"1:506730551098:web:1b9639865cb8501b7c2203\",\n        measurementId: \"G-RL299QYBNB\"\n      };\n\n      const app = initializeApp(firebaseConfig);\n      const analytics = getAnalytics(app);\n    </script>\n</head>\n<body>\n    <div id=\"boot-container\">\n        <div class=\"boot-header\">\n            <h1>REPLOID</h1>\n            <p class=\"subtitle\">\n                <a href=\"https://github.com/clocksmith/reploid\" target=\"_blank\" class=\"subtitle-link\">Browser-Native AI Agent with Recursive Self-Improvement</a>\n            </p>\n        </div>\n\n        <div id=\"api-error-message\" class=\"error-message hidden\" role=\"alert\">\n            <strong>Server Offline</strong>\n            <p>Reploid can't reach <code>localhost:8000</code>.</p>\n            <p><code>npm start</code> to boot the service, or read the <a href=\"https://github.com/clocksmith/deco/tree/main/docs\" target=\"_blank\" rel=\"noreferrer\">setup guide</a>.</p>\n        </div>\n\n        <!-- Quick WebLLM Demo -->\n        <div style=\"width: 100%; margin: 20px 0; padding: 15px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 6px; box-sizing: border-box; display: flex; align-items: center; justify-content: space-between; gap: 15px;\">\n            <div style=\"color: #ccc; font-size: 16px;\">Quick start with WebLLM</div>\n            <div style=\"color: #666; font-size: 14px; flex: 1;\">Run Llama 3.2 1B locally in browser via WebGPU. ~2GB download first time.</div>\n            <button id=\"quick-webllm-demo-btn\" class=\"btn primary\" style=\"min-width: 140px;\">Go!</button>\n        </div>\n\n        <!-- Provider Status (Read-Only) -->\n        <div class=\"provider-status-bar\" style=\"width: 100%;\">\n            <div class=\"provider-status-item\">\n                <span class=\"provider-status-icon online\" id=\"browser-cloud-icon\">â˜</span>\n                <span class=\"provider-status-label\">Browser â†’ Cloud</span>\n                <span class=\"provider-status-value online\" id=\"browser-cloud-text\">Ready</span>\n            </div>\n            <div class=\"provider-status-item\">\n                <span class=\"provider-status-icon\" id=\"proxy-cloud-icon\">â‡„</span>\n                <span class=\"provider-status-label\">Proxy â†’ Cloud</span>\n                <span class=\"provider-status-value\" id=\"proxy-cloud-text\">Checking...</span>\n            </div>\n            <div class=\"provider-status-item\">\n                <span class=\"provider-status-icon\" id=\"browser-local-icon\">â—†</span>\n                <span class=\"provider-status-label\">Browser â†’ Local</span>\n                <span class=\"provider-status-value\" id=\"browser-local-text\">Checking...</span>\n            </div>\n            <div class=\"provider-status-item\">\n                <span class=\"provider-status-icon\" id=\"proxy-local-icon\">â˜’</span>\n                <span class=\"provider-status-label\">Proxy â†’ Local</span>\n                <span class=\"provider-status-value\" id=\"proxy-local-text\">Checking...</span>\n            </div>\n        </div>\n\n        <!-- Model Cards Container -->\n        <div class=\"model-cards-container\" style=\"width: 100%;\">\n                <h4 class=\"model-cards-title\">Active Models</h4>\n\n                <div class=\"model-cards-list\" id=\"model-cards-list\">\n                    <!-- Model cards will be added here dynamically -->\n\n                    <!-- Add Model card - always visible -->\n                    <div class=\"model-card add-model-card\" id=\"add-model-card\">\n                        <div class=\"add-model-icon\">+</div>\n                        <div class=\"add-model-text\">Add Model</div>\n                    </div>\n                </div>\n\n                <!-- Inline Add/edit Model Form (shown when adding/editing) -->\n                <div id=\"model-form-inline\" class=\"model-form-inline hidden\">\n                    <div class=\"model-form-header\">\n                        <h5 id=\"model-form-title\">Add Model</h5>\n                        <button class=\"close-btn-small\" id=\"close-model-form\">Ã—</button>\n                    </div>\n\n                    <!-- Provider Selection -->\n                    <div class=\"inline-form-row\">\n                        <label>Provider</label>\n                        <select id=\"provider-select\" class=\"inline-select\">\n                            <option value=\"\">Select provider...</option>\n                        </select>\n                    </div>\n\n                    <!-- Model Selection -->\n                    <div class=\"inline-form-row hidden\" id=\"model-select-group\">\n                        <label>Model</label>\n                        <select id=\"model-select-dropdown\" class=\"inline-select\">\n                            <option value=\"\">Select model...</option>\n                        </select>\n                    </div>\n\n                    <!-- API Key (if needed) -->\n                    <div class=\"inline-form-row hidden\" id=\"api-key-group\">\n                        <label>API Key</label>\n                        <input type=\"password\" id=\"model-api-key\" class=\"inline-input\" placeholder=\"Enter API key...\" />\n                    </div>\n\n                    <!-- Connection Type Selection -->\n                    <div class=\"inline-form-row hidden\" id=\"connection-type-group\">\n                        <label>Connection</label>\n                        <select id=\"connection-type-select\" class=\"inline-select\">\n                            <option value=\"\">Select connection type...</option>\n                        </select>\n                    </div>\n\n                    <div class=\"inline-form-actions\">\n                        <button class=\"inline-btn-cancel\" id=\"cancel-model-btn\">Cancel</button>\n                        <button class=\"inline-btn-save\" id=\"save-model-btn\" disabled>Add Model</button>\n                    </div>\n                </div>\n\n                <!-- Consensus Strategy (shown when 2+ models) -->\n                <div id=\"consensus-section\" class=\"consensus-section hidden\">\n                    <label for=\"consensus-strategy\">Consensus Strategy</label>\n                    <select id=\"consensus-strategy\" class=\"consensus-select\">\n                        <option value=\"arena\">Model Arena</option>\n                        <option value=\"peer-review\">Peer Review</option>\n                    </select>\n                </div>\n            </div>\n\n        <!-- Goal Input at Top -->\n        <div class=\"goal-container-top\">\n            <div class=\"goal-input-group\">\n                <input type=\"text\" id=\"goal-input\" placeholder=\"â–º Select at least one model to continue\" maxlength=\"500\" disabled />\n                <button id=\"awaken-btn\" class=\"btn primary\" disabled>Awaken Agent</button>\n                <input type=\"file\" id=\"import-file-input\" accept=\".json\" style=\"display: none;\" />\n            </div>\n            <!-- Example Goal Chips -->\n            <div class=\"goal-example-chips\">\n                <button class=\"goal-chip\" onclick=\"document.getElementById('goal-input').value='Build a tool that iteratively improves prompts by identifying weaknesses and fixing them'\">Prompt Improvement</button>\n                <button class=\"goal-chip\" onclick=\"document.getElementById('goal-input').value='Write a function that improves itself'\">Self-Improvement</button>\n                <button class=\"goal-chip\" onclick=\"document.getElementById('goal-input').value='Create a meta-cognitive evaluator that scores reasoning quality and adjusts strategies'\">Meta-Cognitive</button>\n                <button class=\"goal-chip\" onclick=\"document.getElementById('goal-input').value='Break down goals into subgoals, then improve the decomposition algorithm itself'\">Goal Decomposition</button>\n                <button class=\"goal-chip\" onclick=\"document.getElementById('goal-input').value='Create tools that create tools'\">Meta-Tools</button>\n            </div>\n        </div>\n\n        <!-- Genesis Level Selection -->\n        <div class=\"config-section\">\n            <h4 class=\"model-cards-title\">Genesis Level</h4>\n            <div class=\"boot-mode-options\">\n                <button class=\"boot-mode-btn selected recommended\" data-genesis=\"full\" onclick=\"selectGenesisLevel('full')\">\n                    <div class=\"boot-mode-badge\">RECOMMENDED</div>\n                    <div class=\"boot-mode-label\">FULL SUBSTRATE</div>\n                    <div class=\"boot-mode-desc\">All modules + reflection, monitoring, and self-testing</div>\n                </button>\n                <button class=\"boot-mode-btn\" data-genesis=\"minimal\" onclick=\"selectGenesisLevel('minimal')\">\n                    <div class=\"boot-mode-badge experimental-badge\">EXPERIMENTAL</div>\n                    <div class=\"boot-mode-label\">MINIMAL AXIOMS</div>\n                    <div class=\"boot-mode-desc\">Core modules + reflection - no monitoring or testing</div>\n                </button>\n                <button class=\"boot-mode-btn\" data-genesis=\"tabula\" onclick=\"selectGenesisLevel('tabula')\">\n                    <div class=\"boot-mode-badge experimental-badge\">EXPERIMENTAL</div>\n                    <div class=\"boot-mode-label\">TABULA RASA</div>\n                    <div class=\"boot-mode-desc\">Core modules + reflection only - no advanced capabilities</div>\n                </button>\n            </div>\n\n        </div>\n\n        <!-- Utility Actions -->\n        <div style=\"width: 100%; display: flex; justify-content: center; gap: 12px; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);\">\n            <button id=\"import-state-btn\" class=\"btn secondary\" title=\"Import REPLOID state from exported JSON file\">Import State</button>\n            <button id=\"clear-cache-btn\" class=\"btn secondary\" title=\"Clear all data (localStorage, IndexedDB, VFS) and reload\">Reset All Data</button>\n        </div>\n\n        <!-- Info Overlay -->\n        <div id=\"info-overlay\" class=\"info-overlay hidden\">\n            <div class=\"info-card\">\n                <div class=\"info-card-header\">\n                    <h3 id=\"info-card-title\">Info</h3>\n                    <button type=\"button\" class=\"close-btn\" onclick=\"window.closeInfoCard()\">Ã—</button>\n                </div>\n                <div id=\"info-card-body\" class=\"info-card-body\"></div>\n                <div class=\"info-card-footer\">\n                    <button type=\"button\" id=\"info-card-browse\" class=\"secondary-btn\">Browse Directory â†’</button>\n                </div>\n            </div>\n        </div>\n\n        <!-- Directory Browser -->\n        <div id=\"directory-modal\" class=\"modal hidden\">\n            <div class=\"modal-content directory-modal-content\">\n                <div class=\"modal-header\">\n                    <h3 id=\"directory-modal-title\">Module Directory</h3>\n                    <button type=\"button\" class=\"close-btn\" onclick=\"window.closeDirectoryModal()\">Ã—</button>\n                </div>\n                <div class=\"modal-body directory-modal-body\">\n                    <div class=\"directory-filters\" role=\"group\" aria-label=\"Select preset\">\n                        <button type=\"button\" class=\"directory-filter active\" data-preset=\"core\" onclick=\"switchModulePreset('core')\">CORE</button>\n                        <button type=\"button\" class=\"directory-filter\" data-preset=\"headless\" onclick=\"switchModulePreset('headless')\">HEADLESS</button>\n                        <button type=\"button\" class=\"directory-filter\" data-preset=\"complete\" onclick=\"switchModulePreset('complete')\">COMPLETE</button>\n                    </div>\n                    <div class=\"directory-content\" id=\"directory-content\"></div>\n                </div>\n            </div>\n        </div>\n\n        <div id=\"help-popover\" class=\"help-popover hidden\" role=\"dialog\" aria-modal=\"false\" aria-hidden=\"true\">\n            <div class=\"help-popover-content\">\n                <div class=\"help-popover-header\">\n                    <div id=\"help-popover-title\" class=\"help-popover-title\">Help</div>\n                    <button type=\"button\" class=\"close-btn help-popover-close\" aria-label=\"Close help popover\">Ã—</button>\n                </div>\n                <div id=\"help-popover-body\" class=\"help-popover-body\"></div>\n            </div>\n        </div>\n\n        <div id=\"multi-model-modal\" class=\"modal hidden\" role=\"dialog\" aria-modal=\"true\" aria-hidden=\"true\">\n            <div class=\"modal-content multi-model-modal-content\">\n                <div class=\"modal-header\">\n                    <h3>Multi-Model Setup</h3>\n                    <button type=\"button\" class=\"close-btn\" id=\"close-multi-model\">Ã—</button>\n                </div>\n                <div class=\"modal-body\">\n                    <p class=\"settings-description\">Define primary, fallback, and consensus models for Arena competitive testing.</p>\n                    <div class=\"arena-field\">\n                        <label for=\"arena-primary\">Primary Model</label>\n                        <input type=\"text\" id=\"arena-primary\" placeholder=\"e.g., gemini-2.5-flash-lite\" />\n                    </div>\n                    <div class=\"arena-field\">\n                        <label for=\"arena-fallback\">Fallback Model</label>\n                        <input type=\"text\" id=\"arena-fallback\" placeholder=\"e.g., gpt-5-2025-08-07\" />\n                    </div>\n                    <div class=\"arena-field\">\n                        <label for=\"arena-consensus\">Consensus Model</label>\n                        <input type=\"text\" id=\"arena-consensus\" placeholder=\"e.g., claude-4-5-sonnet\" />\n                    </div>\n                    <div class=\"arena-field\">\n                        <label for=\"arena-strategy\">Strategy</label>\n                        <select id=\"arena-strategy\">\n                            <option value=\"fastest\">Fastest First</option>\n                            <option value=\"consensus\">Consensus Vote</option>\n                            <option value=\"fallback\">Fallback Chain</option>\n                        </select>\n                    </div>\n                    <div class=\"modal-footer\">\n                        <button type=\"button\" class=\"btn secondary\" id=\"cancel-multi-model\">Cancel</button>\n                        <button type=\"button\" class=\"btn primary\" id=\"save-multi-model\">Save Multi-Model Plan</button>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Agent Monitor (shown after awakening) - Mission Control Layout -->\n    <div id=\"agent-container\" style=\"display: none; flex-direction: column; height: 100vh; background: #0a0a0a; color: #e0e0e0; font-family: 'Courier New', monospace;\">\n        <!-- Header -->\n        <div class=\"mission-control-header\" style=\"padding: 12px 20px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;\">\n            <div style=\"display: flex; align-items: center; gap: 20px;\">\n                <h2 style=\"margin: 0; font-size: 18px; color: #0ff;\">REPLOID Mission Control</h2>\n                <div id=\"context-stats\" style=\"font-size: 11px; color: #888; font-family: monospace;\">\n                    <span id=\"context-messages\">0 msgs</span> |\n                    <span id=\"context-tokens\">0 tokens</span>\n                </div>\n                <!-- Current Goal Display -->\n                <div id=\"current-goal-display\" style=\"font-size: 12px; color: #ffd700; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;\"></div>\n            </div>\n            <div style=\"display: flex; gap: 8px; align-items: center;\">\n                <!-- Panel Toggle -->\n                <button id=\"log-toggle-btn\" class=\"holo-btn\" style=\"padding: 6px 12px; font-size: 11px;\">\n                    <span class=\"btn-text\">Show: VISUALIZER</span>\n                </button>\n                <button id=\"pause-btn\" class=\"holo-btn holo-btn-pause\">\n                    <span class=\"btn-icon\">â¸</span>\n                    <span class=\"btn-text\">Pause</span>\n                </button>\n                <button id=\"stop-btn\" class=\"holo-btn holo-btn-stop\">\n                    <span class=\"btn-icon\">â¹</span>\n                    <span class=\"btn-text\">Stop</span>\n                </button>\n                <button id=\"export-btn\" class=\"holo-btn holo-btn-export\" title=\"Export entire REPLOID state\">\n                    <span class=\"btn-icon\">â¬‡</span>\n                    <span class=\"btn-text\">Export</span>\n                </button>\n            </div>\n        </div>\n\n        <!-- Safety Net Banner (shown during proposal approval) -->\n        <div id=\"safety-net-banner\" class=\"safety-net-banner hidden\" style=\"padding: 10px 20px; background: linear-gradient(90deg, rgba(0,255,0,0.1), rgba(0,255,255,0.1)); border-bottom: 1px solid #0f0; display: flex; align-items: center; gap: 12px;\">\n            <span style=\"font-size: 18px;\">ðŸ›¡ï¸</span>\n            <span style=\"color: #0f0; font-size: 13px; font-weight: 600;\">Safety Net Active</span>\n            <span style=\"color: #888; font-size: 12px;\">A restore point has been created. You can undo these changes with one click.</span>\n        </div>\n\n        <!-- Main Content Area -->\n        <div style=\"display: flex; flex: 1; overflow: hidden;\">\n            <!-- Left: Agent Visualizer + Log (60%) -->\n            <div style=\"flex: 0 0 60%; border-right: 1px solid #333; display: flex; flex-direction: column;\">\n                <!-- Agent Visualizer (Primary View - Mission Control) -->\n                <div id=\"agent-visualizer-container\" class=\"advanced-panel\" style=\"flex: 0 0 200px; border-bottom: 1px solid #333; padding: 10px; background: #0a0a0a;\">\n                    <div style=\"text-align: center; color: #555; padding: 40px;\">\n                        Agent FSM Visualizer loads here\n                    </div>\n                </div>\n\n                <!-- Agent Log (Collapsible) -->\n                <div id=\"agent-log\" style=\"flex: 1; overflow-y: auto; padding: 15px; padding-bottom: 40px;\">\n                    <!-- Status messages will be added here dynamically -->\n                </div>\n            </div>\n\n            <!-- Right: Live Preview + Panels (40%) -->\n            <div style=\"flex: 1; display: flex; flex-direction: column; overflow: hidden;\">\n                <!-- Live Preview -->\n                <div id=\"live-preview\" style=\"flex: 1; overflow-y: auto; padding: 15px; background: #0f0f0f;\">\n                    <h3 style=\"margin: 0 0 10px 0; color: #888; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 8px;\">Live Preview</h3>\n                    <div id=\"preview-content\" style=\"color: #888; font-size: 13px;\">\n                        <p>Visualizations and code changes appear here.</p>\n                    </div>\n                </div>\n\n                <!-- Advanced Panels (Hidden by default) -->\n                <div id=\"thought-panel\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">Thought Log</h4>\n                    <div id=\"thought-content\" style=\"font-size: 11px; color: #666;\"></div>\n                </div>\n\n                <div id=\"performance-panel\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">Performance Metrics</h4>\n                    <div id=\"perf-charts\"></div>\n                </div>\n\n                <div id=\"introspection-panel\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">Introspection</h4>\n                    <div id=\"introspection-content\"></div>\n                </div>\n\n                <div id=\"python-repl-panel\" class=\"advanced-panel hidden\" style=\"flex: 0 0 250px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">Python REPL</h4>\n                    <div id=\"pyodide-status-icon\" style=\"display: inline;\">âšª</div>\n                    <span id=\"pyodide-status-text\" style=\"font-size: 11px; color: #666;\">Not loaded</span>\n                    <textarea id=\"python-code-input\" style=\"width: 100%; height: 80px; margin-top: 8px; background: #1a1a1a; color: #0f0; border: 1px solid #333; font-family: monospace; font-size: 11px; padding: 8px;\" placeholder=\"# Python code here...\"></textarea>\n                    <div style=\"margin-top: 8px;\">\n                        <button id=\"python-execute-btn\" style=\"padding: 4px 8px; font-size: 10px;\">â˜‡ï¸ Run</button>\n                        <button id=\"repl-clear-btn\" style=\"padding: 4px 8px; font-size: 10px;\">Clear</button>\n                        <label style=\"font-size: 10px; margin-left: 8px;\">\n                            <input type=\"checkbox\" id=\"python-sync-workspace-check\"> Sync VFS\n                        </label>\n                    </div>\n                    <div id=\"python-output\" style=\"margin-top: 8px; max-height: 100px; overflow-y: auto; font-size: 10px; color: #888;\"></div>\n                </div>\n\n                <div id=\"local-llm-panel\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">Local LLM</h4>\n                    <div id=\"llm-status-icon\" style=\"display: inline;\">âšª</div>\n                    <span id=\"llm-status-text\" style=\"font-size: 11px; color: #666;\">Not loaded</span>\n                    <div id=\"llm-webgpu-status\" style=\"font-size: 10px; margin-top: 4px;\"></div>\n                    <div id=\"llm-current-model\" style=\"font-size: 10px; color: #0ff; margin-top: 4px;\"></div>\n                    <div style=\"margin-top: 8px;\">\n                        <select id=\"llm-model-select\" style=\"font-size: 10px; padding: 4px;\">\n                            <option value=\"\">Select model...</option>\n                            <option value=\"Phi-3.5-mini-instruct-q4f16_1-MLC\">Phi-3.5 Mini (2GB)</option>\n                            <option value=\"Llama-3.2-1B-Instruct-q4f16_1-MLC\">Llama 3.2 1B (1GB)</option>\n                        </select>\n                        <button id=\"llm-load-btn\" style=\"padding: 4px 8px; font-size: 10px;\">Load</button>\n                    </div>\n                    <div id=\"llm-progress-bar\" style=\"margin-top: 8px; height: 4px; background: #333; border-radius: 2px;\">\n                        <div id=\"llm-progress-fill\" style=\"height: 100%; width: 0%; background: #0ff; border-radius: 2px; transition: width 0.3s;\"></div>\n                    </div>\n                    <div id=\"llm-progress-text\" style=\"font-size: 9px; color: #666; margin-top: 2px;\"></div>\n                </div>\n\n                <!-- VFS Tree Panel (Advanced) -->\n                <div id=\"vfs-tree-advanced\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">VFS Explorer</h4>\n                </div>\n\n                <!-- AST Visualizer -->\n                <div id=\"ast-viz-container\" class=\"advanced-panel hidden\" style=\"flex: 0 0 200px; padding: 10px; border-top: 1px solid #333; overflow-y: auto;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #888; font-size: 12px;\">AST Visualizer</h4>\n                </div>\n            </div>\n        </div>\n\n        <!-- Diff Viewer Container (for proposal approval) -->\n        <div id=\"diff-viewer-container\" style=\"display: none;\"></div>\n\n        <div id=\"chat-input-area\" style=\"padding: 15px 20px; border-top: 1px solid #333; display: none;\">\n            <input type=\"text\" placeholder=\"Enter follow-up goal...\" style=\"width: 100%; padding: 10px; background: #1a1a1a; color: #fff; border: 1px solid #555; font-family: inherit; font-size: 13px;\" />\n        </div>\n    </div>\n\n    <style>\n        /* Mission Control CSS */\n        .hidden {\n            display: none !important;\n        }\n\n        .advanced-panel {\n            transition: all 0.3s ease;\n        }\n\n        .safety-net-banner {\n            animation: pulse-glow 2s ease-in-out infinite;\n        }\n\n        @keyframes pulse-glow {\n            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.3); }\n            50% { box-shadow: 0 0 15px rgba(0, 255, 0, 0.6); }\n        }\n\n        /* REPL output styles */\n        .repl-result {\n            padding: 8px;\n            margin-bottom: 8px;\n            border-radius: 4px;\n            font-family: monospace;\n        }\n\n        .repl-result-success {\n            background: rgba(0, 255, 0, 0.1);\n            border-left: 2px solid #0f0;\n        }\n\n        .repl-result-error {\n            background: rgba(255, 0, 0, 0.1);\n            border-left: 2px solid #f00;\n        }\n\n        .repl-stdout { color: #0f0; }\n        .repl-stderr { color: #f80; }\n        .repl-error { color: #f00; }\n        .repl-return-value { color: #0ff; }\n        .repl-result-header { color: #666; font-size: 9px; margin-bottom: 4px; }\n\n        .chat-message {\n            margin-bottom: 15px;\n            padding: 10px;\n            border-left: 3px solid #555;\n            background: #1a1a1a;\n            border-radius: 4px;\n        }\n        .chat-message.agent {\n            border-left-color: #f0f;  /* Magenta for [SYSTEM] messages */\n        }\n        .chat-message.assistant {\n            border-left-color: #0ff;  /* Cyan for [REPLOID] messages */\n        }\n        .chat-message.tool {\n            border-left-color: #ff0;\n        }\n        .chat-message.tool_result {\n            border-left-color: #0a0;\n        }\n        .chat-message.tool_error {\n            border-left-color: #f00;\n        }\n        .chat-message.thinking {\n            border-left-color: #888;\n            opacity: 0.7;\n        }\n        .chat-message.streaming_stats {\n            border-left-color: #0af;\n            background: #0a1a1f;\n            font-family: monospace;\n            font-size: 11px;\n            opacity: 0.8;\n        }\n        .chat-message.streaming_content {\n            border-left-color: #0f0;\n            background: #0a1a0a;\n        }\n        .chat-message.done {\n            border-left-color: #0f0;\n            font-weight: bold;\n        }\n        .chat-message.error {\n            border-left-color: #f00;\n            background: #2a0000;\n        }\n        .chat-message.context_injected {\n            border-left-color: #88f;\n            background: #1a1a2a;\n        }\n        .chat-message.context {\n            border-left-color: #fa0;\n            background: #1a1a0a;\n        }\n        .chat-message.preview {\n            border-left-color: #0af;\n            background: #0a1a1a;\n        }\n        .chat-message.diff {\n            border-left-color: #f0a;\n            background: #1a0a1a;\n        }\n        .chat-message.approval {\n            border-left-color: #ff0;\n            background: #1a1a00;\n        }\n        .message-icon {\n            font-weight: bold;\n            margin-bottom: 5px;\n            font-size: 12px;\n            color: #888;\n        }\n        .message-content {\n            white-space: pre-wrap;\n            word-wrap: break-word;\n            max-height: 600px;\n            overflow-y: auto;\n            overflow-x: hidden;\n            padding-right: 8px;\n            line-height: 1.5;\n            transition: max-height 0.3s ease;\n        }\n        .message-content.collapsed {\n            max-height: 60px;\n            overflow: hidden;\n            position: relative;\n        }\n        .message-content.collapsed::after {\n            content: 'â–¼ click to expand';\n            position: absolute;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(to right, transparent, #1a1a1a 50%);\n            padding: 0 8px 0 30px;\n            color: #666;\n            font-size: 11px;\n            font-style: italic;\n        }\n        .message-content.collapsed:hover::after {\n            color: #0ff;\n        }\n\n        /* Holographic Button Styles */\n        .holo-btn {\n            position: relative;\n            display: inline-flex;\n            align-items: center;\n            gap: 8px;\n            padding: 10px 18px;\n            font-family: 'Courier New', monospace;\n            font-size: 13px;\n            font-weight: 600;\n            text-transform: uppercase;\n            letter-spacing: 0.5px;\n            border: 1px solid;\n            border-radius: 3px;\n            background: rgba(0, 0, 0, 0.5);\n            cursor: pointer;\n            transition: all 0.3s ease;\n            overflow: hidden;\n        }\n\n        .holo-btn::before {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: -100%;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n            transition: left 0.5s ease;\n        }\n\n        .holo-btn:hover::before {\n            left: 100%;\n        }\n\n        .holo-btn .btn-icon {\n            font-size: 16px;\n            line-height: 1;\n        }\n\n        .holo-btn .btn-text {\n            position: relative;\n            z-index: 1;\n        }\n\n        /* Pause Button - Cyan/Blue theme */\n        .holo-btn-pause {\n            color: #0ff;\n            border-color: #0ff;\n            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);\n        }\n\n        .holo-btn-pause:hover {\n            background: rgba(0, 255, 255, 0.15);\n            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), inset 0 0 15px rgba(0, 255, 255, 0.2);\n            transform: translateY(-1px);\n        }\n\n        .holo-btn-pause:active {\n            transform: translateY(0);\n            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4), inset 0 0 10px rgba(0, 255, 255, 0.15);\n        }\n\n        /* Resume state for pause button */\n        .holo-btn-pause.resume-state {\n            color: #0f0;\n            border-color: #0f0;\n            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3), inset 0 0 10px rgba(0, 255, 0, 0.1);\n        }\n\n        .holo-btn-pause.resume-state:hover {\n            background: rgba(0, 255, 0, 0.15);\n            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 15px rgba(0, 255, 0, 0.2);\n        }\n\n        /* Stop Button - Red/Pink theme */\n        .holo-btn-stop {\n            color: #f0f;\n            border-color: #f0f;\n            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(255, 0, 255, 0.1);\n        }\n\n        .holo-btn-stop:hover {\n            background: rgba(255, 0, 255, 0.15);\n            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6), inset 0 0 15px rgba(255, 0, 255, 0.2);\n            transform: translateY(-1px);\n        }\n\n        .holo-btn-stop:active {\n            transform: translateY(0);\n            box-shadow: 0 0 10px rgba(255, 0, 255, 0.4), inset 0 0 10px rgba(255, 0, 255, 0.15);\n        }\n\n        /* Export Button - Green theme */\n        .holo-btn-export {\n            color: #0f0;\n            border-color: #0f0;\n            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3), inset 0 0 10px rgba(0, 255, 0, 0.1);\n        }\n\n        .holo-btn-export:hover {\n            background: rgba(0, 255, 0, 0.15);\n            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 15px rgba(0, 255, 0, 0.2);\n            transform: translateY(-1px);\n        }\n\n        .holo-btn-export:active {\n            transform: translateY(0);\n            box-shadow: 0 0 10px rgba(0, 255, 0, 0.4), inset 0 0 10px rgba(0, 255, 0, 0.15);\n        }\n\n        /* Custom scrollbar for message content */\n        .message-content::-webkit-scrollbar {\n            width: 8px;\n        }\n        .message-content::-webkit-scrollbar-track {\n            background: #0a0a0a;\n            border-radius: 4px;\n        }\n        .message-content::-webkit-scrollbar-thumb {\n            background: #333;\n            border-radius: 4px;\n        }\n        .message-content::-webkit-scrollbar-thumb:hover {\n            background: #555;\n        }\n        /* Ensure chat messages container is scrollable */\n        #chat-messages {\n            scroll-behavior: smooth;\n        }\n    </style>\n\n    <div id=\"app-root\" style=\"display: none;\"></div>\n\n    <script>\n        // Boot mode selection\n        let selectedBootMode = 'single'; // Default\n\n        function selectBootMode(mode) {\n            selectedBootMode = mode;\n            console.log('[Boot] Selected mode:', mode);\n\n            // Update UI\n            document.querySelectorAll('.boot-mode-btn').forEach(btn => {\n                btn.classList.remove('selected');\n            });\n            document.querySelector(`[data-mode=\"${mode}\"]`).classList.add('selected');\n\n            // Store selection\n            localStorage.setItem('reploid_boot_mode', mode);\n        }\n\n        // Module browser\n        function openModuleBrowser() {\n            alert('Module browser coming soon!\\n\\nYou can manually configure modules by editing boot.js.\\n\\nCurrent mode: ' + selectedBootMode);\n        }\n\n        // Restore saved boot mode\n        window.addEventListener('DOMContentLoaded', () => {\n            const saved = localStorage.getItem('reploid_boot_mode');\n            if (saved) {\n                selectBootMode(saved);\n            }\n        });\n    </script>\n\n    <script src=\"https://unpkg.com/@isomorphic-git/lightning-fs\"></script>\n    <script src=\"https://unpkg.com/isomorphic-git\"></script>\n    <script type=\"module\" src=\"https://unpkg.com/isomorphic-git/http/web/index.js\"></script>\n    <!-- App container for dashboard -->\n    <div id=\"app\"></div>\n    <!-- Dev integrations loaded conditionally via boot.js -->\n    <script type=\"module\" src=\"boot.js\"></script>\n</body>\n</html>\n\n<script>\n// Genesis level selection\nlet selectedGenesisLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL') || 'full';\nlet genesisLevelLoaded = false;\n\nfunction selectGenesisLevel(level) {\n  const previousLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL');\n\n  // Update UI immediately\n  document.querySelectorAll('[data-genesis]').forEach(btn => {\n    btn.classList.remove('selected');\n  });\n  document.querySelector(`[data-genesis=\"${level}\"]`).classList.add('selected');\n\n  // Store selection\n  localStorage.setItem('REPLOID_GENESIS_LEVEL', level);\n  selectedGenesisLevel = level;\n\n  console.log(`[Config] Genesis level set to: ${level}`);\n\n  // If changing from a previously loaded level, reload for full sweep\n  if (previousLevel && previousLevel !== level && genesisLevelLoaded) {\n    console.log(`[Config] Genesis level changed from ${previousLevel} to ${level}, reloading...`);\n    location.reload();\n  }\n}\n\n// Called by boot.js when system is ready\nwindow.onGenesisLevelLoaded = () => {\n  genesisLevelLoaded = true;\n  console.log(`[Config] Genesis level ${selectedGenesisLevel} loaded successfully`);\n};\n\n// Restore saved genesis level on load\nwindow.addEventListener('DOMContentLoaded', () => {\n  const savedLevel = localStorage.getItem('REPLOID_GENESIS_LEVEL');\n  if (savedLevel && ['full', 'minimal', 'tabula'].includes(savedLevel)) {\n    // Just update UI, don't trigger reload\n    document.querySelectorAll('[data-genesis]').forEach(btn => {\n      btn.classList.remove('selected');\n    });\n    const btn = document.querySelector(`[data-genesis=\"${savedLevel}\"]`);\n    if (btn) btn.classList.add('selected');\n    selectedGenesisLevel = savedLevel;\n  }\n});\n\n// Expose genesis level for boot.js\nwindow.getGenesisLevel = () => selectedGenesisLevel;\n\n// Reset All Data button handler\nwindow.addEventListener('DOMContentLoaded', () => {\n  const clearBtn = document.getElementById('clear-cache-btn');\n  if (clearBtn) {\n    clearBtn.addEventListener('click', async () => {\n      if (!confirm('This will delete ALL data including:\\n\\nâ€¢ LocalStorage settings\\nâ€¢ IndexedDB (VFS, reflections, state)\\nâ€¢ Selected models\\n\\nAre you sure?')) {\n        return;\n      }\n\n      // Clear localStorage\n      localStorage.clear();\n\n      // Clear all IndexedDB databases\n      const databases = await indexedDB.databases();\n      for (const db of databases) {\n        if (db.name) {\n          indexedDB.deleteDatabase(db.name);\n          console.log(`[Reset] Deleted IndexedDB: ${db.name}`);\n        }\n      }\n\n      console.log('[Reset] All data cleared, reloading...');\n      location.reload();\n    });\n  }\n});\n\n// Concurrency limit management\nwindow.addEventListener('DOMContentLoaded', () => {\n  const concurrencyInput = document.getElementById('concurrency-limit');\n  if (concurrencyInput) {\n    // Load saved value\n    const saved = localStorage.getItem('MAX_CONCURRENT_PROXY_REQUESTS');\n    if (saved) {\n      concurrencyInput.value = saved;\n    }\n\n    // Save on change\n    concurrencyInput.addEventListener('change', (e) => {\n      const value = parseInt(e.target.value);\n      if (value >= 1 && value <= 10) {\n        localStorage.setItem('MAX_CONCURRENT_PROXY_REQUESTS', value);\n        console.log(`[Config] Concurrency limit set to: ${value}`);\n        alert(`Concurrency limit set to ${value}. Refresh the page for changes to take effect.`);\n      }\n    });\n  }\n});\n</script>\n",
      "hash": "b742c2244b6864c02c55eae0ca56debef83d239025763e314046930e52d60ed9"
    },
    "styles/vfs-explorer.css": {
      "meta": {
        "mtimeMs": 1763564495258.318,
        "size": 9032,
        "binary": false
      },
      "content": "/* VFS Explorer Styles */\n\n.vfs-explorer {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  background: rgba(0, 20, 40, 0.8);\n  border: 1px solid rgba(0, 255, 255, 0.3);\n  border-radius: 4px;\n  overflow: hidden;\n}\n\n.vfs-toolbar {\n  display: flex;\n  gap: 8px;\n  padding: 8px;\n  background: rgba(0, 255, 255, 0.1);\n  border-bottom: 1px solid rgba(0, 255, 255, 0.3);\n}\n\n.vfs-search {\n  flex: 1;\n  padding: 6px 12px;\n  background: rgba(0, 0, 0, 0.3);\n  border: 1px solid rgba(0, 255, 255, 0.3);\n  border-radius: 4px;\n  color: #00ffff;\n  font-family: 'Courier New', monospace;\n  font-size: 13px;\n}\n\n.vfs-search:focus {\n  outline: none;\n  border-color: #00ffff;\n  box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);\n}\n\n.vfs-search::placeholder {\n  color: rgba(0, 255, 255, 0.5);\n}\n\n.vfs-toolbar button {\n  padding: 6px 12px;\n  background: rgba(0, 255, 255, 0.1);\n  border: 1px solid rgba(0, 255, 255, 0.3);\n  border-radius: 4px;\n  color: #00ffff;\n  cursor: pointer;\n  font-size: 16px;\n  transition: all 0.2s;\n}\n\n.vfs-toolbar button:hover {\n  background: rgba(0, 255, 255, 0.2);\n  border-color: #00ffff;\n  box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);\n}\n\n.vfs-tree {\n  flex: 1;\n  overflow-y: auto;\n  padding: 4px;\n  font-family: 'Courier New', monospace;\n  font-size: 13px;\n}\n\n.vfs-tree::-webkit-scrollbar {\n  width: 8px;\n}\n\n.vfs-tree::-webkit-scrollbar-track {\n  background: rgba(0, 0, 0, 0.3);\n}\n\n.vfs-tree::-webkit-scrollbar-thumb {\n  background: rgba(0, 255, 255, 0.3);\n  border-radius: 4px;\n}\n\n.vfs-tree::-webkit-scrollbar-thumb:hover {\n  background: rgba(0, 255, 255, 0.5);\n}\n\n.vfs-item {\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  padding: 4px 8px;\n  cursor: pointer;\n  border-radius: 3px;\n  transition: background 0.15s;\n  user-select: none;\n  white-space: nowrap;\n}\n\n.vfs-item:hover {\n  background: rgba(0, 255, 255, 0.15);\n}\n\n.vfs-item.selected {\n  background: rgba(0, 255, 255, 0.25);\n  border-left: 2px solid #00ffff;\n}\n\n.vfs-item.highlight .vfs-name {\n  background: rgba(255, 255, 0, 0.3);\n  color: #ffff00;\n  padding: 2px 4px;\n  border-radius: 2px;\n}\n\n.vfs-folder-header {\n  font-weight: 600;\n  color: #00ffff;\n}\n\n.vfs-file {\n  color: rgba(255, 255, 255, 0.9);\n}\n\n.vfs-expand {\n  display: inline-block;\n  width: 16px;\n  text-align: center;\n  font-size: 10px;\n  color: rgba(0, 255, 255, 0.7);\n}\n\n.vfs-icon {\n  font-size: 14px;\n  min-width: 20px;\n}\n\n.vfs-name {\n  flex: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.vfs-count {\n  font-size: 11px;\n  color: rgba(0, 255, 255, 0.6);\n  margin-left: 4px;\n}\n\n.vfs-size {\n  font-size: 11px;\n  color: rgba(0, 255, 255, 0.6);\n  margin-left: auto;\n}\n\n.vfs-children.collapsed {\n  display: none;\n}\n\n.vfs-children.expanded {\n  display: block;\n}\n\n.vfs-stats {\n  padding: 8px;\n  text-align: center;\n  font-size: 11px;\n  color: rgba(0, 255, 255, 0.6);\n  background: rgba(0, 255, 255, 0.05);\n  border-top: 1px solid rgba(0, 255, 255, 0.2);\n}\n\n/* File Viewer Modal */\n\n.vfs-file-viewer-modal {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 10000;\n  display: none;\n  align-items: center;\n  justify-content: center;\n  animation: fadeIn 0.2s;\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.vfs-file-viewer-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.8);\n  backdrop-filter: blur(4px);\n}\n\n.vfs-file-viewer-content {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  width: 90%;\n  max-width: 1200px;\n  height: 80vh;\n  background: rgba(0, 20, 40, 0.95);\n  border: 2px solid rgba(0, 255, 255, 0.5);\n  border-radius: 8px;\n  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);\n  animation: slideIn 0.3s ease-out;\n}\n\n@keyframes slideIn {\n  from {\n    transform: translateY(-20px);\n    opacity: 0;\n  }\n  to {\n    transform: translateY(0);\n    opacity: 1;\n  }\n}\n\n.vfs-file-viewer-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 12px 16px;\n  background: rgba(0, 255, 255, 0.1);\n  border-bottom: 1px solid rgba(0, 255, 255, 0.3);\n}\n\n.vfs-file-viewer-title {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  color: #00ffff;\n  font-family: 'Courier New', monospace;\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.vfs-file-viewer-close {\n  padding: 4px 8px;\n  background: transparent;\n  border: 1px solid rgba(255, 0, 0, 0.5);\n  border-radius: 4px;\n  color: #ff6666;\n  font-size: 18px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.vfs-file-viewer-close:hover {\n  background: rgba(255, 0, 0, 0.2);\n  border-color: #ff0000;\n  box-shadow: 0 0 8px rgba(255, 0, 0, 0.3);\n}\n\n.vfs-file-viewer-meta {\n  padding: 8px 16px;\n  font-size: 12px;\n  color: rgba(0, 255, 255, 0.7);\n  background: rgba(0, 0, 0, 0.3);\n  border-bottom: 1px solid rgba(0, 255, 255, 0.2);\n}\n\n.vfs-file-viewer-body {\n  flex: 1;\n  overflow: auto;\n  padding: 16px;\n  background: rgba(0, 0, 0, 0.5);\n}\n\n.vfs-file-viewer-body::-webkit-scrollbar {\n  width: 12px;\n  height: 12px;\n}\n\n.vfs-file-viewer-body::-webkit-scrollbar-track {\n  background: rgba(0, 0, 0, 0.3);\n}\n\n.vfs-file-viewer-body::-webkit-scrollbar-thumb {\n  background: rgba(0, 255, 255, 0.3);\n  border-radius: 6px;\n}\n\n.vfs-file-viewer-body::-webkit-scrollbar-thumb:hover {\n  background: rgba(0, 255, 255, 0.5);\n}\n\n.vfs-file-viewer-body pre {\n  margin: 0;\n  font-family: 'Courier New', monospace;\n  font-size: 13px;\n  line-height: 1.6;\n  color: #ffffff;\n}\n\n.vfs-file-viewer-body code {\n  display: block;\n  white-space: pre;\n  color: #ffffff;\n}\n\n.vfs-file-viewer-footer {\n  display: flex;\n  gap: 8px;\n  padding: 12px 16px;\n  background: rgba(0, 255, 255, 0.1);\n  border-top: 1px solid rgba(0, 255, 255, 0.3);\n}\n\n.vfs-file-viewer-footer button {\n  padding: 8px 16px;\n  background: rgba(0, 255, 255, 0.1);\n  border: 1px solid rgba(0, 255, 255, 0.3);\n  border-radius: 4px;\n  color: #00ffff;\n  font-size: 13px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.vfs-file-viewer-footer button:hover {\n  background: rgba(0, 255, 255, 0.2);\n  border-color: #00ffff;\n  box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);\n}\n\n/* ========================================\n   MOBILE RESPONSIVE DESIGN\n   ======================================== */\n\n/* Tablet breakpoint */\n@media (max-width: 1024px) {\n  .vfs-toolbar {\n    gap: 6px;\n    padding: 6px;\n  }\n\n  .vfs-item {\n    padding: 3px 6px;\n    font-size: 12px;\n  }\n\n  .vfs-file-viewer-content {\n    width: 92%;\n    height: 85vh;\n  }\n}\n\n/* Mobile breakpoint */\n@media (max-width: 768px) {\n  .vfs-explorer {\n    font-size: 12px;\n  }\n\n  .vfs-toolbar {\n    flex-wrap: wrap;\n    padding: 6px;\n  }\n\n  .vfs-search {\n    min-width: 100%;\n    flex-basis: 100%;\n    order: 1;\n    font-size: 12px;\n  }\n\n  .vfs-toolbar button {\n    padding: 6px 10px;\n    font-size: 14px;\n  }\n\n  .vfs-tree {\n    font-size: 11px;\n  }\n\n  .vfs-item {\n    padding: 4px 6px;\n    gap: 4px;\n  }\n\n  .vfs-icon {\n    font-size: 12px;\n    min-width: 18px;\n  }\n\n  .vfs-size,\n  .vfs-count {\n    font-size: 10px;\n  }\n\n  .vfs-stats {\n    padding: 6px;\n    font-size: 10px;\n  }\n\n  /* File viewer modal */\n  .vfs-file-viewer-content {\n    width: 95%;\n    height: 90vh;\n  }\n\n  .vfs-file-viewer-header {\n    padding: 10px 12px;\n  }\n\n  .vfs-file-viewer-title {\n    font-size: 12px;\n    gap: 6px;\n  }\n\n  .vfs-file-viewer-meta {\n    padding: 6px 12px;\n    font-size: 11px;\n  }\n\n  .vfs-file-viewer-body {\n    padding: 12px;\n  }\n\n  .vfs-file-viewer-body pre {\n    font-size: 11px;\n    line-height: 1.5;\n  }\n\n  .vfs-file-viewer-footer {\n    padding: 10px 12px;\n    gap: 6px;\n    flex-wrap: wrap;\n  }\n\n  .vfs-file-viewer-footer button {\n    padding: 6px 12px;\n    font-size: 12px;\n    flex: 1;\n    min-width: 80px;\n  }\n}\n\n/* Small mobile breakpoint */\n@media (max-width: 480px) {\n  .vfs-toolbar button {\n    padding: 5px 8px;\n    font-size: 12px;\n  }\n\n  .vfs-item {\n    padding: 3px 4px;\n    font-size: 10px;\n  }\n\n  .vfs-name {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    max-width: 150px;\n  }\n\n  .vfs-file-viewer-content {\n    width: 98%;\n    height: 95vh;\n    border-radius: 4px;\n  }\n\n  .vfs-file-viewer-title {\n    font-size: 11px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .vfs-file-viewer-body {\n    padding: 8px;\n  }\n\n  .vfs-file-viewer-body pre {\n    font-size: 10px;\n    line-height: 1.4;\n  }\n\n  .vfs-file-viewer-footer button {\n    font-size: 11px;\n    padding: 5px 10px;\n  }\n}\n\n/* touch optimizations */\n@media (hover: none) and (pointer: coarse) {\n  .vfs-item {\n    min-height: 36px;\n    align-items: center;\n  }\n\n  .vfs-toolbar button {\n    min-height: 36px;\n    min-width: 36px;\n  }\n\n  .vfs-file-viewer-close {\n    min-height: 40px;\n    min-width: 40px;\n  }\n\n  .vfs-file-viewer-footer button {\n    min-height: 40px;\n  }\n\n  /* Better scroll */\n  .vfs-tree {\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .vfs-file-viewer-body {\n    -webkit-overflow-scrolling: touch;\n  }\n}\n\n/* Landscape mobile */\n@media (max-height: 500px) and (orientation: landscape) {\n  .vfs-file-viewer-content {\n    height: 95vh;\n  }\n\n  .vfs-file-viewer-body pre {\n    font-size: 10px;\n  }\n}",
      "hash": "6a5856c32937ba12fe2a64f4d41f34aca77155e6aac823ed166cbc3360767c2a"
    },
    "styles/theme.css": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 8760,
        "binary": false
      },
      "content": "/* ========================================\n   REPLOID Design System - Unified Theme\n   Modern IDE palette with semantic tokens\n   ======================================== */\n\n:root {\n  /* ---- Background Surfaces ---- */\n  --bg-app: #09090b;\n  --bg-panel: #18181b;\n  --bg-element: #27272a;\n  --bg-elevated: #1f1f23;\n  --bg-hover: rgba(63, 63, 70, 0.5);\n  --bg-active: rgba(6, 182, 212, 0.1);\n\n  /* ---- Borders ---- */\n  --border-subtle: #27272a;\n  --border-default: #3f3f46;\n  --border-active: #52525b;\n\n  /* ---- Text ---- */\n  --text-primary: #e4e4e7;\n  --text-secondary: #a1a1aa;\n  --text-muted: #71717a;\n  --text-disabled: #52525b;\n\n  /* ---- Functional Accents ---- */\n  --primary: #06b6d4;\n  --primary-dim: rgba(6, 182, 212, 0.15);\n  --primary-bright: rgba(6, 182, 212, 0.3);\n\n  --success: #10b981;\n  --success-dim: rgba(16, 185, 129, 0.15);\n\n  --warning: #f59e0b;\n  --warning-dim: rgba(245, 158, 11, 0.15);\n\n  --danger: #ef4444;\n  --danger-dim: rgba(239, 68, 68, 0.15);\n\n  /* ---- Legacy Aliases (for backward compatibility) ---- */\n  --accent-cyan: var(--primary);\n  --accent-cyan-dim: var(--primary-dim);\n  --accent-cyan-bright: var(--primary-bright);\n  --accent-gold: var(--warning);\n  --accent-gold-dim: var(--warning-dim);\n  --error: var(--danger);\n  --error-bg: var(--danger-dim);\n  --success-bg: var(--success-dim);\n  --warning-bg: var(--warning-dim);\n\n  /* ---- Spacing Scale ---- */\n  --space-xs: 4px;\n  --space-sm: 8px;\n  --space-md: 12px;\n  --space-lg: 16px;\n  --space-xl: 24px;\n  --space-2xl: 32px;\n\n  /* ---- Typography Scale ---- */\n  --font-xs: 10px;\n  --font-sm: 11px;\n  --font-base: 13px;\n  --font-md: 14px;\n  --font-lg: 16px;\n  --font-xl: 18px;\n  --font-2xl: 24px;\n\n  /* ---- Border Radius ---- */\n  --radius-sm: 3px;\n  --radius-md: 6px;\n  --radius-lg: 8px;\n  --radius-xl: 12px;\n\n  /* ---- Transitions ---- */\n  --transition-fast: 0.1s ease;\n  --transition-normal: 0.2s ease;\n  --transition-slow: 0.3s ease;\n\n  /* ---- Shadows ---- */\n  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);\n  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);\n  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);\n\n  /* ---- Scrollbar ---- */\n  --scrollbar-bg: var(--bg-panel);\n  --scrollbar-thumb: var(--border-default);\n  --scrollbar-thumb-hover: var(--border-active);\n}\n\n/* ========================================\n   Global Reset\n   ======================================== */\n\n* {\n  box-sizing: border-box;\n}\n\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\nhtml {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  background: var(--bg-app);\n  color: var(--text-primary);\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  font-size: var(--font-base);\n  line-height: 1.5;\n}\n\n/* ========================================\n   Scrollbar Styling\n   ======================================== */\n\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: var(--scrollbar-bg);\n}\n\n::-webkit-scrollbar-thumb {\n  background: var(--scrollbar-thumb);\n  border-radius: var(--radius-md);\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: var(--scrollbar-thumb-hover);\n}\n\n/* ========================================\n   Common Component Classes\n   ======================================== */\n\n/* Buttons */\n.btn {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-sm);\n  padding: var(--space-sm) var(--space-lg);\n  font-family: inherit;\n  font-size: var(--font-sm);\n  font-weight: 500;\n  border-radius: var(--radius-md);\n  border: 1px solid transparent;\n  cursor: pointer;\n  transition: all var(--transition-normal);\n}\n\n.btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.btn-primary {\n  background: var(--primary-dim);\n  border-color: var(--primary);\n  color: var(--primary);\n}\n\n.btn-primary:hover:not(:disabled) {\n  background: var(--primary-bright);\n}\n\n.btn-secondary {\n  background: var(--bg-element);\n  border-color: var(--border-default);\n  color: var(--text-secondary);\n}\n\n.btn-secondary:hover:not(:disabled) {\n  background: var(--bg-hover);\n  border-color: var(--border-active);\n  color: var(--text-primary);\n}\n\n.btn-danger {\n  background: var(--danger-dim);\n  border-color: var(--danger);\n  color: var(--danger);\n}\n\n.btn-danger:hover:not(:disabled) {\n  background: rgba(239, 68, 68, 0.25);\n}\n\n.btn-sm {\n  padding: var(--space-xs) var(--space-sm);\n  font-size: var(--font-xs);\n}\n\n.btn-icon {\n  padding: var(--space-sm);\n  width: 32px;\n  height: 32px;\n}\n\n/* Cards */\n.card {\n  background: var(--bg-panel);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-md);\n  overflow: hidden;\n}\n\n.card:hover {\n  border-color: var(--border-default);\n}\n\n.card-header {\n  padding: var(--space-md) var(--space-lg);\n  border-bottom: 1px solid var(--border-subtle);\n  font-weight: 600;\n  font-size: var(--font-sm);\n  color: var(--text-secondary);\n}\n\n.card-body {\n  padding: var(--space-lg);\n}\n\n.card-footer {\n  padding: var(--space-md) var(--space-lg);\n  border-top: 1px solid var(--border-subtle);\n}\n\n/* Inputs */\n.input {\n  width: 100%;\n  padding: var(--space-sm) var(--space-md);\n  background: var(--bg-element);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  font-family: inherit;\n  font-size: var(--font-base);\n  transition: border-color var(--transition-normal);\n}\n\n.input:focus {\n  outline: none;\n  border-color: var(--primary);\n}\n\n.input::placeholder {\n  color: var(--text-muted);\n}\n\n/* Badges */\n.badge {\n  display: inline-flex;\n  align-items: center;\n  padding: 2px var(--space-sm);\n  border-radius: var(--radius-sm);\n  font-size: var(--font-xs);\n  font-weight: 600;\n  text-transform: uppercase;\n}\n\n.badge-success {\n  background: var(--success-dim);\n  color: var(--success);\n}\n\n.badge-warning {\n  background: var(--warning-dim);\n  color: var(--warning);\n}\n\n.badge-danger {\n  background: var(--danger-dim);\n  color: var(--danger);\n}\n\n/* Status indicators */\n.status-dot {\n  display: inline-block;\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n}\n\n.status-dot-success {\n  background: var(--success);\n}\n\n.status-dot-warning {\n  background: var(--warning);\n}\n\n.status-dot-danger {\n  background: var(--danger);\n}\n\n.status-dot-idle {\n  background: var(--text-muted);\n}\n\n/* Monospace text */\n.mono {\n  font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;\n}\n\n/* Text utilities */\n.text-primary { color: var(--text-primary); }\n.text-secondary { color: var(--text-secondary); }\n.text-muted { color: var(--text-muted); }\n.text-success { color: var(--success); }\n.text-warning { color: var(--warning); }\n.text-danger { color: var(--danger); }\n\n/* Layout utilities */\n.hidden { display: none !important; }\n.flex { display: flex; }\n.flex-col { flex-direction: column; }\n.items-center { align-items: center; }\n.justify-between { justify-content: space-between; }\n.gap-sm { gap: var(--space-sm); }\n.gap-md { gap: var(--space-md); }\n.gap-lg { gap: var(--space-lg); }\n\n/* ========================================\n   IDE Shell Layout\n   ======================================== */\n\n.app-shell {\n  display: grid;\n  grid-template-columns: 48px 1fr 320px;\n  grid-template-rows: 1fr;\n  height: 100vh;\n  width: 100%;\n}\n\n.sidebar {\n  background: var(--bg-panel);\n  border-right: 1px solid var(--border-subtle);\n  display: flex;\n  flex-direction: column;\n  padding: var(--space-sm);\n  gap: var(--space-xs);\n}\n\n.sidebar-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 32px;\n  height: 32px;\n  border: none;\n  border-radius: var(--radius-md);\n  background: transparent;\n  color: var(--text-muted);\n  cursor: pointer;\n  transition: all var(--transition-normal);\n  font-size: var(--font-md);\n}\n\n.sidebar-btn:hover {\n  background: var(--bg-hover);\n  color: var(--text-primary);\n}\n\n.sidebar-btn.active {\n  background: var(--primary-dim);\n  color: var(--primary);\n}\n\n.sidebar-spacer {\n  flex: 1;\n}\n\n.workspace {\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.workspace-header {\n  padding: var(--space-md) var(--space-lg);\n  border-bottom: 1px solid var(--border-subtle);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.workspace-content {\n  flex: 1;\n  overflow: auto;\n  padding: var(--space-lg);\n}\n\n.utility-panel {\n  background: var(--bg-panel);\n  border-left: 1px solid var(--border-subtle);\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n/* Responsive adjustments */\n@media (max-width: 1024px) {\n  .app-shell {\n    grid-template-columns: 48px 1fr;\n  }\n\n  .utility-panel {\n    display: none;\n  }\n}\n\n@media (max-width: 768px) {\n  .app-shell {\n    grid-template-columns: 1fr;\n  }\n\n  .sidebar {\n    display: none;\n  }\n}\n",
      "hash": "8b440b5d1c624d402108b6514197f0840bc009fa51beeabf2f4f518c281692dc"
    },
    "styles/dashboard.css": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 14343,
        "binary": false
      },
      "content": "/* Dashboard Styles\n   Uses tokens from theme.css\n   Legacy variable mappings for backward compatibility */\n\n:root {\n    /* Map old variable names to new theme tokens */\n    --bg-primary: var(--bg-app);\n    --bg-secondary: var(--bg-panel);\n    --bg-tertiary: var(--bg-element);\n    --border-primary: var(--primary);\n    --border-secondary: var(--border-subtle);\n    --border-color: var(--border-subtle);\n}\n\n/* ========================================\n   DASHBOARD LAYOUT\n   ======================================== */\n\n#app {\n    width: 100%;\n    height: 100vh;\n}\n\n.dashboard-container {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    height: 100vh;\n    background: var(--bg-primary);\n    color: var(--text-primary);\n    font-family: 'Courier New', monospace;\n}\n\n.dashboard-header {\n    padding: var(--space-lg);\n    border-bottom: 1px solid var(--border-primary);\n    background: var(--bg-secondary);\n}\n\n.dashboard-header h1 {\n    margin: 0 0 var(--space-sm) 0;\n    color: var(--accent-cyan);\n    font-size: var(--font-xl);\n}\n\n.status-bar {\n    font-size: var(--font-sm);\n    color: var(--text-secondary);\n    margin-bottom: var(--space-md);\n}\n\n.controls {\n    display: flex;\n    gap: var(--space-md);\n    align-items: center;\n}\n\n.controls input {\n    flex: 1;\n    padding: var(--space-sm) var(--space-md);\n    background: var(--bg-tertiary);\n    border: 1px solid var(--border-primary);\n    border-radius: var(--radius-md);\n    color: var(--text-primary);\n    font-size: var(--font-base);\n    font-family: inherit;\n}\n\n.controls input:focus {\n    outline: none;\n    border-color: var(--accent-cyan);\n}\n\n.controls button {\n    padding: var(--space-sm) var(--space-lg);\n    background: var(--accent-cyan-dim);\n    border: 1px solid var(--accent-cyan);\n    border-radius: var(--radius-md);\n    color: var(--accent-cyan);\n    cursor: pointer;\n    font-weight: 600;\n    font-family: inherit;\n    transition: all var(--transition-normal);\n}\n\n.controls button:hover:not(:disabled) {\n    background: var(--accent-cyan-bright);\n}\n\n.controls button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n/* Small button variant */\n.btn-small {\n    padding: var(--space-xs) var(--space-sm);\n    background: var(--accent-cyan-dim);\n    border: 1px solid var(--accent-cyan);\n    border-radius: var(--radius-sm);\n    color: var(--accent-cyan);\n    cursor: pointer;\n    font-size: var(--font-xs);\n    font-family: inherit;\n    transition: all var(--transition-normal);\n}\n\n.btn-small:hover {\n    background: var(--accent-cyan-bright);\n}\n\n.dashboard-main {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n}\n\n.panel {\n    flex: 1;\n    padding: var(--space-lg);\n    overflow: auto;\n    display: flex;\n    flex-direction: column;\n}\n\n.left-panel {\n    border-right: 1px solid var(--border-secondary);\n}\n\n.right-panel {\n    background: var(--bg-panel);\n}\n\n/* ========================================\n   LOG CONTAINER\n   ======================================== */\n\n.log-container {\n    height: calc(100% - 30px);\n    overflow-y: auto;\n    font-family: monospace;\n    font-size: var(--font-sm);\n    background: var(--bg-tertiary);\n    padding: var(--space-md);\n    border-radius: var(--radius-md);\n}\n\n.log-entry {\n    padding: var(--space-xs) 0;\n    border-bottom: 1px solid var(--border-secondary);\n}\n\n.log-info { color: var(--text-primary); }\n.log-warn { color: var(--warning); }\n.log-error { color: var(--error); }\n.log-debug { color: var(--text-muted); }\n\n/* Reflection Entries */\n.reflection-entry {\n    padding: var(--space-sm);\n    margin-bottom: var(--space-xs);\n    border-radius: var(--radius-sm);\n    border-left: 3px solid transparent;\n}\n\n.reflection-success {\n    background: var(--success-bg);\n    border-left-color: var(--success);\n}\n\n.reflection-error {\n    background: var(--error-bg);\n    border-left-color: var(--error);\n}\n\n.reflection-header {\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n    font-size: var(--font-sm);\n}\n\n.reflection-icon {\n    font-weight: bold;\n}\n\n.reflection-success .reflection-icon {\n    color: var(--success);\n}\n\n.reflection-error .reflection-icon {\n    color: var(--error);\n}\n\n.reflection-tool {\n    color: var(--text-primary);\n    font-weight: 600;\n    flex: 1;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.reflection-cycle {\n    color: var(--text-muted);\n    font-size: var(--font-xs);\n}\n\n.reflection-detail {\n    margin-top: var(--space-xs);\n    font-size: var(--font-xs);\n    color: var(--text-secondary);\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n/* ========================================\n   UTILITY CLASSES\n   ======================================== */\n\n/* .hidden defined in theme.css */\n\n.badge {\n    display: inline-block;\n    padding: 2px var(--space-sm);\n    border-radius: var(--radius-sm);\n    font-size: var(--font-xs);\n    font-weight: bold;\n    text-transform: uppercase;\n}\n\n.success { color: var(--success); }\n.warning { color: var(--warning); }\n.error { color: var(--error); }\n\n.card {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-secondary);\n    border-radius: var(--radius-md);\n    padding: var(--space-lg);\n}\n\n.card:hover {\n    border-color: var(--border-primary);\n}\n\n.card-header {\n    color: var(--accent-cyan);\n    font-weight: bold;\n    margin-bottom: var(--space-md);\n    padding-bottom: var(--space-sm);\n    border-bottom: 1px solid var(--border-secondary);\n}\n\n.card-body {\n    color: var(--text-primary);\n    line-height: 1.6;\n}\n\n.card-footer {\n    margin-top: var(--space-md);\n    padding-top: var(--space-sm);\n    border-top: 1px solid var(--border-secondary);\n}\n\n/* Agent Status */\n#agent-status-container {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-sm);\n    margin-bottom: var(--space-md);\n}\n\n.status-item {\n    display: flex;\n    justify-content: space-between;\n    padding: var(--space-sm);\n    background: var(--bg-tertiary);\n    border-radius: var(--radius-sm);\n}\n\n.status-label {\n    color: var(--text-muted);\n    font-size: var(--font-sm);\n}\n\n.status-value {\n    color: var(--accent-cyan);\n    font-size: var(--font-sm);\n    font-weight: 600;\n}\n\n/* History Entries */\n.history-entry {\n    margin-bottom: var(--space-md);\n    border: 1px solid var(--border-secondary);\n    border-radius: var(--radius-sm);\n    overflow: hidden;\n}\n\n.history-header {\n    background: var(--bg-tertiary);\n    padding: var(--space-sm) var(--space-md);\n    font-size: var(--font-sm);\n    font-weight: 600;\n    color: var(--accent-cyan);\n    border-bottom: 1px solid var(--border-secondary);\n}\n\n.history-content {\n    margin: 0;\n    padding: var(--space-md);\n    font-size: var(--font-xs);\n    overflow-x: auto;\n    white-space: pre-wrap;\n    word-break: break-word;\n    max-height: 300px;\n    overflow-y: auto;\n}\n\n/* Streaming animation */\n.history-entry.streaming .history-header {\n    color: var(--warning);\n}\n\n.history-entry.streaming .history-header::after {\n    content: '';\n    animation: pulse 1s ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.5; }\n}\n\n/* ========================================\n   SCROLLBAR\n   ======================================== */\n\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--scrollbar-bg);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--scrollbar-thumb);\n    border-radius: var(--radius-md);\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--scrollbar-thumb-hover);\n}\n\n/* ========================================\n   RESPONSIVE\n   ======================================== */\n\n@media (max-width: 768px) {\n    .dashboard-main {\n        flex-direction: column;\n    }\n\n    .left-panel {\n        border-right: none;\n        border-bottom: 1px solid var(--border-secondary);\n    }\n\n    .panel {\n        max-height: 50vh;\n    }\n}\n\n/* ========================================\n   IDE LAYOUT ADDITIONS\n   ======================================== */\n\n/* Workspace Title */\n.workspace-title {\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n    font-size: var(--font-sm);\n    overflow: hidden;\n}\n\n.workspace-title span:last-child {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n/* Workspace Status */\n.workspace-status {\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n    font-size: var(--font-sm);\n}\n\n/* History Stream */\n.history-stream {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-md);\n}\n\n/* Reflections Stream */\n.reflections-stream {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-xs);\n}\n\n/* Status Panel */\n.status-panel {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-sm);\n}\n\n/* Utility Panel Header */\n.utility-header {\n    padding: var(--space-md) var(--space-lg);\n    border-bottom: 1px solid var(--border-subtle);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    font-size: var(--font-sm);\n    font-weight: 600;\n    color: var(--text-secondary);\n}\n\n/* VFS Tree */\n.vfs-tree {\n    flex: 1;\n    overflow: auto;\n    padding: var(--space-sm);\n    border-bottom: 1px solid var(--border-subtle);\n    font-size: var(--font-xs);\n}\n\n.vfs-tree .vfs-dir {\n    color: var(--warning);\n    font-weight: 600;\n    margin-top: var(--space-xs);\n}\n\n.vfs-tree .vfs-file {\n    padding: 2px var(--space-sm);\n    cursor: pointer;\n    color: var(--text-secondary);\n    border-radius: var(--radius-sm);\n}\n\n.vfs-tree .vfs-file:hover {\n    background: var(--bg-hover);\n    color: var(--primary);\n}\n\n/* VFS Content */\n.vfs-content {\n    flex: 1;\n    overflow: auto;\n    padding: var(--space-sm);\n    font-size: var(--font-xs);\n    white-space: pre-wrap;\n    word-break: break-all;\n}\n\n.vfs-file-path {\n    color: var(--primary);\n    font-weight: 600;\n    margin-bottom: var(--space-sm);\n    padding-bottom: var(--space-xs);\n    border-bottom: 1px solid var(--border-subtle);\n}\n\n/* Confirmation Modal */\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.72);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 10000;\n    animation: fadeIn 0.2s ease;\n}\n\n.modal-content {\n    background: var(--bg-panel);\n    border: 2px solid var(--primary-dim);\n    border-radius: var(--radius-lg);\n    min-width: 360px;\n    max-width: 560px;\n    max-height: 80vh;\n    overflow: auto;\n    box-shadow: var(--shadow-lg);\n    animation: slideIn 0.3s ease;\n}\n\n.modal-content.modal-danger {\n    border-color: var(--danger-dim);\n}\n\n.modal-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: var(--space-lg);\n    border-bottom: 1px solid var(--border-default);\n}\n\n.modal-title {\n    margin: 0;\n    font-size: var(--font-lg);\n    color: var(--primary);\n    font-family: 'Courier New', monospace;\n}\n\n.modal-content.modal-danger .modal-title {\n    color: var(--danger);\n}\n\n.modal-close {\n    background: transparent;\n    border: none;\n    color: var(--text-secondary);\n    font-size: var(--font-lg);\n    cursor: pointer;\n}\n\n.modal-body {\n    padding: var(--space-lg);\n}\n\n.modal-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: var(--space-sm);\n    padding: var(--space-lg);\n    border-top: 1px solid var(--border-default);\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n}\n\n@keyframes slideIn {\n    from { transform: translateY(-12px); opacity: 0; }\n    to { transform: translateY(0); opacity: 1; }\n}\n\n@media (max-width: 640px) {\n    .modal-content {\n        width: 92%;\n        min-width: auto;\n    }\n\n    .modal-actions {\n        flex-direction: column-reverse;\n    }\n\n    .modal-actions .btn {\n        width: 100%;\n    }\n}\n\n/* ========================================\n   Diff Viewer\n   ======================================== */\n.diff-viewer {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-default);\n    border-radius: var(--radius-lg);\n    color: var(--text-primary);\n    font-family: 'Courier New', monospace;\n    padding: var(--space-lg);\n}\n\n.diff-header,\n.diff-footer {\n    border-bottom: 1px solid var(--border-default);\n    margin-bottom: var(--space-lg);\n    padding-bottom: var(--space-md);\n}\n\n.diff-footer {\n    border-top: 1px solid var(--border-default);\n    border-bottom: none;\n    margin-top: var(--space-lg);\n    padding-top: var(--space-md);\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n}\n\n.diff-actions {\n    display: flex;\n    gap: var(--space-sm);\n    margin-bottom: var(--space-lg);\n    flex-wrap: wrap;\n}\n\n.diff-files {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-sm);\n}\n\n.diff-file {\n    background: var(--bg-element);\n    border-radius: var(--radius-md);\n    overflow: hidden;\n}\n\n.diff-file-header {\n    display: flex;\n    justify-content: space-between;\n    padding: var(--space-md);\n    background: var(--bg-panel);\n    align-items: center;\n    gap: var(--space-md);\n}\n\n.diff-file-info {\n    display: flex;\n    gap: var(--space-md);\n    align-items: center;\n    flex-wrap: wrap;\n}\n\n.diff-operation {\n    border-radius: var(--radius-sm);\n    font-size: var(--font-xs);\n    padding: 2px 8px;\n    text-transform: uppercase;\n}\n\n.diff-operation.create {\n    background: var(--success-dim);\n    color: var(--bg-app);\n}\n\n.diff-operation.modify {\n    background: var(--warning-dim);\n    color: var(--bg-app);\n}\n\n.diff-operation.delete {\n    background: var(--danger-dim);\n    color: var(--bg-app);\n}\n\n.diff-file-actions {\n    display: flex;\n    gap: var(--space-sm);\n    align-items: center;\n    flex-wrap: wrap;\n}\n\n.side-by-side-diff {\n    display: flex;\n    gap: 2px;\n}\n\n.diff-pane {\n    flex: 1;\n    overflow-x: auto;\n}\n\n.diff-line {\n    display: flex;\n    min-height: 20px;\n}\n\n.diff-line.added {\n    background: rgba(16, 185, 129, 0.15);\n}\n\n.diff-line.removed {\n    background: rgba(239, 68, 68, 0.15);\n}\n\n.diff-line.changed {\n    background: rgba(245, 158, 11, 0.15);\n}\n\n.line-number {\n    width: 40px;\n    color: var(--text-muted);\n    text-align: right;\n    padding-right: var(--space-sm);\n    user-select: none;\n}\n\n.code-block {\n    background: var(--bg-panel);\n    padding: var(--space-md);\n    overflow-x: auto;\n    border-radius: var(--radius-md);\n    font-size: var(--font-xs);\n}\n",
      "hash": "dd3ef9ff5610be0cfc445ba06c2361d55a1148ee4e7fc85ecf717d1cdc0aaf74"
    },
    "styles/boot.css": {
      "meta": {
        "mtimeMs": 1763677825555.2888,
        "size": 18436,
        "binary": false
      },
      "content": "/* New Persona-Based Onboarding Styles */\n\n:root {\n  --color-primary: #0ff;\n  --color-secondary: #888;\n  --color-bg-primary: #0a0a14;\n  --color-text-primary: #e0e0e0;\n  --color-border: #333;\n  --font-family: 'Courier New', monospace;\n}\n\nbody {\n  font-family: var(--font-family);\n  background: var(--color-bg-primary);\n  color: var(--color-text-primary);\n  margin: 0;\n  padding: 20px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  box-sizing: border-box;\n}\n\n/* Boot message animations */\n@keyframes slideDown {\n  from {\n    opacity: 0;\n    transform: translateX(-50%) translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(-50%) translateY(0);\n  }\n}\n\n@keyframes slideUp {\n  from {\n    opacity: 1;\n    transform: translateX(-50%) translateY(0);\n  }\n  to {\n    opacity: 0;\n    transform: translateX(-50%) translateY(-20px);\n  }\n}\n\n#boot-container {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  max-width: 1200px;\n  text-align: center;\n  box-sizing: border-box;\n  min-height: 100vh;\n  padding: 20px 40px;\n  align-items: center;\n  justify-content: flex-start;\n  margin: 0 auto;\n}\n\n.boot-header {\n  margin-bottom: 30px;\n  max-width: 900px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.boot-header h1 {\n  color: var(--color-primary);\n  text-shadow: 0 0 10px var(--color-primary);\n  font-size: 2.5em;\n  margin: 0 0 5px 0;\n  background: linear-gradient(90deg, #00ffff, #ffd700, #00ffff);\n  background-size: 200% auto;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n  animation: shimmer 3s linear infinite;\n}\n\n@keyframes shimmer {\n  0% {\n    background-position: 0% center;\n  }\n  100% {\n    background-position: 200% center;\n  }\n}\n\n.boot-header .subtitle {\n  color: var(--color-secondary);\n  font-size: 1em;\n  margin: 0 0 20px 0;\n  opacity: 0.8;\n}\n\n.subtitle-link {\n  color: #999;\n  text-decoration: none;\n  transition: all 0.3s ease;\n  border-bottom: 1px dashed #666;\n  text-shadow: none;\n}\n\n.subtitle-link:hover {\n  opacity: 1;\n  color: #bbb;\n  border-bottom-style: solid;\n}\n\n/* Provider Status Bar */\n.provider-status-bar {\n  display: flex;\n  gap: 12px;\n  padding: 16px 0;\n  margin: 24px 0 16px 0;\n  flex-wrap: wrap;\n}\n\n.provider-status-item {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 8px 14px;\n  background: rgba(0, 255, 255, 0.05);\n  border: 1px solid rgba(0, 255, 255, 0.2);\n  border-radius: 0;\n  flex: 1;\n  min-width: 150px;\n  transition: all 0.2s ease;\n}\n\n.provider-status-icon {\n  font-size: 14px;\n  color: #666;\n  transition: color 0.3s ease;\n}\n\n.provider-status-icon.online {\n  color: #4ec9b0;\n}\n\n.provider-status-icon.offline {\n  color: #e74856;\n}\n\n.provider-status-label {\n  font-size: 13px;\n  color: var(--color-primary);\n  font-weight: 500;\n}\n\n.provider-status-value {\n  font-size: 12px;\n  color: #aaa;\n  margin-left: auto;\n  font-weight: 400;\n}\n\n.provider-status-value.online {\n  color: #4ec9b0;\n}\n\n.provider-status-value.offline {\n  color: #e74856;\n}\n\n.provider-status.connecting {\n  background: rgba(255, 215, 0, 0.1);\n  color: #ffd700;\n  border: 1px solid rgba(255, 215, 0, 0.3);\n  animation: pulse 1.5s infinite;\n}\n\n@keyframes pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.6; }\n}\n\n/* Model Cards Container */\n.model-cards-container {\n  margin: 0 0 24px 0;\n  padding: 20px;\n  width: 100%;\n  background: rgba(0, 255, 255, 0.03);\n  border: 1px solid var(--color-border);\n  border-radius: 0;\n  box-sizing: border-box;\n}\n\n.model-cards-title {\n  margin: 0 0 16px 0;\n  font-size: 16px;\n  color: var(--color-primary);\n  font-weight: 600;\n}\n\n.model-cards-list {\n  display: flex;\n  flex-direction: row;\n  gap: 12px;\n  margin-bottom: 16px;\n  overflow-x: auto;\n  padding-bottom: 8px;\n}\n\n.model-card {\n  position: relative;\n  background: rgba(40, 40, 40, 0.4);\n  border: 2px solid rgba(80, 80, 80, 0.3);\n  border-radius: 0;\n  padding: 16px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  min-height: 120px;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  min-width: 220px;\n  max-width: 220px;\n  flex-shrink: 0;\n}\n\n.model-card:hover {\n  background: rgba(60, 60, 60, 0.5);\n  border-color: rgba(150, 150, 150, 0.5);\n  box-shadow: 0 4px 12px rgba(80, 80, 80, 0.3);\n}\n\n.model-card-provider {\n  font-size: 11px;\n  color: #888;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  margin-bottom: 6px;\n}\n\n.model-card-name {\n  font-size: 14px;\n  font-weight: 600;\n  color: var(--color-text-primary);\n  margin-bottom: 8px;\n  word-break: break-word;\n}\n\n.model-card-connection {\n  font-size: 11px;\n  color: #4ec9b0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 4px;\n}\n\n.model-card-connection::before {\n  content: 'â˜…';\n  font-size: 8px;\n}\n\n.model-card-actions {\n  display: flex;\n  gap: 8px;\n  margin-top: 12px;\n  padding-top: 12px;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.model-card-btn {\n  flex: 1;\n  padding: 6px;\n  background: rgba(255, 255, 255, 0.05);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 0;\n  color: var(--color-text-primary);\n  font-size: 11px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.model-card-btn:hover {\n  background: rgba(255, 255, 255, 0.1);\n  border-color: var(--color-primary);\n}\n\n.model-card-btn.remove:hover {\n  background: rgba(231, 72, 86, 0.2);\n  border-color: #e74856;\n  color: #e74856;\n}\n\n.add-model-card {\n  background: transparent;\n  border: 2px dashed rgba(0, 255, 255, 0.3);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  min-height: 120px;\n  transition: all 0.3s ease;\n}\n\n.add-model-card:hover {\n  background: rgba(60, 60, 60, 0.5);\n  border-color: rgba(150, 150, 150, 0.5);\n  border-style: solid;\n  box-shadow: 0 4px 12px rgba(80, 80, 80, 0.3);\n}\n\n.add-model-icon {\n  font-size: 32px;\n  color: var(--color-primary);\n  line-height: 1;\n}\n\n.add-model-text {\n  font-size: 13px;\n  color: var(--color-primary);\n  font-weight: 500;\n}\n\n/* Goal Input */\n.goal-container-top {\n  margin-bottom: 30px;\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n  width: 100%;\n  box-sizing: border-box;\n}\n\n.goal-input-group {\n  display: flex;\n  gap: 10px;\n}\n\n.goal-input-group #goal-input {\n  flex: 1;\n  padding: 12px 16px;\n  font-family: var(--font-family);\n  background: #111 !important;\n  border: 2px solid var(--color-border);\n  color: #f0f0f0 !important;\n  font-size: 1em;\n  transition: all 0.3s;\n}\n\n.goal-input-group #goal-input:focus {\n  outline: none;\n  background: #111 !important;\n  border-color: #888;\n  border-width: 2px;\n  box-shadow: 0 0 12px rgba(120, 120, 120, 0.3);\n}\n\n.goal-input-group #goal-input::placeholder {\n  color: rgba(224, 224, 224, 0.5);\n}\n\n.goal-input-group #goal-input:disabled {\n  opacity: 0.5;\n}\n\n.goal-input-group .btn {\n  white-space: nowrap;\n  padding: 12px 24px;\n}\n\n.goal-example-chips {\n  display: flex;\n  gap: 8px;\n  flex-wrap: wrap;\n  margin-top: 12px;\n}\n\n.goal-chip {\n  padding: 8px 14px;\n  background: rgba(60, 60, 60, 0.5);\n  border: 1px solid rgba(100, 100, 100, 0.3);\n  border-radius: 999px;\n  color: #aaa;\n  font-size: 12px;\n  font-family: var(--font-family);\n  cursor: pointer;\n  transition: all 0.2s ease;\n  white-space: nowrap;\n}\n\n.goal-chip:hover {\n  background: rgba(80, 80, 80, 0.6);\n  border-color: rgba(150, 150, 150, 0.5);\n  box-shadow: 0 2px 8px rgba(100, 100, 100, 0.3);\n}\n\n/* Buttons - base styles in theme.css, boot-specific overrides here */\n.btn.primary {\n  background: transparent;\n  border-color: #ffc107;\n  color: #ffc107;\n}\n\n.btn.primary:hover:not(:disabled) {\n  background: rgba(255, 215, 0, 0.2);\n  box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);\n}\n\n.btn.secondary {\n  font-size: 12px;\n  padding: 8px 16px;\n  opacity: 0.7;\n  background: transparent;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  color: #888;\n}\n\n.btn.secondary:hover:not(:disabled) {\n  opacity: 1;\n  background: rgba(255, 255, 255, 0.05);\n  border-color: rgba(255, 255, 255, 0.3);\n}\n\n/* Boot Mode Options */\n.boot-mode-options {\n  display: flex;\n  flex-direction: row;\n  gap: 15px;\n  justify-content: center;\n}\n\n.boot-mode-btn {\n  background: rgba(40, 40, 40, 0.4);\n  border: 2px solid rgba(0, 255, 255, 0.3);\n  border-radius: 0;\n  padding: 20px;\n  padding-top: 45px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  text-align: left;\n  color: var(--color-text-primary);\n  font-family: var(--font-family);\n  position: relative;\n  flex: 1;\n  min-width: 0;\n  display: flex;\n  flex-direction: column;\n}\n\n.boot-mode-btn:hover {\n  background: rgba(60, 60, 60, 0.5);\n  border-color: rgba(0, 255, 255, 0.5);\n}\n\n.boot-mode-btn.selected {\n  background: rgba(0, 255, 255, 0.15);\n  border-color: var(--color-primary);\n  box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);\n}\n\n.boot-mode-btn.selected::after {\n  content: 'âœ“';\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  color: var(--color-primary);\n  font-size: 1.3em;\n  font-weight: bold;\n}\n\n.boot-mode-label {\n  font-size: 1.2em;\n  color: var(--color-secondary);\n  margin-bottom: 8px;\n  margin-top: 0;\n  font-weight: bold;\n  text-align: left;\n}\n\n.boot-mode-desc {\n  font-size: 0.95em;\n  color: var(--color-text-primary);\n  opacity: 0.8;\n  margin-bottom: 8px;\n  line-height: 1.5;\n  font-weight: 600;\n  text-align: left;\n}\n\n.boot-mode-badge {\n  position: absolute;\n  top: 12px;\n  left: 12px;\n  padding: 3px 6px;\n  background: rgba(78, 201, 176, 0.2);\n  color: #4ec9b0;\n  border: 1px solid #4ec9b0;\n  border-radius: 0;\n  font-size: 9px;\n  font-weight: bold;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.boot-mode-badge.experimental-badge {\n  background: rgba(255, 193, 7, 0.2);\n  color: #ffc107;\n  border: 1px solid #ffc107;\n}\n\n/* Inline Model Form */\n.model-form-inline {\n  margin-top: 16px;\n  padding: 20px;\n  background: rgba(0, 255, 255, 0.05);\n  border: 2px solid var(--color-primary);\n  border-radius: 0;\n  animation: slideDown 0.3s ease;\n}\n\n.model-form-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  padding-bottom: 12px;\n  border-bottom: 1px solid rgba(0, 255, 255, 0.2);\n}\n\n.model-form-header h5 {\n  margin: 0;\n  font-size: 15px;\n  color: var(--color-primary);\n  font-weight: 600;\n}\n\n.close-btn-small {\n  background: none;\n  border: none;\n  color: #888;\n  font-size: 20px;\n  cursor: pointer;\n  padding: 0;\n  width: 24px;\n  height: 24px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n}\n\n.close-btn-small:hover {\n  color: var(--color-primary);\n}\n\n.inline-form-row {\n  margin-bottom: 16px;\n}\n\n.inline-form-row label {\n  display: block;\n  font-size: 12px;\n  color: var(--color-text-primary);\n  margin-bottom: 6px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.inline-select,\n.inline-input {\n  width: 100%;\n  padding: 10px 12px;\n  background: rgba(255, 255, 255, 0.05);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 0;\n  color: var(--color-text-primary);\n  font-size: 14px;\n  font-family: var(--font-family);\n  transition: all 0.2s ease;\n  box-sizing: border-box;\n}\n\n.inline-select option {\n  background: #1e1e1e;\n  color: var(--color-text-primary);\n  padding: 8px;\n}\n\n.inline-select:focus,\n.inline-input:focus {\n  outline: none;\n  border-color: var(--color-primary);\n  box-shadow: 0 0 0 2px rgba(0, 255, 255, 0.1);\n}\n\n.inline-input::placeholder {\n  color: #666;\n}\n\n.inline-form-actions {\n  display: flex;\n  gap: 12px;\n  margin-top: 20px;\n  padding-top: 16px;\n  border-top: 1px solid rgba(0, 255, 255, 0.2);\n}\n\n.inline-btn-cancel,\n.inline-btn-save {\n  flex: 1;\n  padding: 10px 16px;\n  border-radius: 0;\n  font-size: 13px;\n  font-family: var(--font-family);\n  cursor: pointer;\n  transition: all 0.2s ease;\n  border: none;\n  font-weight: 500;\n}\n\n.inline-btn-save {\n  background: var(--color-primary);\n  color: #0a0a14;\n}\n\n.inline-btn-save:hover:not(:disabled) {\n  background: #00e6e6;\n  box-shadow: 0 0 12px rgba(0, 255, 255, 0.5);\n}\n\n.inline-btn-save:disabled {\n  background: rgba(0, 255, 255, 0.3);\n  cursor: not-allowed;\n  opacity: 0.5;\n}\n\n.inline-btn-cancel {\n  background: rgba(255, 255, 255, 0.05);\n  color: var(--color-text-primary);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.inline-btn-cancel:hover {\n  background: rgba(255, 255, 255, 0.1);\n  border-color: rgba(255, 255, 255, 0.4);\n}\n\n/* Consensus Section */\n.consensus-section {\n  padding: 16px;\n  background: rgba(255, 215, 0, 0.05);\n  border: 1px solid rgba(255, 215, 0, 0.2);\n  border-radius: 0;\n  margin-top: 16px;\n}\n\n.consensus-section label {\n  display: block;\n  font-size: 13px;\n  color: var(--color-secondary);\n  margin-bottom: 8px;\n  font-weight: 500;\n}\n\n.consensus-select {\n  width: 100%;\n  padding: 10px;\n  background: rgba(0, 0, 0, 0.3);\n  border: 1px solid rgba(255, 215, 0, 0.3);\n  border-radius: 0;\n  color: var(--color-text-primary);\n  font-size: 13px;\n  font-family: var(--font-family);\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.consensus-select option {\n  background: #1e1e1e;\n  color: var(--color-text-primary);\n  padding: 8px;\n}\n\n.consensus-select:focus {\n  outline: none;\n  border-color: var(--color-secondary);\n  box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.1);\n}\n\n/* Error Message */\n.error-message {\n  background: rgba(244, 67, 54, 0.1);\n  border: 1px solid rgba(244, 67, 54, 0.5);\n  border-radius: 0;\n  padding: 15px;\n  margin-bottom: 20px;\n  text-align: left;\n}\n\n.error-message strong {\n  color: #f44;\n  display: block;\n  margin-bottom: 8px;\n}\n\n.error-message p {\n  margin: 8px 0;\n  font-size: 0.9em;\n  line-height: 1.5;\n}\n\n.error-message code {\n  background: rgba(0, 0, 0, 0.3);\n  padding: 2px 6px;\n  border-radius: 0;\n  color: var(--color-primary);\n  font-family: 'Courier New', monospace;\n}\n\n/* Modals */\n.modal {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.85);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1000;\n  padding: 20px;\n  box-sizing: border-box;\n}\n\n.modal-content {\n  background: var(--color-bg-primary);\n  border: 2px solid var(--color-primary);\n  border-radius: 0;\n  max-width: 650px;\n  width: 100%;\n  max-height: 85vh;\n  overflow-y: auto;\n  box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);\n  position: relative;\n  margin: 0 auto;\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 20px;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.modal-header h3 {\n  color: var(--color-primary);\n  margin: 0;\n}\n\n.close-btn {\n  background: none;\n  border: none;\n  color: var(--color-text-primary);\n  font-size: 2em;\n  cursor: pointer;\n  line-height: 1;\n  padding: 0;\n  width: 30px;\n  height: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s;\n}\n\n.close-btn:hover {\n  color: var(--color-primary);\n}\n\n.modal-body {\n  padding: 20px;\n}\n\n/* Help Popover */\n.help-popover {\n  position: absolute;\n  z-index: 10000;\n  background: #111118;\n  border: 1px solid #2d2d3d;\n  border-radius: 0;\n  padding: 16px;\n  width: min(280px, 90vw);\n  box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);\n}\n\n.help-popover-content {\n  display: grid;\n  gap: 12px;\n}\n\n.help-popover-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 12px;\n}\n\n.help-popover-title {\n  font-size: 14px;\n  letter-spacing: 0.08em;\n  text-transform: uppercase;\n  color: #75e6cc;\n}\n\n.help-popover-body {\n  font-size: 13px;\n  color: #d0d0e0;\n  line-height: 1.5;\n}\n\n.help-popover-close {\n  border: none;\n  background: none;\n  color: #8e8ea6;\n  font-size: 20px;\n  cursor: pointer;\n}\n\n.help-popover-close:hover {\n  color: #f4f4ff;\n}\n\n/* Info Overlay */\n.info-overlay {\n  position: fixed;\n  inset: 0;\n  background: rgba(10, 10, 14, 0.7);\n  backdrop-filter: blur(6px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 24px;\n  z-index: 1200;\n}\n\n.info-overlay.hidden {\n  display: none;\n}\n\n.info-card {\n  background: #12121a;\n  border: 1px solid #1f1f23;\n  border-radius: 0;\n  width: min(420px, 90vw);\n  box-shadow: 0 12px 40px rgba(5, 5, 10, 0.55);\n  display: flex;\n  flex-direction: column;\n}\n\n.info-card-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 18px 20px 12px;\n}\n\n.info-card-header h3 {\n  margin: 0;\n  font-size: 16px;\n  letter-spacing: 0.08em;\n  text-transform: uppercase;\n  color: #c0c0d0;\n}\n\n.info-card-body {\n  padding: 0 20px 16px;\n  color: #b9bad6;\n  font-size: 14px;\n  line-height: 1.5;\n}\n\n.info-card-footer {\n  padding: 12px 20px 18px;\n  border-top: 1px solid #1f1f23;\n  display: flex;\n  justify-content: flex-end;\n}\n\n.secondary-btn {\n  background: #1d1d28;\n  border: 1px solid #343446;\n  color: #d0d0e0;\n  padding: 8px 14px;\n  border-radius: 0;\n  cursor: pointer;\n}\n\n.secondary-btn:hover {\n  border-color: #4ec9b0;\n  color: #4ec9b0;\n}\n\n/* Config Section */\n.config-section {\n  margin-bottom: 20px;\n  width: 100%;\n  box-sizing: border-box;\n}\n\n/* Directory Modal */\n.directory-modal-content {\n  width: min(720px, 95vw);\n}\n\n.directory-modal-body {\n  padding-top: 8px;\n  max-height: 70vh;\n  overflow-y: auto;\n}\n\n.directory-filters {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 8px;\n  margin-bottom: 16px;\n}\n\n.directory-filter {\n  background: #151521;\n  border: 1px solid #2d2d3d;\n  border-radius: 0;\n  color: #9fa0bb;\n  padding: 5px 12px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  font-size: 12px;\n  text-transform: uppercase;\n  letter-spacing: 0.06em;\n}\n\n.directory-filter.active,\n.directory-filter:hover {\n  background: #4ec9b0;\n  border-color: #4ec9b0;\n  color: #0c0c12;\n  box-shadow: 0 0 12px rgba(76, 201, 176, 0.25);\n}\n\n/* Modal Footer */\n.modal-footer {\n  margin-top: 24px;\n  display: flex;\n  justify-content: flex-end;\n  gap: 12px;\n}\n\n/* Multi-model modal */\n.multi-model-modal-content {\n  width: min(520px, 90vw);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  body {\n    padding: 15px;\n  }\n\n  #boot-container {\n    max-width: 100%;\n    padding: 0 10px;\n  }\n\n  .boot-header h1 {\n    font-size: 2em;\n  }\n\n  .boot-mode-options {\n    flex-direction: column;\n  }\n\n  .goal-input-group {\n    flex-direction: column;\n    gap: 12px;\n  }\n\n  .btn {\n    width: 100%;\n    padding: 12px 20px;\n    font-size: 1.05em;\n  }\n\n  .model-cards-list {\n    flex-direction: row;\n    overflow-x: auto;\n  }\n}\n\n@media (max-width: 480px) {\n  body {\n    padding: 10px;\n  }\n\n  .boot-header h1 {\n    font-size: 1.8em;\n  }\n\n  .model-card {\n    min-width: 180px;\n    max-width: 180px;\n  }\n}\n",
      "hash": "892deef30204de8959a97b0c53999da5478ffb4691c3bd18588fa0fd74f7104d"
    }
  }
}