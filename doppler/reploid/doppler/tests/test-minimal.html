<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Minimal Inference Test</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    #log {
      white-space: pre-wrap;
      font-size: 12px;
      background: #16213e;
      padding: 10px;
      max-height: 70vh;
      overflow-y: auto;
      margin-top: 10px;
    }
    .controls {
      margin-bottom: 10px;
    }
    button {
      padding: 8px 16px;
      margin-right: 8px;
      cursor: pointer;
      background: #0f3460;
      color: #eee;
      border: 1px solid #1a5276;
      border-radius: 4px;
    }
    button:hover { background: #1a5276; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    input, select {
      padding: 8px;
      background: #16213e;
      color: #eee;
      border: 1px solid #1a5276;
      border-radius: 4px;
      margin-right: 8px;
    }
    input { width: 300px; }
    .error { color: #ff6b6b; }
    .success { color: #6bff6b; }
    .info { color: #6b9fff; }
    .status { margin: 10px 0; padding: 10px; background: #0f3460; border-radius: 4px; }
    #output { margin-top: 10px; padding: 10px; background: #1e3a5f; border-radius: 4px; min-height: 50px; }
  </style>
</head>
<body>
  <h1>Minimal Inference Test</h1>

  <div class="controls">
    <input type="text" id="prompt-input" value="the color of the sky is" placeholder="Enter prompt...">
    <button id="run-btn">Run Test</button>
    <button id="clear-btn">Clear Log</button>
  </div>

  <div class="status">
    <strong>Status:</strong> <span id="status-text">Ready</span>
  </div>

  <div id="output">
    <strong>Output:</strong> <span id="output-text">--</span>
  </div>

  <div id="log"></div>

  <script type="module">
    const MODEL_URL = 'http://localhost:8080/models/gemma3-1b-q4';

    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status-text');
    const outputEl = document.getElementById('output-text');
    const runBtn = document.getElementById('run-btn');
    const promptInput = document.getElementById('prompt-input');

    // Expose state for Playwright
    window.testState = {
      ready: false,
      loading: false,
      loaded: false,
      generating: false,
      done: false,
      output: '',
      tokens: [],
      errors: [],
    };

    function log(msg, className = '') {
      const line = document.createElement('div');
      line.className = className;
      const time = new Date().toISOString().slice(11, 19);
      line.textContent = `[${time}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setStatus(text, className = '') {
      statusEl.textContent = text;
      statusEl.className = className;
    }

    async function runTest() {
      const prompt = promptInput.value || 'the color of the sky is';

      window.testState = {
        ready: false,
        loading: true,
        loaded: false,
        generating: false,
        done: false,
        output: '',
        tokens: [],
        errors: [],
      };

      logEl.innerHTML = '';
      outputEl.textContent = '--';
      runBtn.disabled = true;

      try {
        log('='.repeat(50));
        log('Starting Minimal Inference Test', 'info');
        log('='.repeat(50));

        // 1. Initialize WebGPU
        setStatus('Initializing WebGPU...', 'info');
        log('1. Initializing WebGPU...');

        const { initDevice, getDevice, getKernelCapabilities } = await import('/dist/gpu/device.js');
        await initDevice();
        const device = getDevice();
        const caps = getKernelCapabilities();

        log(`   GPU initialized: hasF16=${caps.hasF16}, hasSubgroups=${caps.hasSubgroups}`, 'success');

        // 2. Fetch manifest
        setStatus('Fetching manifest...', 'info');
        log('2. Fetching manifest...');

        const manifestResp = await fetch(`${MODEL_URL}/manifest.json`);
        if (!manifestResp.ok) throw new Error(`Failed to fetch manifest: ${manifestResp.status}`);
        const manifest = await manifestResp.json();

        log(`   Model: ${manifest.architecture || manifest.modelId}`, 'success');
        log(`   Layers: ${manifest.config?.num_hidden_layers || '?'}, Hidden: ${manifest.config?.hidden_size || '?'}`);

        // 3. Parse manifest
        setStatus('Parsing manifest...', 'info');
        log('3. Parsing manifest...');

        const { parseManifest } = await import('/dist/storage/rdrr-format.js');
        const modelInfo = parseManifest(JSON.stringify(manifest));
        log(`   Parsed ${modelInfo.tensors.size} tensors`, 'success');

        // 4. Create pipeline
        setStatus('Loading model...', 'info');
        log('4. Creating pipeline and loading model...');

        const { createPipeline } = await import('/dist/inference/pipeline.js');

        // Custom shard loader
        const loadShard = async (idx) => {
          log(`   Loading shard idx=${idx}, type=${typeof idx}, shards.length=${manifest.shards.length}`);
          const shard = manifest.shards[idx];
          if (!shard) {
            log(`   ERROR: No shard at index ${idx}`, 'error');
            throw new Error(`No shard at index ${idx}`);
          }
          log(`   Loading shard ${idx}: ${shard.fileName}`);
          const resp = await fetch(`${MODEL_URL}/${shard.fileName}`);
          if (!resp.ok) throw new Error(`Failed to load shard ${idx}`);
          const data = new Uint8Array(await resp.arrayBuffer());
          log(`   Shard ${idx}: ${(data.byteLength / 1024 / 1024).toFixed(1)}MB`);
          return data;
        };

        const pipeline = await createPipeline(modelInfo, {
          storage: { loadShard },
          gpu: { device },
          baseUrl: MODEL_URL,
          runtime: { debug: true },
          onProgress: (phase, progress, detail) => {
            if (detail) {
              log(`   [${phase}] ${Math.round(progress * 100)}% - ${detail}`);
            }
          },
        });

        log('   Model loaded!', 'success');
        window.testState.loaded = true;
        window.testState.loading = false;

        // 5. Generate
        setStatus('Generating...', 'info');
        window.testState.generating = true;
        log(`5. Generating from: "${prompt}"`);

        const tokens = [];
        const startTime = Date.now();

        for await (const tokenText of pipeline.generate(prompt, {
          maxTokens: 50,
          temperature: 0.7,
          topK: 40,
          topP: 0.9,
        })) {
          tokens.push(tokenText);
          window.testState.tokens = tokens;
          log(`   Token ${tokens.length}: "${tokenText}"`, 'info');

          // Update output live
          outputEl.textContent = tokens.join('');
        }

        const elapsed = Date.now() - startTime;
        const tokPerSec = tokens.length / (elapsed / 1000);

        const output = tokens.join('');
        window.testState.output = output;
        window.testState.generating = false;
        window.testState.done = true;

        log('='.repeat(50));
        log(`OUTPUT: ${output}`, 'success');
        log(`Generated ${tokens.length} tokens in ${elapsed}ms (${tokPerSec.toFixed(1)} tok/s)`);
        log('='.repeat(50));

        // Analyze output
        const goodWords = ['blue', 'clear', 'beautiful', 'cloudy', 'dark', 'bright', 'typically', 'usually'];
        const hasGood = goodWords.some(w => output.toLowerCase().includes(w));

        if (hasGood) {
          setStatus('PASS - Coherent output', 'success');
          log('STATUS: PASS - Output looks coherent!', 'success');
        } else {
          setStatus('CHECK - Review output', 'info');
          log('STATUS: CHECK - Output may need review', 'info');
        }

      } catch (err) {
        window.testState.errors.push(err.message);
        window.testState.done = true;
        setStatus(`ERROR: ${err.message}`, 'error');
        log(`ERROR: ${err.message}`, 'error');
        log(err.stack, 'error');
      } finally {
        runBtn.disabled = false;
      }
    }

    // Event listeners
    runBtn.addEventListener('click', runTest);
    document.getElementById('clear-btn').addEventListener('click', () => {
      logEl.innerHTML = '';
      outputEl.textContent = '--';
      setStatus('Ready');
    });

    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !runBtn.disabled) runTest();
    });

    // Mark ready
    window.testState.ready = true;
    log('Ready. Click "Run Test" or press Enter to start.');
    log(`Model server: ${MODEL_URL}`);
  </script>
</body>
</html>
