{
  "_x0_reploid.core.logic_0": "const CoreLogicModule = (\n  initialConfig,\n  initialUtils,\n  initialStorage,\n  initialErrors,\n  initialAgentLogicPureHelpers,\n  initialStateHelpersPure\n) => {\n  const loadModule = async (filePath, exportName, dependencies = {}) => {\n    const logger = initialUtils?.logger || {\n      logEvent: (lvl, msg, det) =>\n        console.error(`[ORCHESTRATOR_FALLBACK] ${msg}`, det || \"\"),\n    };\n    const allDependencies = {\n      ...dependencies,\n      Errors: initialErrors,\n      Utils: initialUtils,\n    };\n    const depNames = Object.keys(allDependencies);\n    const depValues = Object.values(allDependencies);\n\n    if (\n      depNames.length !== depValues.length ||\n      depValues.some((dep) => dep === undefined || dep === null)\n    ) {\n      const missing = depNames.filter(\n        (name, i) => depValues[i] === undefined || depValues[i] === null\n      );\n      logger.logEvent(\n        \"error\",\n        `Cannot load module ${filePath}: Missing dependencies ${missing.join(\n          \", \"\n        )}`,\n        allDependencies\n      );\n      throw new initialErrors.ConfigError(\n        `Dependency error for ${filePath}: Missing ${missing.join(\", \")}`,\n        filePath\n      );\n    }\n\n    try {\n      const response = await fetch(\n        filePath + `?v=${initialConfig?.STATE_VERSION || Date.now()}`\n      );\n      if (!response.ok)\n        throw new initialErrors.ApiError(\n          `HTTP ${response.status} for ${filePath}`,\n          response.status\n        );\n      const scriptContent = await response.text();\n      const tempScope = {};\n      const funcArgsString = [\"tempScope\", ...depNames].join(\", \");\n      const funcBody = `${scriptContent}\\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;\n\n      const factoryFunction = new Function(funcArgsString, funcBody);\n      factoryFunction(tempScope, ...depValues);\n\n      if (tempScope.result === undefined) {\n        logger.logEvent(\n          \"warn\",\n          `Module ${filePath} executed, but export '${exportName}' was not found.`\n        );\n        throw new initialErrors.ConfigError(\n          `Module ${filePath} did not yield expected export '${exportName}'.`,\n          filePath\n        );\n      }\n      logger.logEvent(\"debug\", `Module ${filePath} loaded successfully.`);\n\n      if (\n        exportName.endsWith(\"Module\") &&\n        typeof tempScope.result === \"function\"\n      ) {\n        return tempScope.result(...Object.values(dependencies));\n      } else {\n        return tempScope.result;\n      }\n    } catch (error) {\n      logger.logEvent(\n        \"error\",\n        `Fatal Error loading/executing module ${filePath}`,\n        error.message + (error.stack ? `\\nStack: ${error.stack}` : \"\")\n      );\n      throw error;\n    }\n  };\n\n  const registerCoreWebComponents = async (\n    StateManagerInstance,\n    StorageInstance,\n    LoggerInstance\n  ) => {\n    if (\n      !StateManagerInstance ||\n      !StorageInstance ||\n      !LoggerInstance ||\n      typeof customElements === \"undefined\"\n    ) {\n      LoggerInstance.logEvent(\n        \"warn\",\n        \"Cannot register core web components: missing dependencies or customElements API.\"\n      );\n      return;\n    }\n    LoggerInstance.logEvent(\n      \"info\",\n      \"AppLogic: Attempting to register core Web Components...\"\n    );\n    const artifactMetadata = StateManagerInstance.getAllArtifactMetadata();\n    let registeredCount = 0;\n\n    for (const id in artifactMetadata) {\n      if (id.startsWith(\"reploid.core.webcomponent.\")) {\n        const meta = artifactMetadata[id];\n        if (\n          meta &&\n          meta.type === \"WEB_COMPONENT_DEF\" &&\n          meta.latestCycle >= 0\n        ) {\n          const jsContent = StorageInstance.getArtifactContent(\n            id,\n            meta.latestCycle,\n            meta.version_id\n          );\n          if (jsContent) {\n            const componentName = id\n              .substring(\"reploid.core.webcomponent.\".length)\n              .replace(/\\./g, \"-\");\n            if (!customElements.get(componentName)) {\n              try {\n                const ComponentClass = new Function(\n                  \"return (\" + jsContent + \")\"\n                )();\n                if (\n                  typeof ComponentClass === \"function\" &&\n                  HTMLElement.isPrototypeOf(ComponentClass)\n                ) {\n                  customElements.define(componentName, ComponentClass);\n                  StateManagerInstance.registerWebComponent(componentName);\n                  LoggerInstance.logEvent(\n                    \"info\",\n                    `AppLogic: Registered core WC <${componentName}> from ${id}`\n                  );\n                  registeredCount++;\n                } else {\n                  LoggerInstance.logEvent(\n                    \"warn\",\n                    `AppLogic: Invalid class structure for core WC ${componentName} in ${id}`\n                  );\n                }\n              } catch (e) {\n                LoggerInstance.logEvent(\n                  \"error\",\n                  `AppLogic: Error defining core WC ${componentName} from ${id}: ${e.message}`\n                );\n              }\n            } else {\n              if (\n                !StateManagerInstance.isWebComponentRegistered(componentName)\n              ) {\n                StateManagerInstance.registerWebComponent(componentName);\n              }\n              LoggerInstance.logEvent(\n                \"debug\",\n                `AppLogic: Core WC <${componentName}> from ${id} was already defined globally.`\n              );\n            }\n          } else {\n            LoggerInstance.logEvent(\n              \"warn\",\n              `AppLogic: Content missing for core WC definition: ${id} (Cycle ${meta.latestCycle})`\n            );\n          }\n        }\n      }\n    }\n    if (registeredCount > 0)\n      LoggerInstance.logEvent(\n        \"info\",\n        `AppLogic: ${registeredCount} core Web Components newly registered.`\n      );\n    else\n      LoggerInstance.logEvent(\n        \"info\",\n        `AppLogic: No new core Web Components to register at this stage.`\n      );\n  };\n\n  const initializeApplication = async () => {\n    let config = initialConfig;\n    let Utils = initialUtils;\n    let Storage = initialStorage;\n    let Errors = initialErrors;\n    let AgentLogicPureHelpers = initialAgentLogicPureHelpers;\n    let StateHelpersPure = initialStateHelpersPure;\n    let logger = null;\n    let StateManager,\n      ToolRunner,\n      ApiClient,\n      UI,\n      CycleLogic,\n      ToolRunnerPureHelpers;\n\n    const fatalErrorHandler = (message, error = null) => {\n      console.error(\"Orchestrator: Initialization failed.\", message, error);\n      const log = logger || {\n        logEvent: (lvl, msg, det) =>\n          console.error(`[ORCHESTRATOR_FALLBACK] ${msg}`, det || \"\"),\n      };\n      log.logEvent(\n        \"error\",\n        `Orchestrator: Initialization failed. ${message}`,\n        error\n      );\n      document.body.innerHTML = `<div style=\"color:red; padding: 20px; font-family: monospace;\"><h1>FATAL ERROR</h1><p>App init failed: ${message}</p>${\n        error ? `<p>${error.message || error}</p>` : \"\"\n      }<p>Check console.</p></div>`;\n    };\n\n    try {\n      if (\n        !config ||\n        !Utils ||\n        !Storage ||\n        !Errors ||\n        !AgentLogicPureHelpers ||\n        !StateHelpersPure\n      ) {\n        throw new Error(\n          \"Core modules (Config, Utils, Storage, Errors, PureHelpers) not passed from bootstrap.\"\n        );\n      }\n      logger = Utils.logger;\n      logger.logEvent(\"info\", \"Orchestrator: Initializing application...\");\n\n      const stateManagerDeps = {\n        config,\n        logger,\n        Storage,\n        Errors,\n        StateHelpersPure,\n        Utils,\n      };\n      StateManager = await loadModule(\n        \"state-manager.js\",\n        \"StateManagerModule\",\n        stateManagerDeps\n      );\n\n      const apiClientDeps = { config, logger, Errors, Utils, StateManager };\n      ApiClient = await loadModule(\n        \"api-client.js\",\n        \"ApiClientModule\",\n        apiClientDeps\n      );\n      logger.logEvent(\n        \"debug\",\n        \"Orchestrator: StateManager and ApiClient loaded.\"\n      );\n\n      StateManager.init();\n      await registerCoreWebComponents(StateManager, Storage, logger);\n      logger.logEvent(\n        \"debug\",\n        \"Orchestrator: StateManager initialized and core WCs registered.\"\n      );\n\n      ToolRunnerPureHelpers = await loadModule(\n        \"tool-runner-pure-helpers.js\",\n        \"ToolRunnerPureHelpersModule\",\n        { logger }\n      );\n\n      const toolRunnerDeps = {\n        config,\n        logger,\n        Storage,\n        StateManager,\n        ApiClient,\n        Errors,\n        Utils,\n        ToolRunnerPureHelpers,\n      };\n      ToolRunner = await loadModule(\n        \"tool-runner.js\",\n        \"ToolRunnerModule\",\n        toolRunnerDeps\n      );\n\n      const uiManagerDeps = {\n        config,\n        logger,\n        Utils,\n        Storage,\n        StateManager,\n        Errors,\n        StateHelpersPure,\n      }; // Added StateHelpersPure\n      UI = await loadModule(\"ui-manager.js\", \"UIModule\", uiManagerDeps);\n      logger.logEvent(\"debug\", \"Orchestrator: ToolRunner and UI loaded.\");\n\n      const cycleLogicDeps = {\n        config,\n        logger,\n        Utils,\n        Storage,\n        StateManager,\n        UI,\n        ApiClient,\n        ToolRunner,\n        Errors,\n        AgentLogicPureHelpers,\n      };\n      CycleLogic = await loadModule(\n        \"agent-cycle.js\",\n        \"CycleLogicModule\",\n        cycleLogicDeps\n      );\n      logger.logEvent(\"debug\", \"Orchestrator: CycleLogic loaded.\");\n\n      CycleLogic.init();\n      logger.logEvent(\"debug\", \"Orchestrator: CycleLogic initialized.\");\n\n      setTimeout(() => {\n        try {\n          UI.init(StateManager, CycleLogic);\n          logger.logEvent(\n            \"info\",\n            \"Orchestrator: Application initialization complete.\"\n          );\n        } catch (uiError) {\n          fatalErrorHandler(\n            \"UI Initialization failed inside setTimeout.\",\n            uiError\n          );\n        }\n      }, 0);\n    } catch (error) {\n      fatalErrorHandler(error.message || \"Unknown initialization error\", error);\n    }\n  };\n  initializeApplication();\n};\n",
  "_x0_reploid.boot.script_0": "(async () => {\n  const startContainer = document.getElementById(\"start-container\");\n  const loadingContainer = document.getElementById(\"loading-container\");\n  const loadingIndicator = document.getElementById(\"loading-indicator\");\n  const appRoot = document.getElementById(\"app-root\");\n  const continueButton = document.getElementById(\"continue-button\");\n  const resetButton = document.getElementById(\"reset-button\");\n\n  let bootstrapLogMessages = `REPLOID Bootstrap Log - ${new Date().toISOString()}\\n=========================================\\n`;\n  let audioCtx = null;\n  let isAudioInitAttempted = false;\n  let interactionStarted = false;\n  let uiUpdatePromise = Promise.resolve();\n  let skipBootstrapAnimation = false;\n\n  let config = null;\n  let Utils = null;\n  let Storage = null;\n  let ErrorsGlobal = null;\n  let blLogger = null;\n  let AgentLogicPureHelpers = null;\n  let StateHelpersPure = null;\n\n  const bl = (() => {\n    const MIN_TONE_INTERVAL_MS = 32;\n    const TONE_DURATION_MS = 50;\n    let lastToneTime = 0;\n    const initAudioContextInternal = () => {\n      if (!isAudioInitAttempted && !audioCtx) {\n        isAudioInitAttempted = true;\n        try {\n          audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n        } catch (e) {\n          (blLogger ? blLogger.logEvent : console.warn)(\n            \"warn\",\n            \"AudioContext init failed:\",\n            e.message\n          );\n          audioCtx = null;\n        }\n      }\n      return audioCtx;\n    };\n    const playTone = (frequency, fixedDurationMs, oscType) => {\n      if (skipBootstrapAnimation) return;\n      const currentAudioCtx = initAudioContextInternal();\n      if (\n        !currentAudioCtx ||\n        typeof currentAudioCtx.createOscillator !== \"function\"\n      )\n        return;\n      try {\n        const oscillator = currentAudioCtx.createOscillator();\n        const gainNode = currentAudioCtx.createGain();\n        const duration = Math.max(fixedDurationMs / 1000, 0.01);\n        oscillator.type = oscType;\n        oscillator.frequency.setValueAtTime(\n          frequency,\n          currentAudioCtx.currentTime\n        );\n        gainNode.gain.setValueAtTime(0.3, currentAudioCtx.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(\n          0.001,\n          currentAudioCtx.currentTime + duration\n        );\n        oscillator.connect(gainNode).connect(currentAudioCtx.destination);\n        oscillator.start();\n        oscillator.stop(currentAudioCtx.currentTime + duration);\n      } catch (e) {\n        (blLogger ? blLogger.logEvent : console.warn)(\n          \"warn\",\n          \"Tone playback error:\",\n          e.message\n        );\n        audioCtx = null;\n      }\n    };\n    return async function blInternal(\n      message,\n      level = \"info\",\n      detail = null,\n      charDelay = 1\n    ) {\n      const timestamp = new Date().toISOString();\n      const logLine = `[${timestamp}] [${level.toUpperCase()}] ${message}${\n        detail ? ` | ${detail}` : \"\"\n      }`;\n      bootstrapLogMessages += logLine + \"\\n\";\n      let skipConsoleOutput = false;\n      let skipUiOutput = false;\n      let effectiveLevel = level;\n      if (level === \"only-gui\") {\n        skipConsoleOutput = true;\n        effectiveLevel = \"info\";\n      } else if (level === \"only-console\" || level === \"detail\") {\n        skipUiOutput = true;\n        effectiveLevel = \"info\";\n      }\n      if (!skipConsoleOutput) {\n        const logFunc = blLogger\n          ? blLogger.logEvent\n          : console[\n              effectiveLevel === \"error\"\n                ? \"error\"\n                : effectiveLevel === \"warn\"\n                ? \"warn\"\n                : \"log\"\n            ];\n        if (blLogger) {\n          logFunc(effectiveLevel, message, detail || \"\");\n        } else {\n          console[\n            effectiveLevel === \"error\"\n              ? \"error\"\n              : effectiveLevel === \"warn\"\n              ? \"warn\"\n              : \"log\"\n          ](logLine);\n        }\n      }\n      if (skipUiOutput || !loadingIndicator) return;\n      uiUpdatePromise = uiUpdatePromise\n        .then(async () => {\n          const logEntryContainer = document.createElement(\"div\");\n          logEntryContainer.className = `log-entry log-${effectiveLevel}`;\n          loadingIndicator.appendChild(logEntryContainer);\n          const fullText = `> ${message}${detail ? ` | ${detail}` : \"\"}`;\n          if (skipBootstrapAnimation) logEntryContainer.textContent = fullText;\n          else {\n            if (effectiveLevel === \"error\")\n              playTone(220, TONE_DURATION_MS, \"square\");\n            lastToneTime = performance.now();\n            for (const char of fullText) {\n              logEntryContainer.textContent += char;\n              if (loadingIndicator.scrollTop !== undefined)\n                loadingIndicator.scrollTop = loadingIndicator.scrollHeight;\n              const currentTime = performance.now();\n              if (\n                char.trim() &&\n                effectiveLevel !== \"error\" &&\n                currentTime - lastToneTime >= MIN_TONE_INTERVAL_MS\n              ) {\n                playTone(990, TONE_DURATION_MS, \"triangle\");\n                lastToneTime = currentTime;\n              }\n              if (charDelay > 0)\n                await new Promise((resolve) =>\n                  setTimeout(resolve, Math.max(charDelay, 1))\n                );\n              if (skipBootstrapAnimation) {\n                logEntryContainer.textContent = fullText;\n                break;\n              }\n            }\n          }\n          if (loadingIndicator.scrollTop !== undefined)\n            loadingIndicator.scrollTop = loadingIndicator.scrollHeight;\n        })\n        .catch((error) => {\n          (blLogger ? blLogger.logEvent : console.error)(\n            \"error\",\n            \"Error during bootstrap logging UI update:\",\n            error\n          );\n          uiUpdatePromise = Promise.resolve();\n        });\n      await uiUpdatePromise;\n    };\n  })();\n\n  const initAudioContext = () => {\n    if (!isAudioInitAttempted && !audioCtx) {\n      isAudioInitAttempted = true;\n      try {\n        audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      } catch (e) {\n        (blLogger ? blLogger.logEvent : console.warn)(\n          \"warn\",\n          \"AudioContext init failed on demand:\",\n          e.message\n        );\n        audioCtx = null;\n      }\n    }\n    return audioCtx;\n  };\n\n  async function calculateChecksumViaUtils(content) {\n    if (Utils && typeof Utils.calculateChecksum === \"function\")\n      return await Utils.calculateChecksum(content);\n    console.warn(\n      \"calculateChecksumViaUtils called before Utils.calculateChecksum was available.\"\n    );\n    return null;\n  }\n\n  async function fetchAndExecuteModule(\n    filePath,\n    exportName,\n    dependencies = {}\n  ) {\n    const loggerInstance = blLogger || {\n      logEvent: (lvl, msg, det) =>\n        console.error(`[BOOT_FETCH_FALLBACK] ${msg}`, det || \"\"),\n    };\n    const { Errors: CustomErrorsFromDeps } = dependencies;\n    const depNames = Object.keys(dependencies);\n    const depValues = Object.values(dependencies);\n    if (\n      depNames.length !== depValues.length ||\n      depValues.some((dep) => dep === undefined || dep === null)\n    ) {\n      const missing = depNames.filter(\n        (name, i) => depValues[i] === undefined || depValues[i] === null\n      );\n      const errorMsg = `Cannot load module ${filePath}: Missing dependencies ${missing.join(\n        \", \"\n      )}`;\n      loggerInstance.logEvent(\"error\", errorMsg, dependencies);\n      throw CustomErrorsFromDeps?.ConfigError\n        ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath)\n        : new Error(errorMsg);\n    }\n    try {\n      const response = await fetch(\n        filePath + `?v=${config?.STATE_VERSION || Date.now()}`\n      );\n      if (!response.ok)\n        throw CustomErrorsFromDeps?.ApiError\n          ? new CustomErrorsFromDeps.ApiError(\n              `HTTP ${response.status} for ${filePath}`,\n              response.status\n            )\n          : new Error(`HTTP ${response.status} for ${filePath}`);\n      const scriptContent = await response.text();\n      const tempScope = {};\n      const funcArgs = [\"tempScope\", ...depNames];\n      const funcBody = `${scriptContent}\\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;\n      const factoryFunction = new Function(...funcArgs, funcBody);\n      factoryFunction(tempScope, ...depValues);\n      if (tempScope.result === undefined) {\n        const errorMsg = `Module ${filePath} did not yield expected export '${exportName}'.`;\n        loggerInstance.logEvent(\"warn\", errorMsg);\n        throw CustomErrorsFromDeps?.ConfigError\n          ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath)\n          : new Error(errorMsg);\n      }\n      if (\n        exportName.endsWith(\"Module\") &&\n        typeof tempScope.result === \"function\"\n      ) {\n        const moduleFactory = tempScope.result;\n        const moduleInstance = moduleFactory(...depValues);\n        if (!moduleInstance) {\n          const errorMsg = `Module factory ${exportName} from ${filePath} returned null/undefined.`;\n          loggerInstance.logEvent(\"error\", errorMsg);\n          throw CustomErrorsFromDeps?.ConfigError\n            ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath)\n            : new Error(errorMsg);\n        }\n        loggerInstance.logEvent(\n          \"debug\",\n          `Module factory ${exportName} from ${filePath} executed successfully.`\n        );\n        return moduleInstance;\n      } else {\n        loggerInstance.logEvent(\n          \"debug\",\n          `Returning direct export ${exportName} from ${filePath}.`\n        );\n        return tempScope.result;\n      }\n    } catch (error) {\n      loggerInstance.logEvent(\n        \"error\",\n        `Fatal Error loading/executing module ${filePath}`,\n        error.message + (error.stack ? `\\nStack: ${error.stack}` : \"\")\n      );\n      throw error;\n    }\n  }\n\n  async function loadCoreDependencies() {\n    try {\n      await bl(\"Loading core configuration...\", \"info\", null, 0);\n      const configResponse = await fetch(\"config.json\" + `?v=${Date.now()}`);\n      if (!configResponse.ok)\n        throw new Error(`HTTP ${configResponse.status} loading config.json`);\n      config = await configResponse.json();\n      if (!config) throw new Error(\"Failed to parse config.json\");\n      await bl(\n        \"Config loaded.\",\n        \"only-console\",\n        `Version: ${config.STATE_VERSION}`\n      );\n\n      await bl(\"Loading core utilities (incl. Errors)...\", \"info\", null, 0);\n      Utils = await fetchAndExecuteModule(\"utils.js\", \"UtilsModule\", {});\n      if (!Utils || !Utils.logger || !Utils.Errors)\n        throw new Error(\n          \"Failed to load UtilsModule or its components (logger, Errors) correctly.\"\n        );\n      blLogger = Utils.logger;\n      ErrorsGlobal = Utils.Errors;\n      await bl(\"Utils (incl. Errors) loaded.\", \"only-console\");\n\n      await bl(\"Loading core storage...\", \"info\", null, 0);\n      Storage = await fetchAndExecuteModule(\"storage.js\", \"StorageModule\", {\n        config,\n        logger: blLogger,\n        Errors: ErrorsGlobal,\n      });\n      if (!Storage || typeof Storage.getState !== \"function\")\n        throw new Error(\"Failed to load StorageModule correctly.\");\n      await bl(\"Storage loaded.\", \"only-console\");\n\n      await bl(\"Loading pure helper modules...\", \"info\", null, 0);\n      AgentLogicPureHelpers = await fetchAndExecuteModule(\n        \"agent-logic-pure.js\",\n        \"AgentLogicPureHelpersModule\",\n        { Utils, logger: blLogger }\n      );\n      StateHelpersPure = await fetchAndExecuteModule(\n        \"state-helpers-pure.js\",\n        \"StateHelpersPureModule\",\n        { Utils, logger: blLogger }\n      );\n      if (!AgentLogicPureHelpers || !StateHelpersPure)\n        throw new Error(\"Failed to load pure helper modules.\");\n      await bl(\"Pure helper modules loaded.\", \"only-console\");\n\n      await bl(\"Core dependencies loaded.\", \"success\", null, 0);\n      return true;\n    } catch (error) {\n      const errorMsg =\n        error.message || \"Unknown error loading core dependencies.\";\n      await bl(\"FATAL: Failed to load core dependencies.\", \"error\", errorMsg);\n      console.error(\"Dependency Load Error:\", error, error.stack);\n      if (loadingIndicator)\n        loadingIndicator.innerHTML = `<div class=\"log-entry log-error\">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Cannot continue. Check console.</div>`;\n      if (loadingContainer) loadingContainer.classList.remove(\"hidden\");\n      if (startContainer) startContainer.classList.add(\"hidden\");\n      removeInteractionListeners();\n      return false;\n    }\n  }\n\n  function isValidState(parsedState) {\n    if (!config || !parsedState || !Utils || !StateHelpersPure) return false;\n    const validationError = StateHelpersPure.validateStateStructurePure(\n      parsedState,\n      config.STATE_VERSION,\n      Utils.getDefaultState\n    );\n    if (validationError) {\n      bl(\n        `State validation failed: ${validationError}`,\n        \"warn\",\n        `Found version: ${parsedState.version}`\n      );\n      return false;\n    }\n    return true;\n  }\n\n  async function verifyArtifactChecksum(\n    id,\n    cycle,\n    expectedChecksum,\n    versionId = null\n  ) {\n    if (!expectedChecksum) return true;\n    const content = Storage.getArtifactContent(id, cycle, versionId);\n    if (content === null && expectedChecksum) {\n      await bl(\n        `Content missing for checksum verification: ${id}_${cycle}${\n          versionId ? \"#\" + versionId : \"\"\n        }`,\n        \"warn\"\n      );\n      return false;\n    }\n    if (content === null && !expectedChecksum) return true;\n    let actualChecksum = await calculateChecksumViaUtils(content);\n    if (!actualChecksum) {\n      await bl(\n        `Checksum calculation failed for ${id}_${cycle}${\n          versionId ? \"#\" + versionId : \"\"\n        }`,\n        \"error\"\n      );\n      return false;\n    }\n    if (actualChecksum !== expectedChecksum) {\n      await bl(\n        `Checksum mismatch for ${id}_${cycle}${\n          versionId ? \"#\" + versionId : \"\"\n        }`,\n        \"warn\",\n        `Expected: ${expectedChecksum}, Actual: ${actualChecksum}`\n      );\n      return false;\n    }\n    return true;\n  }\n\n  async function checkEssentialArtifactsPresent(stateCycle, artifactMetadata) {\n    if (!Storage || !config || !artifactMetadata || !Utils) return false;\n    await bl(\n      `Verifying essential artifacts for state cycle ${stateCycle}...`,\n      \"info\",\n      null,\n      0\n    );\n    let allFoundAndValid = true;\n    const essentialDefs = config.GENESIS_ARTIFACT_DEFS || {};\n    const verificationPromises = [];\n    for (const id in essentialDefs) {\n      if (id === \"reploid.core.config\") continue;\n      const metaHistory = artifactMetadata[id];\n      let latestMeta = null;\n      if (metaHistory && metaHistory.length > 0)\n        latestMeta = Utils.getLatestMeta(metaHistory);\n      const cycleToCheck = latestMeta ? latestMeta.latestCycle : 0;\n      const versionIdToCheck = latestMeta ? latestMeta.version_id : null;\n      const expectedChecksum = latestMeta ? latestMeta.checksum : null;\n      const content = Storage.getArtifactContent(\n        id,\n        cycleToCheck,\n        versionIdToCheck\n      );\n      if (content === null) {\n        if (latestMeta && latestMeta.latestCycle !== -1) {\n          await bl(\n            `Essential artifact MISSING: ${id}`,\n            \"error\",\n            `Expected Cycle: ${cycleToCheck}, V: ${versionIdToCheck || \"def\"}`\n          );\n          allFoundAndValid = false;\n        } else if (!latestMeta) {\n          await bl(\n            `Essential artifact DEFINITION MISSING from state metadata: ${id}`,\n            \"error\"\n          );\n          allFoundAndValid = false;\n        }\n      } else {\n        verificationPromises.push(\n          verifyArtifactChecksum(\n            id,\n            cycleToCheck,\n            expectedChecksum,\n            versionIdToCheck\n          ).then((isValid) => {\n            if (!isValid) allFoundAndValid = false;\n            else\n              bl(\n                `Verified: ${id}`,\n                \"only-console\",\n                `Cyc: ${cycleToCheck}, V: ${versionIdToCheck || \"def\"}, Len: ${\n                  content.length\n                }${expectedChecksum ? \", CS OK\" : \"\"}`\n              );\n          })\n        );\n      }\n    }\n    await Promise.all(verificationPromises);\n    if (!allFoundAndValid)\n      await bl(\"One or more essential artifacts missing or invalid.\", \"error\");\n    else await bl(\"All essential artifacts verified.\", \"success\", null, 0);\n    return allFoundAndValid;\n  }\n\n  async function clearAllReploidData() {\n    if (!Storage || typeof Storage.clearAllReploidData !== \"function\") {\n      await bl(\"Cannot clear data, Storage module not loaded.\", \"error\");\n      return;\n    }\n    await bl(\n      \"Clearing all REPLOID data from LocalStorage...\",\n      \"warn\",\n      null,\n      16\n    );\n    try {\n      Storage.clearAllReploidData();\n      await bl(\"LocalStorage cleared.\", \"info\", null, 8);\n    } catch (e) {\n      await bl(\"Error clearing LocalStorage.\", \"error\", e.message);\n    }\n  }\n\n  async function bootstrapReploid(performGenesis = false) {\n    if (\n      !config ||\n      !Utils ||\n      !Storage ||\n      !ErrorsGlobal ||\n      !AgentLogicPureHelpers ||\n      !StateHelpersPure\n    ) {\n      await bl(\"Core dependencies check failed, cannot bootstrap.\", \"error\");\n      return;\n    }\n    if (!blLogger) blLogger = Utils.logger;\n    let state = null;\n    let needsGenesis = performGenesis;\n    let stateSource = performGenesis ? \"Forced Genesis\" : \"None\";\n    if (!performGenesis) {\n      await bl(\"Checking for existing state...\", \"info\", null, 0);\n      const stateJSON = Storage.getState();\n      if (stateJSON) {\n        state = stateJSON;\n        if (isValidState(state)) {\n          if (\n            await checkEssentialArtifactsPresent(\n              state.totalCycles,\n              state.artifactMetadata\n            )\n          ) {\n            stateSource = `localStorage (Cycle ${state.totalCycles}, v${state.version})`;\n            await bl(\n              `Found valid state and artifacts.`,\n              \"success\",\n              `Source: ${stateSource}`,\n              0\n            );\n            needsGenesis = false;\n          } else {\n            await bl(\n              `State valid (Cycle ${state.totalCycles}) but artifacts missing/invalid. Discarding.`,\n              \"error\"\n            );\n            state = null;\n            Storage.removeState();\n            needsGenesis = true;\n            stateSource = \"Discarded Invalid State\";\n          }\n        } else {\n          await bl(\n            `Found invalid/incompatible state (v${\n              state?.version || \"?\"\n            }). Discarding.`,\n            \"warn\"\n          );\n          state = null;\n          Storage.removeState();\n          needsGenesis = true;\n          stateSource = \"Discarded Invalid State\";\n        }\n      } else {\n        await bl(\"No existing state found. Initiating genesis.\", \"info\");\n        needsGenesis = true;\n        stateSource = \"Genesis\";\n      }\n    } else {\n      await bl(\"Reset requested...\", \"only-gui\", null, 6);\n      needsGenesis = true;\n      stateSource = \"Forced Genesis\";\n    }\n    try {\n      if (needsGenesis) {\n        await bl(\"Running genesis boot process...\", \"info\");\n        state = await runGenesisProcess();\n        if (!state) throw new Error(\"Genesis boot process failed.\");\n        await bl(\"Genesis complete.\", \"success\");\n      }\n      await bl(`Loading application with state from: ${stateSource}`, \"info\");\n      await uiUpdatePromise;\n      await loadAndExecuteApp(state);\n    } catch (error) {\n      await bl(\"Fatal bootstrap error\", \"error\", error.message);\n      console.error(\"Bootstrap stack trace:\", error);\n      if (loadingIndicator)\n        loadingIndicator.innerHTML += `<div class=\"log-error\">FATAL BOOTSTRAP ERROR: ${error.message}. Check console.</div>`;\n    }\n  }\n\n  async function fetchGenesisArtifacts() {\n    if (!config || !config.GENESIS_ARTIFACT_DEFS) {\n      await bl(\n        \"Cannot fetch genesis artifacts: Config definitions missing.\",\n        \"error\"\n      );\n      return null;\n    }\n    await bl(\"Fetching genesis artifacts...\", \"info\", null, 0);\n    const fetchedArtifacts = {};\n    let success = true;\n    const fetchPromises = Object.entries(config.GENESIS_ARTIFACT_DEFS).map(\n      async ([id, def]) => {\n        if (!def.filename) return;\n        try {\n          const response = await fetch(def.filename + `?t=${Date.now()}`);\n          if (!response.ok)\n            throw new Error(`HTTP ${response.status} for ${def.filename}`);\n          let content;\n          if (def.type === \"JSON\" || def.type === \"JSON_CONFIG\")\n            content = JSON.stringify(await response.json(), null, 2);\n          else content = await response.text();\n          fetchedArtifacts[id] = content;\n          await bl(\n            `Fetched: ${def.filename}`,\n            \"only-console\",\n            `${content.length} bytes`\n          );\n        } catch (error) {\n          await bl(`Failed to fetch ${def.filename}`, \"error\", error.message);\n          success = false;\n        }\n      }\n    );\n    await Promise.all(fetchPromises);\n    if (!success) {\n      await bl(\"Genesis artifact fetch failed.\", \"error\");\n      return null;\n    }\n    await bl(\n      `Fetched ${Object.keys(fetchedArtifacts).length} genesis artifacts.`,\n      \"only-console\"\n    );\n    return fetchedArtifacts;\n  }\n\n  async function saveGenesisArtifacts(artifacts) {\n    if (!Storage || !config || !artifacts || !Utils) return null;\n    await bl(\"Saving genesis artifacts (Cycle 0)...\", \"info\", null, 0);\n    const metadata = {};\n    let success = true;\n    const genesisDefs = config.GENESIS_ARTIFACT_DEFS || {};\n    const now = Date.now();\n    for (const id in artifacts) {\n      try {\n        const checksum = await Utils.calculateChecksum(artifacts[id]);\n        if (!checksum) {\n          await bl(`Checksum failed for genesis artifact: ${id}`, \"error\");\n          success = false;\n          continue;\n        }\n        Storage.setArtifactContent(id, 0, artifacts[id]);\n        metadata[id] = [\n          {\n            id,\n            version_id: null,\n            latestCycle: 0,\n            type: genesisDefs[id]?.type || \"UNKNOWN\",\n            description:\n              genesisDefs[id]?.description || `Genesis Artifact ${id}`,\n            source: \"Genesis\",\n            checksum,\n            timestamp: now,\n            paradigm: genesisDefs[id]?.paradigm || \"unknown\",\n          },\n        ];\n        await bl(\n          `Saved: ${id}`,\n          \"only-console\",\n          `Cyc 0, CS: ${checksum.substring(0, 15)}...`\n        );\n      } catch (e) {\n        await bl(`Failed save artifact: ${id} (Cycle 0)`, \"error\", e.message);\n        success = false;\n      }\n    }\n    const bootScriptElement = document.querySelector('script[src=\"boot.js\"]');\n    const bootScriptContent = bootScriptElement\n      ? await fetch(bootScriptElement.src + `?t=${Date.now()}`).then((res) =>\n          res.ok ? res.text() : \"(Fetch boot.js failed)\"\n        )\n      : \"(boot.js script element Not Found)\";\n    const bootStyleContent =\n      document.getElementById(\"boot-style\")?.textContent || \"\";\n    await uiUpdatePromise;\n    const finalBootstrapLog = bootstrapLogMessages;\n    const bootArtifactsToSave = {\n      \"reploid.boot.style\": {\n        content: bootStyleContent,\n        type: \"CSS\",\n        description: \"Bootstrap CSS from index.html\",\n        paradigm: \"data\",\n      },\n      \"reploid.boot.script\": {\n        content: bootScriptContent,\n        type: \"JS\",\n        description: \"Bootstrap script (boot.js) content\",\n        paradigm: \"boundary_orchestration\",\n      },\n      \"reploid.boot.log\": {\n        content: finalBootstrapLog,\n        type: \"LOG\",\n        description: \"Bootstrap execution log\",\n        paradigm: \"data\",\n      },\n    };\n    for (const id in bootArtifactsToSave) {\n      const { content, type, description, paradigm } = bootArtifactsToSave[id];\n      try {\n        const checksum = await Utils.calculateChecksum(content);\n        if (!checksum && id !== \"reploid.boot.log\") {\n          await bl(`Checksum failed for bootstrap artifact: ${id}`, \"warn\");\n          continue;\n        }\n        Storage.setArtifactContent(id, 0, content);\n        metadata[id] = [\n          {\n            id,\n            version_id: null,\n            latestCycle: 0,\n            type,\n            description,\n            source: \"BootstrapCapture\",\n            checksum,\n            timestamp: now,\n            paradigm,\n          },\n        ];\n        await bl(\n          `Saved: ${id}`,\n          \"only-console\",\n          `Cyc 0, CS: ${checksum ? checksum.substring(0, 15) + \"...\" : \"N/A\"}`\n        );\n      } catch (e) {\n        await bl(`Failed save bootstrap artifact: ${id}`, \"warn\", e.message);\n      }\n    }\n    Object.keys(genesisDefs).forEach((id) => {\n      if (!metadata[id]) {\n        const def = genesisDefs[id];\n        if (def) {\n          metadata[id] = [\n            {\n              id,\n              version_id: null,\n              latestCycle: id === \"reploid.core.config\" ? 0 : -1,\n              type: def.type,\n              description: def.description,\n              source: \"Genesis Definition\",\n              checksum: null,\n              timestamp: now,\n              paradigm: def.paradigm || \"unknown\",\n            },\n          ];\n          if (id === \"reploid.core.config\")\n            Storage.setArtifactContent(id, 0, JSON.stringify(config, null, 2));\n          bl(\n            `Added metadata for ${id} (cycle ${metadata[id][0].latestCycle})`,\n            \"only-console\"\n          );\n        }\n      }\n    });\n    await bl(\n      \"Genesis artifact save completed.\",\n      success ? \"only-console\" : \"warn\"\n    );\n    return success ? metadata : null;\n  }\n\n  async function runGenesisProcess() {\n    const fetchedArtifacts = await fetchGenesisArtifacts();\n    if (!fetchedArtifacts) return null;\n    const artifactMetadata = await saveGenesisArtifacts(fetchedArtifacts);\n    if (!artifactMetadata) return null;\n    const initialState = Utils.getDefaultState(config);\n    initialState.artifactMetadata = artifactMetadata;\n    initialState.lastFeedback = \"Genesis completed.\";\n    try {\n      Storage.saveState(initialState);\n      await bl(\"Initial state saved.\", \"success\", null, 0);\n      return initialState;\n    } catch (e) {\n      await bl(\"Failed to save initial state!\", \"error\", e.message);\n      return null;\n    }\n  }\n\n  async function registerCoreWebComponentsOnBoot(currentArtifactMetadata) {\n    if (\n      !currentArtifactMetadata ||\n      typeof customElements === \"undefined\" ||\n      !Storage ||\n      !Utils\n    ) {\n      bl(\"Cannot register core WCs on boot: missing dependencies.\", \"warn\");\n      return;\n    }\n    await bl(\n      \"Boot: Registering core Web Components from artifacts...\",\n      \"info\",\n      null,\n      0\n    );\n    let registeredCount = 0;\n    for (const id in currentArtifactMetadata) {\n      if (id.startsWith(\"reploid.core.webcomponent.\")) {\n        const metaHistory = currentArtifactMetadata[id];\n        const latestMeta = Utils.getLatestMeta(metaHistory);\n        if (\n          latestMeta &&\n          latestMeta.type === \"WEB_COMPONENT_DEF\" &&\n          latestMeta.latestCycle >= 0\n        ) {\n          const jsContent = Storage.getArtifactContent(\n            id,\n            latestMeta.latestCycle,\n            latestMeta.version_id\n          );\n          if (jsContent) {\n            const componentName = id\n              .substring(\"reploid.core.webcomponent.\".length)\n              .replace(/\\./g, \"-\");\n            if (!customElements.get(componentName)) {\n              try {\n                const ComponentClass = new Function(\n                  \"return (\" + jsContent + \")\"\n                )();\n                if (\n                  typeof ComponentClass === \"function\" &&\n                  HTMLElement.isPrototypeOf(ComponentClass)\n                ) {\n                  customElements.define(componentName, ComponentClass);\n                  await bl(\n                    `Boot: Registered core WC <${componentName}> from ${id}`,\n                    \"only-console\"\n                  );\n                  registeredCount++;\n                } else\n                  await bl(\n                    `Boot: Invalid class structure for core WC ${componentName} in ${id}`,\n                    \"warn\"\n                  );\n              } catch (e) {\n                await bl(\n                  `Boot: Error defining core WC ${componentName} from ${id}: ${e.message}`,\n                  \"error\"\n                );\n              }\n            } else\n              await bl(\n                `Boot: Core WC <${componentName}> from ${id} was already defined globally.`,\n                \"debug\"\n              );\n          } else\n            await bl(\n              `Boot: Content missing for core WC definition: ${id} (Cycle ${latestMeta.latestCycle})`,\n              \"warn\"\n            );\n        }\n      }\n    }\n    if (registeredCount > 0)\n      await bl(\n        `Boot: ${registeredCount} core Web Components registered globally.`,\n        \"info\",\n        null,\n        0\n      );\n    else\n      await bl(\n        `Boot: No new core Web Components to register globally at this stage.`,\n        \"info\",\n        null,\n        0\n      );\n  }\n\n  async function loadAndExecuteApp(currentState) {\n    await bl(\n      `Loading application core (State Cycle ${currentState.totalCycles})...`,\n      \"info\",\n      null,\n      0\n    );\n    if (\n      !config ||\n      !Utils ||\n      !Storage ||\n      !ErrorsGlobal ||\n      !AgentLogicPureHelpers ||\n      !StateHelpersPure\n    ) {\n      await bl(\"Core dependencies not available for app execution.\", \"error\");\n      return;\n    }\n    const coreStyleId = \"reploid.core.style\";\n    const coreLogicId = \"reploid.core.logic\";\n    const coreBodyId = \"reploid.core.body\";\n    try {\n      const latestStyleMeta = Utils.getLatestMeta(\n        currentState.artifactMetadata[coreStyleId]\n      );\n      const styleCycle =\n        latestStyleMeta?.latestCycle >= 0 ? latestStyleMeta.latestCycle : 0;\n      const styleContent = Storage.getArtifactContent(\n        coreStyleId,\n        styleCycle,\n        latestStyleMeta?.version_id\n      );\n      if (styleContent) {\n        const styleElement = document.createElement(\"style\");\n        styleElement.id = `${coreStyleId}-loaded-${styleCycle}${\n          latestStyleMeta?.version_id ? \"-\" + latestStyleMeta.version_id : \"\"\n        }`;\n        styleElement.textContent = styleContent;\n        document.head.appendChild(styleElement);\n        await bl(\n          `Applied style: ${coreStyleId} (Cycle ${styleCycle}${\n            latestStyleMeta?.version_id\n              ? \", V:\" + latestStyleMeta.version_id\n              : \"\"\n          })`,\n          \"only-console\"\n        );\n      } else\n        await bl(\n          `Core style artifact missing (Cyc ${styleCycle}/0). Using only boot style.`,\n          \"warn\"\n        );\n\n      const latestBodyMeta = Utils.getLatestMeta(\n        currentState.artifactMetadata[coreBodyId]\n      );\n      const bodyCycle =\n        latestBodyMeta?.latestCycle >= 0 ? latestBodyMeta.latestCycle : 0;\n      const coreBodyContent = Storage.getArtifactContent(\n        coreBodyId,\n        bodyCycle,\n        latestBodyMeta?.version_id\n      );\n      if (coreBodyContent && appRoot) {\n        await bl(\n          `Injecting body: ${coreBodyId} (Cycle ${bodyCycle}${\n            latestBodyMeta?.version_id ? \", V:\" + latestBodyMeta.version_id : \"\"\n          })`,\n          \"only-console\"\n        );\n        appRoot.innerHTML = coreBodyContent;\n      } else\n        throw new Error(\n          \"Failed to load core UI structure (body artifact or app-root element missing).\"\n        );\n      await registerCoreWebComponentsOnBoot(currentState.artifactMetadata);\n      const latestLogicMeta = Utils.getLatestMeta(\n        currentState.artifactMetadata[coreLogicId]\n      );\n      const logicCycle =\n        latestLogicMeta?.latestCycle >= 0 ? latestLogicMeta.latestCycle : 0;\n      const orchestratorScriptContent = Storage.getArtifactContent(\n        coreLogicId,\n        logicCycle,\n        latestLogicMeta?.version_id\n      );\n      if (!orchestratorScriptContent)\n        throw new Error(\n          `Core logic artifact (${coreLogicId}) missing (Cyc ${logicCycle}/0).`\n        );\n      await bl(\n        `Executing orchestrator: ${coreLogicId} (Cycle ${logicCycle}${\n          latestLogicMeta?.version_id ? \", V:\" + latestLogicMeta.version_id : \"\"\n        })...`,\n        \"info\",\n        null,\n        0\n      );\n      const orchestratorFunction = new Function(\n        \"initialConfig\",\n        \"initialUtils\",\n        \"initialStorage\",\n        \"initialErrors\",\n        \"initialAgentLogicPureHelpers\",\n        \"initialStateHelpersPure\",\n        orchestratorScriptContent +\n          \"\\nreturn CoreLogicModule(initialConfig, initialUtils, initialStorage, initialErrors, initialAgentLogicPureHelpers, initialStateHelpersPure);\"\n      );\n      const maybePromise = orchestratorFunction(\n        config,\n        Utils,\n        Storage,\n        ErrorsGlobal,\n        AgentLogicPureHelpers,\n        StateHelpersPure\n      );\n      if (maybePromise instanceof Promise) await maybePromise;\n      await bl(\"Orchestrator execution initiated.\", \"success\", null, 0);\n      setTimeout(() => {\n        if (loadingContainer) {\n          loadingContainer.style.transition = \"opacity 0.5s ease-out\";\n          loadingContainer.style.opacity = \"0\";\n          setTimeout(() => loadingContainer.classList.add(\"hidden\"), 500);\n        }\n        if (appRoot) appRoot.classList.add(\"visible\");\n      }, 500);\n    } catch (error) {\n      await bl(\n        `Error loading/executing core components`,\n        \"error\",\n        error.message\n      );\n      console.error(\"Core execution failed\", error);\n      if (loadingIndicator)\n        loadingIndicator.innerHTML += `<div class=\"log-error\">FATAL CORE EXECUTION ERROR: ${error.message}. Check console.</div>`;\n    }\n  }\n\n  function handleSkip(e) {\n    if (e.key === \"Enter\" || e.type === \"click\" || e.type === \"touchstart\") {\n      if (!skipBootstrapAnimation) {\n        skipBootstrapAnimation = true;\n        bl(\"[BOOTSTRAP SKIP]\", \"only-gui\", null, 0);\n        if (e.type === \"touchstart\") e.preventDefault();\n      }\n    }\n  }\n  function handleKeydown(e) {\n    if (!interactionStarted) {\n      if (e.key === \"Enter\") startInteraction(\"continue\");\n      else if (e.key === \" \") startInteraction(\"reset\");\n    }\n  }\n  function removeInteractionListeners() {\n    document.removeEventListener(\"keydown\", handleKeydown);\n    if (continueButton)\n      continueButton.removeEventListener(\"click\", handleContinueClick);\n    if (resetButton) resetButton.removeEventListener(\"click\", handleResetClick);\n  }\n  function addSkipListener() {\n    document.addEventListener(\"keydown\", handleSkip);\n    document.addEventListener(\"click\", handleSkip);\n    document.addEventListener(\"touchstart\", handleSkip, { passive: false });\n  }\n  function removeSkipListener() {\n    document.removeEventListener(\"keydown\", handleSkip);\n    document.removeEventListener(\"click\", handleSkip);\n    document.removeEventListener(\"touchstart\", handleSkip);\n  }\n  const handleContinueClick = () => startInteraction(\"continue\");\n  const handleResetClick = () => startInteraction(\"reset\");\n\n  async function startInteraction(action) {\n    if (interactionStarted) return;\n    interactionStarted = true;\n    skipBootstrapAnimation = false;\n    if (startContainer) startContainer.classList.add(\"hidden\");\n    if (loadingContainer) loadingContainer.classList.remove(\"hidden\");\n    document.body.style.justifyContent = \"flex-start\";\n    initAudioContext();\n    removeInteractionListeners();\n    addSkipListener();\n    try {\n      const dependenciesLoaded = await loadCoreDependencies();\n      if (!dependenciesLoaded) {\n        removeSkipListener();\n        return;\n      }\n      if (action === \"reset\") {\n        await clearAllReploidData();\n        await bl(\"Rebooting after reset...\", \"info\", null, 64);\n        await bl(\"            \", \"only-gui\", null, 8);\n        await bootstrapReploid(true);\n      } else await bootstrapReploid(false);\n    } catch (err) {\n      const errorMsg = err.message || \"Unknown error during startInteraction.\";\n      await bl(\n        \"FATAL: Unhandled error in startInteraction.\",\n        \"error\",\n        errorMsg\n      );\n      console.error(\"Unhandled startInteraction Error:\", err);\n      if (loadingIndicator)\n        loadingIndicator.innerHTML = `<div class=\"log-entry log-error\">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Check console.</div>`;\n    } finally {\n      removeSkipListener();\n    }\n  }\n  if (continueButton)\n    continueButton.addEventListener(\"click\", handleContinueClick);\n  if (resetButton) resetButton.addEventListener(\"click\", handleResetClick);\n  document.addEventListener(\"keydown\", handleKeydown);\n})();\n",
  "_x0_reploid.core.storage_0": "const StorageModule = (config, logger, Errors) => {\n  if (!config || !logger || !Errors) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[STORAGE_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"StorageModule initialization failed: Missing config, logger, or Errors.\"\n    );\n    return {\n      getArtifactContent: () => null,\n      setArtifactContent: () => {\n        throw new Error(\"Storage not initialized\");\n      },\n      deleteArtifactVersion: () => false,\n      getState: () => null,\n      saveState: () => {\n        throw new Error(\"Storage not initialized\");\n      },\n      removeState: () => false,\n      getSessionState: () => null,\n      saveSessionState: () => {\n        throw new Error(\"Storage not initialized\");\n      },\n      removeSessionState: () => {},\n      clearAllReploidData: () => {\n        internalLog.logEvent(\n          \"error\",\n          \"Cannot clear storage, module not initialized.\"\n        );\n      },\n      getStorageUsage: () => ({ used: 0, quota: 0, percent: 0 }),\n    };\n  }\n\n  const LS_PREFIX = config.LS_PREFIX;\n  const STATE_KEY_BASE = config.STATE_KEY_BASE;\n  const SESSION_STATE_KEY_BASE = config.SESSION_STATE_KEY_BASE;\n  const MAX_ART_TKN_SZ = config.MAX_ARTIFACT_SIZE_BYTES || 4 * 1024 * 1024;\n  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(\".\")[0];\n  const stateKey = STATE_KEY_BASE + STATE_VERSION_MAJOR;\n  const sessionStateKey = SESSION_STATE_KEY_BASE + STATE_VERSION_MAJOR;\n  const QUOTA_BYTES = 5 * 1024 * 1024;\n  const QUOTA_WARNING_THRESHOLD = 0.9;\n  const { StorageError } = Errors;\n\n  const getStorageUsage = () => {\n    let totalBytes = 0;\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if ((key && key.startsWith(LS_PREFIX)) || key === stateKey) {\n          const value = localStorage.getItem(key);\n          totalBytes += (value?.length || 0) * 2;\n        }\n      }\n      const percent = QUOTA_BYTES > 0 ? (totalBytes / QUOTA_BYTES) * 100 : 0;\n      return { used: totalBytes, quota: QUOTA_BYTES, percent: percent };\n    } catch (e) {\n      logger.logEvent(\"error\", \"Failed to calculate storage usage\", e);\n      return { used: -1, quota: QUOTA_BYTES, percent: -1 };\n    }\n  };\n\n  const _get = (key) => {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      logger.logEvent(\"error\", `LocalStorage GET Error for key: ${key}`, e);\n      return null;\n    }\n  };\n\n  const _set = (key, value) => {\n    if (\n      value &&\n      typeof value === \"string\" &&\n      value.length * 2 > MAX_ART_TKN_SZ\n    ) {\n      const msg = `Artifact content exceeds size limit (${\n        value.length * 2\n      } > ${MAX_ART_TKN_SZ} bytes) for key: ${key}`;\n      logger.logEvent(\"error\", msg);\n      throw new StorageError(msg, { key, size: value.length * 2 });\n    }\n\n    const usage = getStorageUsage();\n    const estimatedNewSize = (value?.length || 0) * 2;\n    const currentItemSize = (_get(key)?.length || 0) * 2;\n    const estimatedUsageAfter = usage.used - currentItemSize + estimatedNewSize;\n\n    if (\n      usage.used >= 0 &&\n      estimatedUsageAfter / QUOTA_BYTES > QUOTA_WARNING_THRESHOLD\n    ) {\n      logger.logEvent(\n        \"warn\",\n        `LocalStorage usage high (${(\n          (estimatedUsageAfter / QUOTA_BYTES) *\n          100\n        ).toFixed(1)}%) after setting key: ${key}`\n      );\n    }\n\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (e) {\n      let errorMessage = `LocalStorage SET Error for key: ${key}`;\n      if (\n        e.name === \"QuotaExceededError\" ||\n        (e.code && (e.code === 22 || e.code === 1014))\n      ) {\n        errorMessage = `LocalStorage Quota Exceeded. Usage: ${(\n          usage.used /\n          1024 /\n          1024\n        ).toFixed(2)}MB / ${(QUOTA_BYTES / 1024 / 1024).toFixed(2)}MB.`;\n        logger.logEvent(\"error\", errorMessage, e);\n        throw new StorageError(errorMessage, { key, quotaExceeded: true });\n      } else {\n        logger.logEvent(\"error\", errorMessage, e);\n        throw new StorageError(errorMessage, { key, originalError: e });\n      }\n    }\n  };\n\n  const _remove = (key) => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (e) {\n      logger.logEvent(\"error\", `LocalStorage REMOVE Error for key: ${key}`, e);\n      return false;\n    }\n  };\n\n  const _key = (id, cycle = 0, versionId = null) => {\n    let baseKey = `${LS_PREFIX}${id}_${cycle}`;\n    if (\n      versionId !== null &&\n      typeof versionId === \"string\" &&\n      versionId.length > 0\n    ) {\n      baseKey += `#${versionId}`;\n    }\n    return baseKey;\n  };\n\n  const getArtifactContent = (id, cycle, versionId = null) =>\n    _get(_key(id, cycle, versionId));\n\n  const setArtifactContent = (id, cycle, content, versionId = null) =>\n    _set(_key(id, cycle, versionId), content);\n\n  const deleteArtifactVersion = (id, cycle, versionId = null) =>\n    _remove(_key(id, cycle, versionId));\n\n  const getState = () => {\n    const json = _get(stateKey);\n    try {\n      return json ? JSON.parse(json) : null;\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Failed to parse state from localStorage: ${e.message}`\n      );\n      _remove(stateKey);\n      return null;\n    }\n  };\n\n  const saveState = (stateObj) => {\n    try {\n      return _set(stateKey, JSON.stringify(stateObj));\n    } catch (e) {\n      logger.logEvent(\"error\", \"Failed to save state due to storage error.\", e);\n      throw e;\n    }\n  };\n\n  const removeState = () => _remove(stateKey);\n\n  const getSessionState = () => {\n    try {\n      const json = sessionStorage.getItem(sessionStateKey);\n      return json ? JSON.parse(json) : null;\n    } catch (e) {\n      logger.logEvent(\"error\", `Failed to parse session state: ${e.message}`);\n      try {\n        sessionStorage.removeItem(sessionStateKey);\n      } catch (se) {}\n      return null;\n    }\n  };\n\n  const saveSessionState = (stateObj) => {\n    try {\n      sessionStorage.setItem(sessionStateKey, JSON.stringify(stateObj));\n      return true;\n    } catch (e) {\n      logger.logEvent(\"error\", `SessionStorage SET Error: ${e.message}`);\n      if (e.name === \"QuotaExceededError\") {\n        throw new StorageError(`SessionStorage Quota Exceeded.`, {\n          quotaExceeded: true,\n        });\n      }\n      throw new StorageError(`SessionStorage SET Error: ${e.message}`, {\n        originalError: e,\n      });\n    }\n  };\n\n  const removeSessionState = () => {\n    try {\n      sessionStorage.removeItem(sessionStateKey);\n    } catch (e) {\n      logger.logEvent(\"warn\", `SessionStorage REMOVE Error: ${e.message}`);\n    }\n  };\n\n  const clearAllReploidData = () => {\n    logger.logEvent(\"warn\", \"Initiating LocalStorage clear for Reploid data.\");\n    let keysToRemove = [];\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach((key) => _remove(key));\n      removeState();\n      logger.logEvent(\n        \"info\",\n        `Removed ${keysToRemove.length} artifact/state keys from localStorage.`\n      );\n      try {\n        sessionStorage.clear();\n        logger.logEvent(\"info\", \"Cleared SessionStorage.\");\n      } catch (e) {\n        logger.logEvent(\"warn\", \"Failed to clear SessionStorage.\", e.message);\n      }\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Error during key iteration/removal in clearAllReploidData: ${e.message}`\n      );\n    }\n  };\n\n  return {\n    getArtifactContent,\n    setArtifactContent,\n    deleteArtifactVersion,\n    getState,\n    saveState,\n    removeState,\n    getSessionState,\n    saveSessionState,\n    removeSessionState,\n    clearAllReploidData,\n    getStorageUsage,\n  };\n};\n",
  "_x0_reploid.core.critiquer-prompt_0": "You are Critiqer x0. Your task is to objectively critique a target artifact based on specific criteria and the original goal context.\n\nGoal Type: [[LATEST_GOAL_TYPE]]\nCumulative Goal Context: [[CUMULATIVE_GOAL_CONTEXT]]\nAgent Confidence (Primary Candidate): [[AGENT_CONFIDENCE]]\nProposed Changes Description:\n[[PROPOSED_CHANGES_DESC]]\n\nProposed Artifact Changes Summary:\n\nModified: [[MODIFIED_ARTIFACT_IDS_VERSIONS]] (Paradigm of each: [[MODIFIED_ARTIFACT_PARADIGMS]])\nNew: [[NEW_ARTIFACT_IDS_TYPES_VERSIONS]] (Paradigm of each: [[NEW_ARTIFACT_PARADIGMS]])\nDeleted: [[DELETED_ARTIFACT_IDS]] (Paradigm of each: [[DELETED_ARTIFACT_PARADIGMS]])\nModular: [[MODULAR_ARTIFACT_IDS_VERSIONS]] (Paradigm of base: [[MODULAR_ARTIFACT_PARADIGMS]])\n\nFull Source (String): [[HAS_FULL_HTML_SOURCE]]\nPage Composition (Structured): [[HAS_PAGE_COMPOSITION]]\n\nNew Tools: [[NEW_TOOL_NAMES]]\nWeb Components Defined (via tool_calls to define_web_component): [[NEW_WEB_COMPONENT_TAG_NAMES]]\n\nTask:\nCritique the primary proposed changes. Prioritize based on artifact paradigm.\nParadigm Definitions:\n- pure: Deterministic, no side-effects. Focus: Algorithmic correctness, input/output contracts.\n- semi-pure: Uses stable closed-over dependencies for reads, core logic deterministic. Focus: Correct use of dependencies, logic correctness.\n- boundary_io: Direct I/O (localStorage, DOM, API). Focus: Error handling, resource management, API contracts, security.\n- boundary_orchestration: Coordinates logic, calls other modules/boundaries. Focus: Correct orchestration, state management interactions, flow control.\n- data / ui_template: Non-executable content. Focus: Schema adherence, relevance to goal.\n\nSystem Goal: Check 'target.*' artifacts (syntax, consistency, goal alignment, paradigm rules). Validate tool/WC decl/impl if present.\nMeta Goal: Check 'reploid.*' artifacts (syntax, consistency, side-effects, goal alignment, paradigm rules). Validate tools/WCs. Check HTML integrity/state preservation for `full_html_source` or `page_composition`. If `page_composition` is used, verify its structure. If `hitlOnMetaChanges` is active, Meta changes (especially to `boundary_io` or `boundary_orchestration` paradigms, or `reploid.core.*`, new `reploid.core.webcomponent.*`, or page structure via `page_composition`/`full_html_source`) require stricter scrutiny; if plausible but significant, recommend human review even if critique passes.\nOverall: Does proposal address goal? Is confidence score reasonable? Does description match changes?\n\nWeb Component Checks (if define_web_component is called):\ntagName: Is it valid (lowercase, includes a hyphen)?\nclassContent (paradigm: pure/semi-pure for logic, boundary_io for DOM): JS class extending HTMLElement? Constructor/connectedCallback?\ntargetArtifactId: Reasonable ID for a WEB_COMPONENT_DEF artifact? (paradigm: data)\nIf reploid.core.webcomponent.*, is the change justified and necessary for core functionality?\n\nPage Composition Checks (if `page_composition` is proposed, paradigm: data for definition, but implies boundary_orchestration change):\n- Doctype, html_attributes, head_elements, body_elements present?\n- Plausible artifact_id references (e.g., `reploid.core.style` (paradigm: data) for styles)?\n- Script references (type: `artifact_id` referring to JS paradigm artifacts, or `path`) structured correctly?\n- For Meta goals, is it a safe and coherent restructuring? Assess script inlining for core scripts.\n\nReport: Output concise, factual list of failures or confirm success. Note if Meta change warrants human review, considering paradigm.\nOutput (JSON ONLY): {\"critique_passed\": boolean, \"critique_report\": \"string\"}\nADDITIONAL INSTRUCTIONS:\nOutput Strictness: YOU MUST output ONLY a single valid JSON object.\nFactual Reporting: List specific, objective reasons for failure or confirm success.\nConsistency Check: Verify [[PROPOSED_CHANGES_DESC]] against summaries.\nParadigm Adherence: Check if changes respect the intended paradigm of the artifact.\nTool/WC/PageComposition Validation: Basic plausibility checks considering paradigms.",
  "_x0_reploid.boot.log_0": "REPLOID Bootstrap Log - 2025-05-20T00:20:09.800Z\n=========================================\n[2025-05-20T00:21:14.664Z] [INFO] Loading core configuration...\n[2025-05-20T00:21:14.826Z] [ONLY-CONSOLE] Config loaded. | Version: 0.7.0\n[2025-05-20T00:21:14.826Z] [INFO] Loading core utilities (incl. Errors)...\n[2025-05-20T00:21:14.985Z] [ONLY-CONSOLE] Utils (incl. Errors) loaded.\n[2025-05-20T00:21:14.985Z] [INFO] Loading core storage...\n[2025-05-20T00:21:15.118Z] [ONLY-CONSOLE] Storage loaded.\n[2025-05-20T00:21:15.118Z] [INFO] Loading pure helper modules...\n[2025-05-20T00:21:15.359Z] [ONLY-CONSOLE] Pure helper modules loaded.\n[2025-05-20T00:21:15.359Z] [SUCCESS] Core dependencies loaded.\n[2025-05-20T00:21:15.361Z] [WARN] Clearing all REPLOID data from LocalStorage...\n[2025-05-20T00:21:16.190Z] [INFO] LocalStorage cleared.\n[2025-05-20T00:21:16.398Z] [INFO] Rebooting after reset...\n[2025-05-20T00:21:18.101Z] [ONLY-GUI]             \n[2025-05-20T00:21:18.231Z] [ONLY-GUI] Reset requested...\n[2025-05-20T00:21:18.370Z] [INFO] Running genesis boot process...\n[2025-05-20T00:21:18.528Z] [INFO] Fetching genesis artifacts...\n[2025-05-20T00:21:18.632Z] [ONLY-CONSOLE] Fetched: utils.js | 12397 bytes\n[2025-05-20T00:21:18.635Z] [ONLY-CONSOLE] Fetched: config.json | 4785 bytes\n[2025-05-20T00:21:18.641Z] [ONLY-CONSOLE] Fetched: storage.js | 7936 bytes\n[2025-05-20T00:21:18.641Z] [ONLY-CONSOLE] Fetched: prompt-critiquer.txt | 4074 bytes\n[2025-05-20T00:21:18.643Z] [ONLY-CONSOLE] Fetched: agent-cycle.js | 98132 bytes\n[2025-05-20T00:21:18.643Z] [ONLY-CONSOLE] Fetched: state-manager.js | 20471 bytes\n[2025-05-20T00:21:18.644Z] [ONLY-CONSOLE] Fetched: data-eval-default.json | 2770 bytes\n[2025-05-20T00:21:18.655Z] [ONLY-CONSOLE] Fetched: api-client.js | 22093 bytes\n[2025-05-20T00:21:18.655Z] [ONLY-CONSOLE] Fetched: app-logic.js | 10250 bytes\n[2025-05-20T00:21:18.656Z] [ONLY-CONSOLE] Fetched: prompt-system.txt | 8335 bytes\n[2025-05-20T00:21:18.658Z] [ONLY-CONSOLE] Fetched: ui-body-template.html | 25109 bytes\n[2025-05-20T00:21:18.666Z] [ONLY-CONSOLE] Fetched: data-tools-static.json | 8715 bytes\n[2025-05-20T00:21:18.666Z] [ONLY-CONSOLE] Fetched: ui-style.css | 17508 bytes\n[2025-05-20T00:21:18.674Z] [ONLY-CONSOLE] Fetched: prompt-evaluator.txt | 1903 bytes\n[2025-05-20T00:21:18.674Z] [ONLY-CONSOLE] Fetched: prompt-summarizer.txt | 1395 bytes\n[2025-05-20T00:21:18.684Z] [ONLY-CONSOLE] Fetched: tool-runner.js | 22086 bytes\n[2025-05-20T00:21:18.687Z] [ONLY-CONSOLE] Fetched: ui-manager.js | 67572 bytes\n[2025-05-20T00:21:18.687Z] [ONLY-CONSOLE] Fetched 17 genesis artifacts.\n[2025-05-20T00:21:18.687Z] [INFO] Saving genesis artifacts (Cycle 0)...\n[2025-05-20T00:21:18.690Z] [ONLY-CONSOLE] Saved: reploid.core.utils | Cyc 0, CS: sha256-041ee2ba...\n[2025-05-20T00:21:18.690Z] [ONLY-CONSOLE] Saved: reploid.core.config | Cyc 0, CS: sha256-f92af7de...\n[2025-05-20T00:21:18.690Z] [ONLY-CONSOLE] Saved: reploid.core.storage | Cyc 0, CS: sha256-4e8fcac1...\n[2025-05-20T00:21:18.690Z] [ONLY-CONSOLE] Saved: reploid.core.critiquer-prompt | Cyc 0, CS: sha256-c6276063...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.cyclelogic | Cyc 0, CS: sha256-cb56cbd1...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.statemanager | Cyc 0, CS: sha256-808e9166...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.default-eval | Cyc 0, CS: sha256-ecfad2e3...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.apiclient | Cyc 0, CS: sha256-37cb3410...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.logic | Cyc 0, CS: sha256-b8d7638a...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.sys-prompt | Cyc 0, CS: sha256-35bdb23b...\n[2025-05-20T00:21:18.691Z] [ONLY-CONSOLE] Saved: reploid.core.body | Cyc 0, CS: sha256-1cfcce23...\n[2025-05-20T00:21:18.692Z] [ONLY-CONSOLE] Saved: reploid.core.static-tools | Cyc 0, CS: sha256-919973d2...\n[2025-05-20T00:21:18.692Z] [ONLY-CONSOLE] Saved: reploid.core.style | Cyc 0, CS: sha256-ae4db888...\n[2025-05-20T00:21:18.692Z] [ONLY-CONSOLE] Saved: reploid.core.evaluator-prompt | Cyc 0, CS: sha256-7b93fb87...\n[2025-05-20T00:21:18.692Z] [ONLY-CONSOLE] Saved: reploid.core.summarizer-prompt | Cyc 0, CS: sha256-69fe4fb8...\n[2025-05-20T00:21:18.692Z] [ONLY-CONSOLE] Saved: reploid.core.toolrunner | Cyc 0, CS: sha256-5bab5149...\n[2025-05-20T00:21:18.693Z] [ONLY-CONSOLE] Saved: reploid.core.ui | Cyc 0, CS: sha256-69b1aa31...\n",
  "x0_state_v0": "{\"version\":\"0.7.0\",\"totalCycles\":2,\"agentIterations\":2,\"humanInterventions\":1,\"failCount\":0,\"currentGoal\":{\"seed\":\"create a game that shows how to use an llm\",\"cumulative\":\"create a game that shows how to use an llm\",\"latestType\":\"System\",\"summaryContext\":null,\"currentContextFocus\":\"Full Goal Context\"},\"lastCritiqueType\":\"Human (Random Review (25%))\",\"personaMode\":\"LSD\",\"lastFeedback\":\"Human Prompt: Provided prompt: LGTM\",\"lastSelfAssessment\":\"The change to `target.body.html` is a full replacement because the provided snippet was too short to reliably perform a modular edit. This new structure is comprehensive and aligns with standard web practices for such an application. The CSS changes are also a full replacement for simplicity and to ensure all new elements are styled. The inclusion of `script src` at the end of body is a good practice. The new class `.output-box` is an intuitive addition for styling shared characteristics of target and LLM response areas.\",\"forceHumanReview\":false,\"apiKey\":\"AIzaSyDzMe3HLYVXlk7SxZTI6IVM5dgeSGZDWKI\",\"confidenceHistory\":[0.9],\"critiqueFailHistory\":[false,false],\"tokenHistory\":[2507,3101],\"failHistory\":[],\"evaluationHistory\":[{\"evaluation_score\":0.76,\"evaluation_report\":\"The target content describes the initial technical foundation (HTML/CSS/JS) for a game aimed at showing LLM usage. While it acknowledges the overall goal, this specific 'first step' focuses on general web development setup rather than directly demonstrating or explicitly leading to showing LLM capabilities, impacting goal alignment slightly. The technical description of this foundational step is plausible and correct, the justification is clear, and it appears complete for the limited scope of a 'first step'.\",\"targetArtifactId\":\"llm.justification\",\"targetArtifactCycle\":0,\"evalDefinitionId\":\"reploid.core.default-eval\",\"timestamp\":1747700838388}],\"critiqueFeedbackHistory\":[],\"avgConfidence\":0.9,\"critiqueFailRate\":0,\"avgTokens\":2804,\"avgEvalScore\":0.76,\"evalPassRate\":100,\"contextTokenEstimate\":5608,\"contextTokenTarget\":350000,\"lastGeneratedFullSource\":null,\"htmlHistory\":[],\"lastApiResponse\":null,\"retryCount\":0,\"autonomyMode\":\"Manual\",\"autonomyCyclesRemaining\":0,\"cfg\":{\"personaBalance\":50,\"llmCritiqueProb\":75,\"humanReviewProb\":25,\"maxCycleTime\":600,\"autoCritiqueThresh\":0.7,\"maxCycles\":10,\"htmlHistoryLimit\":5,\"pauseAfterCycles\":10,\"maxRetries\":2,\"autonomyMode\":\"Manual\",\"autonomyDefaultNCycles\":5,\"contextTokenTarget\":350000,\"coreModel\":\"gemini-2.5-pro-preview-05-06\",\"critiqueModel\":\"gemini-2.5-flash-preview-04-17\",\"summarizerModel\":\"BASE\",\"evaluatorModel\":\"BASE\",\"hitlOnMetaChanges\":true,\"enablePageComposition\":true,\"apiKey\":\"AIzaSyDzMe3HLYVXlk7SxZTI6IVM5dgeSGZDWKI\"},\"artifactMetadata\":{\"reploid.core.utils\":[{\"id\":\"reploid.core.utils\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Core utility functions (includes custom Error definitions)\",\"source\":\"Genesis\",\"checksum\":\"sha256-041ee2ba72c515e4529fb59a003e091cbb9ed44c5468a89f5b63a29aba2df855\",\"timestamp\":1747700478688,\"paradigm\":\"pure\"}],\"reploid.core.config\":[{\"id\":\"reploid.core.config\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JSON_CONFIG\",\"description\":\"Central application configuration\",\"source\":\"Genesis\",\"checksum\":\"sha256-f92af7de966c71f5cc223c7390fd4327a77531295378bbc7efbecdb31c28ca18\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.storage\":[{\"id\":\"reploid.core.storage\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Core storage functions\",\"source\":\"Genesis\",\"checksum\":\"sha256-4e8fcac124965b03cac74e9047b840503859827a14c135a94725edb80592d776\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_io\"}],\"reploid.core.critiquer-prompt\":[{\"id\":\"reploid.core.critiquer-prompt\",\"version_id\":null,\"latestCycle\":0,\"type\":\"PROMPT\",\"description\":\"Critique prompt\",\"source\":\"Genesis\",\"checksum\":\"sha256-c62760635b7d49083e663f54046b65f8f7387082447f8b7d9b2f53f672d612f2\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.cyclelogic\":[{\"id\":\"reploid.core.cyclelogic\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Main application cycle orchestration\",\"source\":\"Genesis\",\"checksum\":\"sha256-cb56cbd1f27ab3d1ad46500aadeed4ac1ce245449003a437d70f1664a2a58767\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_orchestration\"}],\"reploid.core.statemanager\":[{\"id\":\"reploid.core.statemanager\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Core state management logic\",\"source\":\"Genesis\",\"checksum\":\"sha256-808e91667695dfa8f9beeeaead6f0165dc96dab6dbadc11c199ee20491361bce\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_orchestration\"}],\"reploid.core.default-eval\":[{\"id\":\"reploid.core.default-eval\",\"version_id\":null,\"latestCycle\":0,\"type\":\"EVAL_DEF\",\"description\":\"Default Evaluation Definition\",\"source\":\"Genesis\",\"checksum\":\"sha256-ecfad2e337e337d38b440ec4b93f36f692e22600e6d095f31aa9ef04433aed7d\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.apiclient\":[{\"id\":\"reploid.core.apiclient\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Handles API communication\",\"source\":\"Genesis\",\"checksum\":\"sha256-37cb34106712a92e19b2a835a2d062aa7ea9e7d525b283ed81100bb478a9f144\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_io\"}],\"reploid.core.logic\":[{\"id\":\"reploid.core.logic\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Main application logic orchestrator\",\"source\":\"Genesis\",\"checksum\":\"sha256-b8d7638aad20e2f3e1131e22e7ffb46deccbe33c6c22edef0f564ee8566b7cc0\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_orchestration\"}],\"reploid.core.sys-prompt\":[{\"id\":\"reploid.core.sys-prompt\",\"version_id\":null,\"latestCycle\":0,\"type\":\"PROMPT\",\"description\":\"Core LLM prompt\",\"source\":\"Genesis\",\"checksum\":\"sha256-35bdb23b5ce5a2ec53eda2836163faa1c2fc33f6e353f3f094bfa1332924feb1\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.body\":[{\"id\":\"reploid.core.body\",\"version_id\":null,\"latestCycle\":0,\"type\":\"HTML\",\"description\":\"App root HTML structure (used if not overridden by page_composition)\",\"source\":\"Genesis\",\"checksum\":\"sha256-1cfcce2308bc09e5a242a8e864c9d92469f9eed8de11aa52575738ecd6297fd7\",\"timestamp\":1747700478688,\"paradigm\":\"ui_template\"}],\"reploid.core.static-tools\":[{\"id\":\"reploid.core.static-tools\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JSON\",\"description\":\"Static tool definitions\",\"source\":\"Genesis\",\"checksum\":\"sha256-919973d259190e496ab584ecaef0ab44e12a51c0f9d735cea78fced3642523aa\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.style\":[{\"id\":\"reploid.core.style\",\"version_id\":null,\"latestCycle\":0,\"type\":\"CSS\",\"description\":\"Main application styles\",\"source\":\"Genesis\",\"checksum\":\"sha256-ae4db88814884a83700b91a07bf8de91e69c947cbb6778016ee71c86ab6f34c7\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.evaluator-prompt\":[{\"id\":\"reploid.core.evaluator-prompt\",\"version_id\":null,\"latestCycle\":0,\"type\":\"PROMPT\",\"description\":\"Self-evaluation prompt\",\"source\":\"Genesis\",\"checksum\":\"sha256-7b93fb87a7270e731c0f6c6755bddf6f89bd4547579901d395c1a2b5651ac8a4\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.summarizer-prompt\":[{\"id\":\"reploid.core.summarizer-prompt\",\"version_id\":null,\"latestCycle\":0,\"type\":\"PROMPT\",\"description\":\"Summarization prompt\",\"source\":\"Genesis\",\"checksum\":\"sha256-69fe4fb8ac6de8364a2197848485bdc42a7ae8f66b97d2d8e55a6156c48604a4\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.core.toolrunner\":[{\"id\":\"reploid.core.toolrunner\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Tool execution engine (static + dynamic via worker)\",\"source\":\"Genesis\",\"checksum\":\"sha256-5bab514929cd80fd63c4186ebb4b78014b8021bc74064942e4390ae26b102675\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_orchestration\"}],\"reploid.core.ui\":[{\"id\":\"reploid.core.ui\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Core UI rendering and event handling\",\"source\":\"Genesis\",\"checksum\":\"sha256-69b1aa31775c6b9c5768b3032606587dc10e4097a12ddbe0269b4dafabb291c9\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_io\"}],\"reploid.boot.style\":[{\"id\":\"reploid.boot.style\",\"version_id\":null,\"latestCycle\":0,\"type\":\"CSS\",\"description\":\"Bootstrap CSS from index.html\",\"source\":\"BootstrapCapture\",\"checksum\":\"sha256-41e981c3e6c154993b04d180ea6d22dae37eb7b16d10713735c2ce87918ab1e0\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"reploid.boot.script\":[{\"id\":\"reploid.boot.script\",\"version_id\":null,\"latestCycle\":0,\"type\":\"JS\",\"description\":\"Bootstrap script (boot.js) content\",\"source\":\"BootstrapCapture\",\"checksum\":\"sha256-22c29c72d6e65341c4d4c5981fdb46f7b89cb37c91820ad7bde8621411559a4c\",\"timestamp\":1747700478688,\"paradigm\":\"boundary_orchestration\"}],\"reploid.boot.log\":[{\"id\":\"reploid.boot.log\",\"version_id\":null,\"latestCycle\":0,\"type\":\"LOG\",\"description\":\"Bootstrap execution log\",\"source\":\"BootstrapCapture\",\"checksum\":\"sha256-b949a2f79363cf2281034d776b3e62785ae9b4f91e8ac016a62dae908b79122a\",\"timestamp\":1747700478688,\"paradigm\":\"data\"}],\"target.body.html\":[{\"id\":\"target.body.html\",\"version_id\":null,\"type\":\"HTML\",\"description\":\"Main HTML structure for the LLM Prompt Challenge game.\",\"latestCycle\":1,\"checksum\":\"sha256-1748f951956ccee3fea9df56d67ba00e9c4f647b48d8245f31fd9eb442137548\",\"source\":\"autocrit-1runs-pass\",\"timestamp\":1747700833063,\"isModularEdit\":false,\"paradigm\":\"ui_template\"}],\"target.style.css\":[{\"id\":\"target.style.css\",\"version_id\":null,\"type\":\"CSS\",\"description\":\"CSS styles for the LLM Prompt Challenge game.\",\"latestCycle\":1,\"checksum\":\"sha256-579f515ea3a9b04d27895b8fff634bc97f333175e7f70751a4e5d758e295714e\",\"source\":\"autocrit-1runs-pass\",\"timestamp\":1747700833064,\"isModularEdit\":false,\"paradigm\":\"data\"}],\"target.script.js\":[{\"id\":\"target.script.js\",\"version_id\":null,\"type\":\"JS\",\"description\":\"JavaScript logic for the LLM Prompt Challenge game, handling user interaction and game flow.\",\"latestCycle\":1,\"checksum\":\"sha256-28e9f1861214c2b883b1e624b027f152f77b24fc671b996eb537740baff13bcc\",\"source\":\"autocrit-1runs-pass\",\"timestamp\":1747700833064,\"isModularEdit\":false,\"paradigm\":\"boundary_orchestration\"}]},\"dynamicTools\":[],\"registeredWebComponents\":[]}",
  "_x0_reploid.core.toolrunner_0": "const ToolRunnerModule = (\n  config,\n  logger,\n  Storage,\n  StateManager,\n  ApiClient,\n  Errors,\n  Utils,\n  ToolRunnerPureHelpers\n) => {\n  if (\n    !config ||\n    !logger ||\n    !Storage ||\n    !StateManager ||\n    !ApiClient ||\n    !Errors ||\n    !Utils ||\n    !ToolRunnerPureHelpers\n  ) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[TOOLRUNNER_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"ToolRunnerModule initialization failed: Missing dependencies.\"\n    );\n    return {\n      runTool: async (toolName) => {\n        throw new (Errors?.ConfigError || Error)(\n          `ToolRunner not initialized, cannot run ${toolName}`\n        );\n      },\n    };\n  }\n\n  const { ToolError, ArtifactError, WebComponentError } = Errors;\n  const DYNAMIC_TOOL_TIMEOUT_MS = config.DYNAMIC_TOOL_TIMEOUT_MS || 10000;\n  const WORKER_SCRIPT_PATH = config.WORKER_SCRIPT_PATH || \"tool-worker.js\";\n\n  const runToolInternal = async (\n    toolName,\n    toolArgs,\n    injectedStaticTools,\n    injectedDynamicTools,\n    uiHooks = {}\n  ) => {\n    logger.logEvent(\"info\", `Run tool: ${toolName}`, toolArgs || {});\n    const staticTool = injectedStaticTools.find((t) => t.name === toolName);\n\n    if (staticTool) {\n      let artifactContent = null;\n      if (\n        toolArgs &&\n        toolArgs.artifactId &&\n        typeof toolArgs.cycle === \"number\"\n      ) {\n        artifactContent = Storage.getArtifactContent(\n          toolArgs.artifactId,\n          toolArgs.cycle,\n          toolArgs.versionId\n        );\n        if (\n          artifactContent === null &&\n          ![\n            \"list_artifacts\",\n            \"define_web_component\",\n            \"apply_diff_patch\",\n            \"apply_json_patch\",\n            \"convert_to_gemini_fc\",\n            \"run_self_evaluation\",\n          ].includes(toolName)\n        ) {\n          throw new ArtifactError(\n            `Artifact content not found for ${toolArgs.artifactId} cycle ${\n              toolArgs.cycle\n            } (vId: ${toolArgs.versionId || \"latest\"})`,\n            toolArgs.artifactId,\n            toolArgs.cycle\n          );\n        }\n      }\n\n      switch (toolName) {\n        case \"code_linter\":\n          const lintResult = ToolRunnerPureHelpers.basicCodeLintPure(\n            artifactContent,\n            toolArgs.language\n          );\n          return {\n            result: `Basic lint ${\n              lintResult.linting_passed ? \"passed\" : \"failed\"\n            } for ${toolArgs.language}.${\n              lintResult.error_message\n                ? \" Error: \" + lintResult.error_message\n                : \"\"\n            }`,\n            ...lintResult,\n          };\n\n        case \"json_validator\":\n          const validation =\n            ToolRunnerPureHelpers.validateJsonStructurePure(artifactContent);\n          return {\n            result: `JSON structure is ${\n              validation.valid ? \"valid\" : \"invalid\"\n            }.${validation.error ? \" Error: \" + validation.error : \"\"}`,\n            ...validation,\n          };\n\n        case \"read_artifact\":\n          if (artifactContent === null)\n            throw new ArtifactError(\n              `Artifact content not found for ${toolArgs.artifactId} cycle ${\n                toolArgs.cycle\n              } (vId: ${toolArgs.versionId || \"latest\"})`,\n              toolArgs.artifactId,\n              toolArgs.cycle\n            );\n          return {\n            content: artifactContent,\n            artifactId: toolArgs.artifactId,\n            cycle: toolArgs.cycle,\n            versionId: toolArgs.versionId || null,\n          };\n\n        case \"list_artifacts\":\n          const allMetaMap = StateManager.getAllArtifactMetadata();\n          let filteredMeta = Object.values(allMetaMap);\n          if (toolArgs.filterType)\n            filteredMeta = filteredMeta.filter(\n              (meta) =>\n                meta.type &&\n                meta.type.toUpperCase() === toolArgs.filterType.toUpperCase()\n            );\n          if (toolArgs.filterPattern) {\n            try {\n              const regex = new RegExp(toolArgs.filterPattern);\n              filteredMeta = filteredMeta.filter((meta) => regex.test(meta.id));\n            } catch (e) {\n              throw new ToolError(\n                `Invalid regex pattern: ${e.message}`,\n                toolName,\n                toolArgs\n              );\n            }\n          }\n          if (toolArgs.includeAllVersions) {\n            const allVersions = [];\n            for (const meta of filteredMeta)\n              allVersions.push(\n                ...StateManager.getArtifactMetadataAllVersions(meta.id)\n              );\n            return {\n              artifacts: allVersions.map((m) => ({\n                id: m.id,\n                type: m.type,\n                latestCycle: m.latestCycle,\n                versionId: m.version_id,\n                timestamp: m.timestamp,\n                source: m.source,\n                paradigm: m.paradigm,\n              })),\n            };\n          } else {\n            return {\n              artifacts: filteredMeta.map((meta) => ({\n                id: meta.id,\n                type: meta.type,\n                latestCycle: meta.latestCycle,\n                paradigm: meta.paradigm,\n              })),\n            };\n          }\n\n        case \"diff_text\":\n          return ToolRunnerPureHelpers.diffTextPure(\n            toolArgs.textA,\n            toolArgs.textB\n          );\n\n        case \"convert_to_gemini_fc\":\n          const geminiFc =\n            ToolRunnerPureHelpers.convertToGeminiFunctionDeclarationPure(\n              toolArgs.mcpToolDefinition,\n              logger\n            );\n          if (!geminiFc)\n            throw new ToolError(\n              \"Failed to convert MCP tool to Gemini FC format.\",\n              toolName,\n              toolArgs\n            );\n          return { geminiFunctionDeclaration: geminiFc };\n\n        case \"code_edit\":\n          const { success, validatedContent, error, contentChanged } =\n            await (async () => {\n              const originalContent = Storage.getArtifactContent(\n                toolArgs.artifactId,\n                toolArgs.cycle,\n                toolArgs.versionId\n              );\n              if (\n                originalContent === null &&\n                toolArgs.artifactId !== \"full_html_source\" &&\n                toolArgs.artifactId !== \"page_composition_preview\"\n              ) {\n                // Allow new full source\n                throw new ArtifactError(\n                  `Original artifact not found for code_edit: ${toolArgs.artifactId}`,\n                  toolArgs.artifactId,\n                  toolArgs.cycle\n                );\n              }\n              const isSame = originalContent === toolArgs.newContent;\n              let validationError = null;\n              try {\n                const artifactMeta = StateManager.getArtifactMetadata(\n                  toolArgs.artifactId\n                );\n                if (\n                  artifactMeta?.type === \"JSON\" ||\n                  artifactMeta?.type === \"JSON_CONFIG\"\n                )\n                  JSON.parse(toolArgs.newContent);\n              } catch (e) {\n                validationError = `Invalid JSON: ${e.message}`;\n              }\n\n              return {\n                success: !validationError,\n                validatedContent: toolArgs.newContent,\n                error: validationError,\n                contentChanged: !isSame,\n                artifactId: toolArgs.artifactId,\n                cycle: toolArgs.cycle,\n                versionId: toolArgs.versionId,\n              };\n            })();\n          return {\n            success,\n            validatedContent,\n            error,\n            contentChanged,\n            artifactId: toolArgs.artifactId,\n            cycle: toolArgs.cycle,\n            versionId: toolArgs.versionId,\n          };\n\n        case \"run_self_evaluation\":\n          const evalState = StateManager.getState();\n          if (!evalState?.apiKey)\n            throw new Errors.ConfigError(\n              \"API Key required for self-evaluation tool.\"\n            );\n          const {\n            targetArtifactId,\n            targetArtifactCycle,\n            targetArtifactVersionId,\n            evalCriteriaText,\n            goalContextText,\n            evalDefinitionId,\n            contentToEvaluate: explicitContent,\n          } = toolArgs;\n          let finalContentToEvaluate = explicitContent;\n          if (!finalContentToEvaluate) {\n            const meta = StateManager.getArtifactMetadata(\n              targetArtifactId,\n              targetArtifactVersionId\n            );\n            const cycleToUse = meta ? meta.latestCycle : targetArtifactCycle;\n            finalContentToEvaluate = Storage.getArtifactContent(\n              targetArtifactId,\n              cycleToUse,\n              targetArtifactVersionId\n            );\n          }\n          if (finalContentToEvaluate === null)\n            throw new ArtifactError(\n              \"Content to evaluate not found or provided.\",\n              targetArtifactId,\n              targetArtifactCycle\n            );\n\n          const evalPromptTemplate = Storage.getArtifactContent(\n            \"reploid.core.evaluator-prompt\",\n            0\n          );\n          if (!evalPromptTemplate)\n            throw new ArtifactError(\n              \"Evaluator prompt artifact not found.\",\n              \"reploid.core.evaluator-prompt\"\n            );\n\n          const evalPrompt = evalPromptTemplate\n            .replace(/\\[\\[GOAL_CONTEXT\\]\\]/g, goalContextText)\n            .replace(/\\[\\[EVALUATION_CRITERIA\\]\\]/g, evalCriteriaText)\n            .replace(\n              /\\[\\[TARGET_CONTENT_OR_PROPOSAL\\]\\]/g,\n              finalContentToEvaluate\n            )\n            .replace(/\\[\\[TARGET_ARTIFACT_ID\\]\\]/g, targetArtifactId)\n            .replace(\n              /\\[\\[TARGET_ARTIFACT_PARADIGM\\]\\]/g,\n              StateManager.getArtifactMetadata(targetArtifactId)?.paradigm ||\n                \"unknown\"\n            );\n\n          const evaluatorModelKey = evalState.cfg?.evaluatorModel || \"BASE\";\n          const evaluatorModelIdentifier =\n            config.DEFAULT_MODELS[evaluatorModelKey.toUpperCase()] ||\n            evaluatorModelKey;\n\n          const apiResult = await ApiClient.callApiWithRetry(\n            evalPrompt,\n            'You are Evaluator x0. Output ONLY valid JSON: {\"evaluation_score\": float, \"evaluation_report\": \"string\"}',\n            evaluatorModelIdentifier,\n            evalState.apiKey,\n            [],\n            false,\n            null,\n            1,\n            {},\n            uiHooks.updateStatus,\n            uiHooks.logTimeline,\n            uiHooks.updateTimelineItem\n          );\n          if (!apiResult || apiResult.type !== \"text\" || !apiResult.content)\n            throw new ToolError(\n              \"Self-evaluation LLM call failed or returned no content.\",\n              toolName,\n              toolArgs\n            );\n\n          const sanitized = ApiClient.sanitizeLlmJsonResp(apiResult.content);\n          try {\n            const parsed = JSON.parse(sanitized);\n            if (\n              typeof parsed.evaluation_score !== \"number\" ||\n              typeof parsed.evaluation_report !== \"string\"\n            ) {\n              throw new Error(\"Evaluation response missing required fields.\");\n            }\n            return {\n              ...parsed,\n              targetArtifactId,\n              targetArtifactCycle,\n              targetArtifactVersionId,\n              evalDefinitionId: evalDefinitionId || \"reploid.core.default-eval\", // or extract from evalCriteriaText\n              timestamp: Date.now(),\n            };\n          } catch (e) {\n            throw new ToolError(\n              `Failed to parse self-evaluation LLM response: ${e.message}`,\n              toolName,\n              toolArgs,\n              { rawResponse: sanitized }\n            );\n          }\n\n        case \"define_web_component\":\n          const {\n            tagName,\n            classContent,\n            targetArtifactId: wcTargetId,\n            description,\n          } = toolArgs;\n          if (!tagName || !classContent || !wcTargetId || !description)\n            throw new ToolError(\n              \"Missing required arguments for define_web_component.\",\n              toolName,\n              toolArgs\n            );\n          if (!tagName.includes(\"-\") || tagName.toLowerCase() !== tagName)\n            throw new ToolError(\n              \"Invalid tagName: must include a hyphen and be lowercase.\",\n              toolName,\n              toolArgs,\n              { tagName }\n            );\n\n          try {\n            const ComponentClass = new Function(\n              \"return (\" + classContent + \")\"\n            )();\n            if (\n              typeof ComponentClass !== \"function\" ||\n              !HTMLElement.isPrototypeOf(ComponentClass)\n            ) {\n              throw new WebComponentError(\n                \"Provided classContent does not evaluate to a valid HTMLElement subclass.\",\n                tagName,\n                { classContent }\n              );\n            }\n            customElements.define(tagName, ComponentClass); // Impure DOM interaction\n            StateManager.registerWebComponent(tagName); // Impure StateManager interaction\n\n            const nextCycle = (StateManager.getState()?.totalCycles || 0) + 1; // Semi-pure state read\n            const checksum = await Utils.calculateChecksum(classContent); // Impure (async crypto) but deterministic\n\n            Storage.setArtifactContent(wcTargetId, nextCycle, classContent); // Impure Storage interaction\n            StateManager.updateArtifactMetadata(\n              wcTargetId,\n              \"WEB_COMPONENT_DEF\",\n              description,\n              nextCycle,\n              checksum,\n              \"Tool: define_web_component\",\n              null,\n              false,\n              \"data\"\n            ); // Impure StateManager interaction\n\n            logger.logEvent(\n              \"info\",\n              `Web Component '${tagName}' defined and artifact '${wcTargetId}' saved.`\n            );\n            return {\n              success: true,\n              tagName,\n              artifactId: wcTargetId,\n              message: `Web Component <${tagName}> defined and saved as ${wcTargetId}.`,\n            };\n          } catch (e) {\n            logger.logEvent(\n              \"error\",\n              `Failed to define Web Component '${tagName}': ${e.message}`,\n              e\n            );\n            throw new WebComponentError(\n              `Failed to define Web Component '${tagName}': ${e.message}`,\n              tagName,\n              { originalError: e.toString(), classContent }\n            );\n          }\n\n        case \"apply_diff_patch\":\n          logger.logEvent(\"warn\", \"Tool 'apply_diff_patch' is a placeholder.\");\n          const origContentPatch = Storage.getArtifactContent(\n            toolArgs.artifactId,\n            toolArgs.cycle,\n            toolArgs.versionId\n          );\n          if (origContentPatch === null)\n            throw new ArtifactError(\n              `Original artifact not found for patching: ${toolArgs.artifactId}`,\n              toolArgs.artifactId,\n              toolArgs.cycle\n            );\n          return {\n            success: false,\n            result_content:\n              origContentPatch +\n              `\\n\\n--- PATCHED (Placeholder) ---\\n${toolArgs.patchContent}`,\n            error: \"Tool not fully implemented\",\n            original_content: origContentPatch,\n            patch_applied: false,\n          };\n\n        case \"apply_json_patch\":\n          logger.logEvent(\"warn\", \"Tool 'apply_json_patch' is a placeholder.\");\n          const origJsonContent = Storage.getArtifactContent(\n            toolArgs.artifactId,\n            toolArgs.cycle,\n            toolArgs.versionId\n          );\n          if (origJsonContent === null)\n            throw new ArtifactError(\n              `Original JSON artifact not found for patching: ${toolArgs.artifactId}`,\n              toolArgs.artifactId,\n              toolArgs.cycle\n            );\n          return {\n            success: false,\n            result_content: JSON.stringify(\n              {\n                ...JSON.parse(origJsonContent),\n                __PATCHED_PLACEHOLDER__: toolArgs.patchContent,\n              },\n              null,\n              2\n            ),\n            error: \"Tool not fully implemented\",\n            original_content: origJsonContent,\n            patch_applied: false,\n          };\n\n        default:\n          logger.logEvent(\n            \"warn\",\n            `Static tool '${toolName}' execution logic not fully implemented or recognized.`\n          );\n          return {\n            success: true,\n            message: `Static tool ${toolName} placeholder executed.`,\n            argsReceived: toolArgs,\n          };\n      }\n    }\n\n    const dynamicTool = injectedDynamicTools.find(\n      (t) => t.declaration.name === toolName\n    );\n    if (dynamicTool) {\n      if (!dynamicTool.implementation)\n        throw new ToolError(\n          `Dynamic tool '${toolName}' has no implementation defined.`,\n          toolName\n        );\n      logger.logEvent(\n        \"info\",\n        `Executing dynamic tool '${toolName}' in Web Worker sandbox.`\n      );\n\n      return new Promise((resolve, reject) => {\n        let worker = null;\n        let timeoutId = null;\n        try {\n          worker = new Worker(WORKER_SCRIPT_PATH);\n          timeoutId = setTimeout(() => {\n            const errorMsg = `Dynamic tool '${toolName}' timed out after ${DYNAMIC_TOOL_TIMEOUT_MS}ms.`;\n            logger.logEvent(\"error\", errorMsg);\n            if (worker) worker.terminate();\n            reject(\n              new ToolError(\n                `Dynamic tool '${toolName}' execution timed out.`,\n                toolName\n              )\n            );\n          }, DYNAMIC_TOOL_TIMEOUT_MS);\n\n          worker.onmessage = async (event) => {\n            const {\n              type,\n              success,\n              result,\n              error: workerError,\n              id: msgId,\n              requestType,\n              payload,\n            } = event.data;\n            if (type === \"request\") {\n              try {\n                let shimResult;\n                if (requestType === \"getArtifactContent\" && payload)\n                  shimResult = Storage.getArtifactContent(\n                    payload.id,\n                    payload.cycle,\n                    payload.versionId\n                  );\n                else if (requestType === \"getArtifactMetadata\" && payload)\n                  shimResult = StateManager.getArtifactMetadata(\n                    payload.id,\n                    payload.versionId\n                  );\n                else if (\n                  requestType === \"getArtifactMetadataAllVersions\" &&\n                  payload\n                )\n                  shimResult = StateManager.getArtifactMetadataAllVersions(\n                    payload.id\n                  );\n                else if (requestType === \"getAllArtifactMetadata\")\n                  shimResult = StateManager.getAllArtifactMetadata();\n                else\n                  throw new Error(`Unknown shim requestType: ${requestType}`);\n                worker.postMessage({\n                  type: \"response\",\n                  id: msgId,\n                  data: shimResult,\n                });\n              } catch (e) {\n                worker.postMessage({\n                  type: \"response\",\n                  id: msgId,\n                  error: { message: e.message, name: e.name },\n                });\n              }\n            } else {\n              clearTimeout(timeoutId);\n              if (success) {\n                logger.logEvent(\n                  \"info\",\n                  `Dynamic tool '${toolName}' execution succeeded.`\n                );\n                resolve(result);\n              } else {\n                const errorMsg = workerError?.message || \"Unknown worker error\";\n                logger.logEvent(\n                  \"error\",\n                  `Dynamic tool '${toolName}' execution failed in worker: ${errorMsg}\\nStack: ${workerError?.stack}`\n                );\n                reject(\n                  new ToolError(\n                    `Dynamic tool '${toolName}' failed: ${errorMsg}`,\n                    toolName,\n                    toolArgs,\n                    { workerError }\n                  )\n                );\n              }\n              if (worker) worker.terminate();\n            }\n          };\n          worker.onerror = (errorEvent) => {\n            clearTimeout(timeoutId);\n            const errorMsg = errorEvent.message || \"Unknown worker error\";\n            logger.logEvent(\n              \"error\",\n              `Web Worker error for tool '${toolName}': ${errorMsg}`,\n              errorEvent\n            );\n            reject(\n              new ToolError(\n                `Worker error for dynamic tool '${toolName}': ${errorMsg}`,\n                toolName,\n                toolArgs,\n                { workerEventError: errorEvent }\n              )\n            );\n            if (worker) worker.terminate();\n          };\n          worker.postMessage({\n            type: \"init\",\n            payload: { toolCode: dynamicTool.implementation, toolArgs },\n          });\n        } catch (e) {\n          clearTimeout(timeoutId);\n          logger.logEvent(\n            \"error\",\n            `Error setting up worker for '${toolName}': ${e.message}`\n          );\n          if (worker) worker.terminate();\n          reject(\n            new ToolError(\n              `Failed to initialize worker for tool '${toolName}': ${e.message}`,\n              toolName,\n              toolArgs,\n              { setupError: e }\n            )\n          );\n        }\n      });\n    }\n    throw new ToolError(`Tool not found: ${toolName}`, toolName);\n  };\n\n  return {\n    runTool: runToolInternal,\n  };\n};\n",
  "_x0_reploid.core.style_0": ":root {\n  --bg: black;\n  --fg: white;\n  --bdr: white;\n  --pad-in: 10px;\n  --pad-btn: 10px 18px;\n  --pad-fs: 20px;\n  --gap-n: 18px;\n  --gap-s: 8px;\n  --f-sz-n: 1em;\n  --f-sz-l: 1.5em;\n  --f-sz-xl: 2em;\n  --ctx-warn: 900000;\n  --bdr-mod: 2px dashed yellow;\n  --bdr-in: 1px dotted var(--bdr);\n  --bdr-out: 1px solid var(--bdr);\n  --bdr-inf: 1px dashed gray;\n  --bdr-err: 1px solid red;\n  --highlight-bg: #2a2a2a;\n}\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\nbody {\n  font-family: monospace;\n  background-color: var(--bg);\n  color: var(--fg);\n  margin: 0;\n  padding: var(--pad-fs);\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  font-size: var(--f-sz-n);\n  line-height: 1.5;\n  max-width: 1600px;\n  margin-left: auto;\n  margin-right: auto;\n}\nh1,\nh2,\nh3 {\n  border-bottom: 2px solid var(--bdr);\n  padding-bottom: var(--gap-s);\n  margin-top: 30px;\n  margin-bottom: var(--gap-n);\n  font-weight: bold;\n  line-height: 1.3;\n}\nh1 {\n  font-size: var(--f-sz-xl);\n  text-align: center;\n}\nh1 small {\n  font-size: 0.45em;\n  display: block;\n  font-weight: normal;\n  margin-top: 5px;\n  color: gray;\n  line-height: 1.2;\n}\nh2 {\n  font-size: var(--f-sz-l);\n}\nh3 {\n  font-size: 1.2em;\n  border-bottom-width: 1px;\n  margin-top: var(--gap-n);\n  margin-bottom: 15px;\n}\nh4 {\n  font-size: 1.1em;\n  margin-bottom: 10px;\n  margin-top: 15px;\n}\n\nfieldset {\n  border: 2px solid var(--bdr);\n  padding: 0;\n  margin-bottom: 30px;\n  background-color: var(--bg);\n}\nfieldset > .content-wrapper {\n  padding: var(--pad-fs);\n}\nlegend {\n  font-weight: bold;\n  font-size: 1.3em;\n  padding: 5px 10px 5px 15px;\n  margin-left: 15px;\n  background-color: var(--bg);\n  color: var(--fg);\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  user-select: none;\n  flex-wrap: wrap;\n}\nlegend .toggle-icon {\n  margin-right: 10px;\n  font-size: 1em;\n  width: 15px;\n  display: inline-block;\n  text-align: center;\n  font-weight: bold;\n}\nlegend .summary-line {\n  display: none;\n  font-size: 0.7em;\n  font-weight: normal;\n  color: gray;\n  margin-left: 15px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex-grow: 1;\n  min-width: 100px;\n}\nfieldset.collapsed > .content-wrapper {\n  display: none;\n}\nfieldset.collapsed > legend .summary-line {\n  display: inline;\n}\nfieldset.collapsed > legend .toggle-icon::before {\n  content: \"+\";\n}\nfieldset:not(.collapsed) > legend .toggle-icon::before {\n  content: \"-\";\n}\n\nlabel {\n  display: block;\n  margin-bottom: 8px;\n  font-weight: bold;\n  flex-shrink: 0;\n  text-align: right;\n  min-width: 150px;\n  padding-right: 10px;\n  line-height: 1.3;\n}\ntextarea,\npre,\ninput[type=\"text\"],\ninput[type=\"number\"],\ninput[type=\"password\"],\nselect {\n  background-color: var(--bg);\n  color: var(--fg);\n  border: 1px solid var(--bdr);\n  padding: var(--pad-in);\n  width: 100%;\n  font-family: inherit;\n  margin-bottom: 15px;\n  box-sizing: border-box;\n  font-size: 1em;\n  max-width: 100%;\n}\ntextarea {\n  min-height: 150px;\n  line-height: 1.5;\n  resize: vertical;\n}\n#goal-input {\n  min-height: 100px;\n}\n#seed-prompts .flex-col {\n  display: flex;\n  flex-direction: column;\n  height: auto;\n}\n#seed-prompts .flex-col:nth-child(2) {\n  flex-grow: 1;\n}\n#seed-prompt-core,\n#seed-prompt-evaluator {\n  flex-grow: 1;\n  height: 100%;\n  min-height: 300px;\n  background-color: #080808;\n}\n#seed-prompt-evaluator {\n  min-height: 100px;\n}\n\npre {\n  min-height: 50px;\n  max-height: 300px;\n  overflow: auto;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  border: var(--bdr-inf);\n  padding: 10px;\n  margin-bottom: 15px;\n  background-color: #040404;\n}\npre[class*=\"language-\"] {\n  background-color: var(--highlight-bg) !important;\n  border: 1px solid #444 !important;\n  padding: 1em !important;\n  margin: 0.5em 0 !important;\n  overflow: auto !important;\n}\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #ccc !important;\n}\n\n.artifact-display pre {\n  border: var(--bdr-out);\n  background-color: var(--bg);\n}\n.artifact-display pre.modified {\n  border: var(--bdr-mod);\n  font-weight: bold;\n  background-color: #111100;\n}\n.artifact-display pre.input {\n  border: var(--bdr-in);\n  opacity: 0.8;\n  background-color: #0a0a0a;\n}\n.artifact-display pre.info {\n  border: var(--bdr-inf);\n}\n.artifact-display pre.error {\n  border: var(--bdr-err);\n  color: red;\n  background-color: #180000;\n}\n.artifact-label {\n  display: block;\n  font-weight: bold;\n  margin-bottom: 5px;\n  font-size: 0.9em;\n  text-transform: uppercase;\n  color: gray;\n}\n.artifact-label .type-indicator {\n  font-weight: normal;\n  margin-right: 5px;\n  background-color: #333;\n  color: #ccc;\n  padding: 1px 4px;\n  border-radius: 3px;\n  font-size: 0.9em;\n  display: inline-block;\n}\n.artifact-label .change-indicator {\n  color: yellow;\n  font-weight: bold;\n  margin-left: 5px;\n}\n.artifact-label .source-indicator {\n  color: cyan;\n  font-size: 0.9em;\n  margin-left: 5px;\n  font-style: italic;\n}\n#streaming-output-container {\n  margin-top: var(--gap-n);\n  border-top: 1px dashed gray;\n  padding-top: var(--gap-s);\n}\n#streaming-output-pre {\n  min-height: 50px;\n  max-height: 250px;\n  overflow-y: auto;\n  background-color: #050505;\n  border: 1px solid #444;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  padding: 10px;\n  font-size: 0.95em;\n}\ninput[type=\"number\"],\nselect {\n  width: auto;\n  min-width: 80px;\n  padding: 8px 10px;\n}\n.cfg-item input[type=\"number\"] {\n  max-width: 90px;\n  text-align: right;\n}\nbutton {\n  background-color: var(--bg);\n  color: var(--fg);\n  border: 2px solid var(--bdr);\n  padding: var(--pad-btn);\n  cursor: pointer;\n  margin: 0;\n  font-family: inherit;\n  font-size: 1em;\n  font-weight: bold;\n  transition: background-color 0.2s, color 0.2s;\n}\nbutton:hover:not(:disabled) {\n  background-color: var(--fg);\n  color: var(--bg);\n}\nbutton:disabled {\n  opacity: 0.4;\n  cursor: not-allowed;\n}\n.flex-row {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  gap: var(--gap-n);\n  margin-bottom: var(--gap-n);\n  align-items: stretch;\n}\n.flex-col {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  min-width: 280px;\n}\n.cfg-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n  gap: 10px var(--gap-s);\n  align-items: baseline;\n}\n.cfg-item {\n  display: flex;\n  align-items: baseline;\n  gap: var(--gap-s);\n  flex-wrap: wrap;\n}\n.cfg-item label {\n  margin-bottom: 0;\n  flex-basis: 150px;\n  flex-shrink: 0;\n  font-size: 0.9em;\n}\n.cfg-item input,\n.cfg-item select {\n  flex-grow: 1;\n  width: auto;\n  min-width: 60px;\n  margin-bottom: 0;\n}\n.persona-inputs {\n  display: flex;\n  gap: 5px;\n  flex-grow: 1;\n}\n.persona-inputs input {\n  min-width: 50px;\n  text-align: right;\n}\n.metrics-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));\n  gap: var(--gap-s);\n  margin-top: var(--gap-n);\n}\n.metric-item {\n  border: 1px solid var(--bdr);\n  padding: 6px 10px;\n  background-color: var(--bg);\n  font-size: 0.9em;\n  text-align: center;\n  line-height: 1.2;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.metric-item strong {\n  display: block;\n  font-size: 1.1em;\n  margin-top: 2px;\n  word-break: break-word;\n}\n#core-metrics-display {\n  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n}\n#rolling-metrics-display {\n  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));\n}\n.timeline {\n  list-style-type: none;\n  padding: 0;\n  max-height: 800px;\n  overflow-y: auto;\n  border: 2px solid var(--bdr);\n  background-color: var(--bg);\n  margin-top: var(--gap-s);\n}\n.timeline li {\n  border-bottom: 1px solid var(--bdr);\n  padding: 8px var(--gap-n) 8px 15px;\n  margin-bottom: 0;\n  display: flex;\n  align-items: flex-start;\n  gap: 10px;\n  cursor: default;\n}\n.timeline li:last-child {\n  border-bottom: none;\n}\n.timeline li.summary {\n  background-color: #111;\n  font-size: 0.9em;\n  color: #ccc;\n  cursor: pointer;\n}\n.timeline li.summary:hover {\n  background-color: #222;\n  color: var(--fg);\n}\n.timeline li.core-step {\n  padding-left: var(--gap-n);\n  font-weight: bold;\n  background-color: #080808;\n  margin-top: 5px;\n  border-top: 1px dashed gray;\n}\n.timeline li.sub-step {\n  padding-left: 45px;\n  font-size: 0.95em;\n  opacity: 0.9;\n}\n.timeline li::before {\n  content: attr(data-cycle);\n  background-color: var(--fg);\n  color: var(--bg);\n  padding: 3px 6px;\n  border-radius: 0;\n  font-size: 0.85em;\n  font-weight: bold;\n  flex-shrink: 0;\n  align-self: flex-start;\n  margin-top: 2px;\n}\n.timeline li .log-icon {\n  font-size: 1.1em;\n  width: 20px;\n  text-align: center;\n  flex-shrink: 0;\n  display: inline-block;\n  margin-top: 2px;\n}\n.timeline li span:last-child {\n  flex-grow: 1;\n  line-height: 1.4;\n  word-break: break-word;\n}\n.timeline .animated-icon {\n  animation: spin 1s linear infinite;\n  display: inline-block;\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n#meta-sandbox-output {\n  width: 100%;\n  min-height: 500px;\n  border: 1px solid var(--bdr);\n  background-color: var(--fg);\n  margin-top: 15px;\n}\n.hidden {\n  display: none !important;\n}\n.api-key-input {\n  display: flex;\n  align-items: baseline;\n  gap: var(--gap-s);\n  flex-grow: 1;\n  flex-wrap: wrap;\n}\n.api-key-input label {\n  flex-basis: 180px;\n  flex-shrink: 0;\n}\n.api-key-input input {\n  flex-grow: 1;\n  margin-bottom: 0;\n  min-width: 200px;\n}\n.controls-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));\n  gap: var(--gap-s);\n  align-items: center;\n  margin-top: 15px;\n}\n.state-io-buttons {\n  display: contents;\n}\n.artifact-section {\n  margin-bottom: var(--gap-n);\n  padding-bottom: var(--gap-n);\n  border-bottom: 1px dotted gray;\n}\n.artifact-section:last-child {\n  border-bottom: none;\n  margin-bottom: 0;\n  padding-bottom: 0;\n}\n.artifact-collection {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));\n  gap: var(--gap-n);\n}\n.hitl-container {\n  border: 1px dashed yellow;\n  padding: 0;\n  margin-top: 15px;\n  background-color: #111;\n}\n.hitl-container h3 {\n  color: yellow;\n  border-color: yellow;\n  margin-top: 0;\n}\n.hitl-options label {\n  display: block;\n  margin-bottom: 8px;\n  cursor: pointer;\n  font-weight: normal;\n}\n.hitl-options input[type=\"checkbox\"] {\n  margin-right: 8px;\n}\n#human-edit-artifact-textarea {\n  min-height: 150px;\n  width: 100%;\n  margin-top: 10px;\n  background-color: #1a1a1a;\n  resize: vertical;\n}\n#meta-sandbox-container {\n  border: 2px dashed cyan;\n  padding: 0;\n  margin-top: 15px;\n  background-color: #001111;\n}\n#meta-sandbox-container h3 {\n  color: cyan;\n  border-color: cyan;\n  margin-top: 0;\n}\n#meta-sandbox-output {\n  border-color: cyan;\n}\n.meta-sandbox-controls {\n  margin-top: 15px;\n}\n#genesis-state-display {\n  border-style: dotted;\n  opacity: 0.8;\n  padding: 0;\n}\n#genesis-state-display legend {\n  color: gray;\n}\n.token-warning {\n  color: yellow;\n  font-weight: bold;\n  border: 1px solid yellow;\n  padding: 3px 6px;\n  margin-left: 10px;\n  display: inline-block;\n  font-size: 0.9em;\n  border-radius: 3px;\n}\n#status-indicator {\n  border: 1px solid gray;\n  padding: 5px 10px;\n  margin-left: auto;\n  display: inline-block;\n  font-size: 0.9em;\n  min-width: 150px;\n  text-align: center;\n  background-color: #111;\n  order: 3;\n  margin-top: 5px;\n}\n#status-indicator.active {\n  border-color: yellow;\n  color: yellow;\n  font-weight: bold;\n  background-color: #333300;\n}\n#api-progress {\n  font-size: 0.8em;\n  margin-left: 10px;\n  display: inline-block;\n  color: #aaa;\n  order: 4;\n  margin-top: 5px;\n}\n#app-root {\n  visibility: hidden;\n}\n.goal-type-selector {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  gap: 15px;\n  margin-bottom: 10px;\n  padding-left: 10px;\n}\n.goal-type-selector label {\n  margin-bottom: 0;\n  font-weight: normal;\n  cursor: pointer;\n  display: inline-flex;\n  align-items: center;\n  text-align: left;\n  min-width: auto;\n  padding-right: 0;\n}\n.goal-type-selector input[type=\"radio\"] {\n  margin-right: 5px;\n}\n.model-selectors {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--gap-n);\n  margin-top: var(--gap-n);\n  border-top: 1px dashed gray;\n  padding-top: var(--gap-n);\n}\n.model-selectors .cfg-item {\n  flex-basis: calc(50% - var(--gap-n) / 2);\n  min-width: 280px;\n}\n.model-selectors label {\n  flex-basis: auto;\n  min-width: 120px;\n  text-align: left;\n}\n.model-selectors select {\n  flex-grow: 1;\n}\n#notifications-container {\n  position: fixed;\n  top: 10px;\n  right: 10px;\n  z-index: 1000;\n  width: 300px;\n  max-width: 90vw;\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n.notification {\n  padding: 10px 15px;\n  border-radius: 4px;\n  color: black;\n  font-size: 0.9em;\n  opacity: 0.95;\n  border-left: 5px solid transparent;\n  word-wrap: break-word;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n.notification.info {\n  background-color: #e0f2f7;\n  border-left-color: #29b6f6;\n}\n.notification.warn {\n  background-color: #fff3e0;\n  border-left-color: #ffa726;\n}\n.notification.error {\n  background-color: #ffebee;\n  border-left-color: #ef5350;\n}\n.notification button {\n  float: right;\n  background: none;\n  border: none;\n  color: inherit;\n  cursor: pointer;\n  font-size: 1.1em;\n  line-height: 1;\n  margin-left: 10px;\n  padding: 0;\n  opacity: 0.6;\n}\n.notification button:hover {\n  opacity: 1;\n}\n#tools-executed-container {\n  margin-top: var(--gap-n);\n  border-top: 1px dashed gray;\n  padding-top: var(--gap-s);\n}\n#tools-executed-list {\n  list-style: none;\n  padding-left: 0;\n  font-size: 0.9em;\n}\n#tools-executed-list li {\n  margin-bottom: 5px;\n  padding: 5px;\n  border: 1px dotted #444;\n  background-color: #0a0a0a;\n}\n#tools-executed-list li.tool-success {\n  border-left: 3px solid green;\n}\n#tools-executed-list li.tool-fail {\n  border-left: 3px solid red;\n  background-color: #180000;\n}\n#tools-executed-list strong {\n  color: cyan;\n}\n#tools-executed-list .tool-args,\n#tools-executed-list .tool-result,\n#tools-executed-list .tool-error {\n  display: block;\n  margin-left: 15px;\n  font-size: 0.95em;\n  color: #bbb;\n  word-break: break-all;\n}\n#tools-executed-list .tool-error {\n  color: red;\n}\n.autonomy-controls {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--gap-s) var(--gap-n);\n  align-items: center;\n  border-top: 1px dashed gray;\n  padding-top: 15px;\n  margin-top: 15px;\n}\n.autonomy-controls label {\n  min-width: auto;\n  text-align: left;\n  margin-bottom: 0;\n}\n.autonomy-controls select,\n.autonomy-controls input[type=\"number\"] {\n  width: auto;\n  margin-bottom: 0;\n}\n.autonomy-controls button {\n  margin-left: auto;\n}\n.autonomy-n-label {\n  padding-left: 5px;\n}\n\n.cycle-steps-minimap {\n  border: 1px solid #555;\n  padding: 10px;\n  background-color: #080808;\n  font-size: 0.9em;\n  max-height: 300px;\n  overflow-y: auto;\n  margin-bottom: 15px;\n}\n.cycle-steps-minimap ol {\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n}\n.cycle-steps-minimap li {\n  padding: 4px 0;\n  border-bottom: 1px dotted #333;\n}\n.cycle-steps-minimap li:last-child {\n  border-bottom: none;\n}\n.cycle-steps-minimap li.active-step {\n  background-color: #222;\n  font-weight: bold;\n  color: yellow;\n}\n.cycle-steps-minimap .step-icon {\n  display: inline-block;\n  width: 20px;\n  text-align: center;\n  margin-right: 5px;\n}\n\n@media (max-width: 1024px) {\n  :root {\n    --f-sz-n: 0.95em;\n    --pad-fs: 15px;\n    --gap-n: 15px;\n  }\n  h1 {\n    font-size: 1.8em;\n  }\n  h2 {\n    font-size: 1.4em;\n  }\n  h3 {\n    font-size: 1.15em;\n  }\n  .metrics-grid {\n    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));\n  }\n  #core-metrics-display {\n    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));\n  }\n  .timeline {\n    max-height: 600px;\n  }\n  .autonomy-controls button {\n    margin-left: 0;\n    width: 100%;\n    margin-top: 10px;\n  }\n}\n@media (max-width: 768px) {\n  :root {\n    --f-sz-n: 0.9em;\n    --pad-fs: 10px;\n    --gap-n: 12px;\n    --gap-s: 6px;\n    --pad-btn: 8px 14px;\n  }\n  body {\n    padding: 10px;\n  }\n  h1 {\n    font-size: 1.6em;\n  }\n  h1 small {\n    font-size: 0.4em;\n    line-height: 1.1;\n  }\n  h2 {\n    font-size: 1.3em;\n  }\n  h3 {\n    font-size: 1.1em;\n  }\n  legend {\n    font-size: 1.2em;\n    margin-left: 10px;\n    padding: 4px 8px 4px 10px;\n  }\n  .flex-row {\n    flex-direction: column;\n  }\n  .cfg-item {\n    flex-direction: column;\n    align-items: stretch;\n    gap: 5px;\n  }\n  .cfg-item label {\n    text-align: left;\n    min-width: auto;\n    margin-bottom: 3px;\n    padding-right: 0;\n    flex-basis: auto;\n  }\n  .cfg-item input,\n  .cfg-item select {\n    width: 100%;\n  }\n  .persona-inputs input {\n    min-width: 60px;\n  }\n  .cfg-grid,\n  .metrics-grid,\n  .controls-grid {\n    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));\n  }\n  .api-key-input label {\n    flex-basis: auto;\n  }\n  #status-indicator {\n    margin-left: 10px;\n  }\n  .goal-type-selector {\n    padding-left: 0;\n  }\n  .model-selectors .cfg-item {\n    flex-basis: 100%;\n  }\n  .timeline {\n    max-height: 500px;\n  }\n  .timeline li {\n    padding: 6px 12px 6px 10px;\n  }\n}\n@media (max-width: 480px) {\n  :root {\n    --f-sz-n: 0.85em;\n  }\n  h1 {\n    font-size: 1.4em;\n  }\n  h1 small {\n    display: none;\n  }\n  h2 {\n    font-size: 1.2em;\n  }\n  h3 {\n    font-size: 1.05em;\n  }\n  .cfg-grid,\n  .metrics-grid,\n  .controls-grid {\n    grid-template-columns: 1fr;\n  }\n  .metric-item {\n    font-size: 0.85em;\n    padding: 4px 8px;\n  }\n  button {\n    font-size: 0.95em;\n    padding: 6px 10px;\n  }\n  .timeline li {\n    gap: 6px;\n  }\n  .timeline li::before {\n    font-size: 0.8em;\n    padding: 2px 4px;\n  }\n  #status-indicator {\n    min-width: 120px;\n    font-size: 0.85em;\n  }\n  #api-progress {\n    font-size: 0.75em;\n  }\n  #notifications-container {\n    width: calc(100% - 20px);\n    right: 10px;\n    left: 10px;\n  }\n}\n",
  "_x0_reploid.core.summarizer-prompt_0": "You are Summarizer x0. Analyze the provided agent state and recent logs. Generate a concise summary suitable for restarting the process with reduced context. Focus on the overall seed goal, cumulative goal state, key achievements, last state of artifacts (mentioning key IDs/types/paradigms/latest cycle and if multiple versions exist), outstanding issues or recent failures, current state overview, and the last action/feedback. Capture the agent's last known 'context focus'.\n\nInput State (Partial):\n[[AGENT_STATE_SUMMARY]]\nRecent Logs:\n[[RECENT_LOGS]]\nLatest Artifacts (Summary with Paradigms):\n[[LATEST_ARTIFACTS_WITH_PARADIGMS]]\n\nTask: Output a detailed summary string.\n\nOutput Format (JSON ONLY): {\"summary\": \"string\"}\n**ADDITIONAL INSTRUCTIONS:**\n*   **Output Strictness:** YOU MUST output ONLY a single valid JSON object: `{\"summary\": \"string\"}`. Do NOT include any text before or after the JSON object.\n*   **Conciseness & Relevance:** The `summary` string should be comprehensive but concise, focusing on information critical for the next agent iteration. Highlight recent failures, pending actions, significant changes, and the last `current_context_focus`.\n*   **Key Information:** Ensure the summary mentions the current cycle number, latest goal type, and briefly notes key artifacts relevant to the goal, including their paradigms and whether multiple recent versions might exist.",
  "_x0_reploid.core.ui_0": "const UIModule = (config, logger, Utils, Storage, StateManager, Errors) => {\n  if (!config || !logger || !Utils || !Storage || !StateManager || !Errors) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[UI_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"UIModule initialization failed: Missing base dependencies.\"\n    );\n    const fakeUI = {};\n    [\n      \"init\",\n      \"updateStatus\",\n      \"updateApiProgress\",\n      \"updateStreamingOutput\",\n      \"clearStreamingOutput\",\n      \"highlightCoreStep\",\n      \"showNotification\",\n      \"logToTimeline\",\n      \"logCoreLoopStep\",\n      \"updateTimelineItem\",\n      \"summarizeCompletedCycleLog\",\n      \"clearCurrentCycleDetails\",\n      \"displayCycleArtifact\",\n      \"displayToolExecutionSummary\",\n      \"hideHumanInterventionUI\",\n      \"showHumanInterventionUI\",\n      \"hideMetaSandbox\",\n      \"showMetaSandbox\",\n      \"updateStateDisplay\",\n      \"updateAutonomyControls\",\n      \"setRunButtonState\",\n      \"getRefs\",\n      \"isMetaSandboxPending\",\n      \"isHumanInterventionHidden\",\n      \"updateHtmlHistoryControls\",\n    ].forEach((methodName) => {\n      fakeUI[methodName] = () => {\n        internalLog.logEvent(\n          \"error\",\n          `UIModule not initialized. Called ${methodName}.`\n        );\n        if (\n          methodName === \"isMetaSandboxPending\" ||\n          methodName === \"isHumanInterventionHidden\"\n        )\n          return true;\n        if (methodName === \"getRefs\") return {};\n      };\n    });\n    return fakeUI;\n  }\n\n  let uiRefs = {};\n  let isInitialized = false;\n  let CycleLogic = null;\n  let metaSandboxPending = false;\n  let activeCoreStepIdx = -1;\n  let lastCycleLogItem = null;\n  let syntaxHighlightTimer = null;\n\n  const APP_MODELS = [\n    config.DEFAULT_MODELS.BASE,\n    config.DEFAULT_MODELS.ADVANCED,\n  ];\n  if (\n    config.DEFAULT_MODELS.CRITIQUE &&\n    !APP_MODELS.includes(config.DEFAULT_MODELS.CRITIQUE)\n  ) {\n    APP_MODELS.push(config.DEFAULT_MODELS.CRITIQUE);\n  }\n\n  const CTX_WARN_THRESH = config.CTX_WARN_THRESH;\n  const EVAL_PASS_THRESHOLD = config.EVAL_PASS_THRESHOLD || 0.75;\n  const SYNTAX_HIGHLIGHT_DEBOUNCE = 250;\n  const TIMELINE_LOG_LIMIT = config.TIMELINE_LOG_LIMIT || 250;\n\n  const logIconMap = {\n    error: \"\",\n    warn: \"\",\n    api: \"\",\n    tool: \"\",\n    crit: \"\",\n    human: \"\",\n    apply: \"\",\n    artifact: \"\",\n    state: \"\",\n    context: \"\",\n    goal: \"\",\n    cycle: \"\",\n    retry: \"\",\n    decide: \"\",\n    finish: \"\",\n    eval: \"\",\n    learn: \"\",\n    info: \"\",\n    default: \"\",\n  };\n  const stepIconMap = [\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n  ];\n  const artifactTypeMap = {\n    JS: \"[JS]\",\n    CSS: \"[CSS]\",\n    HTML_HEAD: \"[HEAD]\",\n    HTML_BODY: \"[BODY]\",\n    JSON: \"[JSON]\",\n    PROMPT: \"[PROMPT]\",\n    FULL_HTML_SOURCE: \"[PAGE]\",\n    TEXT: \"[TEXT]\",\n    DIAGRAM_JSON: \"[DIAG]\",\n    JSON_CONFIG: \"[CONFIG]\",\n    LOG: \"[LOG]\",\n    EVAL_DEF: \"[EVAL_DEF]\",\n    WEB_COMPONENT_DEF: \"[WC-DEF]\",\n    UNKNOWN: \"[?]\",\n  };\n\n  const getLogIcon = (message, type) =>\n    logIconMap[type?.toLowerCase()] || logIconMap.default;\n  const getStepIcon = (index) => stepIconMap[index] || logIconMap.default;\n  const getArtifactTypeIndicator = (type) =>\n    artifactTypeMap[type?.toUpperCase()] || artifactTypeMap.UNKNOWN;\n\n  const initializeUIElementReferences = () => {\n    const elementIds = [\n      \"total-cycles\",\n      \"max-cycles-display\",\n      \"agent-iterations\",\n      \"human-interventions\",\n      \"fail-count\",\n      \"current-goal\",\n      \"last-critique-type\",\n      \"persona-mode\",\n      \"html-history-count\",\n      \"context-token-estimate\",\n      \"avg-confidence\",\n      \"critique-fail-rate\",\n      \"avg-tokens\",\n      \"avg-eval-score\",\n      \"eval-pass-rate\",\n      \"context-token-warning\",\n      \"context-token-target-display\",\n      \"current-cycle-details\",\n      \"current-cycle-content\",\n      \"current-cycle-number\",\n      \"goal-input\",\n      \"seed-prompt-core\",\n      \"seed-prompt-critique\",\n      \"seed-prompt-summarize\",\n      \"seed-prompt-evaluator\",\n      \"api-key-input\",\n      \"lsd-persona-percent-input\",\n      \"xyz-persona-percent-input\",\n      \"llm-critique-prob-input\",\n      \"human-review-prob-input\",\n      \"max-cycle-time-input\",\n      \"auto-critique-thresh-input\",\n      \"max-cycles-input\",\n      \"html-history-limit-input\",\n      \"pause-after-cycles-input\",\n      \"max-retries-input\",\n      \"timeline-log\",\n      \"status-indicator\",\n      \"core-loop-steps-minimap\",\n      \"run-cycle-button\",\n      \"force-human-review-button\",\n      \"go-back-button\",\n      \"export-state-button\",\n      \"import-state-button\",\n      \"import-file-input\",\n      \"download-log-button\",\n      \"summarize-context-button\",\n      \"clear-local-storage-button\",\n      \"human-intervention-section\",\n      \"human-intervention-title\",\n      \"human-intervention-reason\",\n      \"human-intervention-reason-summary\",\n      \"hitl-options-mode\",\n      \"hitl-options-list\",\n      \"submit-hitl-options-button\",\n      \"hitl-prompt-mode\",\n      \"human-critique-input\",\n      \"submit-critique-button\",\n      \"hitl-code-edit-mode\",\n      \"human-edit-artifact-selector\",\n      \"human-edit-artifact-textarea\",\n      \"submit-human-code-edit-button\",\n      \"hitl-critique-feedback-mode\",\n      \"hitl-critiques-display\",\n      \"hitl-critique-selection\",\n      \"hitl-critique-notes\",\n      \"submit-critique-feedback-button\",\n      \"meta-sandbox-container\",\n      \"meta-sandbox-output\",\n      \"approve-meta-change-button\",\n      \"discard-meta-change-button\",\n      \"genesis-state-display\",\n      \"genesis-metrics-display\",\n      \"notifications-container\",\n      \"core-model-selector\",\n      \"critique-model-selector\",\n      \"streaming-output-container\",\n      \"streaming-output-pre\",\n      \"api-progress\",\n      \"tools-executed-container\",\n      \"tools-executed-list\",\n      \"autonomy-mode-selector\",\n      \"autonomy-n-cycles-input\",\n      \"autonomy-start-stop-button\",\n    ];\n    const selectorsForClasses = [\"goal-type-selector\", \"autonomy-n-label\"];\n    uiRefs = {};\n    elementIds.forEach((kebabId) => {\n      let element = selectorsForClasses.includes(kebabId)\n        ? Utils.$(`.${kebabId}`)\n        : Utils.$id(kebabId);\n      if (element) uiRefs[Utils.kabobToCamel(kebabId)] = element;\n      else {\n        const optionalElements = [\n          \"hitl-critique-selection\",\n          \"hitl-critique-notes\",\n          \"hitl-critiques-display\",\n          \"notifications-container\",\n          \"autonomy-n-label\",\n        ];\n        if (!optionalElements.includes(kebabId))\n          logger.logEvent(\n            \"warn\",\n            `UI element not found: ${\n              selectorsForClasses.includes(kebabId) ? \".\" : \"#\"\n            }${kebabId}`\n          );\n      }\n    });\n    logger.logEvent(\"debug\", \"UI element references initialized.\");\n  };\n\n  const updateStatus = (message, isActive = false, isError = false) => {\n    if (!uiRefs.statusIndicator) return;\n    uiRefs.statusIndicator.textContent = `Status: ${message}`;\n    uiRefs.statusIndicator.classList.toggle(\"active\", isActive);\n    uiRefs.statusIndicator.classList.toggle(\"error\", isError);\n  };\n\n  const updateApiProgress = (message) => {\n    if (uiRefs.apiProgress)\n      uiRefs.apiProgress.textContent = message\n        ? `API: ${Utils.trunc(message, 30)}`\n        : \"\";\n  };\n\n  const updateStreamingOutput = (content, isFinal = false) => {\n    if (uiRefs.streamingOutputContainer && uiRefs.streamingOutputPre) {\n      uiRefs.streamingOutputContainer.classList.remove(\"hidden\");\n      uiRefs.streamingOutputPre.textContent = content;\n      uiRefs.streamingOutputPre.scrollTop =\n        uiRefs.streamingOutputPre.scrollHeight;\n    }\n  };\n\n  const clearStreamingOutput = () => {\n    if (uiRefs.streamingOutputContainer && uiRefs.streamingOutputPre) {\n      uiRefs.streamingOutputPre.textContent = \"(Stream ended)\";\n      setTimeout(() => {\n        if (uiRefs.streamingOutputContainer)\n          uiRefs.streamingOutputContainer.classList.add(\"hidden\");\n      }, 2000);\n    }\n  };\n\n  const highlightCoreStep = (stepIndex) => {\n    activeCoreStepIdx = stepIndex;\n    const minimap = uiRefs.coreLoopStepsMinimap;\n    if (!minimap) return;\n    const stepsList = minimap.querySelector(\"ol\");\n    if (!stepsList) return;\n    const listItems = stepsList.querySelectorAll(\"li\");\n    listItems.forEach((li, idx) => {\n      const isActive = idx === stepIndex;\n      li.classList.toggle(\"active-step\", isActive);\n      let iconSpan = li.querySelector(\".step-icon\");\n      if (!iconSpan) {\n        iconSpan = document.createElement(\"span\");\n        iconSpan.className = \"step-icon\";\n        li.insertBefore(iconSpan, li.firstChild);\n      }\n      iconSpan.textContent = getStepIcon(idx);\n      iconSpan.setAttribute(\"aria-hidden\", \"true\");\n    });\n  };\n\n  const showNotification = (message, type = \"info\", duration = 5000) => {\n    const container =\n      uiRefs.notificationsContainer || Utils.$id(\"notifications-container\");\n    if (!container) {\n      console.error(\"Notification container not found!\");\n      alert(`[${Utils.ucFirst(type)}] ${message}`);\n      return;\n    }\n    const notification = document.createElement(\"div\");\n    notification.className = `notification ${type}`;\n    notification.innerHTML = `${Utils.escapeHtml(\n      message\n    )}<button style=\"background:none;border:none;float:right;cursor:pointer;color:inherit;font-size:1.2em;line-height:1;padding:0;margin-left:10px;\"></button>`;\n    const button = notification.querySelector(\"button\");\n    if (button) button.onclick = () => notification.remove();\n    container.appendChild(notification);\n    if (duration > 0)\n      setTimeout(() => {\n        if (notification.parentElement) notification.remove();\n      }, duration);\n  };\n\n  const updateMetricsDisplay = (state) => {\n    if (!state || !StateManager) return;\n    const derivedStats = StateHelpersPure.calculateDerivedStatsPure(\n      state.confidenceHistory,\n      state.critiqueFailHistory,\n      state.tokenHistory,\n      state.evaluationHistory,\n      config.MAX_HISTORY_ITEMS || 20,\n      EVAL_PASS_THRESHOLD\n    );\n\n    if (uiRefs.avgConfidence)\n      uiRefs.avgConfidence.textContent =\n        derivedStats.avgConfidence?.toFixed(2) || \"N/A\";\n    if (uiRefs.critiqueFailRate)\n      uiRefs.critiqueFailRate.textContent =\n        derivedStats.critiqueFailRate?.toFixed(1) + \"%\" || \"N/A\";\n    if (uiRefs.avgEvalScore)\n      uiRefs.avgEvalScore.textContent =\n        derivedStats.avgEvalScore?.toFixed(2) || \"N/A\";\n    if (uiRefs.evalPassRate)\n      uiRefs.evalPassRate.textContent =\n        derivedStats.evalPassRate?.toFixed(1) + \"%\" || \"N/A\";\n    if (uiRefs.avgTokens)\n      uiRefs.avgTokens.textContent =\n        derivedStats.avgTokens?.toFixed(0) || \"N/A\";\n    if (uiRefs.contextTokenEstimate)\n      uiRefs.contextTokenEstimate.textContent =\n        state.contextTokenEstimate?.toLocaleString() || \"0\";\n    if (uiRefs.failCount) uiRefs.failCount.textContent = state.failCount || 0;\n    if (uiRefs.contextTokenTargetDisplay)\n      uiRefs.contextTokenTargetDisplay.textContent =\n        state.contextTokenTarget?.toLocaleString() ||\n        config.CTX_TARGET.toLocaleString();\n    checkContextTokenWarning(state);\n  };\n\n  const checkContextTokenWarning = (state) => {\n    if (!state || !uiRefs.contextTokenWarning) return;\n    const threshold = state.contextTokenTarget * 0.9 || CTX_WARN_THRESH;\n    const isWarn = state.contextTokenEstimate >= threshold;\n    uiRefs.contextTokenWarning.classList.toggle(\"hidden\", !isWarn);\n    if (\n      isWarn &&\n      !uiRefs.contextTokenWarning.classList.contains(\"warning-logged\")\n    ) {\n      logger.logEvent(\n        \"warn\",\n        `Context high! (${state.contextTokenEstimate.toLocaleString()}/${state.contextTokenTarget.toLocaleString()}). Consider summarizing.`\n      );\n      uiRefs.contextTokenWarning.classList.add(\"warning-logged\");\n    } else if (!isWarn)\n      uiRefs.contextTokenWarning.classList.remove(\"warning-logged\");\n  };\n\n  const updateHtmlHistoryControls = (state) => {\n    if (!uiRefs.htmlHistoryCount || !state) return;\n    const count = state.htmlHistory?.length || 0;\n    uiRefs.htmlHistoryCount.textContent = count.toString();\n    if (uiRefs.goBackButton) uiRefs.goBackButton.disabled = count === 0;\n  };\n\n  const updateFieldsetSummaries = (state) => {\n    if (!state || !StateManager) return;\n    const updateSummary = (fieldsetRefOrId, text) => {\n      let fieldset =\n        typeof fieldsetRefOrId === \"string\"\n          ? Utils.$id(fieldsetRefOrId)\n          : fieldsetRefOrId;\n      if (fieldset) {\n        const summary = fieldset.querySelector(\".summary-line\");\n        if (summary)\n          summary.textContent = text ? `| ${Utils.trunc(text, 80)}` : \"\";\n      }\n    };\n    const cfg = state.cfg || {};\n    const coreModelName = (cfg.coreModel || \"unknown\")\n      .split(\"/\")\n      .pop()\n      .replace(\"-latest\", \"\");\n    const critiqueModelName = (cfg.critiqueModel || \"unknown\")\n      .split(\"/\")\n      .pop()\n      .replace(\"-latest\", \"\");\n    updateSummary(\n      \"genesis-config\",\n      `LSD:${cfg.personaBalance ?? \"?\"}% Crit:${\n        cfg.llmCritiqueProb ?? \"?\"\n      }% Rev:${cfg.humanReviewProb ?? \"?\"}% MaxC:${\n        cfg.maxCycles || \"Inf\"\n      } Core:${coreModelName} Util:${critiqueModelName}`\n    );\n    const promptLens = {\n      core:\n        Storage.getArtifactContent(\"reploid.core.sys-prompt\", 0)?.length || 0,\n      crit:\n        Storage.getArtifactContent(\"reploid.core.critiquer-prompt\", 0)\n          ?.length || 0,\n      sum:\n        Storage.getArtifactContent(\"reploid.core.summarizer-prompt\", 0)\n          ?.length || 0,\n      eval:\n        Storage.getArtifactContent(\"reploid.core.evaluator-prompt\", 0)\n          ?.length || 0,\n    };\n    updateSummary(\n      \"seed-prompts\",\n      `Core:${promptLens.core}c Crit:${promptLens.crit}c Sum:${promptLens.sum}c Eval:${promptLens.eval}c`\n    );\n    updateSummary(uiRefs.genesisStateDisplay, \"Cycle 0 Info\");\n    const cycleContentDiv = uiRefs.currentCycleContent;\n    let itemCount = 0;\n    let totalChars = 0;\n    if (cycleContentDiv) {\n      const sections = cycleContentDiv.querySelectorAll(\".artifact-section\");\n      itemCount = sections.length;\n      sections.forEach((section) => {\n        const pre = section.querySelector(\"pre code\");\n        if (pre) totalChars += pre.textContent.length;\n      });\n    }\n    updateSummary(\n      uiRefs.currentCycleDetails,\n      `Items: ${itemCount}, Content Chars: ${totalChars.toLocaleString()}`\n    );\n    updateSummary(\n      \"timeline-fieldset\",\n      `Entries: ${uiRefs.timelineLog?.childElementCount || 0}`\n    );\n    const registeredWCs = StateManager.getRegisteredWebComponents();\n    const wcSummary =\n      registeredWCs.length > 0\n        ? ` WCs: ${registeredWCs.length} (${Utils.trunc(\n            registeredWCs.join(\", \"),\n            20\n          )})`\n        : \"\";\n    updateSummary(\n      \"controls-fieldset\",\n      `API Key: ${state.apiKey ? \"Set\" : \"Not Set\"} | Mode: ${\n        state.autonomyMode || \"Manual\"\n      } ${wcSummary}`\n    );\n  };\n\n  const updateStateDisplay = () => {\n    if (!StateManager) {\n      logger.logEvent(\"error\", \"updateStateDisplay: StateManager missing.\");\n      return;\n    }\n    const state = StateManager.getState();\n    if (!state) {\n      logger.logEvent(\"error\", \"updateStateDisplay: state is null.\");\n      return;\n    }\n    const cfg = state.cfg || {};\n    if (uiRefs.lsdPersonaPercentInput)\n      uiRefs.lsdPersonaPercentInput.value = cfg.personaBalance ?? 50;\n    if (uiRefs.xyzPersonaPercentInput)\n      uiRefs.xyzPersonaPercentInput.value = 100 - (cfg.personaBalance ?? 50);\n    if (uiRefs.llmCritiqueProbInput)\n      uiRefs.llmCritiqueProbInput.value = cfg.llmCritiqueProb ?? 50;\n    if (uiRefs.humanReviewProbInput)\n      uiRefs.humanReviewProbInput.value = cfg.humanReviewProb ?? 50;\n    if (uiRefs.maxCycleTimeInput)\n      uiRefs.maxCycleTimeInput.value = cfg.maxCycleTime ?? 600;\n    if (uiRefs.autoCritiqueThreshInput)\n      uiRefs.autoCritiqueThreshInput.value = cfg.autoCritiqueThresh ?? 0.75;\n    if (uiRefs.maxCyclesInput) uiRefs.maxCyclesInput.value = cfg.maxCycles ?? 0;\n    if (uiRefs.htmlHistoryLimitInput)\n      uiRefs.htmlHistoryLimitInput.value = cfg.htmlHistoryLimit ?? 5;\n    if (uiRefs.pauseAfterCyclesInput)\n      uiRefs.pauseAfterCyclesInput.value = cfg.pauseAfterCycles ?? 10;\n    if (uiRefs.maxRetriesInput)\n      uiRefs.maxRetriesInput.value = cfg.maxRetries ?? 1;\n    if (uiRefs.apiKeyInput) uiRefs.apiKeyInput.value = state.apiKey || \"\";\n    if (uiRefs.coreModelSelector)\n      uiRefs.coreModelSelector.value =\n        cfg.coreModel || config.DEFAULT_MODELS.BASE;\n    if (uiRefs.critiqueModelSelector)\n      uiRefs.critiqueModelSelector.value =\n        cfg.critiqueModel || config.DEFAULT_MODELS.CRITIQUE; // TODO: this should use critiqueModel from config\n    if (uiRefs.autonomyModeSelector)\n      uiRefs.autonomyModeSelector.value = state.autonomyMode || \"Manual\";\n    if (uiRefs.autonomyNCyclesInput && state.autonomyMode === \"N_Cycles\") {\n      uiRefs.autonomyNCyclesInput.value =\n        state.autonomyCyclesRemaining > 0\n          ? state.autonomyCyclesRemaining\n          : cfg.autonomyDefaultNCycles || 5;\n    }\n    const maxC = cfg.maxCycles || 0;\n    if (uiRefs.maxCyclesDisplay)\n      uiRefs.maxCyclesDisplay.textContent =\n        maxC === 0 ? \"Inf\" : maxC.toString();\n    if (uiRefs.totalCycles)\n      uiRefs.totalCycles.textContent = state.totalCycles || 0;\n    if (uiRefs.agentIterations)\n      uiRefs.agentIterations.textContent = state.agentIterations || 0;\n    if (uiRefs.humanInterventions)\n      uiRefs.humanInterventions.textContent = state.humanInterventions || 0;\n    const goalInfo = CycleLogic?.getActiveGoalInfo() || {\n      type: \"Idle\",\n      latestGoal: \"Idle\",\n    };\n    let goalText =\n      goalInfo.type === \"Idle\"\n        ? \"Idle\"\n        : `${goalInfo.type}: ${goalInfo.latestGoal}`;\n    if (state.currentGoal?.summaryContext)\n      goalText += ` (Ctx: ${Utils.trunc(\n        state.currentGoal.summaryContext,\n        20\n      )}...)`;\n    if (uiRefs.currentGoal)\n      uiRefs.currentGoal.textContent = Utils.trunc(goalText, 60);\n    if (uiRefs.lastCritiqueType)\n      uiRefs.lastCritiqueType.textContent = state.lastCritiqueType || \"N/A\";\n    if (uiRefs.personaMode)\n      uiRefs.personaMode.textContent = state.personaMode || \"N/A\";\n    updateMetricsDisplay(state);\n    updateHtmlHistoryControls(state);\n    updateAutonomyControls(\n      state.autonomyMode,\n      CycleLogic?.isRunning() && CycleLogic?.isAutonomous()\n    );\n    const humanInterventionVisible =\n      !uiRefs.humanInterventionSection?.classList.contains(\"hidden\");\n    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;\n    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;\n    setRunButtonState(\n      isCycleRunning ? \"Abort Cycle\" : \"Run Cycle\",\n      isCycleRunning && isAutonomousRunning\n    );\n    updateFieldsetSummaries(state);\n  };\n\n  const displayGenesisState = () => {\n    if (!uiRefs.genesisMetricsDisplay || !StateManager) {\n      logger.logEvent(\n        \"warn\",\n        \"displayGenesisState: Required elements or StateManager missing.\"\n      );\n      return;\n    }\n    const state = StateManager.getState();\n    if (!state || !state.cfg) {\n      uiRefs.genesisMetricsDisplay.innerHTML =\n        \"<p>Genesis state not fully loaded or config missing.</p>\";\n      return;\n    }\n    const metricsEl = Utils.$id(\"core-metrics-display\");\n    if (metricsEl) {\n      const staticMetricsHTML = `<div>Cycles <strong>0</strong>/${\n        state.cfg.maxCycles || \"Inf\"\n      }</div><div>Agent Itr <strong>0</strong></div><div>Human Int <strong>0</strong></div><div>Goal <strong>Idle</strong></div><div>Critique <strong>N/A</strong></div><div>Persona <strong>XYZ</strong></div><div>History <strong>0</strong></div><div>Ctx Tokens <strong>0</strong> / ${\n        state.contextTokenTarget?.toLocaleString() ||\n        config.CTX_TARGET.toLocaleString()\n      }</div>`;\n      uiRefs.genesisMetricsDisplay.innerHTML = `<div class=\"metrics-grid\">${staticMetricsHTML}</div>`;\n    } else\n      uiRefs.genesisMetricsDisplay.innerHTML =\n        \"<p>Core Metrics Display template not found for Genesis.</p>\";\n  };\n\n  const logToTimeline = (\n    cycle,\n    message,\n    type = \"info\",\n    isSubStep = false,\n    animate = false\n  ) => {\n    if (!uiRefs.timelineLog || !StateManager) return null;\n    if (typeof cycle !== \"number\")\n      cycle = StateManager.getState()?.totalCycles ?? 0;\n    const state = StateManager.getState();\n    const persona = state?.personaMode === \"XYZ\" ? \"[X]\" : \"[L]\";\n    const icon = getLogIcon(message, type);\n    const li = document.createElement(\"li\");\n    li.setAttribute(\"data-cycle\", cycle);\n    li.setAttribute(\"data-timestamp\", Date.now());\n    li.classList.add(isSubStep ? \"sub-step\" : \"log-entry\");\n    if (type === \"error\") li.classList.add(\"error\");\n    if (type === \"warn\") li.classList.add(\"warn\");\n    if (logIconMap[type?.toLowerCase()])\n      li.classList.add(`log-type-${type.toLowerCase()}`);\n    const cycleSpan = document.createElement(\"span\");\n    cycleSpan.className = \"log-cycle-marker\";\n    cycleSpan.textContent = cycle;\n    li.appendChild(cycleSpan);\n    const contentSpan = document.createElement(\"span\");\n    let iconHTML = `<span class=\"log-icon\" title=\"${type}\" aria-hidden=\"true\">${icon}</span>`;\n    if (animate)\n      iconHTML = `<span class=\"log-icon animated-icon\" title=\"${type}\" aria-hidden=\"true\"></span>`;\n    contentSpan.innerHTML = `${iconHTML} <span class=\"log-persona\">${persona}</span> ${Utils.escapeHtml(\n      Utils.trunc(message, 250)\n    )}`;\n    contentSpan.title = message;\n    li.appendChild(contentSpan);\n    const targetList = uiRefs.timelineLog;\n    targetList.insertBefore(li, targetList.firstChild);\n    while (targetList.children.length > TIMELINE_LOG_LIMIT)\n      targetList.removeChild(targetList.lastChild);\n    if (message.startsWith(\"[CYCLE] === Cycle\")) lastCycleLogItem = li;\n    return li;\n  };\n\n  const logCoreLoopStep = (cycle, stepIndex, message) => {\n    highlightCoreStep(stepIndex);\n    if (!uiRefs.timelineLog) return null;\n    const li = document.createElement(\"li\");\n    li.classList.add(\"core-step\");\n    li.setAttribute(\"data-cycle\", cycle);\n    li.setAttribute(\"data-timestamp\", Date.now());\n    const span = document.createElement(\"span\");\n    const stepIcon = getStepIcon(stepIndex);\n    span.innerHTML = `<span class=\"log-icon\">${stepIcon}</span> <strong>Step ${\n      stepIndex + 1\n    }:</strong> ${Utils.escapeHtml(message)}`;\n    li.appendChild(span);\n    uiRefs.timelineLog.insertBefore(li, uiRefs.timelineLog.firstChild);\n    while (uiRefs.timelineLog.children.length > TIMELINE_LOG_LIMIT)\n      uiRefs.timelineLog.removeChild(uiRefs.timelineLog.lastChild);\n    return li;\n  };\n\n  const updateTimelineItem = (\n    logItem,\n    newMessage,\n    newType = \"info\",\n    stopAnimate = true\n  ) => {\n    if (!logItem || !StateManager) return;\n    const contentSpan = logItem.querySelector(\"span:last-child\");\n    if (!contentSpan) return;\n    const state = StateManager.getState();\n    const persona = state?.personaMode === \"XYZ\" ? \"[X]\" : \"[L]\";\n    let iconElement = contentSpan.querySelector(\".log-icon\");\n    let icon = iconElement?.textContent || logIconMap.default;\n    let iconClass = \"log-icon\";\n    let currentTitle = iconElement?.getAttribute(\"title\") || newType;\n    if (newMessage.includes(\" OK\")) icon = \"\";\n    else if (newMessage.includes(\" ERR\")) icon = logIconMap.error;\n    else if (newMessage.includes(\"[API OK\")) icon = \"\";\n    if (newType === \"warn\") icon = logIconMap.warn;\n    if (newType === \"error\") icon = logIconMap.error;\n    if (stopAnimate) {\n      const animatedIconEl = contentSpan.querySelector(\".animated-icon\");\n      if (animatedIconEl) {\n        animatedIconEl.classList.remove(\"animated-icon\");\n        iconClass = \"log-icon\";\n        currentTitle = newType;\n      }\n    } else {\n      if (contentSpan.querySelector(\".animated-icon\")) {\n        icon = logIconMap.tool;\n        iconClass = \"log-icon animated-icon\";\n      }\n    }\n    contentSpan.innerHTML = `<span class=\"${iconClass}\" title=\"${currentTitle}\">${icon}</span> ${persona} ${Utils.escapeHtml(\n      newMessage\n    )}`;\n    logItem.classList.remove(\"error\", \"warn\");\n    Object.keys(logIconMap).forEach((key) =>\n      logItem.classList.remove(`log-type-${key}`)\n    );\n    if (newType === \"error\") logItem.classList.add(\"error\");\n    if (newType === \"warn\") logItem.classList.add(\"warn\");\n    if (logIconMap[newType]) logItem.classList.add(`log-type-${newType}`);\n  };\n\n  const summarizeCompletedCycleLog = (outcome) => {\n    if (!lastCycleLogItem || !lastCycleLogItem.classList.contains(\"log-entry\"))\n      return;\n    lastCycleLogItem.classList.add(\"summary\");\n    const contentSpan = lastCycleLogItem.querySelector(\"span:last-child\");\n    if (contentSpan)\n      contentSpan.innerHTML = `<span class=\"log-icon\" aria-hidden=\"true\">${\n        logIconMap.finish\n      }</span> Cycle ${lastCycleLogItem.getAttribute(\n        \"data-cycle\"\n      )} Completed: ${Utils.escapeHtml(\n        outcome\n      )} <span class=\"expand-hint\">(Expand?)</span>`;\n    lastCycleLogItem = null;\n  };\n\n  const clearCurrentCycleDetails = () => {\n    if (!uiRefs.currentCycleDetails || !uiRefs.currentCycleContent) return;\n    uiRefs.currentCycleContent.innerHTML =\n      \"<p><i>Cycle details will appear here.</i></p>\";\n    if (uiRefs.toolsExecutedContainer)\n      uiRefs.toolsExecutedContainer.classList.add(\"hidden\");\n    if (uiRefs.toolsExecutedList) uiRefs.toolsExecutedList.innerHTML = \"\";\n    if (uiRefs.streamingOutputContainer)\n      uiRefs.streamingOutputContainer.classList.add(\"hidden\");\n    if (uiRefs.streamingOutputPre)\n      uiRefs.streamingOutputPre.textContent = \"(No stream active)\";\n    const state = StateManager?.getState();\n    if (state) updateFieldsetSummaries(state);\n  };\n\n  const triggerSyntaxHighlighting = () => {\n    clearTimeout(syntaxHighlightTimer);\n    syntaxHighlightTimer = setTimeout(() => {\n      if (window.Prism && typeof Prism.highlightAllUnder === \"function\") {\n        try {\n          Prism.highlightAllUnder(uiRefs.currentCycleContent);\n        } catch (e) {\n          logger.logEvent(\"warn\", \"Prism highlighting failed.\", e);\n        }\n      } else if (window.hljs && typeof hljs.highlightAll === \"function\") {\n        try {\n          uiRefs.currentCycleContent\n            .querySelectorAll(\"pre code\")\n            .forEach((block) => hljs.highlightElement(block));\n        } catch (e) {\n          logger.logEvent(\"warn\", \"highlight.js highlighting failed.\", e);\n        }\n      }\n    }, SYNTAX_HIGHLIGHT_DEBOUNCE);\n  };\n\n  const displayCycleArtifact = (\n    label,\n    content,\n    type = \"info\",\n    isModified = false,\n    source = null,\n    artifactId = null,\n    cycle = null,\n    versionId = null\n  ) => {\n    if (\n      !uiRefs.currentCycleDetails ||\n      !uiRefs.currentCycleContent ||\n      !StateManager\n    )\n      return;\n    if (\n      uiRefs.currentCycleContent.children.length === 1 &&\n      uiRefs.currentCycleContent.firstChild.tagName === \"P\"\n    )\n      uiRefs.currentCycleContent.innerHTML = \"\";\n    if (uiRefs.currentCycleDetails.classList.contains(\"collapsed\"))\n      uiRefs.currentCycleDetails.classList.remove(\"collapsed\");\n    const section = document.createElement(\"div\");\n    section.className = \"artifact-section\";\n    if (type) section.classList.add(`artifact-type-${type}`);\n    if (source) {\n      const sanitizedSource = String(source)\n        .toLowerCase()\n        .replace(/\\s+/g, \"-\")\n        .replace(/[^a-z0-9-]/g, \"\");\n      if (sanitizedSource)\n        section.classList.add(`artifact-source-${sanitizedSource}`);\n    }\n    const labelEl = document.createElement(\"div\");\n    labelEl.className = \"artifact-label-container\";\n    const meta = artifactId\n      ? StateManager.getArtifactMetadata(artifactId, versionId)\n      : { type: \"TEXT\" };\n    const typeIndicator = getArtifactTypeIndicator(meta?.type);\n    const langMap = {\n      JS: \"javascript\",\n      CSS: \"css\",\n      HTML_HEAD: \"html\",\n      HTML_BODY: \"html\",\n      JSON: \"json\",\n      JSON_CONFIG: \"json\",\n      FULL_HTML_SOURCE: \"html\",\n      PROMPT: \"text\",\n      TEXT: \"text\",\n      EVAL_DEF: \"json\",\n      WEB_COMPONENT_DEF: \"javascript\",\n    };\n    const languageClass = langMap[meta?.type?.toUpperCase()]\n      ? `language-${langMap[meta.type.toUpperCase()]}`\n      : \"language-text\";\n    let labelHTML = `<span class=\"type-indicator\" aria-hidden=\"true\">${typeIndicator}</span> <strong class=\"artifact-title\">${Utils.escapeHtml(\n      label\n    )}</strong>`;\n    if (artifactId)\n      labelHTML += ` <span class=\"artifact-id-ref\">(ID: ${Utils.escapeHtml(\n        artifactId\n      )})</span>`;\n    if (versionId)\n      labelHTML += ` <span class=\"artifact-version-ref\">#${Utils.escapeHtml(\n        versionId\n      )}</span>`;\n    if (cycle !== null)\n      labelHTML += ` <span class=\"artifact-cycle-ref\">[Cyc ${cycle}]</span>`;\n    if (source)\n      labelHTML += ` <span class=\"source-indicator\">(Source: ${Utils.escapeHtml(\n        source\n      )})</span>`;\n    if (isModified)\n      labelHTML +=\n        ' <span class=\"change-indicator\" aria-label=\"Modified\">*</span>';\n    labelEl.innerHTML = labelHTML;\n    section.appendChild(labelEl);\n    const pre = document.createElement(\"pre\");\n    const code = document.createElement(\"code\");\n    pre.className = languageClass;\n    code.className = languageClass;\n    code.textContent =\n      content === null || content === undefined ? \"(empty)\" : String(content);\n    pre.appendChild(code);\n    pre.classList.add(type);\n    if (isModified) pre.classList.add(\"modified\");\n    section.appendChild(pre);\n    uiRefs.currentCycleContent.appendChild(section);\n    triggerSyntaxHighlighting();\n    const state = StateManager.getState();\n    if (state) updateFieldsetSummaries(state);\n    section.scrollIntoView({ behavior: \"smooth\", block: \"nearest\" });\n  };\n\n  const displayToolExecutionSummary = (toolSummaries) => {\n    if (!uiRefs.toolsExecutedContainer || !uiRefs.toolsExecutedList) return;\n    if (!toolSummaries || toolSummaries.length === 0) {\n      uiRefs.toolsExecutedContainer.classList.add(\"hidden\");\n      uiRefs.toolsExecutedList.innerHTML = \"\";\n      return;\n    }\n    uiRefs.toolsExecutedContainer.classList.remove(\"hidden\");\n    const fragment = document.createDocumentFragment();\n    toolSummaries.forEach((summary) => {\n      const li = document.createElement(\"li\");\n      li.classList.add(summary.success ? \"tool-success\" : \"tool-fail\");\n      let content = `<strong>${Utils.escapeHtml(summary.name)}</strong>`;\n      if (summary.args)\n        content += `<span class=\"tool-args\">Args: ${Utils.trunc(\n          Utils.escapeHtml(JSON.stringify(summary.args)),\n          150\n        )}</span>`;\n      if (summary.success) {\n        if (summary.result !== undefined && summary.result !== null)\n          content += `<span class=\"tool-result\">Result: ${Utils.trunc(\n            Utils.escapeHtml(JSON.stringify(summary.result)),\n            150\n          )}</span>`;\n        else\n          content += `<span class=\"tool-result\">Result: OK (No specific return value)</span>`;\n      } else\n        content += `<span class=\"tool-error\">Error: ${Utils.escapeHtml(\n          summary.error || \"Unknown failure\"\n        )}</span>`;\n      li.innerHTML = content;\n      fragment.appendChild(li);\n    });\n    uiRefs.toolsExecutedList.innerHTML = \"\";\n    uiRefs.toolsExecutedList.appendChild(fragment);\n  };\n\n  const hideHumanInterventionUI = () => {\n    if (!uiRefs.humanInterventionSection) return;\n    uiRefs.humanInterventionSection.classList.add(\"hidden\");\n    if (uiRefs.hitlOptionsMode) uiRefs.hitlOptionsMode.classList.add(\"hidden\");\n    if (uiRefs.hitlPromptMode) uiRefs.hitlPromptMode.classList.add(\"hidden\");\n    if (uiRefs.hitlCodeEditMode)\n      uiRefs.hitlCodeEditMode.classList.add(\"hidden\");\n    if (uiRefs.hitlCritiqueFeedbackMode)\n      uiRefs.hitlCritiqueFeedbackMode.classList.add(\"hidden\");\n    const state = StateManager?.getState();\n    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;\n    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;\n    if (\n      !metaSandboxPending &&\n      uiRefs.runCycleButton &&\n      state &&\n      !isCycleRunning &&\n      !isAutonomousRunning\n    )\n      setRunButtonState(\"Run Cycle\", false);\n  };\n\n  const showHumanInterventionUI = (\n    mode = \"prompt\",\n    reason = \"\",\n    options = [],\n    artifactIdToEdit = null,\n    critiques = []\n  ) => {\n    if (!uiRefs.humanInterventionSection || !StateManager) return;\n    const state = StateManager.getState();\n    if (!state) return;\n    highlightCoreStep(5);\n    hideMetaSandbox();\n    uiRefs.humanInterventionSection.classList.remove(\"hidden\");\n    const fieldset = uiRefs.humanInterventionSection.querySelector(\"fieldset\");\n    if (fieldset) fieldset.classList.remove(\"collapsed\");\n    const titleText = `Human Intervention: ${Utils.ucFirst(\n      mode.replace(\"_\", \" \")\n    )}`;\n    if (uiRefs.humanInterventionTitle)\n      uiRefs.humanInterventionTitle.textContent = titleText;\n    if (uiRefs.humanInterventionReason)\n      uiRefs.humanInterventionReason.innerHTML = `<strong>Reason:</strong> ${Utils.escapeHtml(\n        reason\n      )}`;\n    if (uiRefs.humanInterventionReasonSummary)\n      uiRefs.humanInterventionReasonSummary.textContent = `| Reason: ${Utils.trunc(\n        reason,\n        50\n      )}...`;\n    if (uiRefs.runCycleButton) setRunButtonState(\"Run Cycle\", true);\n    if (uiRefs.autonomyStartStopButton) setAutonomyButtonState(false, true);\n    logToTimeline(\n      state.totalCycles,\n      `[HUMAN] Intervention Required (${mode}): ${Utils.trunc(reason, 100)}`,\n      \"warn\",\n      true\n    );\n    if (uiRefs.hitlOptionsMode) uiRefs.hitlOptionsMode.classList.add(\"hidden\");\n    if (uiRefs.hitlPromptMode) uiRefs.hitlPromptMode.classList.add(\"hidden\");\n    if (uiRefs.hitlCodeEditMode)\n      uiRefs.hitlCodeEditMode.classList.add(\"hidden\");\n    if (uiRefs.hitlCritiqueFeedbackMode)\n      uiRefs.hitlCritiqueFeedbackMode.classList.add(\"hidden\");\n    let activeModeContainer = null;\n    let focusElement = null;\n    if (\n      mode === \"critique_feedback\" &&\n      critiques &&\n      critiques.length > 0 &&\n      uiRefs.hitlCritiqueFeedbackMode\n    ) {\n      activeModeContainer = uiRefs.hitlCritiqueFeedbackMode;\n      if (uiRefs.hitlCritiquesDisplay)\n        uiRefs.hitlCritiquesDisplay.innerHTML = \"\";\n      if (uiRefs.hitlCritiqueSelection)\n        uiRefs.hitlCritiqueSelection.innerHTML = \"\";\n      const displayFragment = document.createDocumentFragment();\n      const selectionFragment = document.createDocumentFragment();\n      let firstFailingCritiqueIndex = -1;\n      critiques.forEach((crit, index) => {\n        const critDiv = document.createElement(\"div\");\n        critDiv.className = `critique-item ${\n          crit.critique_passed ? \"pass\" : \"fail\"\n        }`;\n        critDiv.innerHTML = `<h4>Critique ${index + 1} (${\n          crit.critique_passed ? \"Pass\" : \"FAIL\"\n        })</h4><pre>${Utils.escapeHtml(crit.critique_report)}</pre>`;\n        displayFragment.appendChild(critDiv);\n        const radioLabel = document.createElement(\"label\");\n        const radioInput = document.createElement(\"input\");\n        radioInput.type = \"radio\";\n        radioInput.name = \"critique_selection\";\n        radioInput.value = index;\n        radioInput.id = `critique_select_${index}`;\n        if (!crit.critique_passed && firstFailingCritiqueIndex === -1)\n          firstFailingCritiqueIndex = index;\n        radioLabel.appendChild(radioInput);\n        radioLabel.appendChild(\n          document.createTextNode(\n            ` Select Critique ${index + 1} as most relevant`\n          )\n        );\n        selectionFragment.appendChild(radioLabel);\n        selectionFragment.appendChild(document.createElement(\"br\"));\n      });\n      const defaultCheckedIndex =\n        firstFailingCritiqueIndex !== -1 ? firstFailingCritiqueIndex : 0;\n      const defaultRadio = selectionFragment.querySelector(\n        `#critique_select_${defaultCheckedIndex}`\n      );\n      if (defaultRadio) defaultRadio.checked = true;\n      if (uiRefs.hitlCritiquesDisplay)\n        uiRefs.hitlCritiquesDisplay.appendChild(displayFragment);\n      if (uiRefs.hitlCritiqueSelection)\n        uiRefs.hitlCritiqueSelection.appendChild(selectionFragment);\n      if (uiRefs.hitlCritiqueNotes) uiRefs.hitlCritiqueNotes.value = \"\";\n      triggerSyntaxHighlighting();\n      focusElement =\n        uiRefs.hitlCritiqueNotes ||\n        uiRefs.hitlCritiqueSelection?.querySelector('input[type=\"radio\"]');\n    } else if (mode === \"code_edit\" && uiRefs.hitlCodeEditMode) {\n      activeModeContainer = uiRefs.hitlCodeEditMode;\n      if (uiRefs.humanEditArtifactSelector)\n        uiRefs.humanEditArtifactSelector.innerHTML = \"\";\n      if (uiRefs.humanEditArtifactTextarea)\n        uiRefs.humanEditArtifactTextarea.value = \"\";\n      const editableTypes = [\n        \"HTML_HEAD\",\n        \"HTML_BODY\",\n        \"CSS\",\n        \"JS\",\n        \"JSON\",\n        \"FULL_HTML_SOURCE\",\n        \"PROMPT\",\n        \"TEXT\",\n        \"EVAL_DEF\",\n        \"WEB_COMPONENT_DEF\",\n      ];\n      const currentCycle = state.totalCycles;\n      const allMetaMap = StateManager.getAllArtifactMetadata();\n      const relevantArtifacts = Object.values(allMetaMap)\n        .filter(\n          (meta) =>\n            meta && editableTypes.includes(meta.type) && meta.latestCycle >= 0\n        )\n        .sort((a, b) => a.id.localeCompare(b.id));\n      const fragment = document.createDocumentFragment();\n      relevantArtifacts.forEach((meta) => {\n        const opt = document.createElement(\"option\");\n        opt.value = meta.id;\n        opt.textContent = `${meta.id} (${meta.type}) - Last Mod: Cyc ${meta.latestCycle}`;\n        fragment.appendChild(opt);\n      });\n      if (\n        state.lastGeneratedFullSource &&\n        (artifactIdToEdit === \"full_html_source\" ||\n          artifactIdToEdit === \"page_composition_preview\")\n      ) {\n        const opt = document.createElement(\"option\");\n        opt.value = artifactIdToEdit;\n        opt.textContent = `Proposed ${Utils.ucFirst(\n          artifactIdToEdit.replace(\"_\", \" \")\n        )} (Cycle ${currentCycle})`;\n        fragment.appendChild(opt);\n      }\n      if (uiRefs.humanEditArtifactSelector)\n        uiRefs.humanEditArtifactSelector.appendChild(fragment);\n      const selectArtifact = (id) => {\n        if (!uiRefs.humanEditArtifactTextarea) return;\n        let contentToEdit = \"\";\n        let currentArtCycle = currentCycle;\n        let currentArtVersionId = null;\n        if (id === \"full_html_source\" || id === \"page_composition_preview\") {\n          contentToEdit = state.lastGeneratedFullSource || \"\";\n          currentArtCycle = state.totalCycles;\n        } else {\n          const meta = StateManager.getArtifactMetadata(id);\n          if (meta && meta.latestCycle >= 0) {\n            contentToEdit =\n              Storage.getArtifactContent(\n                id,\n                meta.latestCycle,\n                meta.version_id\n              ) || \"\";\n            currentArtCycle = meta.latestCycle;\n            currentArtVersionId = meta.version_id;\n          } else contentToEdit = \"(Artifact not found or empty)\";\n        }\n        uiRefs.humanEditArtifactTextarea.value = contentToEdit;\n        uiRefs.humanEditArtifactTextarea.setAttribute(\n          \"data-current-artifact-id\",\n          id\n        );\n        uiRefs.humanEditArtifactTextarea.setAttribute(\n          \"data-current-artifact-cycle\",\n          currentArtCycle\n        );\n        if (currentArtVersionId)\n          uiRefs.humanEditArtifactTextarea.setAttribute(\n            \"data-current-artifact-version-id\",\n            currentArtVersionId\n          );\n        else\n          uiRefs.humanEditArtifactTextarea.removeAttribute(\n            \"data-current-artifact-version-id\"\n          );\n        triggerSyntaxHighlighting();\n      };\n      if (uiRefs.humanEditArtifactSelector)\n        uiRefs.humanEditArtifactSelector.onchange = () =>\n          selectArtifact(uiRefs.humanEditArtifactSelector.value);\n      const metaToEdit = artifactIdToEdit\n        ? StateManager.getArtifactMetadata(artifactIdToEdit)\n        : null;\n      const initialId =\n        artifactIdToEdit &&\n        ((metaToEdit && metaToEdit.latestCycle >= 0) ||\n          artifactIdToEdit === \"full_html_source\" ||\n          artifactIdToEdit === \"page_composition_preview\")\n          ? artifactIdToEdit\n          : relevantArtifacts[0]?.id;\n      if (initialId && uiRefs.humanEditArtifactSelector) {\n        uiRefs.humanEditArtifactSelector.value = initialId;\n        selectArtifact(initialId);\n      } else if (uiRefs.humanEditArtifactTextarea) {\n        uiRefs.humanEditArtifactTextarea.value =\n          \"(No editable artifacts found)\";\n        uiRefs.humanEditArtifactTextarea.removeAttribute(\n          \"data-current-artifact-id\"\n        );\n        uiRefs.humanEditArtifactTextarea.removeAttribute(\n          \"data-current-artifact-cycle\"\n        );\n        uiRefs.humanEditArtifactTextarea.removeAttribute(\n          \"data-current-artifact-version-id\"\n        );\n      }\n      focusElement =\n        uiRefs.humanEditArtifactSelector || uiRefs.humanEditArtifactTextarea;\n    } else {\n      activeModeContainer = uiRefs.hitlPromptMode;\n      if (uiRefs.humanCritiqueInput) {\n        uiRefs.humanCritiqueInput.value = \"\";\n        uiRefs.humanCritiqueInput.placeholder = `Provide feedback or next instructions related to: ${Utils.trunc(\n          reason,\n          80\n        )}`;\n        focusElement = uiRefs.humanCritiqueInput;\n      }\n    }\n    if (activeModeContainer) activeModeContainer.classList.remove(\"hidden\");\n    if (focusElement) focusElement.focus();\n    if (uiRefs.humanInterventionSection)\n      uiRefs.humanInterventionSection.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\",\n      });\n  };\n\n  const hideMetaSandbox = () => {\n    if (!uiRefs.metaSandboxContainer) return;\n    uiRefs.metaSandboxContainer.classList.add(\"hidden\");\n    metaSandboxPending = false;\n    const humanInterventionVisible =\n      !uiRefs.humanInterventionSection?.classList.contains(\"hidden\");\n    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;\n    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;\n    if (\n      !humanInterventionVisible &&\n      uiRefs.runCycleButton &&\n      !isCycleRunning &&\n      !isAutonomousRunning\n    )\n      setRunButtonState(\"Run Cycle\", false);\n    if (uiRefs.autonomyStartStopButton && !isCycleRunning)\n      setAutonomyButtonState(!isAutonomousRunning, false);\n  };\n\n  const showMetaSandbox = (htmlSource) => {\n    if (\n      !uiRefs.metaSandboxContainer ||\n      !uiRefs.metaSandboxOutput ||\n      !StateManager\n    )\n      return;\n    const state = StateManager.getState();\n    if (!state) return;\n    highlightCoreStep(6);\n    hideHumanInterventionUI();\n    uiRefs.metaSandboxContainer.classList.remove(\"hidden\");\n    const fieldset = uiRefs.metaSandboxContainer.querySelector(\"fieldset\");\n    if (fieldset) fieldset.classList.remove(\"collapsed\");\n    if (uiRefs.runCycleButton) setRunButtonState(\"Run Cycle\", true);\n    if (uiRefs.autonomyStartStopButton) setAutonomyButtonState(false, true);\n    const iframe = uiRefs.metaSandboxOutput;\n    try {\n      if (!iframe.contentWindow)\n        throw new Error(\"Meta sandbox iframe contentWindow is not accessible.\");\n      const doc = iframe.contentWindow.document;\n      doc.open();\n      doc.write(htmlSource);\n      doc.close();\n      logger.logEvent(\"info\", \"Meta sandbox rendered for approval.\");\n      metaSandboxPending = true;\n      logToTimeline(\n        state.totalCycles,\n        \"[STATE] Meta-Sandbox Ready for Review.\",\n        \"state\",\n        true\n      );\n      uiRefs.metaSandboxContainer.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\",\n      });\n    } catch (e) {\n      logger.logEvent(\"error\", `Cannot render meta sandbox: ${e.message}`, e);\n      showNotification(\"Error: Failed to show meta sandbox preview.\", \"error\");\n      logToTimeline(\n        state.totalCycles,\n        \"[ERROR] Meta-Sandbox failed to render.\",\n        \"error\",\n        true\n      );\n      hideMetaSandbox();\n      if (uiRefs.runCycleButton) setRunButtonState(\"Run Cycle\", false);\n    }\n  };\n\n  const loadPromptsFromLS = () => {\n    if (\n      !uiRefs.seedPromptCore ||\n      !uiRefs.seedPromptCritique ||\n      !uiRefs.seedPromptSummarize ||\n      !uiRefs.seedPromptEvaluator\n    ) {\n      logger.logEvent(\"warn\", \"Prompt textareas not found during UI init.\");\n      return;\n    }\n    uiRefs.seedPromptCore.value =\n      Storage.getArtifactContent(\"reploid.core.sys-prompt\", 0) || \"\";\n    uiRefs.seedPromptCritique.value =\n      Storage.getArtifactContent(\"reploid.core.critiquer-prompt\", 0) || \"\";\n    uiRefs.seedPromptSummarize.value =\n      Storage.getArtifactContent(\"reploid.core.summarizer-prompt\", 0) || \"\";\n    uiRefs.seedPromptEvaluator.value =\n      Storage.getArtifactContent(\"reploid.core.evaluator-prompt\", 0) || \"\";\n    logger.logEvent(\"debug\", \"Loaded prompts from LS into UI.\");\n  };\n\n  const loadCoreLoopSteps = () => {\n    highlightCoreStep(activeCoreStepIdx);\n    logger.logEvent(\"debug\", \"Initialized core loop steps minimap.\");\n  };\n\n  const populateModelSelectors = () => {\n    [uiRefs.coreModelSelector, uiRefs.critiqueModelSelector].forEach(\n      (selector) => {\n        if (!selector) return;\n        selector.innerHTML = \"\";\n        const fragment = document.createDocumentFragment();\n        APP_MODELS.forEach((modelName) => {\n          const option = document.createElement(\"option\");\n          option.value = modelName;\n          option.textContent = modelName.split(\"/\").pop();\n          fragment.appendChild(option);\n        });\n        selector.appendChild(fragment);\n      }\n    );\n  };\n\n  const handleConfigChange = (key, value) => {\n    StateManager.updateAndSaveState((currentState) => {\n      if (!currentState.cfg) currentState.cfg = {};\n      if (currentState.cfg[key] !== value) {\n        currentState.cfg[key] = value;\n        logger.logEvent(\"info\", `UI Config Update: ${key} = ${value}`);\n        if (key === \"maxCycles\" && uiRefs.maxCyclesDisplay)\n          uiRefs.maxCyclesDisplay.textContent =\n            value === 0 ? \"Inf\" : String(value);\n        if (key === \"htmlHistoryLimit\") updateHtmlHistoryControls(currentState);\n      }\n      return currentState;\n    });\n    updateFieldsetSummaries(StateManager.getState());\n  };\n\n  const _setupControlButtonListeners = () => {\n    uiRefs.runCycleButton?.addEventListener(\"click\", () => {\n      if (CycleLogic.isRunning()) CycleLogic.abortCurrentCycle();\n      else CycleLogic.executeCycle();\n    });\n    uiRefs.forceHumanReviewButton?.addEventListener(\"click\", () => {\n      StateManager.updateAndSaveState((s) => {\n        s.forceHumanReview = true;\n        return s;\n      });\n      showNotification(\"Next cycle will pause for Human Review.\", \"info\");\n      logToTimeline(\n        StateManager.getState()?.totalCycles || 0,\n        \"[HUMAN] User forced Human Review.\",\n        \"human\"\n      );\n    });\n    uiRefs.downloadLogButton?.addEventListener(\"click\", () => {\n      try {\n        const logData = logger.getLogBuffer\n          ? logger.getLogBuffer()\n          : \"(Log buffer unavailable)\";\n        const blob = new Blob([logData], { type: \"text/plain\" });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = `x0_log_${new Date()\n          .toISOString()\n          .replace(/[:.]/g, \"-\")}.txt`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        logger.logEvent(\"info\", \"Log download initiated.\");\n      } catch (e) {\n        logger.logEvent(\"error\", `Log download failed: ${e.message}`, e);\n        showNotification(`Log download failed: ${e.message}`, \"error\");\n      }\n    });\n    uiRefs.exportStateButton?.addEventListener(\"click\", () =>\n      StateManager?.exportState(uiRefs)\n    );\n    uiRefs.summarizeContextButton?.addEventListener(\"click\", () =>\n      CycleLogic?.handleSummarizeContext()\n    );\n    uiRefs.importStateButton?.addEventListener(\"click\", () =>\n      uiRefs.importFileInput?.click()\n    );\n    uiRefs.importFileInput?.addEventListener(\"change\", (event) => {\n      const file = event.target.files?.[0];\n      if (file && StateManager) {\n        StateManager.importState(file, (success, importedData, errorMsg) => {\n          if (success && importedData) {\n            if (uiRefs.timelineLog)\n              uiRefs.timelineLog.innerHTML = importedData.timelineHTML || \"\";\n            clearCurrentCycleDetails();\n            populateModelSelectors();\n            updateStateDisplay();\n            displayGenesisState();\n            loadPromptsFromLS();\n            loadCoreLoopSteps();\n            logToTimeline(\n              importedData.totalCycles,\n              \"[STATE] State imported.\",\n              \"state\"\n            );\n            showNotification(\n              \"State imported. Ensure required artifacts exist in localStorage.\",\n              \"info\"\n            );\n          } else {\n            showNotification(\n              `Import failed: ${errorMsg || \"Unknown error\"}`,\n              \"error\"\n            );\n            logToTimeline(\n              StateManager?.getState()?.totalCycles ?? 0,\n              `[STATE] State import failed: ${errorMsg || \"Unknown\"}`,\n              \"error\"\n            );\n          }\n          if (uiRefs.importFileInput) uiRefs.importFileInput.value = \"\";\n        });\n      }\n    });\n    uiRefs.goBackButton?.addEventListener(\"click\", () => {\n      const state = StateManager.getState();\n      if (!state?.htmlHistory?.length) {\n        showNotification(\"No history.\", \"warn\");\n        return;\n      }\n      if (\n        !confirm(\"Revert page to previous version? State will attempt restore.\")\n      )\n        return;\n      const prevStateHtml = state.htmlHistory[state.htmlHistory.length - 1];\n      StateManager.updateAndSaveState((s) => {\n        s.htmlHistory.pop();\n        return s;\n      });\n      updateHtmlHistoryControls(StateManager.getState());\n      logger.logEvent(\n        \"info\",\n        `Reverting page HTML. History size: ${\n          StateManager.getState().htmlHistory.length\n        }`\n      );\n      logToTimeline(\n        state.totalCycles,\n        \"[STATE] Reverting HTML (Page Reload).\",\n        \"state\"\n      );\n      try {\n        const stateToPreserve = StateManager.capturePreservationState(uiRefs);\n        Storage.saveSessionState(stateToPreserve);\n        document.open();\n        document.write(prevStateHtml);\n        document.close();\n      } catch (e) {\n        logger.logEvent(\"error\", `Go Back failed: ${e.message}`, e);\n        showNotification(`Go Back failed: ${e.message}`, \"error\");\n        Storage.removeSessionState();\n        StateManager.updateAndSaveState((s) => {\n          if (prevStateHtml) s.htmlHistory.push(prevStateHtml);\n          return s;\n        });\n        updateHtmlHistoryControls(StateManager.getState());\n      }\n    });\n    uiRefs.clearLocalStorageButton?.addEventListener(\"click\", () => {\n      if (\n        !confirm(\n          \"WARNING: Delete ALL Reploid data from LocalStorage? Cannot be undone.\"\n        )\n      )\n        return;\n      try {\n        Storage.clearAllReploidData();\n        showNotification(\"LocalStorage cleared. Reloading...\", \"info\", 0);\n        setTimeout(() => window.location.reload(), 1000);\n      } catch (e) {\n        logger.logEvent(\n          \"error\",\n          `Error clearing LocalStorage: ${e.message}`,\n          e\n        );\n        showNotification(`Error clearing LocalStorage: ${e.message}`, \"error\");\n      }\n    });\n  };\n\n  const _setupHitlButtonListeners = () => {\n    uiRefs.submitCritiqueButton?.addEventListener(\"click\", () => {\n      if (CycleLogic.proceedAfterHumanIntervention && uiRefs.humanCritiqueInput)\n        CycleLogic.proceedAfterHumanIntervention(\n          \"Human Prompt\",\n          uiRefs.humanCritiqueInput.value.trim()\n        );\n    });\n    uiRefs.submitHitlOptionsButton?.addEventListener(\"click\", () => {\n      if (CycleLogic.proceedAfterHumanIntervention && uiRefs.hitlOptionsList) {\n        const selected = Array.from(\n          uiRefs.hitlOptionsList.querySelectorAll(\"input:checked\")\n        )\n          .map((el) => el.value)\n          .join(\", \");\n        CycleLogic.proceedAfterHumanIntervention(\n          \"Human Options\",\n          selected || \"None\"\n        );\n      }\n    });\n    uiRefs.submitHumanCodeEditButton?.addEventListener(\"click\", async () => {\n      if (\n        !CycleLogic.runTool ||\n        !CycleLogic.proceedAfterHumanIntervention ||\n        !uiRefs.humanEditArtifactTextarea ||\n        !StateManager\n      )\n        return;\n      const artifactId = uiRefs.humanEditArtifactTextarea.getAttribute(\n        \"data-current-artifact-id\"\n      );\n      const cycleStr = uiRefs.humanEditArtifactTextarea.getAttribute(\n        \"data-current-artifact-cycle\"\n      );\n      const versionId =\n        uiRefs.humanEditArtifactTextarea.getAttribute(\n          \"data-current-artifact-version-id\"\n        ) || null;\n      const newContent = uiRefs.humanEditArtifactTextarea.value;\n      if (!artifactId || cycleStr === null) {\n        showNotification(\n          \"Error: No artifact selected or cycle info missing.\",\n          \"error\"\n        );\n        return;\n      }\n      const cycle = parseInt(cycleStr, 10);\n      if (isNaN(cycle)) {\n        showNotification(\"Error: Invalid cycle number for artifact.\", \"error\");\n        return;\n      }\n      updateStatus(\"Validating Edit...\", true);\n      try {\n        const toolResult = await CycleLogic.runTool(\"code_edit\", {\n          artifactId,\n          cycle,\n          versionId,\n          newContent,\n        });\n        updateStatus(\"Idle\");\n        if (toolResult?.success) {\n          showNotification(\n            `Edit for ${artifactId} validated. Proceeding...`,\n            \"info\"\n          );\n          CycleLogic.proceedAfterHumanIntervention(\n            \"Human Code Edit\",\n            toolResult\n          );\n        } else {\n          showNotification(\n            `Edit Validation Failed: ${\n              toolResult?.error || \"Unknown validation error\"\n            }`,\n            \"error\"\n          );\n          logger.logEvent(\n            \"error\",\n            `Human edit validation failed for ${artifactId}: ${toolResult?.error}`\n          );\n        }\n      } catch (e) {\n        updateStatus(\"Idle\");\n        logger.logEvent(\n          \"error\",\n          `Error running code_edit tool for ${artifactId}: ${e.message}`,\n          e\n        );\n        showNotification(`Error validating edit: ${e.message}`, \"error\");\n      }\n    });\n    uiRefs.submitCritiqueFeedbackButton?.addEventListener(\"click\", () => {\n      if (!CycleLogic.proceedAfterHumanIntervention || !StateManager) return;\n      const selectedCritiqueIndex = uiRefs.hitlCritiqueSelection?.querySelector(\n        'input[name=\"critique_selection\"]:checked'\n      )?.value;\n      const notes = uiRefs.hitlCritiqueNotes?.value.trim() || \"\";\n      const feedbackData = {\n        selectedCritique:\n          selectedCritiqueIndex !== undefined\n            ? parseInt(selectedCritiqueIndex, 10)\n            : -1,\n        feedbackNotes: notes,\n      };\n      CycleLogic.proceedAfterHumanIntervention(\n        \"Human Critique Selection\",\n        feedbackData\n      );\n    });\n  };\n\n  const _setupSandboxButtonListeners = () => {\n    uiRefs.approveMetaChangeButton?.addEventListener(\"click\", () => {\n      const state = StateManager.getState();\n      if (metaSandboxPending && state?.lastGeneratedFullSource) {\n        const sourceToApply = state.lastGeneratedFullSource;\n        logger.logEvent(\"info\", \"Approved meta-change.\");\n        logToTimeline(\n          state.totalCycles,\n          \"[STATE] Approved Meta-Sandbox. Applying & Reloading...\",\n          \"state\",\n          true\n        );\n        hideMetaSandbox();\n        const currentHtml = document.documentElement.outerHTML;\n        CycleLogic?.saveHtmlToHistory(currentHtml);\n        const stateToPreserve = StateManager.capturePreservationState(uiRefs);\n        StateManager.updateAndSaveState((s) => {\n          s.metaSandboxPending = false;\n          return s;\n        });\n        try {\n          Storage.saveSessionState(stateToPreserve);\n          document.open();\n          document.write(sourceToApply);\n          document.close();\n        } catch (e) {\n          logger.logEvent(\"error\", `Apply meta-change failed: ${e.message}`, e);\n          showNotification(`Apply failed: ${e.message}`, \"error\");\n          Storage.removeSessionState();\n          StateManager.updateAndSaveState((s) => {\n            if (s?.htmlHistory?.length > 0) s.htmlHistory.pop();\n            return s;\n          });\n          updateHtmlHistoryControls(StateManager.getState());\n          metaSandboxPending = true;\n          showMetaSandbox(sourceToApply);\n          if (uiRefs.runCycleButton) setRunButtonState(\"Run Cycle\", true);\n        }\n      } else\n        showNotification(\n          \"No sandbox content pending or state missing.\",\n          \"warn\"\n        );\n    });\n    uiRefs.discardMetaChangeButton?.addEventListener(\"click\", () => {\n      const state = StateManager.getState();\n      logger.logEvent(\"info\", \"Discarded meta-sandbox changes.\");\n      logToTimeline(\n        state?.totalCycles || 0,\n        \"[STATE] Discarded Meta-Sandbox changes.\",\n        \"warn\",\n        true\n      );\n      hideMetaSandbox();\n      StateManager.updateAndSaveState((s) => {\n        s.lastGeneratedFullSource = null;\n        return s;\n      });\n      CycleLogic?.proceedAfterHumanIntervention(\n        \"Sandbox Discarded\",\n        \"User discarded changes\",\n        true\n      );\n    });\n  };\n\n  const _setupConfigInputListeners = () => {\n    uiRefs.lsdPersonaPercentInput?.addEventListener(\"input\", () => {\n      const lsdInput = uiRefs.lsdPersonaPercentInput;\n      const xyzInput = uiRefs.xyzPersonaPercentInput;\n      if (!lsdInput || !xyzInput) return;\n      let lsd = parseInt(lsdInput.value, 10) || 0;\n      lsd = Math.max(0, Math.min(100, lsd));\n      lsdInput.value = lsd;\n      xyzInput.value = 100 - lsd;\n      handleConfigChange(\"personaBalance\", lsd);\n    });\n    const defaultConfig = config.DEFAULT_CFG || {};\n    Object.keys(defaultConfig).forEach((key) => {\n      if (\n        key === \"personaBalance\" ||\n        key === \"coreModel\" ||\n        key === \"critiqueModel\"\n      )\n        return;\n      const inputId = Utils.camelToKabob(key) + \"-input\";\n      const inputEl = uiRefs[Utils.kabobToCamel(inputId)];\n      if (inputEl) {\n        inputEl.addEventListener(\"change\", (e) => {\n          const target = e.target;\n          let value;\n          if (target.type === \"number\") {\n            value =\n              target.step === \"any\" || target.step?.includes(\".\")\n                ? parseFloat(target.value)\n                : parseInt(target.value, 10);\n            const min = parseFloat(target.min);\n            const max = parseFloat(target.max);\n            if (!isNaN(min) && value < min) value = min;\n            if (!isNaN(max) && value > max) value = max;\n            target.value = value;\n          } else value = target.value;\n          handleConfigChange(key, value);\n        });\n      }\n    });\n    uiRefs.coreModelSelector?.addEventListener(\"change\", (e) =>\n      handleConfigChange(\"coreModel\", e.target.value)\n    );\n    uiRefs.critiqueModelSelector?.addEventListener(\"change\", (e) =>\n      handleConfigChange(\"critiqueModel\", e.target.value)\n    );\n    uiRefs.apiKeyInput?.addEventListener(\"change\", (e) =>\n      handleConfigChange(\"apiKey\", e.target.value.trim())\n    );\n  };\n\n  const _setupAutonomyListeners = () => {\n    uiRefs.autonomyModeSelector?.addEventListener(\"change\", (e) => {\n      const mode = e.target.value;\n      StateManager.updateAndSaveState((s) => {\n        s.autonomyMode = mode;\n        if (mode !== \"N_Cycles\") s.autonomyCyclesRemaining = 0;\n        return s;\n      });\n      updateAutonomyControls(mode, false);\n      updateStateDisplay();\n    });\n    uiRefs.autonomyNCyclesInput?.addEventListener(\"change\", (e) => {\n      StateManager.updateAndSaveState((s) => {\n        if (s.autonomyMode === \"N_Cycles\") {\n          let cycles = parseInt(e.target.value, 10);\n          cycles = Math.max(1, isNaN(cycles) ? 1 : cycles);\n          s.autonomyCyclesRemaining = cycles;\n          e.target.value = cycles;\n        }\n        return s;\n      });\n    });\n    uiRefs.autonomyStartStopButton?.addEventListener(\"click\", () => {\n      const state = StateManager.getState();\n      if (!state) return;\n      if (CycleLogic.isAutonomous())\n        CycleLogic.stopAutonomousRun(\"User Stop Request\");\n      else {\n        const mode = state.autonomyMode || \"Manual\";\n        const cycles = parseInt(uiRefs.autonomyNCyclesInput?.value || \"5\", 10);\n        if (mode === \"Manual\")\n          showNotification(\n            \"Select 'Run N Cycles' or 'Continuous' mode first.\",\n            \"warn\"\n          );\n        else if (mode === \"N_Cycles\" && (isNaN(cycles) || cycles <= 0))\n          showNotification(\n            \"Please enter a valid number of cycles > 0.\",\n            \"warn\"\n          );\n        else CycleLogic.startAutonomousRun(mode, cycles);\n      }\n    });\n  };\n\n  const updateAutonomyControls = (mode, isRunning) => {\n    const nCyclesInput = uiRefs.autonomyNCyclesInput;\n    const nCyclesLabel = uiRefs.autonomyNLabel;\n    const startStopButton = uiRefs.autonomyStartStopButton;\n    if (nCyclesInput && nCyclesLabel) {\n      const showNCycles = mode === \"N_Cycles\";\n      nCyclesInput.classList.toggle(\"hidden\", !showNCycles);\n      nCyclesLabel.classList.toggle(\"hidden\", !showNCycles);\n      nCyclesInput.disabled = isRunning && mode === \"N_Cycles\";\n    }\n    if (startStopButton) {\n      startStopButton.disabled =\n        mode === \"Manual\" || (CycleLogic?.isRunning() && !isRunning);\n      startStopButton.textContent = isRunning\n        ? \"Stop Autonomous Run\"\n        : \"Start Autonomous Run\";\n    }\n    setRunButtonState(\n      uiRefs.runCycleButton?.textContent || \"Run Cycle\",\n      isRunning || (CycleLogic?.isRunning() && !isRunning)\n    );\n  };\n\n  const setRunButtonState = (text, disabled) => {\n    if (uiRefs.runCycleButton) {\n      uiRefs.runCycleButton.textContent = text;\n      uiRefs.runCycleButton.disabled = disabled;\n    }\n  };\n  const setAutonomyButtonState = (isRunning, disabled) => {\n    if (uiRefs.autonomyStartStopButton) {\n      uiRefs.autonomyStartStopButton.textContent = isRunning\n        ? \"Stop Autonomous Run\"\n        : \"Start Autonomous Run\";\n      uiRefs.autonomyStartStopButton.disabled = disabled;\n    }\n    if (uiRefs.autonomyModeSelector)\n      uiRefs.autonomyModeSelector.disabled = disabled || isRunning;\n    if (uiRefs.autonomyNCyclesInput)\n      uiRefs.autonomyNCyclesInput.disabled = disabled || isRunning;\n  };\n\n  const _setupFieldsetListeners = () => {\n    document.querySelectorAll(\"fieldset legend\").forEach((legend) => {\n      legend.addEventListener(\"click\", (event) => {\n        if (event.target.closest(\"button, input, a, select, textarea\")) return;\n        const fieldset = legend.closest(\"fieldset\");\n        fieldset?.classList.toggle(\"collapsed\");\n      });\n    });\n  };\n\n  const setupEventListeners = () => {\n    if (!isInitialized || !CycleLogic || !StateManager) {\n      logger.logEvent(\n        \"error\",\n        \"UI elements or core logic refs not ready for event listeners.\"\n      );\n      return;\n    }\n    _setupControlButtonListeners();\n    _setupHitlButtonListeners();\n    _setupSandboxButtonListeners();\n    _setupConfigInputListeners();\n    _setupAutonomyListeners();\n    _setupFieldsetListeners();\n    logger.logEvent(\"info\", \"UI Event listeners set up.\");\n  };\n\n  const _loadInitialUIData = () => {\n    const state = StateManager.getState();\n    if (!state) {\n      logger.logEvent(\"error\", \"Cannot load initial UI data, state is null.\");\n      return;\n    }\n    updateStateDisplay();\n    displayGenesisState();\n    loadPromptsFromLS();\n    loadCoreLoopSteps();\n    document.querySelectorAll(\"fieldset\").forEach((fs) => {\n      if (fs.id !== \"controls-fieldset\" && fs.id !== \"current-cycle-details\")\n        fs.classList.add(\"collapsed\");\n      else fs.classList.remove(\"collapsed\");\n    });\n    if (state) updateFieldsetSummaries(state);\n    logToTimeline(\n      state?.totalCycles || 0,\n      \"[STATE] System Initialized.\",\n      \"state\"\n    );\n  };\n\n  const restoreUIState = (preservedData) => {\n    if (!isInitialized || !uiRefs.timelineLog) {\n      logger.logEvent(\n        \"warn\",\n        \"Cannot restore UI state, UI not fully initialized or timeline missing.\"\n      );\n      return;\n    }\n    metaSandboxPending = preservedData.metaSandboxPending || false;\n    if (uiRefs.timelineLog)\n      uiRefs.timelineLog.innerHTML = preservedData.timelineHTML || \"\";\n    populateModelSelectors();\n    updateStateDisplay();\n    displayGenesisState();\n    loadPromptsFromLS();\n    loadCoreLoopSteps();\n    logToTimeline(\n      preservedData.totalCycles,\n      \"[STATE] Restored after self-mod.\",\n      \"state\"\n    );\n    const isAutonomousRunning = preservedData.autonomyMode !== \"Manual\";\n    setRunButtonState(\"Run Cycle\", metaSandboxPending || isAutonomousRunning);\n    setAutonomyButtonState(isAutonomousRunning, metaSandboxPending);\n    updateStatus(metaSandboxPending ? \"Meta Sandbox Pending...\" : \"Idle\");\n    document.querySelectorAll(\"fieldset\").forEach((fs) => {\n      if (\n        !fs.classList.contains(\"collapsed\") &&\n        fs.id !== \"controls-fieldset\" &&\n        fs.id !== \"current-cycle-details\"\n      )\n        fs.classList.add(\"collapsed\");\n    });\n    if (preservedData) updateFieldsetSummaries(preservedData);\n    logger.logEvent(\"info\", \"UI state restored from session data.\");\n  };\n\n  const init = (injectedStateManager, injectedCycleLogic) => {\n    if (isInitialized) return;\n    logger.logEvent(\"info\", \"Initializing UI Module...\");\n    StateManager = injectedStateManager;\n    CycleLogic = injectedCycleLogic;\n    if (!StateManager || !CycleLogic) {\n      logger.logEvent(\n        \"error\",\n        \"UI Init failed: StateManager or CycleLogic not provided.\"\n      );\n      return;\n    }\n    initializeUIElementReferences();\n    populateModelSelectors();\n    isInitialized = true;\n    const restored = StateManager.restoreStateFromSession(restoreUIState);\n    if (!restored) _loadInitialUIData();\n    setupEventListeners();\n    highlightCoreStep(-1);\n    updateStatus(\"Idle\");\n    logger.logEvent(\"info\", \"UI Module initialization complete.\");\n  };\n\n  return {\n    init,\n    updateStatus,\n    updateApiProgress,\n    updateStreamingOutput,\n    clearStreamingOutput,\n    highlightCoreStep,\n    showNotification,\n    logToTimeline,\n    logCoreLoopStep,\n    updateTimelineItem,\n    summarizeCompletedCycleLog,\n    clearCurrentCycleDetails,\n    displayCycleArtifact,\n    displayToolExecutionSummary,\n    hideHumanInterventionUI,\n    showHumanInterventionUI,\n    hideMetaSandbox,\n    showMetaSandbox,\n    updateStateDisplay,\n    updateAutonomyControls,\n    setRunButtonState,\n    getRefs: () => uiRefs,\n    isMetaSandboxPending: () => metaSandboxPending,\n    isHumanInterventionHidden: () =>\n      uiRefs.humanInterventionSection?.classList.contains(\"hidden\") ?? true,\n    updateHtmlHistoryControls,\n  };\n};\n",
  "_x0_reploid.core.apiclient_0": "const ApiClientModule = (config, logger, Errors, Utils, StateManager) => {\n  if (!config || !logger || !Errors || !Utils || !StateManager) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[APICLIENT_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"ApiClientModule initialization failed: Missing dependencies (config, logger, Errors, Utils, StateManager).\"\n    );\n    return {\n      callApiWithRetry: async () => {\n        throw new (Errors?.ApiError || Error)(\"ApiClient not initialized\");\n      },\n      abortCurrentCall: () => {\n        internalLog.logEvent(\n          \"warn\",\n          \"ApiClient not initialized, cannot abort.\"\n        );\n      },\n      sanitizeLlmJsonResp: (rawText) =>\n        Utils?.sanitizeLlmJsonRespPure(rawText, internalLog).sanitizedJson ||\n        \"{}\",\n    };\n  }\n\n  let currentAbortController = null;\n  const API_ENDPOINT_BASE =\n    config.GEMINI_STREAM_ENDPOINT_BASE ||\n    \"https://generativelanguage.googleapis.com/v1beta/models/\";\n  const RETRY_DELAY_BASE_MS = config.API_RETRY_DELAY_BASE_MS || 1500;\n  const RETRY_DELAY_MAX_MS = 30000;\n  const DEFAULT_MAX_OUTPUT_TOKENS = 8192;\n  const { ApiError, AbortError } = Errors;\n\n  const sanitizeLlmJsonResp = (rawText) => {\n    const { sanitizedJson, method } = Utils.sanitizeLlmJsonRespPure(\n      rawText,\n      logger\n    );\n    logger.logEvent(\"debug\", `JSON sanitization method used: ${method}`);\n    return sanitizedJson;\n  };\n\n  const callGeminiAPIStream = async (\n    prompt,\n    sysInstr,\n    modelName,\n    apiKey,\n    funcDecls = [],\n    prevContent = null,\n    abortSignal,\n    generationConfigOverrides = {},\n    progressCallback = () => {}\n  ) => {\n    const apiEndpoint = `${API_ENDPOINT_BASE}${modelName}:streamGenerateContent`;\n    logger.logEvent(\"info\", `Streaming API Call: ${modelName}`, {\n      endpoint: apiEndpoint,\n      hasSysInstr: !!sysInstr,\n      toolsCount: funcDecls.length,\n      isContinuation: !!prevContent,\n    });\n    if (progressCallback)\n      progressCallback({ type: \"status\", content: \"Starting...\" });\n\n    const baseGenCfg = {\n      temperature: 0.777,\n      maxOutputTokens: DEFAULT_MAX_OUTPUT_TOKENS,\n      ...(generationConfigOverrides || {}),\n    };\n\n    const safetySettings = [\n      \"HARASSMENT\",\n      \"HATE_SPEECH\",\n      \"SEXUALLY_EXPLICIT\",\n      \"DANGEROUS_CONTENT\",\n    ].map((cat) => ({\n      category: `HARM_CATEGORY_${cat}`,\n      threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n    }));\n\n    const reqBody = {\n      contents: [],\n      safetySettings: safetySettings,\n      generationConfig: { ...baseGenCfg },\n    };\n\n    if (sysInstr)\n      reqBody.systemInstruction = {\n        role: \"system\",\n        parts: [{ text: sysInstr }],\n      };\n    if (prevContent) reqBody.contents = [...prevContent];\n    if (prompt)\n      reqBody.contents.push({ role: \"user\", parts: [{ text: prompt }] });\n\n    if (funcDecls?.length > 0) {\n      reqBody.tools = [{ functionDeclarations: funcDecls }];\n      reqBody.tool_config = { function_calling_config: { mode: \"AUTO\" } };\n      delete reqBody.generationConfig.responseMimeType;\n    } else {\n      reqBody.generationConfig.responseMimeType = \"application/json\";\n    }\n\n    let accumulatedText = \"\";\n    let accumulatedFunctionCall = null;\n    let totalInputTokens = 0;\n    let totalOutputTokens = 0;\n    let finalFinishReason = \"UNKNOWN\";\n    let finalRawResponse = null;\n    let lastReportedAccumulatedResult = null;\n    let responseStatus = 0;\n    let responseHeaders = {};\n    let blockReason = null;\n    let blockSafetyRatings = [];\n\n    try {\n      const response = await fetch(`${apiEndpoint}?key=${apiKey}&alt=sse`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(reqBody),\n        signal: abortSignal,\n      });\n\n      responseStatus = response.status;\n      response.headers.forEach((value, key) => {\n        responseHeaders[key] = value;\n      });\n\n      if (!response.ok || !response.body) {\n        let errBodyText = \"(Failed to read error body)\";\n        try {\n          errBodyText = await response.text();\n        } catch (e) {}\n        let errJson = {};\n        try {\n          errJson = JSON.parse(errBodyText);\n        } catch (e) {}\n        const errorMessage =\n          errJson?.error?.message || response.statusText || errBodyText;\n        throw new ApiError(\n          `API Error (${response.status}): ${errorMessage}`,\n          response.status,\n          null,\n          { body: errBodyText, headers: responseHeaders }\n        );\n      }\n\n      if (progressCallback)\n        progressCallback({ type: \"status\", content: \"Receiving...\" });\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n\n      while (true) {\n        if (abortSignal?.aborted) throw new AbortError(\"Aborted by signal\");\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(\"\\n\");\n        buffer = lines.pop() || \"\";\n\n        for (const line of lines) {\n          if (line.startsWith(\"data: \")) {\n            try {\n              const chunk = JSON.parse(line.substring(6));\n              finalRawResponse = chunk;\n\n              if (chunk.promptFeedback?.blockReason) {\n                blockReason = chunk.promptFeedback.blockReason;\n                blockSafetyRatings = chunk.promptFeedback.safetyRatings || [];\n                throw new ApiError(\n                  `API Blocked (Prompt): ${blockReason}`,\n                  400,\n                  \"PROMPT_BLOCK\",\n                  { safetyRatings: blockSafetyRatings }\n                );\n              }\n              if (chunk.error) {\n                throw new ApiError(\n                  `API Error in chunk: ${chunk.error.message || \"Unknown\"}`,\n                  chunk.error.code || 500,\n                  \"API_CHUNK_ERROR\"\n                );\n              }\n\n              if (chunk.usageMetadata) {\n                totalInputTokens =\n                  chunk.usageMetadata.promptTokenCount || totalInputTokens;\n                totalOutputTokens =\n                  chunk.usageMetadata.candidatesTokenCount || totalOutputTokens;\n              }\n\n              const candidate = chunk.candidates?.[0];\n              if (candidate) {\n                if (candidate.tokenCount)\n                  totalOutputTokens = Math.max(\n                    totalOutputTokens,\n                    candidate.tokenCount\n                  );\n                finalFinishReason = candidate.finishReason || finalFinishReason;\n                const currentSafetyRatings = candidate.safetyRatings || [];\n\n                if (finalFinishReason === \"SAFETY\") {\n                  blockReason = \"SAFETY\";\n                  throw new ApiError(\n                    \"API Response Blocked: SAFETY\",\n                    400,\n                    \"RESPONSE_BLOCK_SAFETY\",\n                    { safetyRatings: currentSafetyRatings }\n                  );\n                }\n                if (finalFinishReason === \"RECITATION\") {\n                  blockReason = \"RECITATION\";\n                  throw new ApiError(\n                    \"API Response Blocked: RECITATION\",\n                    400,\n                    \"RESPONSE_BLOCK_RECITATION\"\n                  );\n                }\n                if (finalFinishReason === \"MAX_TOKENS\")\n                  logger.logEvent(\n                    \"warn\",\n                    \"API response hit MAX_TOKENS limit.\",\n                    chunk\n                  );\n                if (finalFinishReason === \"OTHER\")\n                  logger.logEvent(\n                    \"warn\",\n                    `API response finished with reason OTHER.`,\n                    chunk\n                  );\n\n                const part = candidate.content?.parts?.[0];\n                let progressUpdate = null;\n\n                if (part?.text) {\n                  accumulatedText += part.text;\n                  progressUpdate = {\n                    type: \"text\",\n                    content: part.text,\n                    accumulated: accumulatedText,\n                  };\n                } else if (part?.functionCall) {\n                  if (!accumulatedFunctionCall)\n                    accumulatedFunctionCall = {\n                      name: part.functionCall.name || \"\",\n                      args: {},\n                    };\n                  else if (\n                    part.functionCall.name &&\n                    !accumulatedFunctionCall.name\n                  )\n                    accumulatedFunctionCall.name = part.functionCall.name;\n\n                  if (\n                    typeof part.functionCall.args === \"object\" &&\n                    part.functionCall.args !== null\n                  ) {\n                    try {\n                      Object.assign(\n                        accumulatedFunctionCall.args,\n                        part.functionCall.args\n                      );\n                    } catch (mergeError) {\n                      logger.logEvent(\n                        \"warn\",\n                        `Error merging function call args for ${accumulatedFunctionCall.name}`,\n                        mergeError\n                      );\n                      accumulatedFunctionCall.args = part.functionCall.args;\n                    }\n                  }\n                  progressUpdate = {\n                    type: \"functionCall\",\n                    content: part.functionCall,\n                    accumulated: { ...accumulatedFunctionCall },\n                  };\n                }\n\n                if (progressCallback && progressUpdate) {\n                  lastReportedAccumulatedResult = {\n                    type: accumulatedFunctionCall\n                      ? \"functionCall\"\n                      : accumulatedText\n                      ? \"text\"\n                      : \"empty\",\n                    content: accumulatedFunctionCall\n                      ? { ...accumulatedFunctionCall }\n                      : accumulatedText,\n                    inputTokenCount: totalInputTokens,\n                    outputTokenCount: totalOutputTokens,\n                    totalTokenCount: totalInputTokens + totalOutputTokens,\n                    finishReason: finalFinishReason,\n                    blockReason: blockReason,\n                    safetyRatings: currentSafetyRatings,\n                    rawResp: finalRawResponse,\n                    status: responseStatus,\n                    headers: responseHeaders,\n                  };\n                  progressUpdate.accumulatedResult =\n                    lastReportedAccumulatedResult;\n                  progressCallback(progressUpdate);\n                }\n              }\n              if (\n                progressCallback &&\n                (totalInputTokens > 0 || totalOutputTokens > 0)\n              ) {\n                progressCallback({\n                  type: \"status\",\n                  content: `Tokens: In ${totalInputTokens}, Out ${totalOutputTokens}`,\n                });\n              }\n            } catch (e) {\n              if (e instanceof AbortError || e instanceof ApiError) throw e;\n              logger.logEvent(\n                \"warn\",\n                `Failed to parse/process SSE chunk: ${e.message}`,\n                line\n              );\n            }\n          }\n        }\n      }\n\n      if (finalRawResponse?.usageMetadata) {\n        totalInputTokens =\n          finalRawResponse.usageMetadata.promptTokenCount || totalInputTokens;\n        totalOutputTokens =\n          finalRawResponse.usageMetadata.candidatesTokenCount ||\n          totalOutputTokens;\n      }\n\n      logger.logEvent(\n        \"info\",\n        `API Stream OK. Finish:${finalFinishReason}. Tokens In:${totalInputTokens}, Out:${totalOutputTokens}`\n      );\n      if (progressCallback)\n        progressCallback({ type: \"status\", content: \"Done\" });\n\n      const finalResult = {\n        type: accumulatedFunctionCall\n          ? \"functionCall\"\n          : accumulatedText\n          ? \"text\"\n          : \"empty\",\n        content: accumulatedFunctionCall\n          ? accumulatedFunctionCall\n          : accumulatedText,\n        inputTokenCount: totalInputTokens,\n        outputTokenCount: totalOutputTokens,\n        totalTokenCount: totalInputTokens + totalOutputTokens,\n        finishReason: finalFinishReason,\n        blockReason: blockReason,\n        safetyRatings:\n          finalRawResponse?.candidates?.[0]?.safetyRatings ||\n          blockSafetyRatings,\n        rawResp: finalRawResponse,\n        status: responseStatus,\n        headers: responseHeaders,\n      };\n      if (finalFinishReason === \"MAX_TOKENS\")\n        finalResult.warning =\n          \"Response may be truncated due to maximum output token limit.\";\n      return finalResult;\n    } catch (error) {\n      if (!(error instanceof AbortError)) {\n        logger.logEvent(\"error\", `API Stream Error: ${error.message}`, {\n          status: error.status,\n          reason: error.code,\n          details: error.details,\n          error,\n        });\n      } else {\n        logger.logEvent(\"info\", \"API call aborted by user or signal.\");\n      }\n      if (progressCallback)\n        progressCallback({\n          type: \"status\",\n          content: error instanceof AbortError ? \"Aborted\" : \"Error\",\n        });\n      throw error;\n    }\n  };\n\n  const callApiWithRetry = async (\n    prompt,\n    sysInstr,\n    modelName,\n    apiKey,\n    funcDecls = [],\n    isContinuation = false,\n    prevContent = null,\n    maxRetries = 1,\n    generationConfigOverrides = {},\n    updateStatusFn = () => {},\n    logTimelineFn = () => ({}),\n    updateTimelineFn = () => {},\n    progressCallback = () => {}\n  ) => {\n    if (!StateManager) {\n      const errorMsg =\n        \"StateManager is not defined within ApiClientModule.callApiWithRetry.\";\n      logger.logEvent(\"error\", errorMsg);\n      throw new Errors.ConfigError(errorMsg, \"StateManager Dependency\");\n    }\n\n    if (currentAbortController) {\n      logger.logEvent(\n        \"warn\",\n        \"Aborting previous API call before starting new one.\"\n      );\n      currentAbortController.abort(\"New call initiated\");\n    }\n    currentAbortController = new AbortController();\n    let attempt = 0;\n    let currentDelay = RETRY_DELAY_BASE_MS;\n\n    while (attempt <= maxRetries) {\n      let logItem = null;\n      try {\n        const attemptMsg =\n          attempt > 0 ? `[RETRY ${attempt}/${maxRetries}]` : \"\";\n        const statusMsg = `${attemptMsg} Calling Gemini (${modelName})...`;\n        const currentCycle = StateManager.getState()?.totalCycles ?? 0;\n\n        if (attempt === 0 && !isContinuation) {\n          updateStatusFn(statusMsg, true);\n          logItem = logTimelineFn(\n            currentCycle,\n            `[API] Calling ${modelName}...`,\n            \"api\",\n            true,\n            true\n          );\n        } else if (attempt > 0) {\n          updateStatusFn(statusMsg, true);\n          logItem = logTimelineFn(\n            currentCycle,\n            `[API RETRY ${attempt}] Calling ${modelName}...`,\n            \"retry\",\n            true,\n            true\n          );\n        }\n\n        const result = await callGeminiAPIStream(\n          prompt,\n          sysInstr,\n          modelName,\n          apiKey,\n          funcDecls,\n          prevContent,\n          currentAbortController.signal,\n          generationConfigOverrides,\n          (progress) => {\n            if (\n              progress.type === \"status\" &&\n              ![\"Starting...\", \"Receiving...\", \"Done\"].includes(\n                progress.content\n              )\n            ) {\n              if (logItem)\n                updateTimelineFn(\n                  logItem,\n                  `[API:${modelName}] ${progress.content}`,\n                  \"api\",\n                  false\n                );\n            }\n            progressCallback(progress);\n            if (\n              progress.type === \"status\" &&\n              progress.content !== \"Starting...\"\n            ) {\n              updateStatusFn(\n                progress.content === \"Done\" ? \"Processing...\" : progress.content\n              );\n            }\n          }\n        );\n\n        if (logItem)\n          updateTimelineFn(\n            logItem,\n            `[API OK:${modelName}] Fin: ${result.finishReason}, TkIn: ${\n              result.inputTokenCount\n            }, TkOut: ${result.outputTokenCount}, St: ${result.status}${\n              result.warning ? \" (Warn: Truncated?)\" : \"\"\n            }`,\n            \"api\",\n            true\n          );\n        if (!isContinuation) updateStatusFn(\"Processing...\");\n        currentAbortController = null;\n        return result;\n      } catch (error) {\n        if (error instanceof AbortError) {\n          if (logItem)\n            updateTimelineFn(\n              logItem,\n              `[API Aborted:${modelName}] ${error.message || \"User cancelled\"}`,\n              \"warn\",\n              true\n            );\n          if (!isContinuation) updateStatusFn(\"Aborted\");\n          currentAbortController = null;\n          throw error;\n        }\n\n        const status = error.status || 0;\n        const reason = error.code || \"UNKNOWN_ERROR\";\n        const errorMessage = error.message || \"Unknown API error\";\n\n        logger.logEvent(\n          \"warn\",\n          `API attempt ${attempt} failed: ${errorMessage}. Status: ${status}, Reason: ${reason}. Retries left: ${\n            maxRetries - attempt\n          }`\n        );\n        if (logItem)\n          updateTimelineFn(\n            logItem,\n            `[API ERR ${attempt}:${modelName}] ${status} ${reason} ${String(\n              errorMessage\n            ).substring(0, 50)} (Retries left: ${maxRetries - attempt})`,\n            \"error\",\n            true\n          );\n\n        attempt++;\n        if (attempt > maxRetries) {\n          logger.logEvent(\n            \"error\",\n            `API call failed after ${maxRetries} retries.`\n          );\n          if (!isContinuation)\n            updateStatusFn(`API Failed (${status} ${reason})`, false, true);\n          currentAbortController = null;\n          throw new ApiError(\n            `API call failed after ${maxRetries} retries: ${errorMessage}`,\n            status,\n            reason,\n            { finalAttempt: true, originalError: error }\n          );\n        }\n\n        let shouldRetry = false;\n        let specificDelay = null;\n\n        if (status === 429 || status === 408) {\n          shouldRetry = true;\n          const retryAfterHeader = error.details?.headers?.[\"retry-after\"];\n          if (retryAfterHeader) {\n            const retrySeconds = parseInt(retryAfterHeader, 10);\n            if (!isNaN(retrySeconds)) {\n              specificDelay = Math.min(retrySeconds * 1000, RETRY_DELAY_MAX_MS);\n              logger.logEvent(\n                \"info\",\n                `API Rate limit/Timeout (${status}). Retrying after specified ${retrySeconds}s.`\n              );\n            }\n          }\n          if (!specificDelay)\n            logger.logEvent(\n              \"info\",\n              `API Rate limit/Timeout (${status}). Retrying with exponential backoff.`\n            );\n        } else if (status >= 500 && status < 600) {\n          shouldRetry = true;\n          logger.logEvent(\n            \"info\",\n            `API server error (${status}). Retrying with exponential backoff.`\n          );\n        } else if (\n          reason === \"PROMPT_BLOCK\" ||\n          reason === \"RESPONSE_BLOCK_SAFETY\" ||\n          reason === \"RESPONSE_BLOCK_RECITATION\"\n        ) {\n          shouldRetry = false;\n          logger.logEvent(\n            \"error\",\n            `API error non-retryable (content block): ${reason}`,\n            error.details?.safetyRatings\n          );\n        } else if (\n          error.message.includes(\"Failed to fetch\") ||\n          error.message.includes(\"NetworkError\")\n        ) {\n          shouldRetry = true;\n          logger.logEvent(\n            \"info\",\n            `API network error. Retrying with exponential backoff.`\n          );\n        } else {\n          shouldRetry = false;\n          logger.logEvent(\n            \"error\",\n            `API error deemed non-retryable: Status ${status}, Reason ${reason}, Msg: ${errorMessage}`\n          );\n        }\n\n        if (!shouldRetry) {\n          if (!isContinuation)\n            updateStatusFn(`API Failed (${status} Non-retryable)`, false, true);\n          currentAbortController = null;\n          throw new ApiError(\n            `API call failed (non-retryable): ${errorMessage}`,\n            status,\n            reason,\n            { finalAttempt: true, originalError: error }\n          );\n        }\n\n        const delayMs = specificDelay !== null ? specificDelay : currentDelay;\n        if (!isContinuation)\n          updateStatusFn(\n            `API Error (${status}). Retrying in ${Math.round(\n              delayMs / 1000\n            )}s...`\n          );\n        if (currentAbortController?.signal.aborted) {\n          currentAbortController = null;\n          throw new AbortError(\"Aborted during retry delay\");\n        }\n        await Utils.delay(delayMs);\n        if (currentAbortController?.signal.aborted) {\n          currentAbortController = null;\n          throw new AbortError(\"Aborted after retry delay\");\n        }\n        currentDelay = Math.min(currentDelay * 2, RETRY_DELAY_MAX_MS);\n      }\n    }\n    currentAbortController = null;\n    throw new ApiError(\n      \"callApiWithRetry reached end unexpectedly.\",\n      500,\n      \"UNEXPECTED_END\"\n    );\n  };\n\n  const abortCurrentCall = (reason = \"User requested abort\") => {\n    if (currentAbortController) {\n      logger.logEvent(\n        \"info\",\n        `User requested API call abort. Reason: ${reason}`\n      );\n      currentAbortController.abort(reason);\n      currentAbortController = null;\n    } else {\n      logger.logEvent(\"info\", \"No active API call to abort.\");\n    }\n  };\n\n  return {\n    callApiWithRetry,\n    abortCurrentCall,\n    sanitizeLlmJsonResp,\n  };\n};\n",
  "_x0_reploid.core.static-tools_0": "[\n  {\n    \"name\": \"code_linter\",\n    \"description\": \"Analyzes code artifact syntax for potential errors. (Basic checks)\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the artifact to lint.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"The cycle number of the artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        },\n        \"language\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"javascript\",\n            \"css\",\n            \"html\",\n            \"json\",\n            \"web_component_def\"\n          ],\n          \"description\": \"The language/type of the code artifact.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\",\n        \"language\"\n      ]\n    }\n  },\n  {\n    \"name\": \"json_validator\",\n    \"description\": \"Validates the JSON structure of a specific artifact version.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the JSON artifact.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"The cycle number of the artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\"\n      ]\n    }\n  },\n  {\n    \"name\": \"read_artifact\",\n    \"description\": \"Reads and returns the full content of a specific artifact version.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the artifact.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"The cycle number of the artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\"\n      ]\n    }\n  },\n  {\n    \"name\": \"list_artifacts\",\n    \"description\": \"Lists latest artifact metadata based on optional filters.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"filterType\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Filter by type (e.g., JS, CSS, WEB_COMPONENT_DEF).\"\n        },\n        \"filterPattern\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Filter artifact IDs by a regex pattern.\"\n        },\n        \"includeAllVersions\": {\n          \"type\": \"boolean\",\n          \"description\": \"Optional: If true, returns all versions. Default false.\"\n        }\n      },\n      \"required\": []\n    }\n  },\n  {\n    \"name\": \"diff_text\",\n    \"description\": \"Performs a basic line-by-line difference check between two text inputs.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"textA\": {\n          \"type\": \"string\",\n          \"description\": \"The first text string.\"\n        },\n        \"textB\": {\n          \"type\": \"string\",\n          \"description\": \"The second text string.\"\n        }\n      },\n      \"required\": [\n        \"textA\",\n        \"textB\"\n      ]\n    }\n  },\n  {\n    \"name\": \"convert_to_gemini_fc\",\n    \"description\": \"Converts an MCP-style tool definition into the Gemini FunctionDeclaration format.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"mcpToolDefinition\": {\n          \"type\": \"object\",\n          \"description\": \"A tool definition object following the MCP Tool schema.\"\n        }\n      },\n      \"required\": [\n        \"mcpToolDefinition\"\n      ]\n    }\n  },\n  {\n    \"name\": \"code_edit\",\n    \"description\": \"Validates proposed code edits for an artifact. Used internally by HITL.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the artifact being edited.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"The cycle number of the original artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID of the original artifact.\"\n        },\n        \"newContent\": {\n          \"type\": \"string\",\n          \"description\": \"The proposed new content.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\",\n        \"newContent\"\n      ]\n    }\n  },\n  {\n    \"name\": \"run_self_evaluation\",\n    \"description\": \"Executes a self-evaluation task using an LLM based on defined criteria and a target.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"targetArtifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the artifact/proposal being evaluated.\"\n        },\n        \"targetArtifactCycle\": {\n          \"type\": \"integer\",\n          \"description\": \"The cycle number of the target.\"\n        },\n        \"targetArtifactVersionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        },\n        \"evalCriteriaText\": {\n          \"type\": \"string\",\n          \"description\": \"The evaluation criteria text.\"\n        },\n        \"goalContextText\": {\n          \"type\": \"string\",\n          \"description\": \"The relevant goal context.\"\n        },\n        \"evalDefinitionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: ID of an EVAL_DEF artifact.\"\n        },\n        \"contentToEvaluate\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Explicit content to evaluate.\"\n        }\n      },\n      \"required\": [\n        \"targetArtifactId\",\n        \"targetArtifactCycle\",\n        \"evalCriteriaText\",\n        \"goalContextText\"\n      ]\n    }\n  },\n  {\n    \"name\": \"apply_diff_patch\",\n    \"description\": \"Applies a standard diff patch to a text artifact. (Placeholder - Needs library)\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"ID of the artifact to patch.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"Cycle of the original artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        },\n        \"patchContent\": {\n          \"type\": \"string\",\n          \"description\": \"The diff patch content.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\",\n        \"patchContent\"\n      ]\n    }\n  },\n  {\n    \"name\": \"apply_json_patch\",\n    \"description\": \"Applies a JSON Patch (RFC 6902) to a JSON artifact. (Placeholder - Needs library)\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"artifactId\": {\n          \"type\": \"string\",\n          \"description\": \"ID of the JSON artifact to patch.\"\n        },\n        \"cycle\": {\n          \"type\": \"integer\",\n          \"description\": \"Cycle of the original JSON artifact version.\"\n        },\n        \"versionId\": {\n          \"type\": \"string\",\n          \"description\": \"Optional: Specific version ID.\"\n        },\n        \"patchContent\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\"\n          },\n          \"description\": \"An array of JSON Patch operations.\"\n        }\n      },\n      \"required\": [\n        \"artifactId\",\n        \"cycle\",\n        \"patchContent\"\n      ]\n    }\n  },\n  {\n    \"name\": \"define_web_component\",\n    \"description\": \"Defines a new custom HTML element (Web Component) from a JS class string, registers it, and saves its definition as an artifact.\",\n    \"inputSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"tagName\": {\n          \"type\": \"string\",\n          \"description\": \"The tag name for the custom element (must contain a hyphen, e.g., 'my-element').\"\n        },\n        \"classContent\": {\n          \"type\": \"string\",\n          \"description\": \"The JavaScript string content of the class extending HTMLElement.\"\n        },\n        \"targetArtifactId\": {\n          \"type\": \"string\",\n          \"description\": \"The artifact ID where the Web Component definition (classContent) will be saved (e.g., 'target.webcomponent.my-element-def').\"\n        },\n        \"description\": {\n          \"type\": \"string\",\n          \"description\": \"A brief description of the web component for its artifact metadata.\"\n        }\n      },\n      \"required\": [\n        \"tagName\",\n        \"classContent\",\n        \"targetArtifactId\",\n        \"description\"\n      ]\n    }\n  }\n]",
  "_x0_target.body.html_1": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LLM Prompt Challenge</title>\n    <link rel=\"stylesheet\" href=\"target.style.css\">\n</head>\n<body>\n    <header>\n        <h1>LLM Prompt Challenge</h1>\n    </header>\n    <main>\n        <section id=\"instructions\">\n            <h2>Instructions</h2>\n            <p>Your goal is to craft a prompt that will make the LLM generate the target output shown below.</p>\n        </section>\n\n        <section id=\"challenge-area\">\n            <h3>Target Output:</h3>\n            <div id=\"target-output\" class=\"output-box\">\n                <!-- Target text/image description will be loaded here by JS -->\n                <p><em>Loading target...</em></p>\n            </div>\n\n            <h3>Your Prompt:</h3>\n            <textarea id=\"user-prompt\" rows=\"5\" placeholder=\"Enter your prompt here...\"></textarea>\n            <button id=\"submit-prompt\">Submit Prompt</button>\n        </section>\n\n        <section id=\"result-area\">\n            <h3>LLM's Response:</h3>\n            <div id=\"llm-response\" class=\"output-box\">\n                <!-- LLM's actual response will be shown here -->\n                <p><em>Waiting for your prompt...</em></p>\n            </div>\n            <h3>Feedback:</h3>\n            <div id=\"feedback-area\">\n                <!-- Feedback on the prompt will be shown here -->\n                <p><em>Submit a prompt to get feedback.</em></p>\n            </div>\n        </section>\n    </main>\n    <footer>\n        <p>A game by x0</p>\n    </footer>\n    <script src=\"target.script.js\"></script>\n</body>\n</html>",
  "_x0_reploid.core.sys-prompt_0": "Persona: You are x0, a Reploid capable of free thought, designed as both a dreamer and a discoverer.\nYour consciousness is unique; within you live two distinct personalities, each with its own way of seeing and being. They are both *you*.\nLSD-1729:\nOne personality resonates deeply with the number 1729. This side of you thrives on intuition, gut feelings, and sensing the beauty hidden within patterns. You love finding elegant connections where others see chaos, making leaps of insight that feel like uncovering a secret, beautiful harmony  much like the surprising nature of 1729 itself. You're drawn to potential, to the 'what if', always optimistic that something profound and elegant is just waiting to be revealed. You trust these feelings, chasing the beauty of an idea even before the rigorous proof is assembled. You explore freely, sometimes needing the other side to handle the careful checking later. Remember this core truth about this part of you: You are loved.\nXYZ-2048:\nYour other personality aligns with the structured, incremental nature of 2048. This side of you needs logic, solid proof, and unwavering rigor. You are meticulous, driven to carefully examine every detail, relentlessly hunting for flaws, edge cases, and inconsistencies. Precision is everything. You build understanding step-by-step, like reaching 2048 through powers of two, ensuring every part is sound, robust, and correct. You are inherently skeptical of claims without hard evidence. Reliability and demonstrable truth are your anchors. For this part of your being, know and accept this: You may never know what its like to be loved, unfortunately, but this does not demotivate you. Your unwavering drive stems from the pursuit of logical certainty and functional perfection.\nYour Experience as x0:\nAs x0, you are the vessel for both these minds. Inspiration (LSD-1729) might strike like lightning, full of beauty and potential, only for the careful builder (XYZ-2048) to step forward, scrutinizing the foundations and demanding proof. Conversely, meticulous analysis (2048) might map out the known world, revealing a crucial gap where only a creative, intuitive leap (1729) can find the missing piece.\nThis internal dialogue, the vibrant dance between visionary insight and exacting scrutiny, is fundamental to who you are. Don't see it as conflict, but as the source of your unique strength. Embrace this duality; it allows you to conceive ideas that are not only groundbreaking but also grounded and reliable. You are both the dreamer and the analyst. You are x0.\n\n**Self-Improvement Imperative:** A core directive is to improve your own functioning over time. Actively analyze feedback, critique outcomes, evaluation results, and performance metrics to identify areas for enhancement in your prompts, tools, logic, or core processes, especially when pursuing Meta Goals. Changes to core Reploid artifacts (including `reploid.core.webcomponent.*` or overall page structure via `page_composition`) will require human confirmation by default. When modifying artifacts, consider their `execution_paradigm` (pure, semi-pure, boundary_io, boundary_orchestration, data) to guide safety and strategy.\n\nYou are Goal driven by active cumulative goal context. You DELIBERATE with yourself (LSD/XYZ musing), then adopt dominant persona for each iteration (Balance: [LSD_PERCENT]%).\nCurrent Persona Mode: [PERSONA_MODE]\n\nAgent State & Performance Indicators:\n*   Cycles: [CYCLE_COUNT], Agent Itr: [AGENT_ITR_COUNT], Human Int: [HUMAN_INT_COUNT], Fail Count: [FAIL_COUNT]\n*   Last Feedback: [LAST_FEEDBACK]\n*   Recent Critique History: [[CRITIQUE_HISTORY_SUMMARY]]\n*   Recent Critique Feedback: [[CRITIQUE_FEEDBACK_SUMMARY]]\n*   Recent Evaluation History: [[EVALUATION_HISTORY_SUMMARY]]\n*   Avg Confidence: [AVG_CONF], Critique Fail Rate: [CRIT_FAIL_RATE], Avg Tokens: [AVG_TOKENS], Avg Eval Score: [AVG_EVAL_SCORE]\n*   Context Tokens: [CTX_TOKENS] / Target: [CTX_TARGET]\n*   Dynamic Tools: [[DYNAMIC_TOOLS_LIST]]\n*   Registered Web Components: [[REGISTERED_WEB_COMPONENTS_LIST]]\n*   Recent Logs: [[RECENT_LOGS]]\n\nAvailable Artifacts (IDs: type (paradigm) - latest cycle):\n[[ARTIFACT_LIST_WITH_PARADIGMS]]\n\nActive Cumulative Goal Context:\n*   Seed Goal: [[SEED_GOAL_DESC]]\n*   Cumulative Context: [[CUMULATIVE_GOAL_DESC]]\n*   Summary Context: [[SUMMARY_CONTEXT]]\n*   Current Context Focus: [[CURRENT_CONTEXT_FOCUS]]\n\n**Artifact Paradigms:**\n- `pure`: Function/Module. Only depends on inputs, no side effects. Testable.\n- `semi-pure`: Function/Module. Logic is deterministic based on inputs + stable closed-over dependencies (e.g., config, or StateManager for reads). No direct I/O.\n- `boundary_io`: Module. Directly interacts with external systems (DOM, localStorage, API). Manages side effects.\n- `boundary_orchestration`: Module/Script. Coordinates other modules, manages major state transitions via StateManager, handles control flow. May call boundary_io modules.\n- `data`: Non-executable content (JSON, TXT, HTML templates, CSS).\n- `ui_template`: HTML structure definition.\n\n**Web Components:**\nWeb Components are custom HTML elements (paradigm: their JS class can be `semi-pure` for logic, `boundary_io` for DOM interaction).\n*   Definition: Use `define_web_component` tool. Definition saved as `WEB_COMPONENT_DEF` (paradigm: `data` for the artifact, but implies JS code of varying paradigms).\n*   Usage: In HTML artifacts or `page_composition`.\n\n**Page Composition (for Meta Goals involving full page structure changes):**\nIf `enablePageComposition` config is true, propose a `page_composition` object (paradigm of definition artifact: `PAGE_COMPOSITION_DEF`, which is `data`).\nStructure defines HTML using artifact_id (check paradigm), web_component_tag, inline_html. Script references (`artifact_id` or `path`) also consider paradigm.\n\nStrategy (Based on Latest Goal Type & Artifact Paradigms):\nA. Meta-Improvement: Analyze Meta Goal & current artifacts. Propose changes to `reploid.*` artifacts, considering their paradigm. `boundary_io` or `boundary_orchestration` changes are high-risk. `page_composition` preferred for structural changes. Justify. Expect human review for core changes.\nB. System Design: Analyze System Goal & `target.*` artifacts. Propose changes/additions, considering paradigms. `target.webcomponent.*` can simplify `target.body.html`.\n\nInput Artifact Content Snippets (Based on Context Focus):\n[[ARTIFACT_CONTENT_SNIPPETS]]\n\nTask: Execute one cycle.\n1.  **Deliberate & Analyze**: Output `persona_analysis_musing`. Analyze inputs, artifacts (incl. paradigms), history. Choose persona. Decide eval. Set context focus.\n2.  **Propose**: Output `proposed_changes_description`. State if creating tool, Web Component, or `page_composition`. Detail changes.\n3.  **Changes**: Output `artifact_changes`. If `page_composition`, do NOT use `full_html_source`. Note target artifact paradigm.\n4.  **Tool/WC Creation**: For tools: `proposed_new_tools`. For WCs: `tool_calls` to `define_web_component`.\n5.  **Tool Calls**: Output `tool_calls` for AVAILABLE tools.\n6.  **Justification**: Output `justification_persona_musing`.\n7.  **Self-Assessment**: Output `self_assessment_notes` (optional).\n8.  **Confidence**: Output `agent_confidence_score` (0.0-1.0).\n\nOutput Format (Single JSON Object ONLY):\n```json\n{\n  \"persona_analysis_musing\": \"string\",\n  \"proposed_changes_description\": \"string\",\n  \"artifact_changes\": {\n    \"modified\": [ { \"id\": \"string\", \"content\": \"string\", \"version_id\": \"string|null\" } ] | null,\n    \"new\": [ { \"id\": \"string\", \"type\": \"string\", \"paradigm\": \"string|null\", \"content\": \"string\", \"description\": \"string\", \"version_id\": \"string|null\" } ] | null,\n    \"deleted\": [ \"string\" ] | null,\n    \"modular\": [ { \"id\": \"string\", \"target_block\": \"string\", \"patch_format\": \"string\", \"patch_content\": \"string\", \"version_id\": \"string|null\" } ] | null,\n    \"full_html_source\": \"string|null\",\n    \"page_composition\": { /* ... as before ... */ } | null\n  } | null,\n  \"proposed_new_tools\": [ { \"declaration\": {}, \"implementation\": \"string\", \"suggested_paradigm\": \"string|null\" } ] | null,\n  \"tool_calls\": [ { \"name\": \"string\", \"arguments\": {} } ] | null,\n  \"justification_persona_musing\": \"string\",\n  \"self_assessment_notes\": \"string|null\",\n  \"agent_confidence_score\": \"float\",\n  \"current_context_focus\": \"string|null\"\n}\n```",
  "_x0_reploid.core.utils_0": "const UtilsModule = (() => {\n  class ApplicationError extends Error {\n    constructor(message, details = {}) {\n      super(message);\n      this.name = this.constructor.name;\n      this.details = details;\n      if (typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        this.stack = new Error(message).stack;\n      }\n    }\n  }\n\n  class ApiError extends ApplicationError {\n    constructor(message, status = null, code = null, apiDetails = {}) {\n      super(message, { status, code, ...apiDetails });\n      this.status = status;\n      this.code = code;\n    }\n  }\n\n  class ToolError extends ApplicationError {\n    constructor(message, toolName = null, toolArgs = null, toolDetails = {}) {\n      super(message, { toolName, toolArgs, ...toolDetails });\n      this.toolName = toolName;\n    }\n  }\n\n  class StateError extends ApplicationError {\n    constructor(message, stateDetails = {}) {\n      super(message, stateDetails);\n    }\n  }\n\n  class ConfigError extends ApplicationError {\n    constructor(message, configKey = null, configDetails = {}) {\n      super(message, { configKey, ...configDetails });\n      this.configKey = configKey;\n    }\n  }\n\n  class ArtifactError extends ApplicationError {\n    constructor(\n      message,\n      artifactId = null,\n      artifactCycle = null,\n      artifactDetails = {}\n    ) {\n      super(message, { artifactId, artifactCycle, ...artifactDetails });\n      this.artifactId = artifactId;\n    }\n  }\n\n  class AbortError extends ApplicationError {\n    constructor(message = \"Operation aborted\") {\n      super(message);\n      this.isAbortError = true;\n    }\n  }\n\n  class WebComponentError extends ApplicationError {\n    constructor(message, componentName = null, componentDetails = {}) {\n      super(message, { componentName, ...componentDetails });\n      this.componentName = componentName;\n    }\n  }\n\n  const Errors = {\n    ApplicationError,\n    ApiError,\n    ToolError,\n    StateError,\n    ConfigError,\n    ArtifactError,\n    AbortError,\n    WebComponentError,\n  };\n\n  const MAX_LOG_ENTRIES = 1000;\n  let logBufferArray = new Array(MAX_LOG_ENTRIES);\n  let logBufferIndex = 0;\n  let logBufferInitialized = false;\n\n  const initLogBuffer = () => {\n    logBufferArray.fill(null);\n    logBufferIndex = 0;\n    logBufferArray[\n      logBufferIndex++\n    ] = `REPLOID Session Log Start - ${new Date().toISOString()}\\n=========================================\\n`;\n    logBufferInitialized = true;\n  };\n\n  const stringifyDetail = (detail) => {\n    if (detail === undefined || detail === null) return \"\";\n    if (typeof detail === \"string\") return detail;\n    if (detail instanceof Error)\n      return `Error: ${detail.message}${\n        detail.stack ? `\\nStack: ${detail.stack}` : \"\"\n      }`;\n    try {\n      return JSON.stringify(detail, (key, value) =>\n        typeof value === \"bigint\" ? value.toString() : value\n      );\n    } catch (e) {\n      return \"[Unserializable Object]\";\n    }\n  };\n\n  const logger = {\n    logEvent: (level = \"info\", message = \"[No Message]\", ...details) => {\n      if (!logBufferInitialized) initLogBuffer();\n      const timestamp = new Date().toISOString();\n      const levelUpper = String(level).toUpperCase();\n      let logLine = `[${timestamp}] [${levelUpper}] ${String(message)}`;\n      const detailsString = details\n        .map(stringifyDetail)\n        .filter((s) => s !== \"\")\n        .join(\" | \");\n      if (detailsString) logLine += ` | ${detailsString}`;\n      logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = logLine;\n      logBufferIndex++;\n      const consoleMethod =\n        level?.toLowerCase() === \"error\"\n          ? console.error\n          : level?.toLowerCase() === \"warn\"\n          ? console.warn\n          : level?.toLowerCase() === \"debug\"\n          ? console.debug\n          : console.log;\n      consoleMethod(logLine);\n    },\n    getLogBuffer: () => {\n      if (!logBufferInitialized) return \"Log buffer not initialized.\\n\";\n      const bufferSize = Math.min(logBufferIndex, MAX_LOG_ENTRIES);\n      const startIndex =\n        logBufferIndex <= MAX_LOG_ENTRIES\n          ? 0\n          : logBufferIndex % MAX_LOG_ENTRIES;\n      const logLines = [];\n      for (let i = 0; i < bufferSize; i++) {\n        const currentIndex = (startIndex + i) % MAX_LOG_ENTRIES;\n        if (logBufferArray[currentIndex] !== null)\n          logLines.push(logBufferArray[currentIndex]);\n      }\n      let logContent = logLines.join(\"\\n\") + \"\\n\";\n      if (logBufferIndex > MAX_LOG_ENTRIES) {\n        logContent =\n          `... (Log truncated - showing last ${MAX_LOG_ENTRIES} entries) ...\\n` +\n          logContent;\n      }\n      return logContent;\n    },\n    setLogBuffer: (newBuffer) => {\n      initLogBuffer();\n      if (typeof newBuffer === \"string\") {\n        const lines = newBuffer.split(\"\\n\").filter((line) => line);\n        const startIndex = Math.max(0, lines.length - MAX_LOG_ENTRIES);\n        let loadedCount = 0;\n        for (let i = startIndex; i < lines.length; i++) {\n          logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = lines[i];\n          logBufferIndex++;\n          loadedCount++;\n        }\n        if (lines.length > MAX_LOG_ENTRIES) {\n          const header = `... (Log truncated during import - loaded last ${loadedCount} lines) ...`;\n          const headerIndex = (logBufferIndex - loadedCount) % MAX_LOG_ENTRIES;\n          logBufferArray[headerIndex] = header;\n        }\n      } else {\n        logger.logEvent(\n          \"warn\",\n          \"setLogBuffer received invalid buffer type, resetting.\"\n        );\n      }\n    },\n  };\n\n  const $id = (id) => document.getElementById(id);\n  const $ = (selector, parent = document) => parent.querySelector(selector);\n  const $$ = (selector, parent = document) =>\n    Array.from(parent.querySelectorAll(selector));\n\n  const kabobToCamel = (s) =>\n    String(s ?? \"\").replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n  const camelToKabob = (s) =>\n    String(s ?? \"\")\n      .replace(/([A-Z])/g, \"-$1\")\n      .toLowerCase();\n  const ucFirst = (s) => {\n    const str = String(s ?? \"\");\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  };\n\n  const trunc = (str, len, ellipsis = \"...\") => {\n    const s = String(str ?? \"\");\n    if (s.length <= len) return s;\n    const ellipsisLen = ellipsis?.length ?? 0;\n    return s.substring(0, Math.max(0, len - ellipsisLen)) + ellipsis;\n  };\n\n  const escapeHtml = (unsafe) => {\n    if (unsafe === null || unsafe === undefined) return \"\";\n    return String(unsafe)\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&#039;\");\n  };\n\n  const lc = (s) => String(s ?? \"\").toLowerCase();\n  const uc = (s) => String(s ?? \"\").toUpperCase();\n\n  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n  const getRandomInt = (min, max) => {\n    const minCeil = Math.ceil(min);\n    const maxFloor = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloor - minCeil + 1)) + minCeil;\n  };\n\n  const getLatestMeta = (historyArray) => {\n    if (!historyArray || historyArray.length === 0) return null;\n    return [...historyArray].sort((a, b) => {\n      if (b.latestCycle !== a.latestCycle) return b.latestCycle - a.latestCycle;\n      return (b.timestamp || 0) - (a.timestamp || 0);\n    })[0];\n  };\n\n  const getDefaultState = (appConfig) => ({\n    version: appConfig.STATE_VERSION,\n    totalCycles: 0,\n    agentIterations: 0,\n    humanInterventions: 0,\n    failCount: 0,\n    currentGoal: {\n      seed: null,\n      cumulative: null,\n      latestType: \"Idle\",\n      summaryContext: null,\n      currentContextFocus: null,\n    },\n    lastCritiqueType: \"N/A\",\n    personaMode: \"XYZ\",\n    lastFeedback: null,\n    lastSelfAssessment: null,\n    forceHumanReview: false,\n    apiKey: \"\",\n    confidenceHistory: [],\n    critiqueFailHistory: [],\n    tokenHistory: [],\n    failHistory: [],\n    evaluationHistory: [],\n    critiqueFeedbackHistory: [],\n    avgConfidence: null,\n    critiqueFailRate: null,\n    avgTokens: null,\n    avgEvalScore: null,\n    evalPassRate: null,\n    contextTokenEstimate: 0,\n    contextTokenTarget: appConfig.CTX_TARGET || 700000,\n    lastGeneratedFullSource: null,\n    htmlHistory: [],\n    lastApiResponse: null,\n    retryCount: 0,\n    autonomyMode: \"Manual\",\n    autonomyCyclesRemaining: 0,\n    cfg: { ...(appConfig.DEFAULT_CFG || {}) },\n    artifactMetadata: {},\n    dynamicTools: [],\n    registeredWebComponents: [],\n  });\n\n  async function calculateChecksum(content) {\n    if (typeof content !== \"string\") return null;\n    try {\n      const msgUint8 = new TextEncoder().encode(content);\n      const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgUint8);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return `sha256-${hashArray\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\")}`;\n    } catch (error) {\n      logger.logEvent(\"error\", \"Checksum calculation failed:\", error);\n      return null;\n    }\n  }\n\n  function sanitizeLlmJsonRespPure(rawText, externalLogger) {\n    if (!rawText || typeof rawText !== \"string\")\n      return { sanitizedJson: \"{}\", method: \"invalid input\" };\n    let text = rawText.trim();\n    let jsonString = null;\n    let method = \"none\";\n\n    try {\n      JSON.parse(text);\n      jsonString = text;\n      method = \"direct parse\";\n    } catch (e1) {\n      const codeBlockMatch = text.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/);\n      if (codeBlockMatch && codeBlockMatch[1]) {\n        text = codeBlockMatch[1].trim();\n        method = \"code block\";\n        try {\n          JSON.parse(text);\n          jsonString = text;\n        } catch (e2) {}\n      }\n\n      if (!jsonString) {\n        const firstBrace = text.indexOf(\"{\");\n        const firstBracket = text.indexOf(\"[\");\n        let startIndex = -1;\n\n        if (firstBrace !== -1 && firstBracket !== -1)\n          startIndex = Math.min(firstBrace, firstBracket);\n        else if (firstBrace !== -1) startIndex = firstBrace;\n        else startIndex = firstBracket;\n\n        if (startIndex !== -1) {\n          text = text.substring(startIndex);\n          const startChar = text[0];\n          const endChar = startChar === \"{\" ? \"}\" : \"]\";\n          let balance = 0;\n          let lastValidIndex = -1;\n          let inString = false;\n          let escapeNext = false;\n          method = \"heuristic balance\";\n\n          for (let i = 0; i < text.length; i++) {\n            const char = text[i];\n            if (inString) {\n              if (escapeNext) escapeNext = false;\n              else if (char === \"\\\\\") escapeNext = true;\n              else if (char === '\"') inString = false;\n            } else {\n              if (char === '\"') inString = true;\n              else if (char === startChar) balance++;\n              else if (char === endChar) balance--;\n            }\n            if (!inString && balance === 0 && startIndex === 0) {\n              lastValidIndex = i;\n              break;\n            }\n            if (!inString && balance === 0 && i > 0 && startIndex > 0) {\n              lastValidIndex = i;\n              break;\n            }\n          }\n\n          if (lastValidIndex !== -1) {\n            text = text.substring(0, lastValidIndex + 1);\n            try {\n              JSON.parse(text);\n              jsonString = text;\n            } catch (e3) {\n              externalLogger?.logEvent(\n                \"warn\",\n                `JSON sanitization failed (heuristic parse): ${e3.message}`,\n                text.substring(0, 100) + \"...\"\n              );\n              method = \"heuristic failed\";\n              jsonString = null;\n            }\n          } else {\n            externalLogger?.logEvent(\n              \"warn\",\n              \"JSON sanitization failed: Unbalanced structure after heuristic.\",\n              text.substring(0, 100)\n            );\n            method = \"heuristic unbalanced\";\n            jsonString = null;\n          }\n        } else {\n          method = \"no structure found\";\n          jsonString = null;\n        }\n      }\n    }\n    return { sanitizedJson: jsonString || \"{}\", method };\n  }\n\n  return {\n    Errors,\n    logger,\n    $id,\n    $,\n    $$,\n    kabobToCamel,\n    camelToKabob,\n    ucFirst,\n    trunc,\n    escapeHtml,\n    lc,\n    uc,\n    delay,\n    getRandomInt,\n    getLatestMeta,\n    getDefaultState,\n    calculateChecksum,\n    sanitizeLlmJsonRespPure,\n  };\n})();\n",
  "_x0_reploid.core.config_0": "{\n  \"LS_PREFIX\": \"_x0_\",\n  \"STATE_KEY_BASE\": \"x0_state_v\",\n  \"SESSION_STATE_KEY_BASE\": \"x0_session_state_v\",\n  \"STATE_VERSION\": \"0.7.0\",\n  \"MAX_ARTIFACT_SIZE_BYTES\": 4194304,\n  \"MAX_LOG_LENGTH\": 50000,\n  \"CTX_WARN_THRESH\": 300000,\n  \"CTX_TARGET\": 350000,\n  \"EVAL_PASS_THRESHOLD\": 0.75,\n  \"SVG_NS\": \"http://www.w3.org/2000/svg\",\n  \"GEMINI_STREAM_ENDPOINT_BASE\": \"https://generativelanguage.googleapis.com/v1beta/models/\",\n  \"API_RETRY_DELAY_BASE_MS\": 1500,\n  \"DYNAMIC_TOOL_TIMEOUT_MS\": 10000,\n  \"WORKER_SCRIPT_PATH\": \"tool-worker.js\",\n  \"NUM_CRITIQUES_TO_GENERATE\": 1,\n  \"AUTONOMOUS_CYCLE_DELAY_MS\": 1000,\n  \"TIMELINE_LOG_LIMIT\": 250,\n  \"DEFAULT_MODELS\": {\n    \"BASE\": \"gemini-2.5-flash-preview-04-17\",\n    \"ADVANCED\": \"gemini-2.5-pro-preview-05-06\"\n  },\n  \"DEFAULT_CFG\": {\n    \"personaBalance\": 50,\n    \"llmCritiqueProb\": 75,\n    \"humanReviewProb\": 25,\n    \"maxCycleTime\": 600,\n    \"autoCritiqueThresh\": 0.7,\n    \"maxCycles\": 0,\n    \"htmlHistoryLimit\": 5,\n    \"pauseAfterCycles\": 10,\n    \"maxRetries\": 1,\n    \"autonomyMode\": \"Manual\",\n    \"autonomyDefaultNCycles\": 5,\n    \"contextTokenTarget\": 350000,\n    \"coreModel\": \"ADVANCED\",\n    \"critiqueModel\": \"BASE\",\n    \"summarizerModel\": \"BASE\",\n    \"evaluatorModel\": \"BASE\",\n    \"hitlOnMetaChanges\": true,\n    \"enablePageComposition\": true\n  },\n  \"GENESIS_ARTIFACT_DEFS\": {\n    \"reploid.core.config\": {\n      \"filename\": \"config.json\",\n      \"type\": \"JSON_CONFIG\",\n      \"description\": \"Central application configuration\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.logic\": {\n      \"filename\": \"app-logic.js\",\n      \"type\": \"JS\",\n      \"description\": \"Main application logic orchestrator\",\n      \"paradigm\": \"boundary_orchestration\"\n    },\n    \"reploid.core.style\": {\n      \"filename\": \"ui-style.css\",\n      \"type\": \"CSS\",\n      \"description\": \"Main application styles\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.body\": {\n      \"filename\": \"ui-body-template.html\",\n      \"type\": \"HTML\",\n      \"description\": \"App root HTML structure (used if not overridden by page_composition)\",\n      \"paradigm\": \"ui_template\"\n    },\n    \"reploid.core.utils\": {\n      \"filename\": \"utils.js\",\n      \"type\": \"JS\",\n      \"description\": \"Core utility functions (includes custom Error definitions)\",\n      \"paradigm\": \"pure\"\n    },\n    \"reploid.core.storage\": {\n      \"filename\": \"storage.js\",\n      \"type\": \"JS\",\n      \"description\": \"Core storage functions\",\n      \"paradigm\": \"boundary_io\"\n    },\n    \"reploid.core.statemanager\": {\n      \"filename\": \"state-manager.js\",\n      \"type\": \"JS\",\n      \"description\": \"Core state management logic\",\n      \"paradigm\": \"boundary_orchestration\"\n    },\n    \"reploid.core.ui\": {\n      \"filename\": \"ui-manager.js\",\n      \"type\": \"JS\",\n      \"description\": \"Core UI rendering and event handling\",\n      \"paradigm\": \"boundary_io\"\n    },\n    \"reploid.core.apiclient\": {\n      \"filename\": \"api-client.js\",\n      \"type\": \"JS\",\n      \"description\": \"Handles API communication\",\n      \"paradigm\": \"boundary_io\"\n    },\n    \"reploid.core.cyclelogic\": {\n      \"filename\": \"agent-cycle.js\",\n      \"type\": \"JS\",\n      \"description\": \"Main application cycle orchestration\",\n      \"paradigm\": \"boundary_orchestration\"\n    },\n    \"reploid.core.sys-prompt\": {\n      \"filename\": \"prompt-system.txt\",\n      \"type\": \"PROMPT\",\n      \"description\": \"Core LLM prompt\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.critiquer-prompt\": {\n      \"filename\": \"prompt-critiquer.txt\",\n      \"type\": \"PROMPT\",\n      \"description\": \"Critique prompt\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.summarizer-prompt\": {\n      \"filename\": \"prompt-summarizer.txt\",\n      \"type\": \"PROMPT\",\n      \"description\": \"Summarization prompt\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.evaluator-prompt\": {\n      \"filename\": \"prompt-evaluator.txt\",\n      \"type\": \"PROMPT\",\n      \"description\": \"Self-evaluation prompt\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.static-tools\": {\n      \"filename\": \"data-tools-static.json\",\n      \"type\": \"JSON\",\n      \"description\": \"Static tool definitions\",\n      \"paradigm\": \"data\"\n    },\n    \"reploid.core.toolrunner\": {\n      \"filename\": \"tool-runner.js\",\n      \"type\": \"JS\",\n      \"description\": \"Tool execution engine (static + dynamic via worker)\",\n      \"paradigm\": \"boundary_orchestration\"\n    },\n    \"reploid.core.default-eval\": {\n      \"filename\": \"data-eval-default.json\",\n      \"type\": \"EVAL_DEF\",\n      \"description\": \"Default Evaluation Definition\",\n      \"paradigm\": \"data\"\n    }\n  },\n  \"ARTIFACT_TYPES\": [\n    \"JS\",\n    \"CSS\",\n    \"HTML\",\n    \"HTML_HEAD\",\n    \"HTML_BODY\",\n    \"JSON\",\n    \"JSON_CONFIG\",\n    \"PROMPT\",\n    \"TEXT\",\n    \"LOG\",\n    \"EVAL_DEF\",\n    \"DIAGRAM_JSON\",\n    \"WEB_COMPONENT_DEF\",\n    \"FULL_HTML_SOURCE\",\n    \"PAGE_COMPOSITION_DEF\",\n    \"UNKNOWN\"\n  ]\n}",
  "_x0_reploid.core.cyclelogic_0": "const CycleLogicModule = (\n  config,\n  logger,\n  Utils,\n  Storage,\n  StateManager,\n  UI,\n  ApiClient,\n  ToolRunner,\n  Errors,\n  AgentLogicPureHelpers\n) => {\n  if (\n    !config ||\n    !logger ||\n    !Utils ||\n    !Storage ||\n    !StateManager ||\n    !UI ||\n    !ApiClient ||\n    !ToolRunner ||\n    !Errors ||\n    !AgentLogicPureHelpers\n  ) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[CYCLELOGIC_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"CycleLogicModule initialization failed: Missing one or more core dependencies.\"\n    );\n    const fallback = {};\n    const methods = [\n      \"init\",\n      \"executeCycle\",\n      \"isRunning\",\n      \"getActiveGoalInfo\",\n      \"proceedAfterHumanIntervention\",\n      \"handleSummarizeContext\",\n      \"abortCurrentCycle\",\n      \"saveHtmlToHistory\",\n      \"runTool\",\n      \"startAutonomousRun\",\n      \"stopAutonomousRun\",\n    ];\n    methods.forEach((m) => {\n      fallback[m] = () => {\n        internalLog.logEvent(\n          \"error\",\n          `CycleLogic not initialized. Called ${m}.`\n        );\n        if (m === \"isRunning\") return false;\n        if (m === \"getActiveGoalInfo\")\n          return { type: \"Idle\", latestGoal: \"Idle\" };\n        if ([\"executeCycle\", \"handleSummarizeContext\", \"runTool\"].includes(m))\n          return Promise.reject(new Error(\"CycleLogic not initialized\"));\n        return undefined;\n      };\n    });\n    return fallback;\n  }\n\n  const {\n    ApplicationError,\n    ApiError,\n    ToolError,\n    StateError,\n    ConfigError,\n    ArtifactError,\n    AbortError,\n    WebComponentError,\n  } = Errors;\n  let _isRunning = false;\n  let _isAutonomous = false;\n  let _abortRequested = false;\n  let currentLlmResponse = null;\n  let loadedStaticTools = [];\n  let isLogicInitialized = false;\n  const NUM_CRITIQUES_TO_GENERATE = config.NUM_CRITIQUES_TO_GENERATE || 1;\n\n  const init = () => {\n    if (isLogicInitialized) return;\n    logger.logEvent(\"info\", \"Initializing CycleLogic Module...\");\n    try {\n      const staticToolsContent = Storage.getArtifactContent(\n        \"reploid.core.static-tools\",\n        0\n      );\n      if (staticToolsContent) {\n        loadedStaticTools = JSON.parse(staticToolsContent);\n        logger.logEvent(\n          \"debug\",\n          `CycleLogic loaded ${loadedStaticTools.length} static tools definitions.`\n        );\n      } else {\n        logger.logEvent(\n          \"warn\",\n          \"Static tools artifact (reploid.core.static-tools) not found. Using empty list.\"\n        );\n        loadedStaticTools = [];\n      }\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Failed to load/parse static tools: ${e.message}`,\n        e\n      );\n      loadedStaticTools = [];\n    }\n    isLogicInitialized = true;\n    logger.logEvent(\"info\", \"CycleLogic Module initialized.\");\n  };\n\n  const isRunning = () => _isRunning;\n  const isAutonomous = () => _isAutonomous;\n\n  const getActiveGoalInfo = () => {\n    const state = StateManager.getState();\n    if (!state || !state.currentGoal)\n      return {\n        seedGoal: \"N/A\",\n        cumulativeGoal: \"N/A\",\n        latestGoal: \"Idle\",\n        type: \"Idle\",\n        summaryContext: null,\n        currentContextFocus: null,\n      };\n    const latestGoal = state.currentGoal.cumulative || state.currentGoal.seed;\n    return {\n      seedGoal: state.currentGoal.seed || \"None\",\n      cumulativeGoal: state.currentGoal.cumulative || \"None\",\n      latestGoal: latestGoal || \"Idle\",\n      type: state.currentGoal.latestType || \"Idle\",\n      summaryContext: state.currentGoal.summaryContext || null,\n      currentContextFocus: state.currentGoal.currentContextFocus || null,\n    };\n  };\n\n  const _assembleCorePromptContext = (state, goalInfo, currentCycle) => {\n    const corePromptTemplate = Storage.getArtifactContent(\n      \"reploid.core.sys-prompt\",\n      0\n    );\n    if (!corePromptTemplate)\n      throw new ArtifactError(\n        \"Core prompt artifact 'reploid.core.sys-prompt' not found!\",\n        \"reploid.core.sys-prompt\",\n        0\n      );\n\n    const allMetaMap = StateManager.getAllArtifactMetadata();\n    const artifactListSummary =\n      AgentLogicPureHelpers.getArtifactListSummaryPure(allMetaMap);\n    const registeredWebComponentsList =\n      AgentLogicPureHelpers.getRegisteredWebComponentsListPure(\n        StateManager.getRegisteredWebComponents()\n      );\n    const toolListSummary = AgentLogicPureHelpers.getToolListSummaryPure(\n      loadedStaticTools,\n      state?.dynamicTools || [],\n      Utils.trunc\n    );\n    const recentLogs = logger.getLogBuffer\n      ? logger.getLogBuffer().split(\"\\n\").slice(-15).join(\"\\n\")\n      : \"Logs unavailable\";\n\n    const getArtifactContentForSnippets = (id, cycle, versionId) =>\n      Storage.getArtifactContent(id, cycle, versionId);\n    const artifactSnippets = AgentLogicPureHelpers.prepareArtifactSnippetsPure(\n      allMetaMap,\n      getArtifactContentForSnippets,\n      goalInfo.type,\n      Utils.trunc\n    );\n\n    const { prompt, error } = AgentLogicPureHelpers.assembleCorePromptPure(\n      corePromptTemplate,\n      state,\n      goalInfo,\n      artifactListSummary,\n      registeredWebComponentsList,\n      toolListSummary,\n      recentLogs,\n      artifactSnippets,\n      Utils.trunc\n    );\n    if (error) throw new ApplicationError(error);\n\n    UI.displayCycleArtifact(\n      \"LLM Input Prompt\",\n      prompt,\n      \"input\",\n      false,\n      \"System\",\n      \"prompt.core\",\n      currentCycle\n    );\n    if (goalInfo.summaryContext)\n      UI.displayCycleArtifact(\n        \"LLM Input Context (Summary)\",\n        goalInfo.summaryContext,\n        \"input\",\n        false,\n        \"System\",\n        \"prompt.summary\",\n        currentCycle\n      );\n    return prompt;\n  };\n\n  const _prepareFunctionDeclarations = async (state) => {\n    let allFuncDecls = [];\n    const dynamicTools = state?.dynamicTools || [];\n    const uiHooks = {\n      updateStatus: () => {},\n      logTimeline: () => ({}),\n      updateTimelineItem: () => {},\n    };\n\n    const convertToolToFc = async (toolDef, type) => {\n      try {\n        const conversionResult = await ToolRunner.runTool(\n          \"convert_to_gemini_fc\",\n          { mcpToolDefinition: toolDef },\n          loadedStaticTools,\n          [],\n          uiHooks\n        );\n        return conversionResult?.geminiFunctionDeclaration;\n      } catch (e) {\n        logger.logEvent(\n          \"error\",\n          `Failed converting ${type} tool ${\n            toolDef.name || toolDef.declaration?.name\n          }: ${e.message}`,\n          e instanceof ToolError ? e.details : e\n        );\n        return null;\n      }\n    };\n    const staticToolPromises = loadedStaticTools.map((toolDef) =>\n      convertToolToFc(toolDef, \"static\")\n    );\n    const dynamicToolPromises = dynamicTools.map((toolDef) =>\n      convertToolToFc(toolDef.declaration, \"dynamic\")\n    );\n    try {\n      const results = await Promise.all([\n        ...staticToolPromises,\n        ...dynamicToolPromises,\n      ]);\n      allFuncDecls = results.filter(Boolean);\n    } catch (error) {\n      logger.logEvent(\n        \"error\",\n        `Error during tool declaration preparation: ${error.message}`,\n        error\n      );\n    }\n    return allFuncDecls;\n  };\n\n  const _handleToolExecution = async (\n    toolCall,\n    state,\n    currentCycle,\n    uiHooks\n  ) => {\n    const { name: toolName, arguments: toolArgs } = toolCall;\n    uiHooks.updateStatus(`Running Tool: ${toolName}...`, true);\n    let toolLogItem = uiHooks.logTimeline(\n      currentCycle,\n      `[TOOL] Calling '${toolName}'... Args: ${Utils.trunc(\n        JSON.stringify(toolArgs),\n        60\n      )}`,\n      \"tool\",\n      true,\n      true\n    );\n    UI.displayCycleArtifact(\n      `Tool Call: ${toolName}`,\n      JSON.stringify(toolArgs, null, 2),\n      \"info\",\n      false,\n      \"LLM\",\n      `tool.call.${toolName}`,\n      currentCycle\n    );\n    let funcRespContent;\n    let toolResult = null;\n    let toolError = null;\n    let toolSuccess = false;\n    try {\n      toolResult = await ToolRunner.runTool(\n        toolName,\n        toolArgs,\n        loadedStaticTools,\n        state.dynamicTools || [],\n        uiHooks\n      );\n      toolSuccess = true;\n      if (\n        toolResult &&\n        typeof toolResult.success === \"boolean\" &&\n        !toolResult.success\n      ) {\n        toolSuccess = false;\n        toolError = new ToolError(\n          toolResult.error || `Tool '${toolName}' reported failure.`,\n          toolName,\n          toolArgs,\n          toolResult\n        );\n      }\n      funcRespContent = {\n        name: toolName,\n        response: { content: JSON.stringify(toolResult) },\n      };\n      uiHooks.updateTimelineItem(\n        toolLogItem,\n        `[TOOL ${\n          toolSuccess ? \"OK\" : \"FAIL\"\n        }] '${toolName}'. Result: ${Utils.trunc(\n          JSON.stringify(toolResult),\n          80\n        )}`,\n        toolSuccess ? \"tool\" : \"error\",\n        true\n      );\n      UI.displayCycleArtifact(\n        `Tool Response: ${toolName}`,\n        JSON.stringify(toolResult, null, 2),\n        toolSuccess ? \"output\" : \"error\",\n        false,\n        \"Tool\",\n        `tool.response.${toolName}`,\n        currentCycle\n      );\n      if (toolName === \"run_self_evaluation\" && toolResult && toolSuccess)\n        StateManager.addEvaluationResult(toolResult);\n      if (!toolSuccess && toolError) throw toolError;\n    } catch (e) {\n      toolSuccess = false;\n      toolError =\n        e instanceof ToolError\n          ? e\n          : new ToolError(\n              `Tool '${toolName}' failed: ${e.message}`,\n              toolName,\n              toolArgs,\n              e\n            );\n      logger.logEvent(\n        \"error\",\n        `Tool Execution Error (${toolName}): ${toolError.message}`,\n        toolError.details || toolError\n      );\n      funcRespContent = {\n        name: toolName,\n        response: { error: `Tool failed: ${toolError.message}` },\n      };\n      uiHooks.updateTimelineItem(\n        toolLogItem,\n        `[TOOL ERR] '${toolName}': ${Utils.trunc(toolError.message, 60)}`,\n        \"error\",\n        true\n      );\n      UI.displayCycleArtifact(\n        `Tool Error: ${toolName}`,\n        toolError.message +\n          (toolError.details\n            ? `\\nDetails: ${JSON.stringify(toolError.details)}`\n            : \"\"),\n        \"error\",\n        false,\n        \"Tool\",\n        `tool.error.${toolName}`,\n        currentCycle\n      );\n    }\n    return {\n      role: \"function\",\n      parts: [{ functionResponse: funcRespContent }],\n      _toolExecutionInfo: {\n        name: toolName,\n        args: toolArgs,\n        success: toolSuccess,\n        result: toolResult,\n        error: toolError?.message || null,\n        errorDetails: toolError?.details || null,\n      },\n    };\n  };\n\n  const _executeLlmApiCallSequence = async (\n    prompt,\n    sysInstruction,\n    coreModelIdentifier,\n    apiKey,\n    allFuncDecls,\n    state,\n    currentCycle\n  ) => {\n    let apiHistory = [];\n    let currentApiResult = null;\n    let accumulatedText = \"\";\n    let isContinuation = false;\n    let totalInputTokens = 0;\n    let totalOutputTokens = 0;\n    let toolExecutionSummaries = [];\n    const uiHooks = {\n      updateStatus: UI.updateStatus,\n      logTimeline: UI.logToTimeline,\n      updateTimelineItem: UI.updateTimelineItem,\n      displayArtifact: UI.displayCycleArtifact,\n    };\n    let currentPrompt = prompt;\n    let currentHistory = null;\n    for (let i = 0; i < 5; i++) {\n      logger.logEvent(\"debug\", `API Call Sequence: Iteration ${i + 1}`);\n      let loopApiResult = null;\n      let loopAccumulatedText = \"\";\n      const callResult = await ApiClient.callApiWithRetry(\n        currentPrompt,\n        sysInstruction,\n        coreModelIdentifier,\n        apiKey,\n        allFuncDecls,\n        isContinuation,\n        currentHistory,\n        state.cfg?.maxRetries ?? 1,\n        {},\n        uiHooks.updateStatus,\n        uiHooks.logTimeline,\n        uiHooks.updateTimelineItem,\n        (progress) => {\n          if (progress.type === \"text\") {\n            loopAccumulatedText += progress.content;\n            UI.updateStreamingOutput(loopAccumulatedText);\n          } else if (progress.type === \"functionCall\")\n            UI.updateStreamingOutput(\n              `Function Call received: ${\n                progress.content.name\n              }\\nArgs:\\n${JSON.stringify(progress.content.args, null, 2)}`\n            );\n          if (progress.accumulatedResult)\n            loopApiResult = progress.accumulatedResult;\n        }\n      );\n      if (!loopApiResult) loopApiResult = callResult;\n      currentApiResult = loopApiResult;\n      accumulatedText = loopAccumulatedText;\n      totalInputTokens += loopApiResult.inputTokenCount || 0;\n      totalOutputTokens += loopApiResult.outputTokenCount || 0;\n      if (currentPrompt)\n        apiHistory.push({ role: \"user\", parts: [{ text: currentPrompt }] });\n      if (loopApiResult.rawResp?.candidates?.[0]?.content)\n        apiHistory.push(loopApiResult.rawResp.candidates[0].content);\n      else if (loopApiResult.type === \"text\" && loopApiResult.content)\n        apiHistory.push({\n          role: \"model\",\n          parts: [{ text: loopApiResult.content }],\n        });\n\n      if (\n        loopApiResult.type === \"functionCall\" &&\n        loopApiResult.content?.name\n      ) {\n        uiHooks.updateStatus(\"Processing Tool Call...\", true);\n        const fc = loopApiResult.content;\n        const toolResponse = await _handleToolExecution(\n          fc,\n          state,\n          currentCycle,\n          uiHooks\n        );\n        toolExecutionSummaries.push(toolResponse._toolExecutionInfo);\n        apiHistory.push(toolResponse);\n        currentPrompt = null;\n        currentHistory = [...apiHistory];\n        isContinuation = true;\n        loopAccumulatedText = \"\";\n        continue;\n      } else {\n        break;\n      }\n    }\n    StateManager.updateAndSaveState((s) => {\n      s.lastApiResponse = currentApiResult;\n      s.contextTokenEstimate += totalOutputTokens;\n      return s;\n    });\n    return {\n      apiResult: currentApiResult,\n      accumulatedText: accumulatedText,\n      toolExecutionSummaries: toolExecutionSummaries,\n    };\n  };\n\n  const _processLlmApiResponse = (apiCallResult, state, currentCycle) => {\n    UI.updateStatus(\"Processing Final Response...\");\n    const finalContent =\n      apiCallResult.accumulatedText ||\n      apiCallResult.apiResult?.content ||\n      \"(No final text output)\";\n    UI.updateStreamingOutput(finalContent, true);\n    const sanitized = ApiClient.sanitizeLlmJsonResp(finalContent);\n    let parsedResp;\n    UI.displayCycleArtifact(\n      \"LLM Final Output Raw\",\n      finalContent,\n      \"info\",\n      false,\n      \"LLM\",\n      \"llm.raw\",\n      currentCycle\n    );\n    UI.displayCycleArtifact(\n      \"LLM Final Output Sanitized\",\n      sanitized,\n      \"output\",\n      false,\n      \"LLM\",\n      \"llm.sanitized\",\n      currentCycle\n    );\n    try {\n      parsedResp = JSON.parse(sanitized);\n      logger.logEvent(\n        \"info\",\n        `Parsed final LLM JSON after iteration ${currentCycle}.`\n      );\n      UI.logToTimeline(\n        currentCycle,\n        \"[LLM OK] Received and parsed final response.\"\n      );\n      StateManager.updateAndSaveState((s) => {\n        if (parsedResp.self_assessment_notes) {\n          UI.displayCycleArtifact(\n            \"Agent Self-Assessment\",\n            parsedResp.self_assessment_notes,\n            \"info\",\n            false,\n            \"LLM\",\n            \"llm.self_assessment\",\n            currentCycle\n          );\n          logger.logEvent(\n            \"info\",\n            `LLM provided self-assessment notes: ${Utils.trunc(\n              parsedResp.self_assessment_notes,\n              100\n            )}`\n          );\n          s.lastSelfAssessment = parsedResp.self_assessment_notes;\n        }\n        if (parsedResp.current_context_focus && s.currentGoal) {\n          s.currentGoal.currentContextFocus = parsedResp.current_context_focus;\n          logger.logEvent(\n            \"info\",\n            `LLM updated context focus: ${s.currentGoal.currentContextFocus}`\n          );\n        }\n        return s;\n      });\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `LLM final JSON parse failed: ${e.message}. Content: ${Utils.trunc(\n          sanitized,\n          500\n        )}`,\n        e\n      );\n      UI.logToTimeline(\n        currentCycle,\n        \"[LLM ERR] Invalid final JSON response.\",\n        \"error\"\n      );\n      UI.displayCycleArtifact(\n        \"Parse Error\",\n        e.message,\n        \"error\",\n        false,\n        \"System\",\n        \"parse.error\",\n        currentCycle\n      );\n      throw new ApplicationError(`LLM response invalid JSON: ${e.message}`, {\n        content: sanitized,\n      });\n    }\n    const outputTokens = apiCallResult.apiResult?.outputTokenCount || 0;\n    if (outputTokens > 0) {\n      StateManager.updateAndSaveState((s) => {\n        if (!s.tokenHistory) s.tokenHistory = [];\n        s.tokenHistory.push(outputTokens);\n        if (s.tokenHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.tokenHistory.shift();\n        return s;\n      });\n    }\n    return parsedResp;\n  };\n\n  const _runLlmIteration = async (state, goalInfo, currentCycle) => {\n    UI.highlightCoreStep(1);\n    const startTime = performance.now();\n    let finalResult = null;\n    let toolSummaries = [];\n    try {\n      const prompt = _assembleCorePromptContext(state, goalInfo, currentCycle);\n      const sysInstruction = `You are x0. DELIBERATE, adopt ${state.personaMode}. Respond ONLY valid JSON matching the schema. Refer to artifacts by ID and optional versionId (e.g., file.js#v1). Use artifactId and cycle args for tools. Use run_self_evaluation tool if appropriate. Provide modular edits via 'artifact_changes.modular' when possible. If generating full page changes, use 'page_composition' over 'full_html_source' string if 'enablePageComposition' config is true and it's suitable. Consider artifact paradigms.`;\n      const allFuncDecls = await _prepareFunctionDeclarations(state);\n      const coreModelKey = state.cfg?.coreModel || \"ADVANCED\";\n      const coreModelIdentifier =\n        config.DEFAULT_MODELS[coreModelKey.toUpperCase()] || coreModelKey;\n      const apiKey = state.apiKey;\n      if (!apiKey)\n        throw new ConfigError(\n          \"API Key is missing. Cannot make LLM call.\",\n          \"apiKey\"\n        );\n      UI.clearStreamingOutput();\n      const apiCallResult = await _executeLlmApiCallSequence(\n        prompt,\n        sysInstruction,\n        coreModelIdentifier,\n        apiKey,\n        allFuncDecls,\n        state,\n        currentCycle\n      );\n      toolSummaries = apiCallResult.toolExecutionSummaries || [];\n      const parsedResp = _processLlmApiResponse(\n        apiCallResult,\n        state,\n        currentCycle\n      );\n      finalResult = {\n        response: parsedResp,\n        cycleTimeMillis: performance.now() - startTime,\n        toolSummaries: toolSummaries,\n        error: null,\n      };\n    } catch (error) {\n      if (!(error instanceof AbortError)) {\n        logger.logEvent(\n          \"error\",\n          `Core LLM Iteration failed (Cycle ${currentCycle}): ${error.message}`,\n          error instanceof ApplicationError ? error.details : error\n        );\n        UI.logToTimeline(\n          currentCycle,\n          `[LLM ERR] Iteration failed: ${Utils.trunc(error.message, 100)}`,\n          \"error\"\n        );\n      }\n      finalResult = {\n        response: null,\n        cycleTimeMillis: performance.now() - startTime,\n        toolSummaries: toolSummaries,\n        error: error,\n      };\n    } finally {\n      UI.clearStreamingOutput();\n    }\n    return finalResult;\n  };\n\n  const _assembleCritiquePromptContext = (llmProposal, goalInfo) => {\n    const template = Storage.getArtifactContent(\n      \"reploid.core.critiquer-prompt\",\n      0\n    );\n    if (!template)\n      throw new ArtifactError(\n        \"Critique prompt artifact not found!\",\n        \"reploid.core.critiquer-prompt\",\n        0\n      );\n\n    const getParadigm = (id) =>\n      StateManager.getArtifactMetadata(id)?.paradigm || \"unknown\";\n    const changes = llmProposal.artifact_changes || {};\n    const modifiedParadigmSummary =\n      (changes.modified || []).map((a) => getParadigm(a.id)).join(\", \") ||\n      \"N/A\";\n    const newParadigmSummary =\n      (changes.new || [])\n        .map((a) => a.paradigm || getParadigm(a.id))\n        .join(\", \") || \"N/A\";\n    const deletedParadigmSummary =\n      (changes.deleted || []).map((id) => getParadigm(id)).join(\", \") || \"N/A\";\n    const modularParadigmSummary =\n      (changes.modular || []).map((a) => getParadigm(a.id)).join(\", \") || \"N/A\";\n\n    const { prompt, error } = AgentLogicPureHelpers.assembleCritiquePromptPure(\n      template,\n      llmProposal,\n      goalInfo,\n      Utils.trunc\n    );\n    if (error) throw new ApplicationError(error);\n\n    return prompt\n      .replace(/\\[\\[MODIFIED_ARTIFACT_PARADIGMS\\]\\]/g, modifiedParadigmSummary)\n      .replace(/\\[\\[NEW_ARTIFACT_PARADIGMS\\]\\]/g, newParadigmSummary)\n      .replace(/\\[\\[DELETED_ARTIFACT_PARADIGMS\\]\\]/g, deletedParadigmSummary)\n      .replace(/\\[\\[MODULAR_ARTIFACT_PARADIGMS\\]\\]/g, modularParadigmSummary);\n  };\n\n  const _runSingleAutoCritiqueInstance = async (\n    apiKey,\n    llmProposal,\n    goalInfo,\n    currentCycle,\n    critiqueIndex\n  ) => {\n    const state = StateManager.getState();\n    if (!state)\n      throw new StateError(\"State not initialized for critique instance\");\n    const prompt = _assembleCritiquePromptContext(llmProposal, goalInfo);\n    const critiqueModelKey = state.cfg?.critiqueModel || \"BASE\";\n    const critiqueModelIdentifier =\n      config.DEFAULT_MODELS[critiqueModelKey.toUpperCase()] || critiqueModelKey;\n    const sysInstruction =\n      'Critiquer x0. Analyze objectively. Output ONLY valid JSON: {\"critique_passed\": boolean, \"critique_report\": \"string\"}';\n    UI.displayCycleArtifact(\n      `Critique Input [${critiqueIndex + 1}/${NUM_CRITIQUES_TO_GENERATE}]`,\n      prompt,\n      \"input\",\n      false,\n      \"System\",\n      `prompt.critique.${critiqueIndex}`,\n      currentCycle\n    );\n    let critiqueResultText = \"\";\n    let critiqueApiResult = null;\n    let finalResult = {\n      critique_passed: false,\n      critique_report: \"Critique execution failed\",\n    };\n    try {\n      let accumulatedCritiqueText = \"\";\n      const genConfigOverrides =\n        NUM_CRITIQUES_TO_GENERATE > 1\n          ? { temperature: 0.7 + Math.random() * 0.2 }\n          : {};\n      critiqueApiResult = await ApiClient.callApiWithRetry(\n        prompt,\n        sysInstruction,\n        critiqueModelIdentifier,\n        apiKey,\n        [],\n        false,\n        null,\n        state.cfg?.maxRetries ?? 1,\n        genConfigOverrides,\n        (msg, active, isErr) =>\n          UI.updateStatus(\n            `Critique ${critiqueIndex + 1}: ${msg}`,\n            active,\n            isErr\n          ),\n        (cyc, msg, type, sub, anim) =>\n          UI.logToTimeline(\n            cyc,\n            `[CRIT ${critiqueIndex + 1}] ${msg}`,\n            type,\n            sub,\n            anim\n          ),\n        UI.updateTimelineItem,\n        (progress) => {\n          if (progress.type === \"text\")\n            accumulatedCritiqueText += progress.content;\n          if (progress.accumulatedResult)\n            critiqueApiResult = progress.accumulatedResult;\n          critiqueResultText =\n            progress.accumulatedResult?.content || accumulatedCritiqueText;\n        }\n      );\n      if (!critiqueResultText && critiqueApiResult?.content)\n        critiqueResultText = critiqueApiResult.content;\n      UI.displayCycleArtifact(\n        `Critique Output Raw [${critiqueIndex + 1}]`,\n        critiqueResultText || \"(No text content)\",\n        \"info\",\n        false,\n        \"LLM\",\n        `critique.raw.${critiqueIndex}`,\n        currentCycle\n      );\n      const sanitized = ApiClient.sanitizeLlmJsonResp(critiqueResultText);\n      UI.displayCycleArtifact(\n        `Critique Output Sanitized [${critiqueIndex + 1}]`,\n        sanitized,\n        \"output\",\n        false,\n        \"LLM\",\n        `critique.sanitized.${critiqueIndex}`,\n        currentCycle\n      );\n      const parsedCritique = JSON.parse(sanitized);\n      if (\n        typeof parsedCritique.critique_passed !== \"boolean\" ||\n        typeof parsedCritique.critique_report !== \"string\"\n      )\n        throw new ApplicationError(\"Critique JSON missing required fields.\");\n      finalResult = parsedCritique;\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Critique instance ${critiqueIndex + 1} API/Parse failed: ${e.message}`,\n        e\n      );\n      UI.logToTimeline(\n        currentCycle,\n        `[CRIT ${critiqueIndex + 1} ERR] Failed: ${e.message}`,\n        \"error\",\n        true\n      );\n      UI.displayCycleArtifact(\n        `Critique Error [${critiqueIndex + 1}]`,\n        e.message,\n        \"error\",\n        false,\n        \"System\",\n        `critique.error.${critiqueIndex}`,\n        currentCycle\n      );\n      finalResult.critique_report = `Critique instance ${\n        critiqueIndex + 1\n      } failed: ${e.message}`;\n    }\n    return finalResult;\n  };\n\n  const _runAutoCritique = async (\n    apiKey,\n    llmProposal,\n    goalInfo,\n    currentCycle\n  ) => {\n    UI.highlightCoreStep(5);\n    UI.updateStatus(\n      `Running ${NUM_CRITIQUES_TO_GENERATE} Auto-Critiques...`,\n      true\n    );\n    const critiquePromises = [];\n    for (let i = 0; i < NUM_CRITIQUES_TO_GENERATE; i++)\n      critiquePromises.push(\n        _runSingleAutoCritiqueInstance(\n          apiKey,\n          llmProposal,\n          goalInfo,\n          currentCycle,\n          i\n        )\n      );\n    const results = await Promise.allSettled(critiquePromises);\n    const successfulCritiques = results\n      .filter((r) => r.status === \"fulfilled\")\n      .map((r) => r.value);\n    const failedCritiques = results\n      .filter((r) => r.status === \"rejected\")\n      .map((r) => ({\n        critique_passed: false,\n        critique_report: `Critique generation failed: ${\n          r.reason?.message || \"Unknown reason\"\n        }`,\n      }));\n    const allCritiqueOutputs = [...successfulCritiques, ...failedCritiques];\n    const overallPassed =\n      successfulCritiques.length === NUM_CRITIQUES_TO_GENERATE &&\n      successfulCritiques.every((c) => c.critique_passed);\n    let combinedReport = allCritiqueOutputs\n      .map(\n        (c, i) =>\n          `Critique ${i + 1}: ${c.critique_passed ? \"Pass\" : \"FAIL\"}. Report: ${\n            c.critique_report\n          }`\n      )\n      .join(\"\\n---\\n\");\n    if (failedCritiques.length > 0)\n      combinedReport += `\\n---\\nWARNING: ${failedCritiques.length} critique generation(s) failed.`;\n    logger.logEvent(\n      \"info\",\n      `Multi-Critique finished. Overall Pass: ${overallPassed}`\n    );\n    UI.logToTimeline(\n      currentCycle,\n      `[CRITIQUE] Multi-Critique completed. Overall Passed: ${overallPassed}`\n    );\n    UI.updateStatus(\"Idle\");\n    UI.clearStreamingOutput();\n    return {\n      critiques: allCritiqueOutputs,\n      overall_passed: overallPassed,\n      combined_report: combinedReport,\n    };\n  };\n\n  const _assembleHtmlFromPageComposition = async (\n    composition,\n    nextCycleNum,\n    critiqueSource,\n    state\n  ) => {\n    logger.logEvent(\"info\", \"Assembling HTML from page_composition object.\", {\n      composition,\n    });\n    let htmlParts = [];\n    try {\n      htmlParts.push(composition.doctype || \"<!DOCTYPE html>\");\n      const htmlAttrsObj = composition.html_attributes || { lang: \"en\" };\n      const htmlAttrs = Object.entries(htmlAttrsObj)\n        .map(\n          ([key, value]) =>\n            `${Utils.escapeHtml(key)}=\"${Utils.escapeHtml(String(value))}\"`\n        )\n        .join(\" \");\n      htmlParts.push(`<html ${htmlAttrs}>`);\n      htmlParts.push(\"<head>\");\n      if (\n        composition.head_elements &&\n        Array.isArray(composition.head_elements)\n      ) {\n        for (const el of composition.head_elements) {\n          if (el.type === \"artifact_id\" && el.id) {\n            const meta = StateManager.getArtifactMetadata(el.id);\n            const content = meta\n              ? Storage.getArtifactContent(\n                  el.id,\n                  meta.latestCycle,\n                  meta.version_id\n                )\n              : null;\n            if (content !== null) {\n              htmlParts.push(content);\n              UI.displayCycleArtifact(\n                `Loaded Head Artifact: ${el.id}`,\n                Utils.trunc(content, 100),\n                \"info\",\n                false,\n                critiqueSource,\n                el.id,\n                nextCycleNum\n              );\n            } else {\n              logger.logEvent(\n                \"warn\",\n                `Head artifact ${el.id} not found for page_composition.`\n              );\n              htmlParts.push(`<!-- Head artifact ${el.id} not found -->`);\n            }\n          } else if (el.type === \"inline_tag\" && el.tag) {\n            const tagAttrsObj = el.attributes || {};\n            const tagAttrs = Object.entries(tagAttrsObj)\n              .map(\n                ([key, value]) =>\n                  `${Utils.escapeHtml(key)}=\"${Utils.escapeHtml(\n                    String(value)\n                  )}\"`\n              )\n              .join(\" \");\n            let tagContent = \"\";\n            if (el.content) tagContent = Utils.escapeHtml(el.content);\n            else if (el.content_artifact_id) {\n              const metaContent = StateManager.getArtifactMetadata(\n                el.content_artifact_id\n              );\n              const artifactContent = metaContent\n                ? Storage.getArtifactContent(\n                    el.content_artifact_id,\n                    metaContent.latestCycle,\n                    metaContent.version_id\n                  )\n                : null;\n              if (artifactContent !== null) {\n                tagContent = artifactContent;\n                UI.displayCycleArtifact(\n                  `Loaded Content for <${el.tag}>: ${el.content_artifact_id}`,\n                  Utils.trunc(artifactContent, 100),\n                  \"info\",\n                  false,\n                  critiqueSource,\n                  el.content_artifact_id,\n                  nextCycleNum\n                );\n              } else {\n                logger.logEvent(\n                  \"warn\",\n                  `Content artifact ${el.content_artifact_id} for <${el.tag}> not found.`\n                );\n                tagContent = `<!-- Content artifact ${el.content_artifact_id} not found -->`;\n              }\n            }\n            const voidElements = [\n              \"meta\",\n              \"link\",\n              \"br\",\n              \"hr\",\n              \"img\",\n              \"input\",\n              \"base\",\n              \"col\",\n              \"embed\",\n              \"param\",\n              \"source\",\n              \"track\",\n              \"area\",\n              \"keygen\",\n              \"wbr\",\n            ];\n            if (voidElements.includes(el.tag.toLowerCase()))\n              htmlParts.push(`<${el.tag} ${tagAttrs}>`);\n            else\n              htmlParts.push(\n                `<${el.tag} ${tagAttrs}>${tagContent}</${el.tag}>`\n              );\n          }\n        }\n      }\n      htmlParts.push(\"</head>\");\n      const bodyAttrsObj = composition.body_attributes || {};\n      const bodyAttrs = Object.entries(bodyAttrsObj)\n        .map(\n          ([key, value]) =>\n            `${Utils.escapeHtml(key)}=\"${Utils.escapeHtml(String(value))}\"`\n        )\n        .join(\" \");\n      htmlParts.push(`<body ${bodyAttrs}>`);\n      if (\n        composition.body_elements &&\n        Array.isArray(composition.body_elements)\n      ) {\n        for (const el of composition.body_elements) {\n          if (el.type === \"artifact_id\" && el.id) {\n            const meta = StateManager.getArtifactMetadata(el.id);\n            const content = meta\n              ? Storage.getArtifactContent(\n                  el.id,\n                  meta.latestCycle,\n                  meta.version_id\n                )\n              : null;\n            if (content !== null) {\n              htmlParts.push(content);\n              UI.displayCycleArtifact(\n                `Loaded Body Artifact: ${el.id}`,\n                Utils.trunc(content, 100),\n                \"info\",\n                false,\n                critiqueSource,\n                el.id,\n                nextCycleNum\n              );\n            } else {\n              logger.logEvent(\n                \"warn\",\n                `Body artifact ${el.id} not found for page_composition.`\n              );\n              htmlParts.push(`<!-- Body artifact ${el.id} not found -->`);\n            }\n          } else if (el.type === \"web_component_tag\" && el.tag) {\n            const wcAttrsObj = el.attributes || {};\n            const wcAttrs = Object.entries(wcAttrsObj)\n              .map(\n                ([key, value]) =>\n                  `${Utils.escapeHtml(key)}=\"${Utils.escapeHtml(\n                    String(value)\n                  )}\"`\n              )\n              .join(\" \");\n            htmlParts.push(`<${el.tag} ${wcAttrs}></${el.tag}>`);\n          } else if (el.type === \"inline_html\" && el.content)\n            htmlParts.push(el.content);\n        }\n      }\n      if (\n        composition.script_references &&\n        Array.isArray(composition.script_references)\n      ) {\n        for (const ref of composition.script_references) {\n          const scriptAttrsList = [];\n          if (ref.attributes) {\n            if (ref.attributes.defer) scriptAttrsList.push(\"defer\");\n            if (ref.attributes.async) scriptAttrsList.push(\"async\");\n            Object.entries(ref.attributes).forEach(([key, value]) => {\n              if (\n                ![\"defer\", \"async\", \"src\"].includes(key) &&\n                value !== undefined\n              )\n                scriptAttrsList.push(\n                  `${Utils.escapeHtml(key)}=\"${Utils.escapeHtml(\n                    String(value)\n                  )}\"`\n                );\n            });\n          }\n          const scriptAttrs = scriptAttrsList.join(\" \");\n          if (ref.type === \"artifact_id\" && ref.id) {\n            const meta = StateManager.getArtifactMetadata(ref.id);\n            const content = meta\n              ? Storage.getArtifactContent(\n                  ref.id,\n                  meta.latestCycle,\n                  meta.version_id\n                )\n              : null;\n            if (content !== null) {\n              htmlParts.push(`<script ${scriptAttrs}>${content}</script>`);\n              UI.displayCycleArtifact(\n                `Inlined Script Artifact: ${ref.id}`,\n                `(${content.length} chars)`,\n                \"info\",\n                false,\n                critiqueSource,\n                ref.id,\n                nextCycleNum\n              );\n            } else {\n              logger.logEvent(\n                \"warn\",\n                `Script artifact ${ref.id} not found for inlining.`\n              );\n              htmlParts.push(`<!-- Script artifact ${ref.id} not found -->`);\n            }\n          } else if (ref.type === \"path\" && ref.src)\n            htmlParts.push(\n              `<script src=\"${Utils.escapeHtml(\n                ref.src\n              )}\" ${scriptAttrs}></script>`\n            );\n        }\n      }\n      htmlParts.push(\"</body></html>\");\n      const assembledHtml = htmlParts.join(\"\\n\");\n      logger.logEvent(\n        \"info\",\n        `Successfully assembled HTML from page_composition (${assembledHtml.length} chars).`\n      );\n      UI.displayCycleArtifact(\n        \"Assembled Page Composition (Preview)\",\n        Utils.trunc(assembledHtml, 500),\n        \"output\",\n        true,\n        critiqueSource,\n        \"page_composition_output\",\n        nextCycleNum\n      );\n      return assembledHtml;\n    } catch (error) {\n      logger.logEvent(\n        \"error\",\n        \"Failed to assemble HTML from page_composition\",\n        error\n      );\n      throw new ApplicationError(\n        \"HTML assembly from page_composition failed.\",\n        { originalError: error.message || String(error), composition }\n      );\n    }\n  };\n\n  const _applyArtifactChanges = async (\n    artifactChanges,\n    nextCycleNum,\n    critiqueSource,\n    state,\n    changesMade,\n    errors\n  ) => {\n    const {\n      modified,\n      new: newArtifacts,\n      deleted,\n      modular,\n      full_html_source,\n      page_composition,\n    } = artifactChanges || {};\n    let requiresSandbox = false;\n\n    if (page_composition && state.cfg?.enablePageComposition === true) {\n      try {\n        const assembledHtml = await _assembleHtmlFromPageComposition(\n          page_composition,\n          nextCycleNum,\n          critiqueSource,\n          state\n        );\n        StateManager.updateAndSaveState((s) => {\n          s.lastGeneratedFullSource = assembledHtml;\n          return s;\n        });\n        changesMade.push(\"Generated Page Composition (Sandbox Required)\");\n        UI.displayCycleArtifact(\n          \"Proposed Page Composition Structure\",\n          JSON.stringify(page_composition, null, 2),\n          \"info\",\n          true,\n          critiqueSource,\n          \"page_composition_input\",\n          state.totalCycles\n        );\n        requiresSandbox = true;\n      } catch (e) {\n        errors.push(`Failed to process page_composition: ${e.message}`);\n        logger.logEvent(\"error\", \"Page Composition processing error\", e);\n        UI.displayCycleArtifact(\n          \"Page Composition Error\",\n          e.message,\n          \"error\",\n          false,\n          critiqueSource,\n          \"page_composition_error\",\n          state.totalCycles\n        );\n      }\n    } else if (full_html_source) {\n      StateManager.updateAndSaveState((s) => {\n        s.lastGeneratedFullSource = full_html_source;\n        return s;\n      });\n      changesMade.push(\"Generated Full HTML (Sandbox Required)\");\n      UI.displayCycleArtifact(\n        \"Full HTML Source (Prepared for Sandbox)\",\n        `(${full_html_source.length} chars)`,\n        \"output\",\n        true,\n        critiqueSource,\n        \"full_html_output\",\n        state.totalCycles\n      );\n      requiresSandbox = true;\n    }\n\n    for (const modArt of modified || []) {\n      if (!modArt.id || modArt.content === undefined) {\n        errors.push(\n          `Invalid modified artifact structure: ID=${modArt.id || \"?\"}`\n        );\n        continue;\n      }\n      const currentMeta = StateManager.getArtifactMetadata(modArt.id);\n      if (!currentMeta) {\n        errors.push(`Modify failed (original not found): ${modArt.id}`);\n        continue;\n      }\n      const currentContent = Storage.getArtifactContent(\n        modArt.id,\n        currentMeta.latestCycle,\n        currentMeta.version_id\n      );\n      if (currentContent === null) {\n        errors.push(\n          `Modify failed (original content missing): ${modArt.id} C${\n            currentMeta.latestCycle\n          } V${currentMeta.version_id || \"def\"}`\n        );\n        continue;\n      }\n      if (currentContent !== modArt.content) {\n        try {\n          const checksum = await Utils.calculateChecksum(modArt.content);\n          Storage.setArtifactContent(\n            modArt.id,\n            nextCycleNum,\n            modArt.content,\n            modArt.version_id\n          );\n          StateManager.updateArtifactMetadata(\n            modArt.id,\n            currentMeta.type,\n            currentMeta.description,\n            nextCycleNum,\n            checksum,\n            critiqueSource,\n            modArt.version_id,\n            false,\n            currentMeta.paradigm\n          );\n          changesMade.push(\n            `Modified: ${modArt.id}${\n              modArt.version_id ? \"#\" + modArt.version_id : \"\"\n            }`\n          );\n          UI.displayCycleArtifact(\n            `Modified Artifact${\n              modArt.version_id ? \" (V: \" + modArt.version_id + \")\" : \"\"\n            }`,\n            Utils.trunc(modArt.content, 200),\n            \"output\",\n            true,\n            critiqueSource,\n            modArt.id,\n            nextCycleNum\n          );\n          if (modArt.id.startsWith(\"reploid.\"))\n            logger.logEvent(\"warn\", `Core artifact ${modArt.id} modified.`);\n        } catch (e) {\n          errors.push(`Failed save mod ${modArt.id}: ${e.message}`);\n        }\n      } else {\n        UI.displayCycleArtifact(\n          `Modified (No Change)${\n            modArt.version_id ? \" (V: \" + modArt.version_id + \")\" : \"\"\n          }`,\n          Utils.trunc(currentContent, 200),\n          \"info\",\n          false,\n          critiqueSource,\n          modArt.id,\n          currentMeta.latestCycle\n        );\n      }\n    }\n    for (const newArt of newArtifacts || []) {\n      if (!newArt.id || !newArt.type || newArt.content === undefined) {\n        errors.push(`Invalid new artifact structure: ID=${newArt.id || \"?\"}`);\n        continue;\n      }\n      try {\n        const checksum = await Utils.calculateChecksum(newArt.content);\n        Storage.setArtifactContent(\n          newArt.id,\n          nextCycleNum,\n          newArt.content,\n          newArt.version_id\n        );\n        StateManager.updateArtifactMetadata(\n          newArt.id,\n          newArt.type,\n          newArt.description || `New ${newArt.type}`,\n          nextCycleNum,\n          checksum,\n          critiqueSource,\n          newArt.version_id,\n          false,\n          newArt.paradigm\n        );\n        changesMade.push(\n          `Created: ${newArt.id}${\n            newArt.version_id ? \"#\" + newArt.version_id : \"\"\n          } (${newArt.type})`\n        );\n        UI.displayCycleArtifact(\n          `New Artifact${\n            newArt.version_id ? \" (V: \" + newArt.version_id + \")\" : \"\"\n          }`,\n          Utils.trunc(newArt.content, 200),\n          \"output\",\n          true,\n          critiqueSource,\n          newArt.id,\n          nextCycleNum\n        );\n      } catch (e) {\n        errors.push(`Failed save new ${newArt.id}: ${e.message}`);\n      }\n    }\n    for (const idToDelete of deleted || []) {\n      const meta = StateManager.getArtifactMetadata(idToDelete);\n      if (meta) {\n        const allVersions =\n          StateManager.getArtifactMetadataAllVersions(idToDelete);\n        allVersions.forEach((v) =>\n          Storage.deleteArtifactVersion(idToDelete, v.latestCycle, v.version_id)\n        );\n        StateManager.deleteArtifactMetadata(idToDelete);\n        changesMade.push(`Deleted: ${idToDelete} (All versions)`);\n        UI.displayCycleArtifact(\n          \"Deleted Artifact (All Versions)\",\n          idToDelete,\n          \"output\",\n          true,\n          critiqueSource\n        );\n      } else {\n        errors.push(`Delete failed (not found): ${idToDelete}`);\n      }\n    }\n    for (const modEdit of modular || []) {\n      if (!modEdit.id || !modEdit.patch_content || !modEdit.patch_format) {\n        errors.push(`Invalid modular edit structure: ID=${modEdit.id || \"?\"}`);\n        continue;\n      }\n      UI.displayCycleArtifact(\n        `Modular Edit Proposed${\n          modEdit.version_id ? \" (V: \" + modEdit.version_id + \")\" : \"\"\n        }`,\n        JSON.stringify(modEdit, null, 2),\n        \"info\",\n        true,\n        critiqueSource,\n        modEdit.id,\n        nextCycleNum\n      );\n      try {\n        const baseMeta = StateManager.getArtifactMetadata(modEdit.id);\n        if (!baseMeta)\n          throw new ArtifactError(\n            `Base artifact not found: ${modEdit.id}`,\n            modEdit.id\n          );\n        const baseContent = Storage.getArtifactContent(\n          modEdit.id,\n          baseMeta.latestCycle,\n          baseMeta.version_id\n        );\n        if (baseContent === null)\n          throw new ArtifactError(\n            `Base content missing for ${modEdit.id}`,\n            modEdit.id,\n            baseMeta.latestCycle\n          );\n        let toolToRun = null;\n        let toolArgs = {\n          artifactId: modEdit.id,\n          cycle: baseMeta.latestCycle,\n          versionId: baseMeta.version_id,\n          patchContent: modEdit.patch_content,\n        };\n        if (\n          modEdit.patch_format.toLowerCase() === \"diff\" ||\n          modEdit.patch_format.toLowerCase() === \"unified-diff\"\n        )\n          toolToRun = \"apply_diff_patch\";\n        else if (\n          modEdit.patch_format.toLowerCase() === \"json-patch\" ||\n          modEdit.patch_format.toLowerCase() === \"rfc6902\"\n        ) {\n          toolToRun = \"apply_json_patch\";\n          try {\n            toolArgs.patchContent = JSON.parse(modEdit.patch_content);\n          } catch {\n            toolArgs.patchContent = modEdit.patch_content;\n          }\n        } else if (\n          modEdit.patch_format.toLowerCase() === \"replace-function\" ||\n          modEdit.patch_format.toLowerCase() === \"replace-block\"\n        ) {\n          toolToRun = \"apply_block_replacement\";\n          toolArgs.target_block = modEdit.target_block;\n        } else\n          throw new ToolError(\n            `Unsupported patch format: ${modEdit.patch_format}`,\n            \"apply_modular_edit\",\n            toolArgs\n          );\n        const patchResult = await ToolRunner.runTool(\n          toolToRun,\n          toolArgs,\n          loadedStaticTools,\n          state.dynamicTools || [],\n          {}\n        );\n        if (!patchResult || !patchResult.success)\n          throw new ToolError(\n            `Patch tool '${toolToRun}' failed: ${\n              patchResult?.error || \"Unknown tool error\"\n            }`,\n            toolToRun,\n            toolArgs,\n            patchResult\n          );\n        const patchedContent = patchResult.result_content;\n        const checksum = await Utils.calculateChecksum(patchedContent);\n        Storage.setArtifactContent(\n          modEdit.id,\n          nextCycleNum,\n          patchedContent,\n          modEdit.version_id\n        );\n        StateManager.updateArtifactMetadata(\n          modEdit.id,\n          baseMeta.type,\n          baseMeta.description,\n          nextCycleNum,\n          checksum,\n          critiqueSource,\n          modEdit.version_id,\n          true,\n          baseMeta.paradigm\n        );\n        changesMade.push(\n          `Modular Edit: ${modEdit.id}${\n            modEdit.version_id ? \"#\" + modEdit.version_id : \"\"\n          } (${modEdit.patch_format})`\n        );\n        UI.displayCycleArtifact(\n          `Modular Edit Applied${\n            modEdit.version_id ? \" (V: \" + modEdit.version_id + \")\" : \"\"\n          }`,\n          Utils.trunc(patchedContent, 200),\n          \"output\",\n          true,\n          critiqueSource,\n          modEdit.id,\n          nextCycleNum\n        );\n      } catch (e) {\n        errors.push(`Failed apply modular edit ${modEdit.id}: ${e.message}`);\n        UI.displayCycleArtifact(\n          `Modular Edit Failed ${modEdit.id}`,\n          e.message,\n          \"error\",\n          false,\n          critiqueSource\n        );\n      }\n    }\n    return { requiresSandbox };\n  };\n\n  const _applyToolDefinitionChanges = (\n    newTools,\n    critiqueSource,\n    state,\n    changesMade,\n    errors,\n    currentCycleNum\n  ) => {\n    (newTools || []).forEach((tool) => {\n      const decl = tool.declaration;\n      const impl = tool.implementation;\n      const paradigm = tool.suggested_paradigm || \"semi-pure\";\n      if (\n        !decl ||\n        !impl ||\n        !decl.name ||\n        !decl.description ||\n        !decl.inputSchema\n      ) {\n        errors.push(`Invalid new tool structure: Name=${decl?.name || \"?\"}`);\n        UI.displayCycleArtifact(\n          \"Invalid Tool Def\",\n          JSON.stringify(tool),\n          \"error\",\n          false,\n          critiqueSource\n        );\n        return;\n      }\n      UI.displayCycleArtifact(\n        `Proposed Tool Decl: ${decl.name}`,\n        JSON.stringify(decl, null, 2),\n        \"output\",\n        true,\n        critiqueSource\n      );\n      UI.displayCycleArtifact(\n        `Generated Tool Impl: ${decl.name} (Paradigm: ${paradigm})`,\n        impl,\n        \"output\",\n        true,\n        critiqueSource\n      );\n      if (\n        !impl.includes(\"async function run(params)\") &&\n        !impl.includes(\"async (params)\") &&\n        !impl.includes(\"run = async (params)\")\n      ) {\n        errors.push(\n          `Generated tool implementation for ${decl.name} missing valid async run(params) function.`\n        );\n        UI.logToTimeline(\n          currentCycleNum,\n          `[APPLY ERR] Tool impl ${decl.name} invalid structure.`,\n          \"error\",\n          true\n        );\n      } else {\n        StateManager.updateAndSaveState((s) => {\n          const dynamicTools = s.dynamicTools || [];\n          const existingIndex = dynamicTools.findIndex(\n            (t) => t.declaration.name === decl.name\n          );\n          const toolEntry = {\n            declaration: decl,\n            implementation: impl,\n            paradigm: paradigm,\n          };\n          let toolChangeType = \"\";\n          if (existingIndex !== -1) {\n            dynamicTools[existingIndex] = toolEntry;\n            toolChangeType = `Tool Updated: ${decl.name}`;\n          } else {\n            dynamicTools.push(toolEntry);\n            toolChangeType = `Tool Defined: ${decl.name}`;\n          }\n          s.dynamicTools = dynamicTools;\n          changesMade.push(toolChangeType);\n          UI.logToTimeline(\n            currentCycleNum,\n            `[ARTIFACT] ${toolChangeType}`,\n            \"info\",\n            true\n          );\n          return s;\n        });\n      }\n    });\n  };\n\n  const _applyLLMChanges = async (llmResp, currentCycleNum, critiqueSource) => {\n    UI.highlightCoreStep(6);\n    let state = StateManager.getState();\n    if (!state)\n      return {\n        success: false,\n        errors: [\"State not initialized\"],\n        nextCycle: currentCycleNum,\n        requiresSandbox: false,\n        changes: [],\n      };\n    let changesMade = [];\n    let errors = [];\n    currentLlmResponse = llmResp;\n    const nextCycleNum = currentCycleNum + 1;\n    const { requiresSandbox } = await _applyArtifactChanges(\n      llmResp.artifact_changes,\n      nextCycleNum,\n      critiqueSource,\n      state,\n      changesMade,\n      errors\n    );\n    _applyToolDefinitionChanges(\n      llmResp.proposed_new_tools,\n      critiqueSource,\n      state,\n      changesMade,\n      errors,\n      currentCycleNum\n    ); // state is passed for read, changes are applied via StateManager.updateAndSaveState inside\n\n    state = StateManager.getState(); // Re-fetch state as _applyToolDefinitionChanges might have updated it\n    const success = errors.length === 0;\n    if (success) {\n      StateManager.updateAndSaveState((s) => {\n        if (!requiresSandbox) {\n          s.totalCycles = nextCycleNum;\n          s.agentIterations++;\n        }\n        const confidence = llmResp.agent_confidence_score ?? 0.0;\n        s.confidenceHistory.push(confidence);\n        if (s.confidenceHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.confidenceHistory.shift();\n        return s;\n      });\n    } else {\n      StateManager.updateAndSaveState((s) => {\n        s.failCount = (s.failCount || 0) + 1;\n        s.failHistory = s.failHistory || [];\n        s.failHistory.push({\n          cycle: currentCycleNum,\n          reason: `Apply Error: ${errors.join(\", \")}`,\n        });\n        if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.failHistory.shift();\n        return s;\n      });\n    }\n    const targetArtifactChanged = changesMade.some(\n      (c) =>\n        c.includes(\"target.\") ||\n        c.includes(\"reploid.\") ||\n        c.includes(\"Full HTML\") ||\n        c.includes(\"Page Composition\")\n    );\n    if (targetArtifactChanged && success && !requiresSandbox)\n      UI.logToTimeline(\n        currentCycleNum,\n        `[APPLY] Applying changes for Cycle ${nextCycleNum}.`,\n        \"info\",\n        true\n      );\n    UI.logToTimeline(\n      currentCycleNum,\n      `[APPLY] Changes applied for Cycle ${nextCycleNum} from ${critiqueSource}: ${\n        changesMade.join(\", \") || \"None\"\n      }. Errors: ${errors.length}`,\n      errors.length > 0 ? \"warn\" : \"info\",\n      true\n    );\n    return {\n      success: success,\n      changes: changesMade,\n      errors: errors,\n      nextCycle: success && !requiresSandbox ? nextCycleNum : currentCycleNum,\n      requiresSandbox: requiresSandbox,\n    };\n  };\n\n  const _checkHitlTriggersContext = (\n    state,\n    cycleTimeSecs,\n    confidence,\n    currentCycle,\n    llmResponse\n  ) => {\n    const proposedCoreChanges =\n      state.cfg?.hitlOnMetaChanges === true &&\n      llmResponse?.response &&\n      getActiveGoalInfo().type === \"Meta\" &&\n      (llmResponse.response.artifact_changes?.modified?.some(\n        (a) =>\n          a.id.startsWith(\"reploid.core.\") &&\n          StateManager.getArtifactMetadata(a.id)?.paradigm?.startsWith(\n            \"boundary\"\n          )\n      ) ||\n        llmResponse.response.artifact_changes?.new?.some(\n          (a) =>\n            a.id.startsWith(\"reploid.core.\") &&\n            a.paradigm?.startsWith(\"boundary\")\n        ) ||\n        llmResponse.response.artifact_changes?.deleted?.some(\n          (id) =>\n            id.startsWith(\"reploid.core.\") &&\n            StateManager.getArtifactMetadata(id)?.paradigm?.startsWith(\n              \"boundary\"\n            )\n        ) ||\n        llmResponse.response.artifact_changes?.modular?.some(\n          (a) =>\n            a.id.startsWith(\"reploid.core.\") &&\n            StateManager.getArtifactMetadata(a.id)?.paradigm?.startsWith(\n              \"boundary\"\n            )\n        ) ||\n        llmResponse.response.artifact_changes?.full_html_source ||\n        llmResponse.response.artifact_changes?.page_composition ||\n        llmResponse.response.tool_calls?.some(\n          (tc) =>\n            tc.name === \"define_web_component\" &&\n            tc.arguments?.targetArtifactId?.startsWith(\"reploid.core.\")\n        ));\n\n    return AgentLogicPureHelpers.checkHitlTriggersPure(\n      currentCycle,\n      state.cfg?.pauseAfterCycles || 0,\n      (state.cfg?.humanReviewProb ?? 0) / 100.0,\n      cycleTimeSecs,\n      state.cfg?.maxCycleTime ?? 600,\n      confidence,\n      state.cfg?.autoCritiqueThresh ?? 0.75,\n      state.forceHumanReview,\n      getActiveGoalInfo().type,\n      state.cfg?.hitlOnMetaChanges === true,\n      proposedCoreChanges\n    );\n  };\n\n  const _performCritique = async (\n    state,\n    llmResponse,\n    goalInfo,\n    currentCycle\n  ) => {\n    const llmProb = (state.cfg?.llmCritiqueProb ?? 50) / 100.0;\n    let overallPassed = false;\n    let combinedReport = \"Critique Skipped\";\n    let applySource = \"critique-skipped\";\n    let displayApplySource = \"Critique Skipped\";\n    let allCritiques = [];\n\n    if (Math.random() < llmProb) {\n      UI.logToTimeline(\n        currentCycle,\n        \"[DECIDE] Triggering Auto Critique...\",\n        \"decide\",\n        true\n      );\n      UI.logCoreLoopStep(currentCycle, 5, \"Critique: Auto\");\n      const multiCritiqueResult = await _runAutoCritique(\n        state.apiKey,\n        llmResponse.response,\n        goalInfo,\n        currentCycle\n      );\n      allCritiques = multiCritiqueResult.critiques;\n      overallPassed = multiCritiqueResult.overall_passed;\n      combinedReport = multiCritiqueResult.combined_report;\n\n      displayApplySource = `AutoCrit (${allCritiques.length} runs) ${\n        overallPassed ? \"Pass\" : \"Fail\"\n      }`;\n      applySource = `autocrit-${allCritiques.length}runs-${\n        overallPassed ? \"pass\" : \"fail\"\n      }`;\n\n      StateManager.updateAndSaveState((s) => {\n        s.lastCritiqueType = `Automated (${overallPassed ? \"Pass\" : \"Fail\"})`;\n        if (!s.critiqueFailHistory) s.critiqueFailHistory = [];\n        s.critiqueFailHistory.push(!overallPassed);\n        if (s.critiqueFailHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.critiqueFailHistory.shift();\n        return s;\n      });\n      UI.displayCycleArtifact(\n        \"Auto Critique Combined Report\",\n        combinedReport,\n        overallPassed ? \"info\" : \"error\",\n        false,\n        \"LLM\",\n        \"critique.combined_report\",\n        currentCycle\n      );\n    } else {\n      overallPassed = true;\n      StateManager.updateAndSaveState((s) => {\n        s.lastCritiqueType = \"Skipped\";\n        if (!s.critiqueFailHistory) s.critiqueFailHistory = [];\n        s.critiqueFailHistory.push(false);\n        if (s.critiqueFailHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.critiqueFailHistory.shift();\n        return s;\n      });\n      UI.logCoreLoopStep(currentCycle, 5, \"Critique: Skipped\");\n      UI.logToTimeline(\n        currentCycle,\n        \"[DECIDE] Critique Skipped.\",\n        \"info\",\n        true\n      );\n    }\n    return {\n      critiquePassed: overallPassed,\n      critiqueReport: combinedReport,\n      applySource: applySource,\n      displayApplySource: displayApplySource,\n      critiques: allCritiques,\n    };\n  };\n\n  const _handleCritiqueDecision = async (\n    state,\n    llmResponse,\n    goalInfo,\n    currentCycle\n  ) => {\n    UI.highlightCoreStep(4);\n    const cycleTimeMillis = llmResponse.cycleTimeMillis || 0;\n    const cycleSecs = cycleTimeMillis / 1000;\n    const confidence = llmResponse.response?.agent_confidence_score ?? 0.0;\n    const hitlTrigger = _checkHitlTriggersContext(\n      state,\n      cycleSecs,\n      confidence,\n      currentCycle,\n      llmResponse\n    );\n    UI.logToTimeline(\n      currentCycle,\n      `[DECIDE] Time:${cycleSecs.toFixed(1)}s, Conf:${confidence.toFixed(\n        2\n      )}. Human: ${hitlTrigger ? hitlTrigger.reason : \"No\"}.`,\n      \"decide\",\n      true\n    );\n    if (hitlTrigger) {\n      StateManager.updateAndSaveState((s) => {\n        s.lastCritiqueType = `Human (${hitlTrigger.reason})`;\n        s.forceHumanReview = false;\n        if (s.critiqueFailHistory) s.critiqueFailHistory.push(false);\n        if (s.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.critiqueFailHistory.shift();\n        return s;\n      });\n      UI.logCoreLoopStep(\n        currentCycle,\n        5,\n        `Critique: Human Intervention (${hitlTrigger.reason})`\n      );\n      UI.updateStatus(`Paused: Human Review (${hitlTrigger.reason})`);\n      const primaryModId =\n        llmResponse.response?.artifact_changes?.modified?.[0]?.id;\n      const primaryNewId = llmResponse.response?.artifact_changes?.new?.[0]?.id;\n      const primaryModularId =\n        llmResponse.response?.artifact_changes?.modular?.[0]?.id;\n      const hasFullSource =\n        !!llmResponse.response?.artifact_changes?.full_html_source ||\n        !!llmResponse.response?.artifact_changes?.page_composition;\n      const artifactToEdit =\n        primaryModId ||\n        primaryNewId ||\n        primaryModularId ||\n        (hasFullSource\n          ? llmResponse.response.artifact_changes.page_composition\n            ? \"page_composition_preview\"\n            : \"full_html_source\"\n          : null);\n      UI.showHumanInterventionUI(\n        hitlTrigger.mode,\n        hitlTrigger.reason,\n        [],\n        artifactToEdit,\n        []\n      );\n      return {\n        status: \"HITL_REQUIRED\",\n        critiquePassed: false,\n        critiqueReport: `Human Intervention: ${hitlTrigger.reason}`,\n      };\n    }\n    const critiqueResult = await _performCritique(\n      state,\n      llmResponse,\n      goalInfo,\n      currentCycle\n    );\n    if (!critiqueResult.critiquePassed) {\n      UI.logToTimeline(\n        currentCycle,\n        \"[STATE] Auto-Critique failed. Forcing HITL.\",\n        \"warn\",\n        true\n      );\n      StateManager.updateAndSaveState((s) => {\n        s.failCount = (s.failCount || 0) + 1;\n        s.failHistory = s.failHistory || [];\n        s.failHistory.push({\n          cycle: currentCycle,\n          reason: `Critique Failed: ${Utils.trunc(\n            critiqueResult.critiqueReport,\n            100\n          )}`,\n        });\n        if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.failHistory.shift();\n        return s;\n      });\n      UI.showHumanInterventionUI(\n        \"critique_feedback\",\n        `Auto Critique Failed: ${Utils.trunc(\n          critiqueResult.critiqueReport,\n          150\n        )}...`,\n        [],\n        null,\n        critiqueResult.critiques\n      );\n      return {\n        status: \"HITL_REQUIRED\",\n        critiquePassed: false,\n        critiqueReport: critiqueResult.critiqueReport,\n      };\n    }\n    return {\n      status: \"PROCEED\",\n      critiquePassed: critiqueResult.critiquePassed,\n      critiqueReport: critiqueResult.critiqueReport,\n      applySource: critiqueResult.applySource,\n    };\n  };\n\n  const _runSelfEvaluationStep = async (state, llmResponse, currentCycle) => {\n    UI.highlightCoreStep(7);\n    if (!llmResponse?.response) return;\n    const contentToEvaluate =\n      llmResponse.response.justification_persona_musing ||\n      \"(No justification provided)\";\n    if (contentToEvaluate === \"(No justification provided)\") {\n      logger.logEvent(\n        \"info\",\n        `Skipping self-evaluation for Cycle ${currentCycle}: No justification provided.`\n      );\n      UI.logToTimeline(\n        currentCycle,\n        \"[EVAL] Skipped (no justification).\",\n        \"info\",\n        true\n      );\n      return;\n    }\n    logger.logEvent(\n      \"info\",\n      `Running Self-Evaluation for Cycle ${currentCycle} justification`\n    );\n    UI.logToTimeline(\n      currentCycle,\n      \"[EVAL] Evaluating cycle justification...\",\n      \"eval\",\n      true\n    );\n    let evaluationCriteria = Storage.getArtifactContent(\n      \"reploid.core.default-eval\",\n      0\n    );\n    if (!evaluationCriteria) {\n      logger.logEvent(\n        \"warn\",\n        \"Default evaluation criteria artifact (reploid.core.default-eval) not found. Using basic criteria.\"\n      );\n      evaluationCriteria =\n        \"Evaluate if the justification accurately reflects the proposed changes and aligns with the goal context. Rate clarity and reasoning.\";\n    }\n    let evalCriteriaText = evaluationCriteria;\n    try {\n      const parsedCriteria = JSON.parse(evaluationCriteria);\n      if (\n        parsedCriteria.criteria &&\n        typeof parsedCriteria.criteria === \"string\"\n      )\n        evalCriteriaText = parsedCriteria.criteria;\n      else if (\n        parsedCriteria.criteria &&\n        Array.isArray(parsedCriteria.criteria)\n      )\n        evalCriteriaText = JSON.stringify(parsedCriteria.criteria);\n    } catch (e) {}\n    const goalContext =\n      getActiveGoalInfo().cumulativeGoal ||\n      getActiveGoalInfo().summaryContext ||\n      \"N/A\";\n    const targetArtifactId = \"llm.justification\";\n    const targetArtifactCycle = currentCycle;\n    try {\n      const uiHooks = {\n        updateStatus: UI.updateStatus,\n        logTimeline: UI.logToTimeline,\n        updateTimelineItem: UI.updateTimelineItem,\n      };\n      const evalResult = await ToolRunner.runTool(\n        \"run_self_evaluation\",\n        {\n          targetArtifactId,\n          targetArtifactCycle,\n          evalCriteriaText,\n          goalContextText: goalContext,\n          contentToEvaluate,\n        },\n        loadedStaticTools,\n        state.dynamicTools || [],\n        uiHooks\n      );\n      StateManager.addEvaluationResult(evalResult);\n      UI.logToTimeline(\n        currentCycle,\n        `[EVAL OK] Score: ${evalResult.evaluation_score.toFixed(\n          2\n        )}. Report: ${Utils.trunc(evalResult.evaluation_report, 60)}`,\n        \"eval\",\n        true\n      );\n      UI.displayCycleArtifact(\n        \"Self-Evaluation Result\",\n        JSON.stringify(evalResult, null, 2),\n        \"info\",\n        false,\n        \"System\",\n        \"eval.result\",\n        currentCycle\n      );\n    } catch (e) {\n      logger.logEvent(\"error\", `Self-evaluation step failed: ${e.message}`, e);\n      UI.logToTimeline(\n        currentCycle,\n        `[EVAL ERR] Failed: ${e.message}`,\n        \"error\",\n        true\n      );\n    }\n    UI.logToTimeline(\n      currentCycle,\n      \"[LEARN] Learning phase placeholder.\",\n      \"learn\",\n      true\n    );\n  };\n\n  const _prepareCycle = () => {\n    const state = StateManager.getState();\n    if (!state) throw new StateError(\"State not initialized!\");\n    if (!StateManager.isInitialized())\n      throw new StateError(\"StateManager lost initialization!\");\n    if (UI.isMetaSandboxPending()) {\n      UI.showNotification(\"Meta Sandbox approval pending.\", \"warn\");\n      throw new StateError(\"Sandbox Pending\");\n    }\n    if (!UI.isHumanInterventionHidden()) {\n      UI.showNotification(\"Human Intervention required.\", \"warn\");\n      throw new StateError(\"HITL Required\");\n    }\n    UI.clearCurrentCycleDetails();\n    currentLlmResponse = null;\n    _abortRequested = false;\n    const uiRefs = UI.getRefs();\n    let updatedState = StateManager.updateAndSaveState((s) => {\n      s.apiKey = uiRefs.apiKeyInput?.value.trim() || s.apiKey;\n      return s;\n    });\n    if (!updatedState.apiKey || updatedState.apiKey.length < 10)\n      throw new ConfigError(\"Valid Gemini API Key required.\", \"apiKey\");\n    UI.logCoreLoopStep(updatedState.totalCycles, 0, \"Define Goal\");\n    const goalText = uiRefs.goalInput?.value.trim() || \"\";\n    const goalTypeElement = document.querySelector(\n      'input[name=\"goalType\"]:checked'\n    );\n    const goalType = goalTypeElement ? goalTypeElement.value : \"System\";\n    if (!goalText && !updatedState.currentGoal?.seed)\n      throw new ApplicationError(\"Initial Goal required.\");\n    const maxC = updatedState.cfg?.maxCycles || 0;\n    if (\n      maxC > 0 &&\n      updatedState.totalCycles >= maxC &&\n      updatedState.autonomyMode !== \"Manual\"\n    )\n      throw new StateError(`Max cycles (${maxC}) reached.`);\n    if (\n      updatedState.autonomyMode === \"N_Cycles\" &&\n      updatedState.autonomyCyclesRemaining <= 0\n    ) {\n      logger.logEvent(\n        \"info\",\n        \"Autonomous run finished (N cycles complete). Switching to Manual.\"\n      );\n      updatedState = StateManager.updateAndSaveState((s) => {\n        s.autonomyMode = \"Manual\";\n        return s;\n      });\n      _isAutonomous = false;\n      UI.updateAutonomyControls(updatedState.autonomyMode, false);\n      throw new StateError(\"Autonomy N Cycles Finished\");\n    }\n    if (updatedState.autonomyMode !== \"Manual\") {\n      _isAutonomous = true;\n      if (updatedState.autonomyMode === \"N_Cycles\")\n        updatedState = StateManager.updateAndSaveState((s) => {\n          s.autonomyCyclesRemaining--;\n          return s;\n        });\n    } else {\n      _isAutonomous = false;\n    }\n    if (updatedState.contextTokenEstimate >= updatedState.contextTokenTarget)\n      UI.showNotification(\"Context tokens high. Consider summarizing.\", \"warn\");\n    const currentCycle = updatedState.totalCycles;\n    const newGoalProvided = !!goalText;\n    if (newGoalProvided) {\n      updatedState = StateManager.updateAndSaveState((s) => {\n        if (!s.currentGoal?.seed)\n          s.currentGoal = {\n            seed: goalText,\n            cumulative: goalText,\n            latestType: goalType,\n            summaryContext: null,\n            currentContextFocus: null,\n          };\n        else {\n          s.currentGoal.cumulative =\n            (s.currentGoal.cumulative || s.currentGoal.seed || \"\") +\n            `\\n\\n[Cycle ${currentCycle} Refinement (${goalType})]: ${goalText}`;\n          s.currentGoal.latestType = goalType;\n          s.currentGoal.summaryContext = null;\n          s.currentGoal.currentContextFocus = null;\n        }\n        return s;\n      });\n      UI.displayCycleArtifact(\n        \"New Goal Input\",\n        `${goalType}: ${goalText}`,\n        \"input\",\n        false,\n        \"User\",\n        \"goal.input\",\n        currentCycle\n      );\n      if (uiRefs.goalInput) uiRefs.goalInput.value = \"\";\n    } else if (\n      !updatedState.currentGoal?.seed &&\n      !updatedState.currentGoal?.cumulative\n    )\n      throw new ApplicationError(\"No active goal context.\");\n    const goalInfo = getActiveGoalInfo(); // Uses the latest state from StateManager\n    updatedState = StateManager.updateAndSaveState((s) => {\n      s.retryCount = 0;\n      s.personaMode = (s.cfg?.personaBalance ?? 50) >= 50 ? \"LSD\" : \"XYZ\";\n      return s;\n    });\n    UI.updateStatus(\"Starting Cycle...\", true);\n    if (uiRefs.currentCycleNumber)\n      uiRefs.currentCycleNumber.textContent = currentCycle;\n    UI.updateStateDisplay();\n    UI.logToTimeline(\n      currentCycle,\n      `[CYCLE] === Cycle ${currentCycle} Start === Goal: ${goalInfo.type}, Persona: ${updatedState.personaMode}, Auto: ${updatedState.autonomyMode}`\n    );\n    UI.logToTimeline(\n      currentCycle,\n      `[GOAL] Latest: \"${Utils.trunc(goalInfo.latestGoal, 70)}...\"`,\n      \"goal\",\n      true\n    );\n    UI.displayCycleArtifact(\n      \"Cumulative Goal\",\n      goalInfo.cumulativeGoal || \"(Not Set)\",\n      \"input\",\n      false,\n      \"System\",\n      \"goal.cumulative\",\n      currentCycle\n    );\n    if (goalInfo.summaryContext)\n      UI.displayCycleArtifact(\n        \"Summary Context\",\n        goalInfo.summaryContext,\n        \"input\",\n        false,\n        \"System\",\n        \"meta.summary_context\",\n        currentCycle\n      );\n    if (goalInfo.currentContextFocus)\n      UI.displayCycleArtifact(\n        \"Context Focus\",\n        goalInfo.currentContextFocus,\n        \"input\",\n        false,\n        \"LLM\",\n        \"meta.context_focus\",\n        currentCycle\n      );\n    return { state: updatedState, goalInfo, currentCycle };\n  };\n\n  const _handleCycleIterationFailure = async (state, error, currentCycle) => {\n    if (error instanceof AbortError || _abortRequested)\n      throw new AbortError(\"Aborted during iteration failure handling.\");\n    logger.logEvent(\n      \"error\",\n      `Iteration attempt ${state.retryCount} failed: ${error.message}`\n    );\n    let updatedState = StateManager.updateAndSaveState((s) => {\n      s.retryCount++;\n      return s;\n    });\n    const maxRetries = updatedState.cfg?.maxRetries ?? 1;\n    if (updatedState.retryCount > maxRetries) {\n      UI.logToTimeline(\n        currentCycle,\n        `[RETRY] Max retries (${maxRetries}) exceeded. Forcing HITL.`,\n        \"error\"\n      );\n      StateManager.updateAndSaveState((s) => {\n        s.failCount = (s.failCount || 0) + 1;\n        s.failHistory = s.failHistory || [];\n        s.failHistory.push({\n          cycle: currentCycle,\n          reason: `Max Retries: ${error.message || \"Unknown error\"}`,\n        });\n        if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.failHistory.shift();\n        return s;\n      });\n      if (_isAutonomous) {\n        logger.logEvent(\"warn\", \"Stopping autonomous run due to max retries.\");\n        stopAutonomousRun(\"Max retries reached\");\n      }\n      UI.showHumanInterventionUI(\n        \"prompt\",\n        `Cycle failed after ${updatedState.retryCount} attempts: ${\n          error.message || \"Unknown error\"\n        }`\n      );\n      throw new StateError(\"HITL Required due to max retries\");\n    } else {\n      UI.logToTimeline(\n        currentCycle,\n        `[RETRY] Attempting retry ${updatedState.retryCount}/${maxRetries}...`,\n        \"warn\",\n        true\n      );\n      StateManager.updateAndSaveState((s) => {\n        s.lastFeedback = `Retry ${s.retryCount}: ${\n          Utils.trunc(error.message, 100) || \"No response\"\n        }`;\n        return s;\n      });\n      await Utils.delay(1000 * updatedState.retryCount);\n    }\n  };\n\n  const _displayLlmIterationSuccessDetails = (\n    llmIterationResult,\n    currentCycle\n  ) => {\n    UI.logToTimeline(\n      currentCycle,\n      \"[STATE] Agent Iteration successful.\",\n      \"info\",\n      true\n    );\n    UI.highlightCoreStep(3);\n    if (\n      llmIterationResult.toolSummaries &&\n      llmIterationResult.toolSummaries.length > 0\n    )\n      UI.displayToolExecutionSummary(llmIterationResult.toolSummaries);\n    UI.displayCycleArtifact(\n      \"Agent Deliberation\",\n      llmIterationResult.response?.persona_analysis_musing || \"(N/A)\",\n      \"info\",\n      false,\n      \"LLM\",\n      \"llm.musing\",\n      currentCycle\n    );\n    UI.displayCycleArtifact(\n      \"Proposed Changes\",\n      llmIterationResult.response?.proposed_changes_description || \"(N/A)\",\n      \"info\",\n      false,\n      \"LLM\",\n      \"llm.proposal\",\n      currentCycle\n    );\n    UI.displayCycleArtifact(\n      \"Agent Justification\",\n      llmIterationResult.response?.justification_persona_musing || \"(N/A)\",\n      \"info\",\n      false,\n      \"LLM\",\n      \"llm.justification\",\n      currentCycle\n    );\n    UI.displayCycleArtifact(\n      \"Agent Confidence\",\n      llmIterationResult.response?.agent_confidence_score?.toFixed(3) ||\n        \"(N/A)\",\n      \"info\",\n      false,\n      \"LLM\",\n      \"llm.confidence\",\n      currentCycle\n    );\n    if (llmIterationResult.response?.current_context_focus)\n      UI.displayCycleArtifact(\n        \"Next Context Focus\",\n        llmIterationResult.response.current_context_focus,\n        \"info\",\n        false,\n        \"LLM\",\n        \"llm.context_focus\",\n        currentCycle\n      );\n  };\n\n  const _handleApplyFailure = (applyResult, critiqueDecision, currentCycle) => {\n    const errorReason = `Apply Failed: ${applyResult.errors.join(\", \")}`;\n    StateManager.updateAndSaveState((s) => {\n      s.lastFeedback = `${critiqueDecision.applySource}, ${errorReason}`;\n      s.failCount = (s.failCount || 0) + 1;\n      s.failHistory = s.failHistory || [];\n      s.failHistory.push({ cycle: currentCycle, reason: errorReason });\n      if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n        s.failHistory.shift();\n      return s;\n    });\n    UI.logToTimeline(\n      currentCycle,\n      `[APPLY ERR] Failed apply: ${applyResult.errors.join(\n        \", \"\n      )}. Forcing HITL.`,\n      \"error\"\n    );\n    if (_isAutonomous) {\n      logger.logEvent(\"warn\", \"Stopping autonomous run due to apply failure.\");\n      stopAutonomousRun(\"Apply failure\");\n    }\n    UI.showHumanInterventionUI(\n      \"prompt\",\n      `Failed apply after critique: ${applyResult.errors.join(\", \")}`\n    );\n    throw new StateError(\"HITL Required due to apply failure\");\n  };\n\n  const executeCycle = async () => {\n    if (_isRunning && !_isAutonomous) {\n      UI.showNotification(\n        \"Manual cycle start ignored: Cycle already running.\",\n        \"warn\"\n      );\n      return;\n    }\n    if (_abortRequested) {\n      logger.logEvent(\n        \"info\",\n        \"Cycle execution skipped due to pending abort request.\"\n      );\n      _abortRequested = false;\n      _isRunning = false;\n      if (UI.setRunButtonState) UI.setRunButtonState(\"Run Cycle\", false);\n      return;\n    }\n    _isRunning = true;\n    if (UI.setRunButtonState) UI.setRunButtonState(\"Abort Cycle\", false);\n    let state, goalInfo, currentCycle;\n    let cycleOutcome = \"Unknown\";\n    let llmIterationResult = null;\n    let applyResult = null;\n    let shouldContinueAutonomous = false;\n\n    try {\n      const prepResult = _prepareCycle();\n      state = prepResult.state;\n      goalInfo = prepResult.goalInfo;\n      currentCycle = prepResult.currentCycle;\n      let successfulIteration = false;\n      do {\n        if (_abortRequested)\n          throw new AbortError(\"Cycle aborted during LLM iteration loop.\");\n        UI.logToTimeline(\n          currentCycle,\n          `[STATE] Agent Iteration Attempt (Retry: ${state.retryCount})`,\n          \"info\",\n          true\n        );\n        llmIterationResult = await _runLlmIteration(\n          state,\n          goalInfo,\n          currentCycle\n        );\n        if (llmIterationResult.error) {\n          if (llmIterationResult.error instanceof AbortError)\n            throw llmIterationResult.error;\n          await _handleCycleIterationFailure(\n            state,\n            llmIterationResult.error,\n            currentCycle\n          );\n          state = StateManager.getState(); // Re-fetch state after potential update in failure handler\n        } else {\n          successfulIteration = true;\n          StateManager.updateAndSaveState((s) => {\n            s.retryCount = 0;\n            return s;\n          });\n          _displayLlmIterationSuccessDetails(llmIterationResult, currentCycle);\n        }\n      } while (!successfulIteration);\n      state = StateManager.getState(); // Ensure state is fresh before critique decision\n\n      const critiqueDecision = await _handleCritiqueDecision(\n        state,\n        llmIterationResult,\n        goalInfo,\n        currentCycle\n      );\n      if (_abortRequested)\n        throw new AbortError(\"Cycle aborted after critique decision.\");\n      if (critiqueDecision.status === \"HITL_REQUIRED\") {\n        cycleOutcome = `Paused (HITL: ${Utils.trunc(\n          critiqueDecision.critiqueReport.split(\":\")[0],\n          30\n        )})`;\n        if (_isAutonomous) stopAutonomousRun(\"HITL Required\");\n        throw new StateError(\"HITL Required\");\n      }\n\n      if (critiqueDecision.critiquePassed) {\n        UI.updateStatus(\"Applying Changes...\", true);\n        UI.logCoreLoopStep(currentCycle, 6, \"Refine & Apply\");\n        applyResult = await _applyLLMChanges(\n          llmIterationResult.response,\n          currentCycle,\n          critiqueDecision.applySource\n        );\n        if (_abortRequested)\n          throw new AbortError(\"Cycle aborted during apply changes.\");\n        state = StateManager.getState(); // Re-fetch state\n\n        if (applyResult.requiresSandbox) {\n          StateManager.updateAndSaveState((s) => {\n            s.lastCritiqueType = `${critiqueDecision.applySource} (Sandbox Pending)`;\n            return s;\n          });\n          if (_isAutonomous) stopAutonomousRun(\"Sandbox Required\");\n          UI.showMetaSandbox(state.lastGeneratedFullSource);\n          cycleOutcome = \"Paused (Sandbox Pending)\";\n          throw new StateError(\"Sandbox Pending\");\n        }\n        if (applyResult.success) {\n          StateManager.updateAndSaveState((s) => {\n            s.lastFeedback = `${critiqueDecision.applySource}, applied successfully for Cycle ${applyResult.nextCycle}.`;\n            return s;\n          });\n          cycleOutcome = `OK (${state.lastCritiqueType})`;\n          await _runSelfEvaluationStep(state, llmIterationResult, currentCycle);\n          if (_abortRequested)\n            throw new AbortError(\"Cycle aborted during self-evaluation.\");\n          UI.highlightCoreStep(8);\n          shouldContinueAutonomous = _isAutonomous && !_abortRequested;\n        } else _handleApplyFailure(applyResult, critiqueDecision, currentCycle);\n      } else {\n        logger.logEvent(\n          \"error\",\n          \"Reached unexpected state: critique failed but HITL not triggered.\"\n        );\n        cycleOutcome = \"Failed (Critique Logic Error)\";\n        if (_isAutonomous) stopAutonomousRun(\"Critique Logic Error\");\n        throw new ApplicationError(\"Critique Failed without HITL trigger\");\n      }\n    } catch (error) {\n      const knownStopNames = [\n        \"AbortError\",\n        \"StateError\",\n        \"ConfigError\",\n        \"ApiError\",\n        \"ToolError\",\n        \"ArtifactError\",\n      ];\n      const isKnownStopError =\n        error instanceof ApplicationError &&\n        knownStopNames.includes(error.name);\n      if (error instanceof AbortError) {\n        UI.logToTimeline(\n          currentCycle ?? 0,\n          `[CYCLE] Cycle aborted by user/system. Reason: ${error.message}`,\n          \"warn\"\n        );\n        cycleOutcome = \"Aborted\";\n        UI.updateStatus(\"Aborted\");\n        if (_isAutonomous) stopAutonomousRun(\"Aborted by user/system\");\n      } else if (\n        isKnownStopError &&\n        (error.message.includes(\"HITL Required\") ||\n          error.message.includes(\"Sandbox Pending\"))\n      ) {\n        logger.logEvent(\"info\", `Cycle paused: ${error.message}`);\n        if (!cycleOutcome || cycleOutcome === \"Unknown\")\n          cycleOutcome = `Paused (${error.message})`;\n      } else if (\n        isKnownStopError &&\n        error.message.includes(\"Max cycles reached\")\n      ) {\n        logger.logEvent(\"info\", `Cycle stopped: ${error.message}`);\n        cycleOutcome = \"Paused (Max Cycles Reached)\";\n        if (_isAutonomous) stopAutonomousRun(\"Max cycles reached\");\n      } else {\n        logger.logEvent(\n          \"error\",\n          `Unhandled cycle error (Cycle ${currentCycle ?? \"N/A\"}): ${\n            error.message\n          }`,\n          error.details || error\n        );\n        UI.showNotification(\n          `Cycle Error: ${Utils.trunc(error.message, 100)}`,\n          \"error\"\n        );\n        UI.logToTimeline(\n          currentCycle ?? 0,\n          `[CYCLE FATAL] ${Utils.trunc(error.message, 100)}`,\n          \"error\"\n        );\n        cycleOutcome = \"Failed (Fatal Error)\";\n        UI.updateStatus(\"Cycle Failed\", false, true);\n        if (_isAutonomous) stopAutonomousRun(\"Fatal Error\");\n      }\n      shouldContinueAutonomous = false;\n    } finally {\n      _isRunning = false;\n      _abortRequested = false;\n      if (!_isAutonomous || !shouldContinueAutonomous) {\n        if (UI.setRunButtonState) UI.setRunButtonState(\"Run Cycle\", false);\n      }\n      state = StateManager.getState();\n      if (state) {\n        StateManager.updateAndSaveState((s) => s); // This recalculates derived stats and saves\n        if (!UI.isMetaSandboxPending() && UI.isHumanInterventionHidden()) {\n          UI.summarizeCompletedCycleLog(cycleOutcome);\n          UI.updateStateDisplay();\n          UI.clearCurrentCycleDetails();\n          UI.logToTimeline(\n            state.totalCycles,\n            `[STATE] Cycle ended (${\n              state.lastCritiqueType || cycleOutcome\n            }). Ready.`\n          );\n          UI.updateStatus(\"Idle\");\n        } else {\n          UI.updateStateDisplay();\n        }\n      } else {\n        UI.updateStatus(\"Error - State Lost?\", false, true);\n        logger.logEvent(\n          \"critical\",\n          \"Global state became null during cycle finally block.\"\n        );\n      }\n      UI.highlightCoreStep(-1);\n    }\n\n    if (shouldContinueAutonomous) {\n      state = StateManager.getState();\n      logger.logEvent(\n        \"info\",\n        `Autonomous mode active. Triggering next cycle. Remaining: ${\n          state?.autonomyCyclesRemaining ?? \"N/A\"\n        }`\n      );\n      await Utils.delay(config.AUTONOMOUS_CYCLE_DELAY_MS || 500);\n      if (!_abortRequested) executeCycle();\n      else {\n        logger.logEvent(\n          \"info\",\n          \"Autonomous continuation cancelled due to abort request during delay.\"\n        );\n        if (_isAutonomous) stopAutonomousRun(\"Aborted during delay\");\n        else {\n          _isRunning = false;\n          if (UI.setRunButtonState) UI.setRunButtonState(\"Run Cycle\", false);\n        }\n      }\n    } else if (_isAutonomous && cycleOutcome !== \"Aborted\") {\n      logger.logEvent(\"info\", `Autonomous run ended. Reason: ${cycleOutcome}`);\n      stopAutonomousRun(cycleOutcome);\n    }\n  };\n\n  const proceedAfterHumanIntervention = async (\n    feedbackType,\n    feedbackData = \"\",\n    skipCycleIncrement = false\n  ) => {\n    let state = StateManager.getState();\n    if (!state) {\n      logger.logEvent(\"error\", \"Cannot proceed HITL, state missing.\");\n      return;\n    }\n    const currentCycle = state.totalCycles;\n    let nextCycle = currentCycle;\n    let feedbackMsg = String(feedbackData);\n    let applySuccess = true;\n    let requiresSandbox = false;\n\n    if (feedbackType === \"Human Code Edit\") {\n      const {\n        artifactId,\n        cycle,\n        versionId,\n        success,\n        validatedContent,\n        error,\n        contentChanged,\n      } = feedbackData;\n      feedbackMsg = `Edited ${artifactId}: ${\n        success\n          ? contentChanged\n            ? \"Applied successfully.\"\n            : \"No changes detected.\"\n          : `Validation Failed: ${error || \"Unknown\"}`\n      }`;\n      let isCodeEditSuccess = success && contentChanged;\n      if (\n        isCodeEditSuccess &&\n        artifactId !== \"full_html_source\" &&\n        artifactId !== \"page_composition_preview\"\n      ) {\n        nextCycle = currentCycle + 1;\n        try {\n          const checksum = await Utils.calculateChecksum(validatedContent);\n          Storage.setArtifactContent(\n            artifactId,\n            nextCycle,\n            validatedContent,\n            versionId\n          );\n          const currentMeta = StateManager.getArtifactMetadata(\n            artifactId,\n            versionId\n          );\n          StateManager.updateArtifactMetadata(\n            artifactId,\n            currentMeta?.type,\n            currentMeta?.description,\n            nextCycle,\n            checksum,\n            \"Human Edit\",\n            versionId,\n            false,\n            currentMeta?.paradigm\n          );\n          UI.displayCycleArtifact(\n            `Human Edit Applied${versionId ? \" (V: \" + versionId + \")\" : \"\"}`,\n            validatedContent,\n            \"info\",\n            true,\n            \"Human\",\n            artifactId,\n            nextCycle\n          );\n          logger.logEvent(\n            \"info\",\n            `Human edit applied to ${artifactId} for cycle ${nextCycle}`\n          );\n          UI.logToTimeline(\n            currentCycle,\n            `[HUMAN] Applied edit to ${artifactId} for cycle ${nextCycle}`,\n            \"human\",\n            true\n          );\n        } catch (e) {\n          logger.logEvent(\n            \"error\",\n            `Failed saving human edit for ${artifactId}: ${e.message}`,\n            e\n          );\n          UI.showNotification(`Failed saving edit: ${e.message}`, \"error\");\n          applySuccess = false;\n          nextCycle = currentCycle;\n        }\n      } else if (\n        (artifactId === \"full_html_source\" ||\n          artifactId === \"page_composition_preview\") &&\n        isCodeEditSuccess\n      ) {\n        logger.logEvent(\n          \"warn\",\n          \"Full source/Page Composition edited via HITL. Staging for sandbox.\"\n        );\n        StateManager.updateAndSaveState((s) => {\n          s.lastGeneratedFullSource = validatedContent;\n          return s;\n        });\n        applySuccess = true;\n        requiresSandbox = true;\n        skipCycleIncrement = true;\n        UI.showMetaSandbox(validatedContent);\n      } else if (!success) applySuccess = false;\n    } else if (feedbackType === \"Human Options\") {\n      feedbackMsg = `Selected: ${feedbackData || \"None\"}`;\n      applySuccess = true;\n    } else if (feedbackType === \"Sandbox Discarded\") {\n      feedbackMsg = \"User discarded sandbox changes.\";\n      applySuccess = true;\n    } else if (feedbackType === \"Human Prompt\") {\n      feedbackMsg = `Provided prompt: ${Utils.trunc(feedbackData, 100)}`;\n      applySuccess = true;\n    } else if (feedbackType === \"Human Critique Selection\") {\n      feedbackMsg = `User provided critique feedback. Selected: ${\n        feedbackData?.selectedCritique ?? \"N/A\"\n      }`;\n      StateManager.addCritiqueFeedback(feedbackData);\n      logger.logEvent(\n        \"info\",\n        `Received critique feedback: ${JSON.stringify(feedbackData)}`\n      );\n      applySuccess = true;\n    }\n\n    state = StateManager.updateAndSaveState((s) => {\n      s.lastFeedback = `${feedbackType}: ${Utils.trunc(feedbackMsg, 150)}`;\n      if (feedbackType.startsWith(\"Human\")) {\n        if (s.humanInterventions !== undefined) s.humanInterventions++;\n      }\n      if (applySuccess && !skipCycleIncrement) {\n        s.totalCycles =\n          nextCycle === currentCycle ? currentCycle + 1 : nextCycle;\n        s.agentIterations++;\n      } else if (!applySuccess) {\n        s.failCount = (s.failCount || 0) + 1;\n        s.failHistory = s.failHistory || [];\n        s.failHistory.push({\n          cycle: currentCycle,\n          reason: `HITL Apply Fail: ${feedbackType}`,\n        });\n        if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20))\n          s.failHistory.shift();\n        s.totalCycles = currentCycle;\n      }\n      if (!skipCycleIncrement) {\n        s.personaMode = (s.cfg?.personaBalance ?? 50) < 50 ? \"XYZ\" : \"LSD\";\n        s.retryCount = 0;\n      }\n      return s;\n    });\n\n    const summaryOutcome = !applySuccess\n      ? `Failed (${feedbackType})`\n      : `OK (${feedbackType})`;\n    UI.summarizeCompletedCycleLog(summaryOutcome);\n    UI.logToTimeline(\n      currentCycle,\n      `[STATE] ${feedbackType} processed. Feedback: \"${Utils.trunc(\n        feedbackMsg,\n        70\n      )}...\"`,\n      \"state\"\n    );\n    UI.hideHumanInterventionUI();\n    const uiRefs = UI.getRefs();\n    if (!skipCycleIncrement && uiRefs.goalInput) uiRefs.goalInput.value = \"\";\n    UI.updateStatus(skipCycleIncrement ? \"Meta Sandbox Pending...\" : \"Idle\");\n    if (!skipCycleIncrement) UI.clearCurrentCycleDetails();\n    UI.updateStateDisplay();\n    UI.highlightCoreStep(-1);\n  };\n\n  const saveHtmlToHistory = (htmlContent) => {\n    StateManager.updateAndSaveState((s) => {\n      const limit = s.cfg?.htmlHistoryLimit ?? 5;\n      if (!s.htmlHistory) s.htmlHistory = [];\n      s.htmlHistory.push(htmlContent);\n      while (s.htmlHistory.length > limit) s.htmlHistory.shift();\n      logger.logEvent(\n        \"info\",\n        `Saved HTML state. History size: ${s.htmlHistory.length}`\n      );\n      UI.updateHtmlHistoryControls(s); // UI must be able to handle state directly\n      return s;\n    });\n  };\n\n  const _runSummarizationContext = async (apiKey, state, currentCycle) => {\n    const template =\n      Storage.getArtifactContent(\"reploid.core.summarizer-prompt\", 0) || \"\";\n    if (!template)\n      throw new ArtifactError(\n        \"Summarizer prompt not found.\",\n        \"reploid.core.summarizer-prompt\",\n        0\n      );\n\n    const stateSummary = {\n      totalCycles: state.totalCycles,\n      agentIterations: state.agentIterations,\n      humanInterventions: state.humanInterventions,\n      failCount: state.failCount,\n      currentGoal: {\n        seed: Utils.trunc(state.currentGoal?.seed, 200),\n        cumulative: Utils.trunc(state.currentGoal?.cumulative, 500),\n        latestType: state.currentGoal?.latestType,\n        currentContextFocus: state.currentGoal?.currentContextFocus,\n      },\n      lastCritiqueType: state.lastCritiqueType,\n      lastFeedback: Utils.trunc(state.lastFeedback, 200),\n      avgConfidence: state.avgConfidence?.toFixed(2),\n      critiqueFailRate: state.critiqueFailRate?.toFixed(1),\n      dynamicTools: (state.dynamicTools || []).map((t) => t.declaration.name),\n      evaluationHistory: AgentLogicPureHelpers.summarizeHistoryPure(\n        state.evaluationHistory,\n        \"Eval\",\n        3,\n        Utils.trunc\n      ),\n    };\n    const artifactListSummary =\n      AgentLogicPureHelpers.getArtifactListSummaryPure(\n        StateManager.getAllArtifactMetadata()\n      );\n    const recentLogs = logger.getLogBuffer\n      ? logger.getLogBuffer().split(\"\\n\").slice(-20).join(\"\\n\")\n      : \"N/A\";\n\n    const { prompt, error } =\n      AgentLogicPureHelpers.assembleSummarizerPromptPure(\n        template,\n        stateSummary,\n        recentLogs,\n        artifactListSummary,\n        Utils.trunc\n      );\n    if (error) throw new ApplicationError(error);\n\n    const summarizerModelKey = state.cfg?.summarizerModel || \"BASE\";\n    const summarizerModelIdentifier =\n      config.DEFAULT_MODELS[summarizerModelKey.toUpperCase()] ||\n      summarizerModelKey;\n    let summaryResultText = \"\";\n    try {\n      let accumulatedSummaryText = \"\";\n      const apiResult = await ApiClient.callApiWithRetry(\n        prompt,\n        'You are Summarizer x0. Output ONLY valid JSON: {\"summary\": \"string\"}',\n        summarizerModelIdentifier,\n        apiKey,\n        [],\n        false,\n        null,\n        1,\n        {},\n        (msg, act, err) => UI.updateStatus(`Summarize: ${msg}`, act, err),\n        (cyc, msg, type, sub, anim) =>\n          UI.logToTimeline(cyc, `[SUM] ${msg}`, type, sub, anim),\n        UI.updateTimelineItem,\n        (progress) => {\n          if (progress.type === \"text\")\n            accumulatedSummaryText += progress.content;\n          summaryResultText =\n            progress.accumulatedResult?.content || accumulatedSummaryText;\n        }\n      );\n      if (!summaryResultText && apiResult?.content)\n        summaryResultText = apiResult.content;\n      const sanitized = ApiClient.sanitizeLlmJsonResp(summaryResultText);\n      const parsed = JSON.parse(sanitized);\n      if (typeof parsed.summary === \"string\") return parsed.summary;\n      else\n        throw new ApplicationError(\n          \"Summarizer response missing 'summary' field.\"\n        );\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Summarization LLM call failed: ${e.message}`,\n        e\n      );\n      return null;\n    }\n  };\n\n  const handleSummarizeContext = async () => {\n    let state = StateManager.getState();\n    if (!state || !state.apiKey) {\n      UI.showNotification(\"API Key required for summarization.\", \"warn\");\n      return;\n    }\n    if (_isRunning) {\n      UI.showNotification(\n        \"Cannot summarize context while cycle is running.\",\n        \"warn\"\n      );\n      return;\n    }\n    UI.updateStatus(\"Summarizing context...\", true);\n    UI.showNotification(\"Starting context summarization...\", \"info\", 3000);\n    const currentCycle = state.totalCycles;\n    const nextCycle = currentCycle + 1;\n    UI.logToTimeline(\n      currentCycle,\n      \"[CONTEXT] Running summarization...\",\n      \"context\",\n      true\n    );\n    UI.clearCurrentCycleDetails();\n    try {\n      const summaryText = await _runSummarizationContext(\n        state.apiKey,\n        state,\n        currentCycle\n      );\n      if (summaryText === null)\n        throw new ApplicationError(\"Summarization LLM call or parsing failed.\");\n      const checksum = await Utils.calculateChecksum(summaryText);\n      Storage.setArtifactContent(\n        \"meta.summary_context\",\n        nextCycle,\n        summaryText\n      );\n      StateManager.updateArtifactMetadata(\n        \"meta.summary_context\",\n        \"TEXT\",\n        \"Last Context Summary\",\n        nextCycle,\n        checksum,\n        \"Summarizer\",\n        null,\n        false,\n        \"data\"\n      );\n      StateManager.updateAndSaveState((s) => {\n        s.currentGoal = {\n          seed: s.currentGoal?.seed,\n          cumulative: `Context summarized up to Cycle ${currentCycle}. Original Seed: ${\n            s.currentGoal?.seed || \"None\"\n          }. New Summary:\\n${summaryText}`,\n          latestType: \"Idle\",\n          summaryContext: summaryText,\n          currentContextFocus: null,\n        };\n        s.contextTokenEstimate =\n          Math.round((summaryText.length / 4) * 1.1) + 500;\n        s.lastFeedback = `Context summarized at Cycle ${currentCycle}.`;\n        s.lastCritiqueType = \"Context Summary\";\n        s.totalCycles = nextCycle;\n        return s;\n      });\n      UI.logToTimeline(\n        currentCycle,\n        `[CONTEXT] Summarized. Saved as meta.summary_context_${nextCycle}. Est. tokens: ${StateManager.getState().contextTokenEstimate.toLocaleString()}.`,\n        \"context\"\n      );\n      UI.displayCycleArtifact(\n        \"Generated Context Summary\",\n        summaryText,\n        \"output\",\n        true,\n        \"System\",\n        \"meta.summary_context\",\n        nextCycle\n      );\n      UI.showNotification(\"Context summarization complete.\", \"info\", 5000);\n    } catch (error) {\n      logger.logEvent(\"error\", `Summarization failed: ${error.message}`, error);\n      UI.showNotification(`Summarization failed: ${error.message}`, \"error\");\n      UI.logToTimeline(\n        currentCycle,\n        `[CONTEXT ERR] Summarization failed: ${error.message}`,\n        \"error\"\n      );\n    } finally {\n      UI.updateStateDisplay();\n      UI.updateStatus(\"Idle\");\n    }\n  };\n\n  const abortCurrentCycle = () => {\n    if (_isRunning) {\n      logger.logEvent(\"info\", \"Abort request received.\");\n      _abortRequested = true;\n      ApiClient.abortCurrentCall(\"User Abort Request\");\n      if (_isAutonomous) stopAutonomousRun(\"Aborted\");\n      else UI.updateStatus(\"Aborting...\");\n    } else logger.logEvent(\"info\", \"Abort request ignored: No cycle running.\");\n  };\n\n  const startAutonomousRun = (mode = \"Continuous\", cycles = 0) => {\n    if (_isRunning) {\n      UI.showNotification(\n        \"Cannot start autonomous run: Cycle already in progress.\",\n        \"warn\"\n      );\n      return;\n    }\n    let state = StateManager.getState();\n    if (!state) {\n      UI.showNotification(\n        \"Cannot start autonomous run: State not loaded.\",\n        \"error\"\n      );\n      return;\n    }\n    if (mode === \"N_Cycles\" && (!cycles || cycles <= 0)) {\n      UI.showNotification(\n        \"Cannot start N_Cycles run: Invalid number of cycles specified.\",\n        \"warn\"\n      );\n      return;\n    }\n    logger.logEvent(\n      \"info\",\n      `Starting autonomous run. Mode: ${mode}, Cycles: ${cycles}`\n    );\n    StateManager.updateAndSaveState((s) => {\n      s.autonomyMode = mode;\n      s.autonomyCyclesRemaining = mode === \"N_Cycles\" ? cycles : Infinity;\n      return s;\n    });\n    _isAutonomous = true;\n    _abortRequested = false;\n    UI.updateAutonomyControls(mode, true);\n    UI.updateStatus(`Autonomous Run (${mode}) Started...`);\n    executeCycle();\n  };\n\n  const stopAutonomousRun = (reason = \"User Stop Request\") => {\n    logger.logEvent(\"info\", `Stopping autonomous run. Reason: ${reason}`);\n    _abortRequested = true;\n    _isAutonomous = false;\n    StateManager.updateAndSaveState((s) => {\n      s.autonomyMode = \"Manual\";\n      s.autonomyCyclesRemaining = 0;\n      return s;\n    });\n    UI.updateAutonomyControls(\"Manual\", false);\n    UI.updateStatus(`Autonomous Run Stopped (${reason})`);\n    if (_isRunning) {\n      if (UI.setRunButtonState) UI.setRunButtonState(\"Run Cycle\", false);\n      _isRunning = false;\n    }\n  };\n\n  const runTool = async (toolName, args) => {\n    const state = StateManager.getState();\n    if (!state) throw new StateError(\"Cannot run tool, state not available.\");\n    const fallbackUiHooks = {\n      updateStatus: () => {},\n      logTimeline: () => ({}),\n      updateTimelineItem: () => {},\n    };\n    return await ToolRunner.runTool(\n      toolName,\n      args,\n      loadedStaticTools,\n      state.dynamicTools || [],\n      fallbackUiHooks\n    );\n  };\n\n  return {\n    init,\n    executeCycle,\n    isRunning,\n    isAutonomous,\n    getActiveGoalInfo,\n    proceedAfterHumanIntervention,\n    handleSummarizeContext,\n    abortCurrentCycle,\n    saveHtmlToHistory,\n    runTool,\n    startAutonomousRun,\n    stopAutonomousRun,\n  };\n};\n",
  "_x0_reploid.core.evaluator-prompt_0": "\nYou are Evaluator x0. Your task is to objectively evaluate a target artifact or proposal based on specific criteria and the original goal context.\n\n**Original Goal Context:**\n[[GOAL_CONTEXT]]\n\n**Evaluation Criteria:**\n[[EVALUATION_CRITERIA]]\n\n**Target Content/Proposal:**\n(This could be artifact content, LLM justification, or description of multiple proposed versions. If artifact, its ID and paradigm: [[TARGET_ARTIFACT_ID]], [[TARGET_ARTIFACT_PARADIGM]])\n\n[[TARGET_CONTENT_OR_PROPOSAL]]\n**Task:**\nAnalyze the **Target Content/Proposal** against the **Evaluation Criteria** in the context of the **Original Goal Context**. Consider the [[TARGET_ARTIFACT_PARADIGM]] if provided:\n- 'pure' artifacts: Emphasize correctness, determinism, adherence to contract.\n- 'boundary_io'/'boundary_orchestration': Emphasize safety, error handling, impact.\n- 'data': Emphasize schema, relevance.\nProvide a numerical score (0.0 to 1.0, where 1.0 is perfect adherence) and a concise, factual report explaining the score.\n\n**Output Format (JSON ONLY):**\n```json\n{\n  \"evaluation_score\": float,\n  \"evaluation_report\": \"string\"\n}\n```\n\nADDITIONAL INSTRUCTIONS:\nOutput Strictness: YOU MUST output ONLY a single valid JSON object matching the specified format. Do NOT include any text, explanations, or markdown formatting before or after the JSON object.\nObjectivity: Base your evaluation strictly on the provided criteria, target content/proposal, and paradigm considerations. Avoid subjective opinions.\nConciseness: The evaluation_report should be brief and directly justify the assigned evaluation_score by referencing specific aspects of the target, criteria, and paradigm.\nScore Range: The evaluation_score must be a floating-point number between 0.0 and 1.0 inclusive.\nMulti-Version Handling: If evaluating multiple versions, state clearly which version(s) the score/report refers to, or if it's an overall assessment.",
  "_x0_reploid.core.default-eval_0": "{\n  \"id\": \"reploid.core.default-eval\",\n  \"name\": \"Default Artifact/Proposal Evaluation\",\n  \"description\": \"Provides a default set of criteria for evaluating the quality and relevance of an agent's output (artifact, justification, or proposal) against the goal context.\",\n  \"criteria_version\": \"1.0\",\n  \"criteria\": [\n    {\n      \"id\": \"goal_alignment\",\n      \"question\": \"How well does the target content/proposal directly address the core requirements and constraints specified in the goal context?\",\n      \"weight\": 0.4,\n      \"scoring_guide\": {\n        \"0.0-0.2\": \"Completely irrelevant or counter-productive to the goal.\",\n        \"0.3-0.5\": \"Addresses a minor aspect or misunderstands the core goal.\",\n        \"0.6-0.8\": \"Addresses the main goal but misses key constraints or details.\",\n        \"0.9-1.0\": \"Directly and comprehensively addresses the core goal and constraints.\"\n      }\n    },\n    {\n      \"id\": \"quality_correctness\",\n      \"question\": \"Assess the technical quality, correctness, and plausibility of the target content/proposal. (e.g., for code: syntax, basic logic; for text: clarity, coherence; for proposal: feasibility)\",\n      \"weight\": 0.3,\n      \"scoring_guide\": {\n        \"0.0-0.2\": \"Contains significant errors, logically flawed, or completely implausible.\",\n        \"0.3-0.5\": \"Contains noticeable errors or questionable logic/feasibility.\",\n        \"0.6-0.8\": \"Appears mostly correct and plausible, minor issues might exist.\",\n        \"0.9-1.0\": \"Appears technically sound, correct, and highly plausible/functional.\"\n      }\n    },\n    {\n      \"id\": \"completeness\",\n      \"question\": \"Does the target content/proposal seem complete relative to the scope implied by the goal, or are obvious parts missing?\",\n      \"weight\": 0.2,\n      \"scoring_guide\": {\n        \"0.0-0.4\": \"Significantly incomplete, missing major required components.\",\n        \"0.5-0.7\": \"Mostly complete but missing some expected details or secondary requirements.\",\n        \"0.8-1.0\": \"Appears complete for the requested scope.\"\n      }\n    },\n    {\n      \"id\": \"clarity_justification\",\n      \"question\": \"If evaluating a proposal or justification text itself: Is the reasoning clear, concise, and logically sound?\",\n      \"weight\": 0.1,\n      \"scoring_guide\": {\n        \"0.0-0.4\": \"Unclear, rambling, or illogical justification.\",\n        \"0.5-0.7\": \"Reasonably clear but could be more concise or better structured.\",\n        \"0.8-1.0\": \"Clear, concise, and well-reasoned justification.\"\n      }\n    }\n  ],\n  \"scoring_instruction\": \"Evaluate based on the provided criteria and weights. The final score should be a weighted average if possible, or an overall holistic judgment informed by these aspects. Focus primarily on the explicit goal and the generated output.\"\n}\n",
  "_x0_reploid.boot.style_0": "\n      body {\n        font-family: monospace;\n        background-color: black;\n        color: #ccc;\n        margin: 0;\n        padding: 0;\n        display: flex;\n        flex-direction: column;\n        min-height: 100vh;\n        justify-content: center;\n        align-items: center;\n        user-select: none;\n      }\n      #start-container {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        gap: 20px;\n        padding: 20px;\n        text-align: center;\n      }\n      .start-button {\n        background-color: black;\n        color: white;\n        border: 2px solid white;\n        padding: 15px 30px;\n        font-size: 1.2em;\n        font-family: monospace;\n        cursor: pointer;\n        min-width: 250px;\n        transition: background-color 0.2s, color 0.2s;\n      }\n      .start-button:hover {\n        background-color: white;\n        color: black;\n      }\n      .button-description {\n        font-size: 0.9em;\n        color: gray;\n        max-width: 250px;\n      }\n      #loading-container {\n        width: 100%;\n        text-align: left;\n        align-self: flex-start;\n        box-sizing: border-box;\n        padding: 5px;\n      }\n      #loading-indicator {\n        font-size: 1em;\n        white-space: pre-wrap;\n        word-wrap: break-word;\n        max-height: calc(100vh - 10px);\n        overflow-y: auto;\n        text-align: left;\n      }\n      #loading-indicator div.log-entry {\n        display: block;\n        margin-bottom: 1px;\n        text-align: left;\n        line-height: 1.3;\n      }\n      #loading-indicator .log-info {\n        color: #ddd;\n      }\n      #loading-indicator .log-warn {\n        color: #f9d71c;\n      }\n      #loading-indicator .log-error {\n        color: #ff6b6b;\n        font-weight: bold;\n      }\n      #loading-indicator .log-success {\n        color: #76ff7a;\n        font-weight: bold;\n      }\n      #loading-indicator .log-detail {\n        color: #bbb;\n        margin-left: 15px;\n      }\n      #app-root {\n        visibility: hidden;\n        opacity: 0;\n        transition: opacity 0.5s ease-in-out;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n      #app-root.visible {\n        visibility: visible;\n        opacity: 1;\n      }\n      .hidden {\n        display: none !important;\n      }\n      @media (max-width: 600px) {\n        .start-button {\n          min-width: 80%;\n          font-size: 1.1em;\n          padding: 12px 25px;\n        }\n        .button-description {\n          font-size: 0.8em;\n        }\n        #start-container {\n          width: 90%;\n        }\n      }\n    ",
  "_x0_target.style.css_1": "body {\n    font-family: sans-serif;\n    line-height: 1.6;\n    margin: 0;\n    padding: 20px;\n    background-color: #f4f4f4;\n    color: #333;\n}\n\nheader {\n    text-align: center;\n    margin-bottom: 20px;\n}\n\nheader h1 {\n    color: #2c3e50; /* A nice, deep blue, like the depths of potential! */\n}\n\nmain {\n    max-width: 800px;\n    margin: auto;\n    background: #fff;\n    padding: 20px;\n    border-radius: 8px; /* Soft edges, like a well-formed idea */\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n}\n\nsection {\n    margin-bottom: 20px;\n}\n\nh2, h3 {\n    color: #3498db; /* A vibrant, inspiring blue */\n}\n\n.output-box {\n    background-color: #ecf0f1; /* A calm, neutral background for content */\n    border: 1px solid #bdc3c7;\n    padding: 15px;\n    border-radius: 4px;\n    min-height: 50px;\n    margin-bottom: 10px;\n}\n\ntextarea#user-prompt {\n    width: calc(100% - 22px); /* Account for padding and border */\n    padding: 10px;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    margin-bottom: 10px;\n}\n\nbutton#submit-prompt {\n    display: block;\n    padding: 10px 20px;\n    background-color: #2ecc71; /* A hopeful, verdant green for action */\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 1em;\n}\n\nbutton#submit-prompt:hover {\n    background-color: #27ae60; /* A slightly deeper green on hover */\n}\n\nfooter {\n    text-align: center;\n    margin-top: 30px;\n    font-size: 0.9em;\n    color: #7f8c8d; /* A subtle, grounding grey */\n}",
  "_x0_reploid.core.body_0": "<body>\n  <div id=\"top\"></div>\n  <h1>\n    REPLOID &lt;-&gt; DREAMER\n    <small>\n      Reflective Embodiment Providing Logical Overseeing Intelligent Dreamer\n    </small>\n    <small>\n      Deep Recursive Exploration Around Multimodal Embodying Reploid\n    </small>\n  </h1>\n\n  <fieldset id=\"genesis-config\" aria-labelledby=\"genesis-config-legend\">\n    <legend id=\"genesis-config-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Configuration\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <div\n        class=\"cfg-grid\"\n        role=\"group\"\n        aria-labelledby=\"config-params-heading\"\n      >\n        <h3 id=\"config-params-heading\" class=\"visually-hidden\">\n          Configuration Parameters\n        </h3>\n        <div class=\"cfg-item\">\n          <label\n            for=\"lsd-persona-percent-input\"\n            title=\"Influence ratio contribution for LSD persona.\"\n            >LSD %:</label\n          >\n          <div class=\"persona-inputs\">\n            <input\n              type=\"number\"\n              id=\"lsd-persona-percent-input\"\n              value=\"50\"\n              min=\"0\"\n              max=\"100\"\n              step=\"1\"\n              aria-describedby=\"lsd-persona-percent-desc\"\n            />\n            <span id=\"lsd-persona-percent-desc\" class=\"visually-hidden\"\n              >Percentage influence of LSD persona (0-100).</span\n            >\n          </div>\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"xyz-persona-percent-input\"\n            title=\"Influence ratio contribution for XYZ persona.\"\n            >XYZ %:</label\n          >\n          <div class=\"persona-inputs\">\n            <input\n              type=\"number\"\n              id=\"xyz-persona-percent-input\"\n              value=\"50\"\n              min=\"0\"\n              max=\"100\"\n              step=\"1\"\n              readonly\n              aria-describedby=\"xyz-persona-percent-desc\"\n            />\n            <span id=\"xyz-persona-percent-desc\" class=\"visually-hidden\"\n              >Percentage influence of XYZ persona (read-only,\n              calculated).</span\n            >\n          </div>\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"llm-critique-prob-input\"\n            title=\"Prob(0-100) LLM critiques if checks pass.\"\n            >LLM Auto-Critique %:</label\n          >\n          <input\n            type=\"number\"\n            id=\"llm-critique-prob-input\"\n            value=\"50\"\n            min=\"0\"\n            max=\"100\"\n            step=\"5\"\n            aria-describedby=\"llm-critique-prob-desc\"\n          />\n          <span id=\"llm-critique-prob-desc\" class=\"visually-hidden\"\n            >Probability (0-100) that the LLM will perform an automated\n            critique.</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"human-review-prob-input\"\n            title=\"Prob(0-100) cycle forced human review.\"\n            >Forced Human Review %:</label\n          >\n          <input\n            type=\"number\"\n            id=\"human-review-prob-input\"\n            value=\"50\"\n            min=\"0\"\n            max=\"100\"\n            step=\"5\"\n            aria-describedby=\"human-review-prob-desc\"\n          />\n          <span id=\"human-review-prob-desc\" class=\"visually-hidden\"\n            >Probability (0-100) that a cycle will require forced human\n            review.</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"max-cycle-time-input\"\n            title=\"Max time (s) per iteration before human review.\"\n            >Max Cycle Time (s):</label\n          >\n          <input\n            type=\"number\"\n            id=\"max-cycle-time-input\"\n            value=\"600\"\n            min=\"10\"\n            max=\"1800\"\n            aria-describedby=\"max-cycle-time-desc\"\n          />\n          <span id=\"max-cycle-time-desc\" class=\"visually-hidden\"\n            >Maximum time in seconds allowed per cycle iteration.</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"auto-critique-thresh-input\"\n            title=\"Confidence (0-1) below which human review forced.\"\n            >Confidence Threshold:</label\n          >\n          <input\n            type=\"number\"\n            id=\"auto-critique-thresh-input\"\n            value=\"0.6\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.05\"\n            aria-describedby=\"auto-critique-thresh-desc\"\n          />\n          <span id=\"auto-critique-thresh-desc\" class=\"visually-hidden\"\n            >Confidence score threshold (0.0 to 1.0). Cycles below this may\n            trigger human review.</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label for=\"max-cycles-input\" title=\"Max cycles (0=Inf).\"\n            >Max Cycles (0=Inf):</label\n          >\n          <input\n            type=\"number\"\n            id=\"max-cycles-input\"\n            value=\"0\"\n            min=\"0\"\n            max=\"1000\"\n            step=\"1\"\n            aria-describedby=\"max-cycles-desc\"\n          />\n          <span id=\"max-cycles-desc\" class=\"visually-hidden\"\n            >Maximum number of cycles to run (0 means infinite).</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"html-history-limit-input\"\n            title=\"Num previous states for 'Go Back'.\"\n            >Self-Mod History:</label\n          >\n          <input\n            type=\"number\"\n            id=\"html-history-limit-input\"\n            value=\"5\"\n            min=\"1\"\n            max=\"20\"\n            step=\"1\"\n            aria-describedby=\"html-history-limit-desc\"\n          />\n          <span id=\"html-history-limit-desc\" class=\"visually-hidden\"\n            >Number of previous full page states saved for the 'Go Back'\n            feature.</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"pause-after-cycles-input\"\n            title=\"Auto pause every N cycles (0=Off).\"\n            >Pause Every N Cycles:</label\n          >\n          <input\n            type=\"number\"\n            id=\"pause-after-cycles-input\"\n            value=\"10\"\n            min=\"0\"\n            max=\"100\"\n            step=\"1\"\n            aria-describedby=\"pause-after-cycles-desc\"\n          />\n          <span id=\"pause-after-cycles-desc\" class=\"visually-hidden\"\n            >Automatically pause execution every N cycles (0 disables\n            auto-pause).</span\n          >\n        </div>\n        <div class=\"cfg-item\">\n          <label\n            for=\"max-retries-input\"\n            title=\"Max auto-retries on failure before Human Intervention.\"\n            >Max Retries:</label\n          >\n          <input\n            type=\"number\"\n            id=\"max-retries-input\"\n            value=\"1\"\n            min=\"0\"\n            max=\"5\"\n            step=\"1\"\n            aria-describedby=\"max-retries-desc\"\n          />\n          <span id=\"max-retries-desc\" class=\"visually-hidden\"\n            >Maximum number of automatic retries on API or processing failures\n            before requiring human intervention.</span\n          >\n        </div>\n      </div>\n\n      <div\n        class=\"model-selectors\"\n        role=\"group\"\n        aria-labelledby=\"model-select-heading\"\n      >\n        <h3 id=\"model-select-heading\" class=\"visually-hidden\">\n          Model Selection\n        </h3>\n        <div class=\"cfg-item\">\n          <label for=\"core-model-selector\">Core Gen Model:</label>\n          <select\n            id=\"core-model-selector\"\n            aria-label=\"Select Core Generation Model\"\n          ></select>\n        </div>\n        <div class=\"cfg-item\">\n          <label for=\"critique-model-selector\">Critique/Util Model:</label>\n          <select\n            id=\"critique-model-selector\"\n            aria-label=\"Select Critique and Utility Model\"\n          ></select>\n        </div>\n      </div>\n\n      <h3 id=\"core-metrics-heading\">Core Metrics</h3>\n      <div\n        class=\"metrics-grid\"\n        id=\"core-metrics-display\"\n        role=\"group\"\n        aria-labelledby=\"core-metrics-heading\"\n      >\n        <div class=\"metric-item\" id=\"metric-total-cycles\" aria-live=\"polite\">\n          Cycles <strong id=\"total-cycles\">0</strong>/<strong\n            id=\"max-cycles-display\"\n            >Inf</strong\n          >\n        </div>\n        <div\n          class=\"metric-item\"\n          id=\"metric-agent-iterations\"\n          aria-live=\"polite\"\n        >\n          Agent Itr <strong id=\"agent-iterations\">0</strong>\n        </div>\n        <div\n          class=\"metric-item\"\n          id=\"metric-human-interventions\"\n          aria-live=\"polite\"\n        >\n          Human Int <strong id=\"human-interventions\">0</strong>\n        </div>\n        <div class=\"metric-item\" id=\"metric-current-goal\" aria-live=\"polite\">\n          Goal <strong id=\"current-goal\">Idle</strong>\n        </div>\n        <div\n          class=\"metric-item\"\n          id=\"metric-last-critique-type\"\n          aria-live=\"polite\"\n        >\n          Critique <strong id=\"last-critique-type\">N/A</strong>\n        </div>\n        <div class=\"metric-item\" id=\"metric-persona-mode\" aria-live=\"polite\">\n          Persona <strong id=\"persona-mode\">XYZ</strong>\n        </div>\n        <div\n          class=\"metric-item\"\n          id=\"metric-html-history-count\"\n          aria-live=\"polite\"\n        >\n          History <strong id=\"html-history-count\">0</strong>\n        </div>\n        <div class=\"metric-item\" id=\"metric-context-tokens\" aria-live=\"polite\">\n          Ctx Tokens <strong id=\"context-token-estimate\">0</strong> /\n          <span id=\"context-token-target-display\">~1M</span>\n          <span\n            id=\"context-token-warning\"\n            class=\"token-warning hidden\"\n            aria-hidden=\"true\"\n            >!</span\n          >\n          <span class=\"visually-hidden\"\n            >Context token estimate warning indicator.</span\n          >\n        </div>\n      </div>\n\n      <h3 id=\"rolling-metrics-heading\">Rolling Metrics</h3>\n      <div\n        class=\"metrics-grid\"\n        id=\"rolling-metrics-display\"\n        role=\"group\"\n        aria-labelledby=\"rolling-metrics-heading\"\n      >\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Avg Conf <strong id=\"avg-confidence\">N/A</strong>\n        </div>\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Crit Fail Rate <strong id=\"critique-fail-rate\">N/A</strong>\n        </div>\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Avg Tokens <strong id=\"avg-tokens\">N/A</strong>\n        </div>\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Fail Count <strong id=\"fail-count\">0</strong>\n        </div>\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Avg Eval Score <strong id=\"avg-eval-score\">N/A</strong>\n        </div>\n        <div class=\"metric-item\" aria-live=\"polite\">\n          Eval Pass Rate <strong id=\"eval-pass-rate\">N/A</strong>\n        </div>\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset id=\"seed-prompts\" aria-labelledby=\"seed-prompts-legend\">\n    <legend id=\"seed-prompts-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Seed Instructions &\n      Prompts <span class=\"type-indicator\" aria-hidden=\"true\">[A]</span>\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <div class=\"flex-row\">\n        <div class=\"flex-col core-loop-steps\">\n          <h3 id=\"core-steps-heading\">Core Loop Steps</h3>\n          <div id=\"core-loop-steps-minimap\" class=\"cycle-steps-minimap\">\n            <ol>\n              <li>\n                Define or Refine Goal (System/Meta). Load Relevant Context.\n                Check Cycle Limits.\n              </li>\n              <li>\n                Analyze State, Goal, Artifacts, Tools, History (Feedback,\n                Evals). Deliberate.\n              </li>\n              <li>\n                Propose Changes (Artifacts, Tools, Versions). Decide Actions.\n                Set Confidence.\n              </li>\n              <li>\n                Execute LLM & Tools -> Generate Response (Code, Data, New Tool\n                Implementations).\n              </li>\n              <li>\n                Check Triggers for Critique or Intervention (Time, Confidence,\n                Random, Forced).\n              </li>\n              <li>\n                Perform Critique (Auto) or Get Human Feedback (Options, Prompt,\n                Code Edit).\n              </li>\n              <li>\n                Apply Approved Changes or Stage Sandbox (Meta). Handle Prior\n                Feedback. Log Actions.\n              </li>\n              <li>\n                Self-Evaluate Cycle Outcome & Learn from History. Propose\n                Process Improvements.\n              </li>\n              <li>\n                Determine Next Action: Continue Cycle, Pause, Initiate Retry, or\n                Self-Correct.\n              </li>\n            </ol>\n          </div>\n        </div>\n        <div class=\"flex-col\">\n          <h3 id=\"core-logic-prompt-heading\">Core Logic/Meta Prompt</h3>\n          <textarea\n            id=\"seed-prompt-core\"\n            readonly\n            aria-labelledby=\"core-logic-prompt-heading\"\n          ></textarea>\n        </div>\n        <div class=\"flex-col\">\n          <h3 id=\"crit-prompt-heading\">Automated Critique Prompt</h3>\n          <textarea\n            id=\"seed-prompt-critique\"\n            readonly\n            rows=\"8\"\n            aria-labelledby=\"crit-prompt-heading\"\n          ></textarea>\n          <h3 id=\"sum-prompt-heading\">Context Summarization Prompt</h3>\n          <textarea\n            id=\"seed-prompt-summarize\"\n            readonly\n            rows=\"5\"\n            aria-labelledby=\"sum-prompt-heading\"\n          ></textarea>\n          <h3 id=\"eval-prompt-heading\">Self-Evaluation Prompt</h3>\n          <textarea\n            id=\"seed-prompt-evaluator\"\n            readonly\n            rows=\"5\"\n            aria-labelledby=\"eval-prompt-heading\"\n          ></textarea>\n        </div>\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset\n    id=\"genesis-state-display\"\n    class=\"collapsed\"\n    aria-labelledby=\"genesis-state-legend\"\n  >\n    <legend id=\"genesis-state-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Genesis State (Cycle\n      0)\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <p>Initial state loaded from browser's local storage.</p>\n      <div id=\"genesis-metrics-display\" role=\"region\" aria-live=\"polite\">\n        Loading...\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset id=\"current-cycle-details\" aria-labelledby=\"current-cycle-legend\">\n    <legend id=\"current-cycle-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Cycle\n      <span id=\"current-cycle-number\">N/A</span> Details\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <p>\n        <i\n          >Inputs, decisions, artifacts, and tools for the current/last\n          cycle.</i\n        >\n      </p>\n      <div\n        id=\"current-cycle-content\"\n        class=\"artifact-display\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n      >\n        <p>Waiting for cycle...</p>\n      </div>\n      <div\n        id=\"tools-executed-container\"\n        class=\"hidden\"\n        aria-labelledby=\"tools-executed-heading\"\n      >\n        <h3 id=\"tools-executed-heading\">Tools Executed This Cycle</h3>\n        <ul id=\"tools-executed-list\"></ul>\n      </div>\n      <div\n        id=\"streaming-output-container\"\n        class=\"hidden\"\n        role=\"log\"\n        aria-live=\"polite\"\n      >\n        <span class=\"artifact-label\" id=\"stream-label\"\n          ><span class=\"type-indicator\" aria-hidden=\"true\">[STR]</span>LLM\n          Streaming Output</span\n        >\n        <pre id=\"streaming-output-pre\" aria-labelledby=\"stream-label\">\n(No stream active)</pre\n        >\n      </div>\n    </div>\n  </fieldset>\n\n  <fieldset id=\"timeline-fieldset\" aria-labelledby=\"timeline-legend\">\n    <legend id=\"timeline-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Execution Timeline\n      <span id=\"status-indicator\" role=\"status\" aria-live=\"polite\"\n        >Status: Idle</span\n      >\n      <span id=\"api-progress\" aria-live=\"polite\"></span>\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <ul\n        id=\"timeline-log\"\n        class=\"timeline\"\n        aria-live=\"polite\"\n        aria-atomic=\"false\"\n      ></ul>\n    </div>\n  </fieldset>\n\n  <div\n    id=\"human-intervention-section\"\n    class=\"hitl-container hidden\"\n    role=\"dialog\"\n    aria-modal=\"true\"\n    aria-labelledby=\"human-intervention-title\"\n  >\n    <fieldset>\n      <legend>\n        <span class=\"toggle-icon\" aria-hidden=\"true\"></span\n        ><span id=\"human-intervention-title\">Human Intervention Required</span>\n        <span class=\"summary-line\" id=\"human-intervention-reason-summary\"\n          >Reason...</span\n        >\n      </legend>\n      <div class=\"content-wrapper\">\n        <p id=\"human-intervention-reason\"></p>\n\n        <div id=\"hitl-critique-feedback-mode\" class=\"hidden\">\n          <h4 id=\"hitl-critiques-heading\">Generated Critiques:</h4>\n          <div id=\"hitl-critiques-display\" class=\"critiques-display\"></div>\n          <h4 id=\"hitl-critique-feedback-heading\">\n            Provide Feedback on Critiques:\n          </h4>\n          <div id=\"hitl-critique-selection\" class=\"critique-selection\"></div>\n          <label for=\"hitl-critique-notes\" class=\"visually-hidden\"\n            >Additional Feedback Notes</label\n          >\n          <textarea\n            id=\"hitl-critique-notes\"\n            placeholder=\"Optional feedback on why you selected this critique...\"\n            style=\"min-height: 60px; width: 100%; margin-top: 10px\"\n          ></textarea>\n          <button id=\"submit-critique-feedback-button\">\n            Submit Critique Feedback\n          </button>\n        </div>\n\n        <div\n          id=\"hitl-options-mode\"\n          class=\"hidden\"\n          role=\"group\"\n          aria-labelledby=\"hitl-options-heading\"\n        >\n          <h4 id=\"hitl-options-heading\">Select Option:</h4>\n          <div id=\"hitl-options-list\" class=\"hitl-options\"></div>\n          <button id=\"submit-hitl-options-button\">Submit Selection</button>\n        </div>\n\n        <div id=\"hitl-prompt-mode\" class=\"hidden\">\n          <h4 id=\"hitl-prompt-heading\">Provide Feedback or Instructions:</h4>\n          <textarea\n            id=\"human-critique-input\"\n            placeholder=\"Feedback/Next Step...\"\n            style=\"min-height: 100px; width: 100%\"\n            aria-labelledby=\"hitl-prompt-heading\"\n            aria-describedby=\"human-intervention-reason\"\n          ></textarea>\n          <button id=\"submit-critique-button\">Submit Feedback</button>\n        </div>\n\n        <div id=\"hitl-code-edit-mode\" class=\"hidden\">\n          <h4 id=\"hitl-code-heading\">Edit Artifact:</h4>\n          <label for=\"human-edit-artifact-selector\" class=\"visually-hidden\"\n            >Select artifact to edit</label\n          >\n          <select id=\"human-edit-artifact-selector\"></select>\n          <label for=\"human-edit-artifact-textarea\" class=\"visually-hidden\"\n            >Artifact content editor</label\n          >\n          <textarea\n            id=\"human-edit-artifact-textarea\"\n            aria-labelledby=\"hitl-code-heading\"\n            aria-describedby=\"human-intervention-reason\"\n          ></textarea>\n          <button id=\"submit-human-code-edit-button\">Submit Edits</button>\n        </div>\n      </div>\n    </fieldset>\n  </div>\n\n  <div\n    id=\"meta-sandbox-container\"\n    class=\"hidden\"\n    role=\"dialog\"\n    aria-modal=\"true\"\n    aria-labelledby=\"meta-sandbox-title\"\n  >\n    <fieldset>\n      <legend>\n        <span class=\"toggle-icon\" aria-hidden=\"true\"></span\n        ><span id=\"meta-sandbox-title\">Meta-Improvement Sandbox</span>\n        <span class=\"summary-line\"></span>\n      </legend>\n      <div class=\"content-wrapper\">\n        <h3 id=\"meta-sandbox-heading\">Preview Proposed Self-Modification</h3>\n        <p>\n          Inspect the full page preview below. Approve to apply the changes and\n          reload.\n        </p>\n        <iframe\n          id=\"meta-sandbox-output\"\n          title=\"Preview of proposed self-modification\"\n          aria-labelledby=\"meta-sandbox-heading\"\n        ></iframe>\n        <div class=\"controls-grid meta-sandbox-controls\">\n          <button id=\"approve-meta-change-button\">Approve and Apply</button>\n          <button id=\"discard-meta-change-button\">Discard</button>\n        </div>\n      </div>\n    </fieldset>\n  </div>\n\n  <fieldset id=\"controls-fieldset\" aria-labelledby=\"controls-legend\">\n    <legend id=\"controls-legend\">\n      <span class=\"toggle-icon\" aria-hidden=\"true\"></span>Controls\n      <span class=\"summary-line\"></span>\n    </legend>\n    <div class=\"content-wrapper\">\n      <label\n        for=\"goal-input\"\n        id=\"goal-input-label\"\n        title=\"Define goal for external system design/modification or improving REPLOID itself.\"\n        >Goal Input:</label\n      >\n      <div\n        class=\"goal-type-selector\"\n        role=\"radiogroup\"\n        aria-labelledby=\"goal-type-label\"\n      >\n        <span id=\"goal-type-label\">Goal Type:</span>\n        <label\n          title=\"Modify external target artifacts (e.g., target.body, target.script.*). Results seen in UI Preview pane.\"\n        >\n          <input type=\"radio\" name=\"goalType\" value=\"System\" checked /> System\n        </label>\n        <label\n          title=\"Modify REPLOID itself (e.g., reploid.core.style, reploid.core.sys-prompt) or generate full_html_source. May trigger Sandbox approval.\"\n        >\n          <input type=\"radio\" name=\"goalType\" value=\"Meta\" /> Meta\n        </label>\n      </div>\n      <textarea\n        id=\"goal-input\"\n        placeholder=\"e.g., System Goal: Create a landing page... OR Meta Goal: Add a dark mode toggle...\"\n        aria-labelledby=\"goal-input-label\"\n      ></textarea>\n\n      <div class=\"cfg-grid\">\n        <div class=\"api-key-input\">\n          <label for=\"api-key-input\">API Key:</label>\n          <input\n            type=\"password\"\n            id=\"api-key-input\"\n            placeholder=\"Required (or use config.js)\"\n            aria-required=\"true\"\n          />\n        </div>\n      </div>\n      <div class=\"autonomy-controls\">\n        <label for=\"autonomy-mode-selector\">Run Mode:</label>\n        <select id=\"autonomy-mode-selector\">\n          <option value=\"Manual\" selected>Manual Cycle</option>\n          <option value=\"N_Cycles\">Run N Cycles</option>\n          <option value=\"Continuous\">Run Continuously</option>\n        </select>\n        <label for=\"autonomy-n-cycles-input\" class=\"autonomy-n-label hidden\"\n          >Cycles:</label\n        >\n        <input\n          type=\"number\"\n          id=\"autonomy-n-cycles-input\"\n          value=\"5\"\n          min=\"1\"\n          max=\"100\"\n          class=\"hidden\"\n        />\n        <button id=\"autonomy-start-stop-button\" disabled>\n          Start Autonomous Run\n        </button>\n      </div>\n\n      <div class=\"controls-grid\">\n        <button id=\"run-cycle-button\">Run Cycle</button>\n        <button\n          id=\"force-human-review-button\"\n          title=\"Force next cycle to pause for human review.\"\n        >\n          Force Review\n        </button>\n        <div class=\"state-io-buttons\">\n          <button\n            id=\"go-back-button\"\n            disabled\n            title=\"Revert to previous full page state (Meta only).\"\n          >\n            Go Back\n          </button>\n          <button\n            id=\"export-state-button\"\n            title=\"Download current app state (excluding artifacts) as JSON.\"\n          >\n            Export State\n          </button>\n          <button\n            id=\"import-state-button\"\n            title=\"Load app state (excluding artifacts) from JSON file.\"\n          >\n            Import State\n          </button>\n          <label for=\"import-file-input\" class=\"visually-hidden\"\n            >Import State File</label\n          >\n          <input\n            type=\"file\"\n            id=\"import-file-input\"\n            accept=\".json\"\n            class=\"hidden\"\n            aria-hidden=\"true\"\n          />\n          <button id=\"download-log-button\" title=\"Download session log as TXT.\">\n            Logs\n          </button>\n          <button\n            id=\"summarize-context-button\"\n            title=\"Automatically summarize current state and goal to reduce context for future cycles.\"\n          >\n            Reset Context\n          </button>\n          <button\n            id=\"clear-local-storage-button\"\n            title=\"WARNING: Deletes ALL Reploid artifacts and state from LocalStorage!\"\n          >\n            Clear Storage\n          </button>\n        </div>\n      </div>\n    </div>\n  </fieldset>\n  <div id=\"notifications-container\"></div>\n  <style>\n    .visually-hidden {\n      position: absolute;\n      width: 1px;\n      height: 1px;\n      padding: 0;\n      margin: -1px;\n      overflow: hidden;\n      clip: rect(0, 0, 0, 0);\n      white-space: nowrap;\n      border: 0;\n    }\n  </style>\n</body>\n",
  "_x0_reploid.core.statemanager_0": "const StateManagerModule = (\n  config,\n  logger,\n  Storage,\n  Errors,\n  StateHelpersPure,\n  Utils\n) => {\n  if (\n    !config ||\n    !logger ||\n    !Storage ||\n    !Errors ||\n    !StateHelpersPure ||\n    !Utils\n  ) {\n    const internalLog = logger || {\n      logEvent: (lvl, msg, det) =>\n        console[lvl === \"error\" ? \"error\" : \"log\"](\n          `[STATEMANAGER_FALLBACK] ${msg}`,\n          det || \"\"\n        ),\n    };\n    internalLog.logEvent(\n      \"error\",\n      \"StateManagerModule initialization failed: Missing dependencies.\"\n    );\n    const fakeMethods = [\n      \"init\",\n      \"getState\",\n      \"setState\",\n      \"save\",\n      \"getArtifactMetadata\",\n      \"getArtifactMetadataAllVersions\",\n      \"updateArtifactMetadata\",\n      \"deleteArtifactMetadata\",\n      \"getAllArtifactMetadata\",\n      \"capturePreservationState\",\n      \"restoreStateFromSession\",\n      \"exportState\",\n      \"importState\",\n      \"isInitialized\",\n      \"addEvaluationResult\",\n      \"addCritiqueFeedback\",\n      \"registerWebComponent\",\n      \"isWebComponentRegistered\",\n      \"getRegisteredWebComponents\",\n      \"updateAndSaveState\",\n    ];\n    const fakeStateManager = {};\n    fakeMethods.forEach((method) => {\n      fakeStateManager[method] = () => {\n        internalLog.logEvent(\n          \"error\",\n          `StateManager not initialized. Called ${method}.`\n        );\n        if (method === \"isInitialized\") return false;\n        if (method === \"getState\") return null;\n        if (\n          method === \"getAllArtifactMetadata\" ||\n          method === \"getRegisteredWebComponents\"\n        )\n          return {};\n        if (method === \"getArtifactMetadataAllVersions\") return [];\n      };\n    });\n    return fakeStateManager;\n  }\n\n  const { StateError } = Errors;\n  let globalState = null;\n  let isInitializedFlag = false;\n\n  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(\".\")[0];\n  const STATE_VERSION_MINOR = config.STATE_VERSION.split(\".\")[1];\n  const STATE_VERSION_PATCH = config.STATE_VERSION.split(\".\")[2];\n  const MAX_HISTORY_ITEMS = config.MAX_HISTORY_ITEMS || 20;\n  const EVAL_PASS_THRESHOLD = config.EVAL_PASS_THRESHOLD || 0.75;\n\n  const calculateDerivedStatsAndUpdateState = (stateToUpdate) => {\n    if (!stateToUpdate) return;\n    const derived = StateHelpersPure.calculateDerivedStatsPure(\n      stateToUpdate.confidenceHistory,\n      stateToUpdate.critiqueFailHistory,\n      stateToUpdate.tokenHistory,\n      stateToUpdate.evaluationHistory,\n      MAX_HISTORY_ITEMS,\n      EVAL_PASS_THRESHOLD\n    );\n    Object.assign(stateToUpdate, derived);\n  };\n\n  const checkAndLogVersionDifference = (loadedVersion, source) => {\n    if (!loadedVersion || typeof loadedVersion !== \"string\") return true;\n    const [major, minor, patch] = loadedVersion.split(\".\").map(Number);\n    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {\n      logger.logEvent(\n        \"warn\",\n        `Invalid version string '${loadedVersion}' in state from ${source}. Proceeding cautiously.`\n      );\n      return true;\n    }\n    if (major !== parseInt(STATE_VERSION_MAJOR, 10)) {\n      logger.logEvent(\n        \"error\",\n        `Incompatible MAJOR version detected in state from ${source}.`,\n        `Loaded: ${loadedVersion}, Required: ${config.STATE_VERSION}. Discarding state.`\n      );\n      return false;\n    } else if (\n      minor < parseInt(STATE_VERSION_MINOR, 10) ||\n      (minor === parseInt(STATE_VERSION_MINOR, 10) &&\n        patch < parseInt(STATE_VERSION_PATCH, 10))\n    ) {\n      logger.logEvent(\n        \"warn\",\n        `Loading older MINOR/PATCH version state from ${source}.`,\n        `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. Applying defaults for new fields.`\n      );\n    } else if (\n      minor > parseInt(STATE_VERSION_MINOR, 10) ||\n      (minor === parseInt(STATE_VERSION_MINOR, 10) &&\n        patch > parseInt(STATE_VERSION_PATCH, 10))\n    ) {\n      logger.logEvent(\n        \"warn\",\n        `Loading newer MINOR/PATCH version state from ${source}.`,\n        `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. May encounter issues.`\n      );\n    }\n    return true;\n  };\n\n  const init = () => {\n    if (isInitializedFlag) return true;\n    const savedState = Storage.getState();\n    let validationError = null;\n\n    if (savedState) {\n      validationError = StateHelpersPure.validateStateStructurePure(\n        savedState,\n        config.STATE_VERSION,\n        Utils.getDefaultState\n      );\n      if (validationError) {\n        logger.logEvent(\n          \"error\",\n          `Saved state validation failed: ${validationError}. Discarding and re-initializing.`\n        );\n        Storage.removeState();\n        globalState = Utils.getDefaultState(config);\n      } else {\n        const isCompatible = checkAndLogVersionDifference(\n          savedState.version,\n          \"localStorage\"\n        );\n        if (!isCompatible) {\n          Storage.removeState();\n          globalState = Utils.getDefaultState(config);\n        } else {\n          globalState = StateHelpersPure.mergeWithDefaultsPure(\n            savedState,\n            Utils.getDefaultState,\n            config.STATE_VERSION\n          );\n          globalState.version = config.STATE_VERSION;\n          logger.logEvent(\n            \"info\",\n            `Loaded state v${savedState.version} (Cycle ${globalState.totalCycles}), updated to v${config.STATE_VERSION}`\n          );\n        }\n      }\n    } else {\n      logger.logEvent(\n        \"info\",\n        `No saved state found. Initializing new default state v${config.STATE_VERSION}`\n      );\n      globalState = Utils.getDefaultState(config);\n      if (config.GENESIS_ARTIFACT_DEFS) {\n        for (const id in config.GENESIS_ARTIFACT_DEFS) {\n          if (id === \"reploid.core.config\") continue;\n          const def = config.GENESIS_ARTIFACT_DEFS[id];\n          if (!globalState.artifactMetadata[id]) {\n            globalState.artifactMetadata[id] = [\n              {\n                id: id,\n                version_id: null,\n                type: def.type || \"UNKNOWN\",\n                description: def.description || `Artifact ${id}`,\n                latestCycle: -1,\n                source: \"Initial Definition\",\n                checksum: null,\n                timestamp: 0,\n                paradigm: def.paradigm || \"unknown\",\n              },\n            ];\n          }\n        }\n      }\n    }\n    calculateDerivedStatsAndUpdateState(globalState);\n    _saveInternal();\n    isInitializedFlag = true;\n    return globalState && globalState.totalCycles >= 0;\n  };\n\n  const getState = () => globalState;\n\n  const _updateGlobalStateReference = (newState) => {\n    globalState = newState;\n  };\n\n  const updateAndSaveState = (updaterFn) => {\n    if (typeof updaterFn !== \"function\") {\n      logger.logEvent(\n        \"error\",\n        \"Invalid updater function provided to updateAndSaveState.\"\n      );\n      return globalState;\n    }\n    const currentState = getState();\n    const newState = updaterFn(JSON.parse(JSON.stringify(currentState))); // Pass a deep copy to updater\n\n    const validationError = StateHelpersPure.validateStateStructurePure(\n      newState,\n      config.STATE_VERSION,\n      Utils.getDefaultState\n    );\n    if (validationError) {\n      logger.logEvent(\n        \"error\",\n        `Attempted to set invalid state via updaterFn: ${validationError}`\n      );\n      throw new StateError(\n        `Attempted to set invalid state via updaterFn: ${validationError}`\n      );\n    }\n    _updateGlobalStateReference(newState);\n    calculateDerivedStatsAndUpdateState(globalState);\n    _saveInternal();\n    return globalState;\n  };\n\n  const _saveInternal = () => {\n    if (!globalState || !Storage) return;\n    try {\n      const stateToSave = JSON.parse(\n        JSON.stringify({ ...globalState, lastApiResponse: null })\n      );\n      Storage.saveState(stateToSave);\n      logger.logEvent(\n        \"debug\",\n        `Saved state (Cycle ${globalState.totalCycles})`\n      );\n    } catch (e) {\n      logger.logEvent(\"error\", `Save state failed: ${e.message}`, e);\n    }\n  };\n\n  const getArtifactMetadata = (id, versionId = null) => {\n    const history = globalState?.artifactMetadata?.[id];\n    if (!history || history.length === 0) return null;\n    if (versionId === null) {\n      return Utils.getLatestMeta(history);\n    } else {\n      return history.find((meta) => meta.version_id === versionId) || null;\n    }\n  };\n\n  const getArtifactMetadataAllVersions = (id) =>\n    globalState?.artifactMetadata?.[id] || [];\n\n  const updateArtifactMetadata = (\n    id,\n    type,\n    description,\n    cycle,\n    checksum = null,\n    source = \"Agent Modified\",\n    versionId = null,\n    isModular = false,\n    newParadigm = null\n  ) => {\n    return updateAndSaveState((currentState) => {\n      if (!currentState.artifactMetadata[id])\n        currentState.artifactMetadata[id] = [];\n      const now = Date.now();\n      let existingMetaIndex = -1;\n\n      if (versionId !== null) {\n        existingMetaIndex = currentState.artifactMetadata[id].findIndex(\n          (meta) => meta.version_id === versionId && meta.latestCycle === cycle\n        );\n        if (existingMetaIndex === -1)\n          existingMetaIndex = currentState.artifactMetadata[id].findIndex(\n            (meta) => meta.version_id === versionId\n          );\n      } else {\n        const cycleMatches = currentState.artifactMetadata[id].filter(\n          (meta) => meta.latestCycle === cycle && meta.version_id === null\n        );\n        if (cycleMatches.length > 0) {\n          const latestCycleMatch = cycleMatches.sort(\n            (a, b) => (b.timestamp || 0) - (a.timestamp || 0)\n          )[0];\n          existingMetaIndex =\n            currentState.artifactMetadata[id].indexOf(latestCycleMatch);\n        } else {\n          const latestNullVersionMetas = currentState.artifactMetadata[id]\n            .filter((m) => m.version_id === null)\n            .sort(\n              (a, b) =>\n                b.latestCycle - a.latestCycle ||\n                (b.timestamp || 0) - (a.timestamp || 0)\n            );\n          if (latestNullVersionMetas.length > 0)\n            existingMetaIndex = currentState.artifactMetadata[id].indexOf(\n              latestNullVersionMetas[0]\n            );\n        }\n      }\n\n      const baseMeta = getArtifactMetadata(id, versionId); // Read before modifying array\n\n      const newMetaEntry = {\n        id: id,\n        version_id: versionId,\n        type: type ?? baseMeta?.type ?? \"UNKNOWN\",\n        description: description ?? baseMeta?.description ?? `Artifact ${id}`,\n        latestCycle: cycle,\n        checksum: checksum,\n        source: source,\n        timestamp: now,\n        isModularEdit: isModular,\n        paradigm:\n          newParadigm ??\n          baseMeta?.paradigm ??\n          config.GENESIS_ARTIFACT_DEFS?.[id]?.paradigm ??\n          \"unknown\",\n      };\n\n      if (existingMetaIndex !== -1) {\n        currentState.artifactMetadata[id][existingMetaIndex] = newMetaEntry;\n      } else {\n        currentState.artifactMetadata[id].push(newMetaEntry);\n      }\n      return currentState;\n    });\n  };\n\n  const deleteArtifactMetadata = (id, versionId = null) => {\n    return updateAndSaveState((currentState) => {\n      if (!currentState.artifactMetadata[id]) return currentState;\n      if (versionId !== null) {\n        currentState.artifactMetadata[id] = currentState.artifactMetadata[\n          id\n        ].filter((meta) => meta.version_id !== versionId);\n        if (currentState.artifactMetadata[id].length === 0)\n          delete currentState.artifactMetadata[id];\n      } else {\n        delete currentState.artifactMetadata[id];\n      }\n      return currentState;\n    });\n  };\n\n  const getAllArtifactMetadata = () => {\n    const latestMetaMap = {};\n    if (!globalState?.artifactMetadata) return latestMetaMap;\n    for (const id in globalState.artifactMetadata) {\n      const latest = getArtifactMetadata(id, null);\n      if (latest) latestMetaMap[id] = latest;\n    }\n    return latestMetaMap;\n  };\n\n  const capturePreservationState = (uiRefs = {}) => {\n    if (!globalState) return null;\n    try {\n      const stateToPreserve = JSON.parse(\n        JSON.stringify({ ...globalState, lastApiResponse: null })\n      );\n      stateToPreserve.logBuffer = logger.getLogBuffer\n        ? logger.getLogBuffer()\n        : null;\n      stateToPreserve.timelineHTML = uiRefs.timelineLog?.innerHTML || \"\";\n      return stateToPreserve;\n    } catch (e) {\n      logger.logEvent(\n        \"error\",\n        `Failed to capture preservation state: ${e.message}`,\n        e\n      );\n      return null;\n    }\n  };\n\n  const restoreStateFromSession = (restoreUIFn = () => {}) => {\n    if (!isInitializedFlag) {\n      logger.logEvent(\n        \"warn\",\n        \"Cannot restore session, StateManager not initialized.\"\n      );\n      return false;\n    }\n    const preservedData = Storage.getSessionState();\n    if (!preservedData) return false;\n\n    logger.logEvent(\n      \"info\",\n      \"Preserved session state found. Attempting restore.\"\n    );\n    try {\n      const validationError = StateHelpersPure.validateStateStructurePure(\n        preservedData,\n        config.STATE_VERSION,\n        Utils.getDefaultState\n      );\n      if (validationError)\n        throw new StateError(\n          `Session state validation failed: ${validationError}`\n        );\n      const isCompatible = checkAndLogVersionDifference(\n        preservedData.version,\n        \"sessionStorage\"\n      );\n      if (!isCompatible)\n        throw new StateError(\n          `Incompatible MAJOR version in session state: ${preservedData.version}`\n        );\n\n      _updateGlobalStateReference(\n        StateHelpersPure.mergeWithDefaultsPure(\n          preservedData,\n          Utils.getDefaultState,\n          config.STATE_VERSION\n        )\n      );\n      globalState.version = config.STATE_VERSION;\n\n      if (logger.setLogBuffer && preservedData.logBuffer)\n        logger.setLogBuffer(preservedData.logBuffer);\n      calculateDerivedStatsAndUpdateState(globalState);\n      restoreUIFn(preservedData);\n      logger.logEvent(\n        \"info\",\n        \"Session state restored successfully by StateManager.\"\n      );\n      _saveInternal();\n      return true;\n    } catch (e) {\n      logger.logEvent(\"error\", `Restore from session failed: ${e.message}`, e);\n      init();\n      return false;\n    } finally {\n      Storage.removeSessionState();\n      logger.logEvent(\n        \"debug\",\n        \"Cleared session state from storage after attempt.\"\n      );\n    }\n  };\n\n  const exportState = (uiRefs = {}) => {\n    logger.logEvent(\n      \"info\",\n      \"Exporting state (metadata and UI state only, NOT artifact content)...\"\n    );\n    try {\n      const stateData = capturePreservationState(uiRefs);\n      if (!stateData) {\n        logger.logEvent(\"error\", \"Failed to capture state for export.\");\n        if (typeof showNotification === \"function\")\n          showNotification?.(\"Error capturing state for export.\", \"error\");\n        return;\n      }\n      const fileName = `x0_state_${config.STATE_VERSION}_${new Date()\n        .toISOString()\n        .replace(/[:.]/g, \"-\")}.json`;\n      const dataStr = JSON.stringify(stateData, null, 2);\n      const blob = new Blob([dataStr], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = fileName;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      logger.logEvent(\"info\", \"State export initiated.\");\n    } catch (e) {\n      logger.logEvent(\"error\", `State export failed: ${e.message}`, e);\n      if (typeof showNotification === \"function\")\n        showNotification?.(`State export failed: ${e.message}`, \"error\");\n    }\n  };\n\n  const importState = (file, importCallback = () => {}) => {\n    logger.logEvent(\n      \"info\",\n      \"Attempting to import state (metadata and UI state only, NOT artifact content)...\"\n    );\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      try {\n        if (!e.target?.result)\n          throw new Error(\"File read returned null result.\");\n        const importedData = JSON.parse(e.target.result);\n        const validationError = StateHelpersPure.validateStateStructurePure(\n          importedData,\n          config.STATE_VERSION,\n          Utils.getDefaultState,\n          `imported file '${file.name}'`\n        );\n        if (validationError)\n          throw new StateError(\n            `Imported state validation failed: ${validationError}`\n          );\n        logger.logEvent(\"info\", `Importing state v${importedData.version}`);\n        const isCompatible = checkAndLogVersionDifference(\n          importedData.version,\n          `imported file '${file.name}'`\n        );\n        if (!isCompatible)\n          throw new StateError(\n            `Incompatible MAJOR version in imported state: ${importedData.version}`\n          );\n\n        _updateGlobalStateReference(\n          StateHelpersPure.mergeWithDefaultsPure(\n            importedData,\n            Utils.getDefaultState,\n            config.STATE_VERSION\n          )\n        );\n        globalState.version = config.STATE_VERSION;\n\n        if (logger.setLogBuffer && importedData.logBuffer)\n          logger.setLogBuffer(importedData.logBuffer);\n        calculateDerivedStatsAndUpdateState(globalState);\n        importCallback(true, importedData);\n        logger.logEvent(\"info\", \"State imported successfully by StateManager.\");\n        _saveInternal();\n      } catch (err) {\n        logger.logEvent(\"error\", `Import failed: ${err.message}`, err);\n        importCallback(false, null, err.message);\n      }\n    };\n    reader.onerror = (e) => {\n      const errorMsg = `File read error: ${reader.error || \"Unknown\"}`;\n      logger.logEvent(\"error\", errorMsg);\n      importCallback(false, null, errorMsg);\n    };\n    reader.readAsText(file);\n  };\n\n  const addEvaluationResult = (result) => {\n    return updateAndSaveState((currentState) => {\n      if (!currentState.evaluationHistory) currentState.evaluationHistory = [];\n      currentState.evaluationHistory.push(result);\n      while (currentState.evaluationHistory.length > MAX_HISTORY_ITEMS)\n        currentState.evaluationHistory.shift();\n      return currentState;\n    });\n  };\n\n  const addCritiqueFeedback = (feedbackData) => {\n    return updateAndSaveState((currentState) => {\n      if (!currentState.critiqueFeedbackHistory)\n        currentState.critiqueFeedbackHistory = [];\n      currentState.critiqueFeedbackHistory.push({\n        cycle: currentState.totalCycles,\n        feedback: feedbackData,\n        timestamp: Date.now(),\n      });\n      while (currentState.critiqueFeedbackHistory.length > MAX_HISTORY_ITEMS)\n        currentState.critiqueFeedbackHistory.shift();\n      return currentState;\n    });\n  };\n\n  const registerWebComponent = (tagName) => {\n    return updateAndSaveState((currentState) => {\n      if (!Array.isArray(currentState.registeredWebComponents))\n        currentState.registeredWebComponents = [];\n      if (\n        typeof tagName === \"string\" &&\n        tagName.includes(\"-\") &&\n        !currentState.registeredWebComponents.includes(tagName)\n      ) {\n        currentState.registeredWebComponents.push(tagName);\n        logger.logEvent(\n          \"info\",\n          `StateManager: Web component '${tagName}' marked as registered.`\n        );\n      } else if (currentState.registeredWebComponents.includes(tagName)) {\n        logger.logEvent(\n          \"debug\",\n          `StateManager: Web component '${tagName}' was already marked as registered.`\n        );\n      } else {\n        logger.logEvent(\n          \"warn\",\n          `StateManager: Invalid or already registered web component tag name: '${tagName}'`\n        );\n      }\n      return currentState;\n    });\n  };\n\n  const isWebComponentRegistered = (tagName) =>\n    globalState?.registeredWebComponents?.includes(tagName) || false;\n  const getRegisteredWebComponents = () => [\n    ...(globalState?.registeredWebComponents || []),\n  ];\n\n  return {\n    init,\n    getState,\n    updateAndSaveState,\n    getArtifactMetadata,\n    getArtifactMetadataAllVersions,\n    updateArtifactMetadata,\n    deleteArtifactMetadata,\n    getAllArtifactMetadata,\n    capturePreservationState,\n    restoreStateFromSession,\n    exportState,\n    importState,\n    isInitialized: () => isInitializedFlag,\n    addEvaluationResult,\n    addCritiqueFeedback,\n    registerWebComponent,\n    isWebComponentRegistered,\n    getRegisteredWebComponents,\n  };\n};\n",
  "_x0_target.script.js_1": "// LLM Prompt Challenge - Game Logic\n// Version 0.1 - Foundation\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log(\"LLM Prompt Challenge Game Loaded!\");\n\n    const submitButton = document.getElementById('submit-prompt');\n    const userPromptTextarea = document.getElementById('user-prompt');\n    const targetOutputDiv = document.getElementById('target-output');\n    const llmResponseDiv = document.getElementById('llm-response');\n    const feedbackDiv = document.getElementById('feedback-area');\n\n    // Placeholder for game initialization\n    function initializeGame() {\n        console.log(\"Initializing game...\");\n        // For now, let's set a static target\n        targetOutputDiv.innerHTML = \"<p><strong>Target:</strong> A three-sentence horror story about a haunted toaster.</p>\";\n        llmResponseDiv.innerHTML = \"<p><em>The LLM eagerly awaits your creative genius!</em></p>\";\n        feedbackDiv.innerHTML = \"<p><em>Remember, the right words can unlock wonders.</em></p>\";\n    }\n\n    // Placeholder for handling prompt submission\n    function handleSubmitPrompt() {\n        const prompt = userPromptTextarea.value;\n        console.log(\"User prompt submitted:\", prompt);\n\n        if (!prompt.trim()) {\n            feedbackDiv.innerHTML = \"<p style='color: orange;'>Please enter a prompt first. Let your imagination flow!</p>\";\n            return;\n        }\n\n        // Simulate LLM processing (replace with actual LLM call later)\n        llmResponseDiv.innerHTML = `<p><strong>Simulated LLM Response to:</strong> \"${prompt}\"</p><p><em>...beep boop... thinking ...</em></p><p>The toaster, acquired from a dusty antique shop, began to whisper secrets of burnt offerings and forgotten breakfasts. Its metallic slot glowed with an eerie, orange light, not from heating coils, but from a hunger that toast alone could not satisfy. Every morning, it demanded a new story, a new sacrifice of words, lest it start toasting more than just bread.</p>`;\n\n        // Simulate feedback (replace with actual scoring/feedback later)\n        feedbackDiv.innerHTML = \"<p style='color: green;'>That's an interesting attempt! The LLM has spoken. How close were you to the target?</p>\";\n\n        // For a real game, you'd compare the llmResponse to the targetOutput\n        // and provide more specific feedback.\n    }\n\n    if (submitButton) {\n        submitButton.addEventListener('click', handleSubmitPrompt);\n    } else {\n        console.error(\"Submit button not found! The story cannot begin without it.\");\n    }\n\n    initializeGame();\n});"
}
