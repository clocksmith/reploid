<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />
    <base id="reploid-base" href="/" />
    <script>
      (function () {
        const base = document.getElementById("reploid-base");
        if (!base) return;
        base.href = window.location.pathname.startsWith("/src/") ? "/src/" : "/";
      })();
    </script>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <title>Reploid</title>

    <script>
    window.REPLOID_SW_VERSION = "1735500005";
    window.REPLOID_VFS_VERSION = "1735500005";
      (function () {
        const key = "REPLOID_SW_VERSION";
        if (!("serviceWorker" in navigator)) return;
        const expected = window.REPLOID_SW_VERSION;
        if (!expected) return;
        const current = localStorage.getItem(key);
        if (current === expected) return;
        navigator.serviceWorker.getRegistrations().then((regs) => {
          if (!regs.length) {
            localStorage.setItem(key, expected);
            return;
          }
          return Promise.all(regs.map((reg) => reg.unregister())).then(() => {
            localStorage.setItem(key, expected);
            window.location.reload();
          });
        }).catch(() => {});
      })();
    </script>

    <link rel="stylesheet" href="styles/rd.css?v=1735500000" />
    <link rel="stylesheet" href="styles/boot.css?v=1735500000" />

    <script type="importmap">
      {
        "imports": {
          "@clocksmith/doppler": "/doppler/src/index.js",
          "@clocksmith/doppler/provider": "/doppler/src/client/doppler-provider.js",
          "@clocksmith/doppler/bridge/": "/doppler/src/bridge/",
          "@clocksmith/doppler/browser/": "/doppler/src/browser/",
          "@clocksmith/doppler/": "/doppler/src/"
        }
      }
    </script>

  </head>
  <body>
    <!-- Boot Wizard -->
    <div id="wizard-container" class="wizard-container" style="display: none">
      <!-- Wizard content rendered by ui/boot-wizard/index.js -->
    </div>

    <!-- App container for main UI -->
    <div id="app"></div>

    <script>
      // Perform full reset (preserves API keys)
      async function performFullReset() {
        const steps = [];

        // Service Workers
        if ("serviceWorker" in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map((reg) => reg.unregister()));
          steps.push(`Unregistered ${regs.length} service worker(s)`);
        }

        // Browser Caches
        if ("caches" in window) {
          const cacheNames = await caches.keys();
          await Promise.all(cacheNames.map((name) => caches.delete(name)));
          steps.push(`Cleared ${cacheNames.length} cache(s)`);
        }

        // LocalStorage (preserve API keys)
        const keysToPreserve = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.includes("KEY_") || key.includes("api_key"))) {
            keysToPreserve.push({ key, value: localStorage.getItem(key) });
          }
        }
        const lsCount = localStorage.length;
        localStorage.clear();
        keysToPreserve.forEach(({ key, value }) =>
          localStorage.setItem(key, value)
        );
        steps.push(
          `Cleared ${lsCount - keysToPreserve.length} localStorage keys`
        );

        // IndexedDB
        if ("databases" in indexedDB) {
          const dbs = await indexedDB.databases();
          await Promise.all(
            dbs.map(
              (db) =>
                new Promise((resolve) => {
                  const timeoutId = setTimeout(() => resolve(), 3000);
                  const req = indexedDB.deleteDatabase(db.name);
                  req.onsuccess = () => {
                    clearTimeout(timeoutId);
                    resolve();
                  };
                  req.onerror = () => {
                    clearTimeout(timeoutId);
                    resolve();
                  };
                  req.onblocked = () => {
                    clearTimeout(timeoutId);
                    resolve();
                  };
                })
            )
          );
          steps.push(`Deleted ${dbs.length} database(s)`);
        }

        console.log("[Reset]", steps.join("; "));
        return steps;
      }

      // Clear only VFS (IndexedDB) - lighter reset for awaken
      async function clearVFS() {
        if (!("databases" in indexedDB)) {
          console.log("[Reset] indexedDB.databases not supported, skipping VFS clear");
          return [];
        }
        const dbs = await indexedDB.databases();
        await Promise.all(
          dbs.map(
            (db) =>
              new Promise((resolve) => {
                const timeoutId = setTimeout(() => resolve(), 3000);
                const req = indexedDB.deleteDatabase(db.name);
                req.onsuccess = () => {
                  clearTimeout(timeoutId);
                  resolve();
                };
                req.onerror = () => {
                  clearTimeout(timeoutId);
                  resolve();
                };
                req.onblocked = () => {
                  clearTimeout(timeoutId);
                  resolve();
                };
              })
          )
        );
        console.log(`[Reset] Cleared ${dbs.length} VFS database(s)`);
        return [`Cleared ${dbs.length} VFS database(s)`];
      }

      // Expose reset functions for entry/start-app.js
      window.shouldResetAll = () =>
        localStorage.getItem("REPLOID_RESET_ALL") === "true";
      window.performFullReset = performFullReset;
      window.clearVFS = clearVFS;

      // Execution limits (used by agent-loop)
      window.getExecutionLimits = () => {
        const stored = localStorage.getItem("REPLOID_MAX_ITERATIONS");
        // 0 means no limit, null/undefined defaults to 25
        const maxIterations =
          stored === "0" ? Infinity : parseInt(stored) || 25;
        return {
          maxIterations,
          approvalInterval:
            parseInt(localStorage.getItem("REPLOID_APPROVAL_INTERVAL")) || 0,
        };
      };

      // Genesis level (used by boot)
      window.getGenesisLevel = () =>
        localStorage.getItem("REPLOID_GENESIS_LEVEL") || "full";

      // Cognition config (used by memory systems)
      window.getCognitionConfig = () => {
        try {
          return JSON.parse(
            localStorage.getItem("REPLOID_COGNITION_CONFIG") || "{}"
          );
        } catch {
          return {};
        }
      };

      // GEPA config (used by GEPA optimizer)
      window.getGEPAConfig = () => {
        try {
          return JSON.parse(
            localStorage.getItem("REPLOID_GEPA_CONFIG") || "{}"
          );
        } catch {
          return {};
        }
      };

      // One-click reset via query param (?reset=1)
      (function () {
        if (typeof window === "undefined") return;
        const key = "REPLOID_RESET_ONCE";
        const url = new URL(window.location.href);
        const resetParam = url.searchParams.get("reset");

        if (!resetParam) {
          if (sessionStorage.getItem(key) === "true") {
            sessionStorage.removeItem(key);
          }
          return;
        }

        if (sessionStorage.getItem(key) === "true") return;
        sessionStorage.setItem(key, "true");

        Promise.resolve()
          .then(() => performFullReset())
          .finally(() => {
            url.searchParams.delete("reset");
            const next =
              url.pathname + (url.search ? url.search : "") + url.hash;
            window.location.replace(next);
          });
      })();
    </script>

    <script type="module" src="entry/seed-vfs.js?v=1735500000"></script>
  </body>
</html>
