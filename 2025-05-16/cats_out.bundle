# Cats Bundle
# Format: Raw UTF-8 (All files appear UTF-8 compatible)

ðŸˆ --- CATS_START_FILE: agent-cycle.js ---
const CycleLogicModule = (
  config,
  logger,
  Utils,
  Storage,
  StateManager,
  UI,
  ApiClient,
  ToolRunner,
  Errors
) => {
  if (
    !config || !logger || !Utils || !Storage || !StateManager ||
    !UI || !ApiClient || !ToolRunner || !Errors
  ) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[CYCLELOGIC_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error", "CycleLogicModule initialization failed: Missing one or more core dependencies.");
    const dummy = {};
    const methods = [ "init", "executeCycle", "isRunning", "getActiveGoalInfo", "proceedAfterHumanIntervention", "handleSummarizeContext", "abortCurrentCycle", "saveHtmlToHistory", "runTool", "startAutonomousRun", "stopAutonomousRun" ];
    methods.forEach(m => {
      dummy[m] = () => {
        internalLog.logEvent("error", `CycleLogic not initialized. Called ${m}.`);
        if (m === "isRunning") return false;
        if (m === "getActiveGoalInfo") return { type: "Idle", latestGoal: "Idle" };
        if (["executeCycle", "handleSummarizeContext", "runTool"].includes(m)) return Promise.reject(new Error("CycleLogic not initialized"));
        return undefined;
      };
    });
    return dummy;
  }

  const {
    ApplicationError, ApiError, ToolError, StateError,
    ConfigError, ArtifactError, AbortError, WebComponentError,
  } = Errors;

  let _isRunning = false;
  let _isAutonomous = false;
  let _abortRequested = false;
  let currentLlmResponse = null;
  let loadedStaticTools = [];
  let isLogicInitialized = false;
  const NUM_CRITIQUES_TO_GENERATE = config.NUM_CRITIQUES_TO_GENERATE || 1;

  const init = () => {
    if (isLogicInitialized) return;
    logger.logEvent("info", "Initializing CycleLogic Module...");
    try {
      const staticToolsContent = Storage.getArtifactContent("reploid.core.static-tools", 0);
      if (staticToolsContent) {
        loadedStaticTools = JSON.parse(staticToolsContent);
        logger.logEvent("debug", `CycleLogic loaded ${loadedStaticTools.length} static tools definitions.`);
      } else {
        logger.logEvent("warn", "Static tools artifact (reploid.core.static-tools) not found. Using empty list.");
        loadedStaticTools = [];
      }
    } catch (e) {
      logger.logEvent("error", `Failed to load/parse static tools: ${e.message}`, e);
      loadedStaticTools = [];
    }
    isLogicInitialized = true;
    logger.logEvent("info", "CycleLogic Module initialized.");
  };

  const isRunning = () => _isRunning;
  const isAutonomous = () => _isAutonomous;

  const getActiveGoalInfo = () => {
    const state = StateManager?.getState();
    if (!state || !state.currentGoal)
      return {
        seedGoal: "N/A", cumulativeGoal: "N/A", latestGoal: "Idle",
        type: "Idle", summaryContext: null, currentContextFocus: null,
      };
    const latestGoal = state.currentGoal.cumulative || state.currentGoal.seed;
    return {
      seedGoal: state.currentGoal.seed || "None",
      cumulativeGoal: state.currentGoal.cumulative || "None",
      latestGoal: latestGoal || "Idle",
      type: state.currentGoal.latestType || "Idle",
      summaryContext: state.currentGoal.summaryContext || null,
      currentContextFocus: state.currentGoal.currentContextFocus || null,
    };
  };

  const _getArtifactListSummary = () => {
    if (!StateManager) return "Error: StateManager not available.";
    const allMetaMap = StateManager.getAllArtifactMetadata();
    return ( Object.values(allMetaMap)
        .filter((meta) => meta && meta.latestCycle >= 0)
        .map( (meta) => `* ${meta.id} (${meta.type || "UNTYPED"}) - Cycle ${meta.latestCycle}${meta.version_id ? ` V:${meta.version_id}` : ""}` )
        .join("\n") || "None" );
  };

  const _getRegisteredWebComponentsList = () => {
    if (!StateManager) return "Error: StateManager not available for WC list.";
    const wcList = StateManager.getRegisteredWebComponents();
    return wcList.length > 0 ? wcList.map((tag) => `* <${tag}>`).join("\n") : "None";
  };

  const _getToolListSummary = () => {
    if (!StateManager) return "Error: StateManager not available.";
    const state = StateManager.getState();
    const dynamicTools = state?.dynamicTools || [];
    const staticToolSummary = loadedStaticTools.map((t) => `* [S] ${t.name}: ${Utils.trunc(t.description, 60)}`).join("\n");
    const dynamicToolSummary = dynamicTools.map( (t) => `* [D] ${t.declaration.name}: ${Utils.trunc(t.declaration.description, 60)}`).join("\n");
    return ( [staticToolSummary, dynamicToolSummary].filter((s) => s).join("\n") || "None" );
  };

  const _summarizeHistory = (historyArray, label, maxItems = 5) => {
    if (!historyArray || historyArray.length === 0) return `No ${label} available.`;
    const recentItems = historyArray.slice(-maxItems);
    return recentItems.map((item, index) => {
        const itemIndex = historyArray.length - recentItems.length + index + 1;
        let summary = `${label} ${itemIndex}: `;
        if (label.includes("Eval")) {
          summary += `Score=${item.evaluation_score?.toFixed(2)}, Target=${item.targetArtifactId || "N/A"}(C${item.targetArtifactCycle ?? "N/A"}), Report=${Utils.trunc(item.evaluation_report, 50)}`;
        } else if (label.includes("Critique History")) {
          summary += item ? "Fail" : "Pass";
        } else if (label.includes("Critique Feedback")) {
          summary += `Selected: ${item.feedback?.selectedCritique ?? "N/A"}, Notes: ${Utils.trunc(item.feedback?.feedbackNotes, 60)}`;
        } else if (label.includes("Fail History")) {
          summary += `Cycle ${item.cycle}, Reason: ${Utils.trunc(item.reason, 60)}`;
        } else {
          summary += Utils.trunc(JSON.stringify(item), 80);
        }
        return summary;
      }).join(" | ");
  };

  const _assembleCorePrompt = (state, goalInfo, currentCycle) => {
    const corePromptTemplate = Storage.getArtifactContent("reploid.core.sys-prompt", 0);
    if (!corePromptTemplate) throw new ArtifactError("Core prompt artifact 'reploid.core.sys-prompt' not found!", "reploid.core.sys-prompt", 0);

    const personaBalance = state.cfg?.personaBalance ?? 50;
    const primaryPersona = state.personaMode;
    const critiqueHistorySummary = _summarizeHistory(state.critiqueFailHistory || [], "Critique History");
    const critiqueFeedbackSummary = _summarizeHistory(state.critiqueFeedbackHistory || [], "Critique Feedback");
    const evaluationHistorySummary = _summarizeHistory(state.evaluationHistory || [], "Evaluation History");

    let currentContext = goalInfo.cumulativeGoal || "None";
    if (goalInfo.summaryContext) {
      currentContext += `\n\n--- Current Summary Context ---\n${goalInfo.summaryContext}`;
    }

    let prompt = corePromptTemplate
      .replace(/\[LSD_PERCENT\]/g, String(personaBalance))
      .replace(/\[PERSONA_MODE\]/g, primaryPersona)
      .replace(/\[CYCLE_COUNT\]/g, String(state.totalCycles))
      .replace(/\[AGENT_ITR_COUNT\]/g, String(state.agentIterations))
      .replace(/\[HUMAN_INT_COUNT\]/g, String(state.humanInterventions))
      .replace(/\[FAIL_COUNT\]/g, String(state.failCount))
      .replace(/\[LAST_FEEDBACK\]/g, Utils.trunc(state.lastFeedback || "None", 500))
      .replace(/\[\[CRITIQUE_HISTORY_SUMMARY\]\]/g, critiqueHistorySummary)
      .replace(/\[\[CRITIQUE_FEEDBACK_SUMMARY\]\]/g, critiqueFeedbackSummary)
      .replace(/\[\[EVALUATION_HISTORY_SUMMARY\]\]/g, evaluationHistorySummary)
      .replace(/\[AVG_CONF\]/g, state.avgConfidence?.toFixed(2) || "N/A")
      .replace(/\[CRIT_FAIL_RATE\]/g, state.critiqueFailRate?.toFixed(1) + "%" || "N/A")
      .replace(/\[AVG_TOKENS\]/g, state.avgTokens?.toFixed(0) || "N/A")
      .replace(/\[AVG_EVAL_SCORE\]/g, state.avgEvalScore?.toFixed(2) || "N/A")
      .replace(/\[CTX_TOKENS\]/g, state.contextTokenEstimate?.toLocaleString() || "0")
      .replace(/\[CTX_TARGET\]/g, state.contextTokenTarget?.toLocaleString() || "~1M")
      .replace(/\[\[DYNAMIC_TOOLS_LIST\]\]/g, _getToolListSummary())
      .replace(/\[\[REGISTERED_WEB_COMPONENTS_LIST\]\]/g, _getRegisteredWebComponentsList())
      .replace(/\[\[RECENT_LOGS\]\]/g, Utils.trunc(logger.getLogBuffer ? logger.getLogBuffer().split("\n").slice(-15).join("\n") : "Logs unavailable", 1000))
      .replace(/\[\[ARTIFACT_LIST\]\]/g, _getArtifactListSummary())
      .replace(/\[\[SEED_GOAL_DESC\]\]/g, Utils.trunc(goalInfo.seedGoal || "None", 1000))
      .replace(/\[\[CUMULATIVE_GOAL_DESC\]\]/g, Utils.trunc(currentContext, 4000))
      .replace(/\[\[SUMMARY_CONTEXT\]\]/g, Utils.trunc(goalInfo.summaryContext || "None", 2000))
      .replace(/\[\[CURRENT_CONTEXT_FOCUS\]\]/g, goalInfo.currentContextFocus || "Full Goal Context");

    const allMetaMap = StateManager.getAllArtifactMetadata();
    const relevantArtifacts = Object.keys(allMetaMap)
      .filter( (id) => allMetaMap[id]?.latestCycle >= 0 && (id.startsWith("target.") || (goalInfo.type === "Meta" && id.startsWith("reploid."))) )
      .sort( (a, b) => (allMetaMap[b]?.latestCycle ?? -1) - (allMetaMap[a]?.latestCycle ?? -1) || a.localeCompare(b) )
      .slice(0, 10);

    let snippets = "";
    for (const id of relevantArtifacts) {
      const meta = allMetaMap[id];
      if (!meta) continue;
      const content = Storage.getArtifactContent(id, meta.latestCycle, meta.version_id);
      if (content !== null) {
        snippets += `\n---\nArtifact: ${id} (Cycle ${meta.latestCycle}${ meta.version_id ? ` V:${meta.version_id}` : "" })\n${Utils.trunc(content, 500)}\n---`;
      }
    }
    prompt = prompt.replace(/\[\[ARTIFACT_CONTENT_SNIPPETS\]\]/g, snippets || "No relevant artifact snippets found or loaded.");

    UI.displayCycleArtifact("LLM Input Prompt", prompt, "input", false, "System", "prompt.core", currentCycle);
    if (goalInfo.summaryContext) {
      UI.displayCycleArtifact("LLM Input Context (Summary)", goalInfo.summaryContext, "input", false, "System", "prompt.summary", currentCycle);
    }
    return prompt;
  };

  const _prepareFunctionDeclarations = async (state) => {
    let allFuncDecls = [];
    const dynamicTools = state?.dynamicTools || [];
    const uiHooks = { updateStatus: () => {}, logTimeline: () => ({}), updateTimelineItem: () => {} };

    const staticToolPromises = loadedStaticTools.map(async (toolDef) => {
        try {
            const conversionResult = await ToolRunner.runTool( "convert_to_gemini_fc", { mcpToolDefinition: toolDef }, loadedStaticTools, [], uiHooks );
            return conversionResult?.geminiFunctionDeclaration;
        } catch (e) {
            logger.logEvent("error", `Failed converting static tool ${toolDef.name}: ${e.message}`, e instanceof ToolError ? e.details : e);
            return null;
        }
    });
    const dynamicToolPromises = dynamicTools.map(async (toolDef) => {
        try {
            const conversionResult = await ToolRunner.runTool( "convert_to_gemini_fc", { mcpToolDefinition: toolDef.declaration }, loadedStaticTools, [], uiHooks );
            return conversionResult?.geminiFunctionDeclaration;
        } catch (e) {
            logger.logEvent("error", `Failed converting dynamic tool ${toolDef.declaration.name}: ${e.message}`, e instanceof ToolError ? e.details : e);
            return null;
        }
    });
    try {
        const results = await Promise.all([...staticToolPromises, ...dynamicToolPromises]);
        allFuncDecls = results.filter(Boolean);
    } catch (error) {
        logger.logEvent("error", `Error during tool declaration preparation: ${error.message}`, error);
    }
    return allFuncDecls;
  };

  const _handleToolExecution = async (toolCall, state, currentCycle, uiHooks) => {
    const { name: toolName, arguments: toolArgs } = toolCall;
    uiHooks.updateStatus(`Running Tool: ${toolName}...`, true);
    let toolLogItem = uiHooks.logTimeline( currentCycle, `[TOOL] Calling '${toolName}'... Args: ${Utils.trunc(JSON.stringify(toolArgs), 60)}`, "tool", true, true );
    UI.displayCycleArtifact(`Tool Call: ${toolName}`, JSON.stringify(toolArgs, null, 2), "info", false, "LLM", `tool.call.${toolName}`, currentCycle);
    let funcRespContent;
    let toolResult = null;
    let toolError = null;
    let toolSuccess = false;
    try {
      toolResult = await ToolRunner.runTool(toolName, toolArgs, loadedStaticTools, state.dynamicTools || [], uiHooks);
      toolSuccess = true;
      if (toolResult && typeof toolResult.success === "boolean" && !toolResult.success) {
        toolSuccess = false;
        toolError = new ToolError(toolResult.error || `Tool '${toolName}' reported failure.`, toolName, toolArgs, toolResult);
      }
      funcRespContent = { name: toolName, response: { content: JSON.stringify(toolResult) }, };
      uiHooks.updateTimelineItem(toolLogItem, `[TOOL ${toolSuccess ? "OK" : "FAIL"}] '${toolName}'. Result: ${Utils.trunc(JSON.stringify(toolResult), 80)}`, toolSuccess ? "tool" : "error", true);
      UI.displayCycleArtifact(`Tool Response: ${toolName}`, JSON.stringify(toolResult, null, 2), toolSuccess ? "output" : "error", false, "Tool", `tool.response.${toolName}`, currentCycle);
      if (toolName === "run_self_evaluation" && toolResult && toolSuccess) { StateManager.addEvaluationResult(toolResult); }
      if (!toolSuccess && toolError) { throw toolError; }
    } catch (e) {
      toolSuccess = false;
      toolError = e instanceof ToolError ? e : new ToolError(`Tool '${toolName}' failed: ${e.message}`, toolName, toolArgs, e);
      logger.logEvent("error", `Tool Execution Error (${toolName}): ${toolError.message}`, toolError.details || toolError);
      funcRespContent = { name: toolName, response: { error: `Tool failed: ${toolError.message}` }, };
      uiHooks.updateTimelineItem(toolLogItem, `[TOOL ERR] '${toolName}': ${Utils.trunc(toolError.message, 60)}`, "error", true);
      UI.displayCycleArtifact(`Tool Error: ${toolName}`, toolError.message + (toolError.details ? `\nDetails: ${JSON.stringify(toolError.details)}` : ""), "error", false, "Tool", `tool.error.${toolName}`, currentCycle);
    }
    return { role: "function", parts: [{ functionResponse: funcRespContent }], _toolExecutionInfo: { name: toolName, args: toolArgs, success: toolSuccess, result: toolResult, error: toolError?.message || null, errorDetails: toolError?.details || null, }, };
  };

  const _executeLlmApiCallSequence = async (prompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, state, currentCycle) => {
    let apiHistory = [];
    let currentApiResult = null;
    let accumulatedText = "";
    let isContinuation = false;
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    let toolExecutionSummaries = [];
    const uiHooks = { updateStatus: UI.updateStatus, logTimeline: UI.logToTimeline, updateTimelineItem: UI.updateTimelineItem, displayArtifact: UI.displayCycleArtifact, };
    let currentPrompt = prompt;
    let currentHistory = null;
    for (let i = 0; i < 5; i++) {
      logger.logEvent("debug", `API Call Sequence: Iteration ${i + 1}`);
      let loopApiResult = null;
      let loopAccumulatedText = "";
      const callResult = await ApiClient.callApiWithRetry( currentPrompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, isContinuation, currentHistory, state.cfg?.maxRetries ?? 1, {}, uiHooks.updateStatus, uiHooks.logTimeline, uiHooks.updateTimelineItem, (progress) => {
          if (progress.type === "text") {
            loopAccumulatedText += progress.content;
            UI.updateStreamingOutput(loopAccumulatedText);
          } else if (progress.type === "functionCall") {
            UI.updateStreamingOutput( `Function Call received: ${progress.content.name}\nArgs:\n${JSON.stringify(progress.content.args, null, 2)}` );
          }
          if (progress.accumulatedResult) loopApiResult = progress.accumulatedResult;
        }
      );
      if (!loopApiResult) loopApiResult = callResult;
      currentApiResult = loopApiResult;
      accumulatedText = loopAccumulatedText;
      totalInputTokens += loopApiResult.inputTokenCount || 0;
      totalOutputTokens += loopApiResult.outputTokenCount || 0;
      if (currentPrompt) apiHistory.push({ role: "user", parts: [{ text: currentPrompt }] });
      if (loopApiResult.rawResp?.candidates?.[0]?.content) { apiHistory.push(loopApiResult.rawResp.candidates[0].content);
      } else if (loopApiResult.type === "text" && loopApiResult.content) { apiHistory.push({ role: "model", parts: [{ text: loopApiResult.content }], }); }
      if ( loopApiResult.type === "functionCall" && loopApiResult.content?.name ) {
        uiHooks.updateStatus("Processing Tool Call...", true);
        const fc = loopApiResult.content;
        const toolResponse = await _handleToolExecution(fc, state, currentCycle, uiHooks);
        toolExecutionSummaries.push(toolResponse._toolExecutionInfo);
        apiHistory.push(toolResponse);
        currentPrompt = null;
        currentHistory = [...apiHistory];
        isContinuation = true;
        loopAccumulatedText = "";
        continue;
      } else { break; }
    }
    state.lastApiResponse = currentApiResult;
    state.contextTokenEstimate += totalOutputTokens;
    return { apiResult: currentApiResult, accumulatedText: accumulatedText, toolExecutionSummaries: toolExecutionSummaries, };
  };

  const _processLlmApiResponse = (apiCallResult, state, currentCycle) => {
    UI.updateStatus("Processing Final Response...");
    const finalContent = apiCallResult.accumulatedText || apiCallResult.apiResult?.content || "(No final text output)";
    UI.updateStreamingOutput(finalContent, true);
    const sanitized = ApiClient.sanitizeLlmJsonResp(finalContent);
    let parsedResp;
    UI.displayCycleArtifact("LLM Final Output Raw", finalContent, "info", false, "LLM", "llm.raw", currentCycle);
    UI.displayCycleArtifact("LLM Final Output Sanitized", sanitized, "output", false, "LLM", "llm.sanitized", currentCycle);
    try {
      parsedResp = JSON.parse(sanitized);
      logger.logEvent("info", `Parsed final LLM JSON after iteration ${currentCycle}.`);
      UI.logToTimeline(currentCycle, "[LLM OK] Received and parsed final response.");
      if (parsedResp.self_assessment_notes) {
        UI.displayCycleArtifact("Agent Self-Assessment", parsedResp.self_assessment_notes, "info", false, "LLM", "llm.self_assessment", currentCycle);
        logger.logEvent("info", `LLM provided self-assessment notes: ${Utils.trunc(parsedResp.self_assessment_notes, 100)}`);
        state.lastSelfAssessment = parsedResp.self_assessment_notes;
      }
      if (parsedResp.current_context_focus && state.currentGoal) {
        state.currentGoal.currentContextFocus = parsedResp.current_context_focus;
        logger.logEvent("info", `LLM updated context focus: ${state.currentGoal.currentContextFocus}`);
      }
    } catch (e) {
      logger.logEvent("error", `LLM final JSON parse failed: ${e.message}. Content: ${Utils.trunc(sanitized, 500)}`, e);
      UI.logToTimeline(currentCycle, "[LLM ERR] Invalid final JSON response.", "error");
      UI.displayCycleArtifact("Parse Error", e.message, "error", false, "System", "parse.error", currentCycle);
      throw new ApplicationError(`LLM response invalid JSON: ${e.message}`, { content: sanitized });
    }
    const outputTokens = apiCallResult.apiResult?.outputTokenCount || 0; // Tokens for the last call, not cumulative sequence
    if (outputTokens > 0 && state.tokenHistory) {
      state.tokenHistory.push(outputTokens);
      if (state.tokenHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.tokenHistory.shift();
    }
    // Note: contextTokenEstimate was already updated in _executeLlmApiCallSequence with cumulative output tokens
    return parsedResp;
  };

  const _runLlmIteration = async (state, goalInfo, currentCycle) => {
    UI.highlightCoreStep(1);
    const startTime = performance.now();
    let finalResult = null;
    let toolSummaries = [];
    try {
      const prompt = _assembleCorePrompt(state, goalInfo, currentCycle);
      const sysInstruction = `You are x0. DELIBERATE, adopt ${state.personaMode}. Respond ONLY valid JSON matching the schema. Refer to artifacts by ID and optional versionId (e.g., file.js#v1). Use artifactId and cycle args for tools. Use run_self_evaluation tool if appropriate. Provide modular edits via 'artifact_changes.modular' when possible. If generating full page changes, use 'page_composition' over 'full_html_source' string if 'enablePageComposition' config is true and it's suitable.`;
      const allFuncDecls = await _prepareFunctionDeclarations(state);
      const coreModelKey = state.cfg?.coreModel || "ADVANCED";
      const coreModelIdentifier = config.DEFAULT_MODELS[coreModelKey.toUpperCase()] || coreModelKey;
      const apiKey = state.apiKey;
      if (!apiKey) throw new ConfigError("API Key is missing. Cannot make LLM call.", "apiKey");
      UI.clearStreamingOutput();
      const apiCallResult = await _executeLlmApiCallSequence(prompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, state, currentCycle);
      toolSummaries = apiCallResult.toolExecutionSummaries || [];
      const parsedResp = _processLlmApiResponse(apiCallResult, state, currentCycle);
      const cycleMs = performance.now() - startTime;
      finalResult = { response: parsedResp, cycleTimeMillis: cycleMs, toolSummaries: toolSummaries, error: null };
    } catch (error) {
      const cycleMs = performance.now() - startTime;
      if (!(error instanceof AbortError)) {
        logger.logEvent("error", `Core LLM Iteration failed (Cycle ${currentCycle}): ${error.message}`, error instanceof ApplicationError ? error.details : error);
        UI.logToTimeline(currentCycle, `[LLM ERR] Iteration failed: ${Utils.trunc(error.message, 100)}`, "error");
      }
      finalResult = { response: null, cycleTimeMillis: cycleMs, toolSummaries: toolSummaries, error: error };
    } finally {
      UI.clearStreamingOutput();
    }
    return finalResult;
  };

  const _runSingleAutoCritiqueInstance = async (apiKey, llmProposal, goalInfo, currentCycle, critiqueIndex) => {
    const state = StateManager?.getState();
    if (!state) throw new StateError("State not initialized for critique instance");
    const template = Storage.getArtifactContent("reploid.core.critiquer-prompt", 0);
    if (!template) throw new ArtifactError("Critique prompt artifact not found!", "reploid.core.critiquer-prompt", 0);

    const changes = llmProposal.artifact_changes || {};
    const modSummary = (changes.modified || []).map((a) => `${a.id}${a.version_id ? "#" + a.version_id : ""}`).join(", ") || "None";
    const newSummary = (changes.new || []).map( (a) => `${a.id}(${a.type})${a.version_id ? "#" + a.version_id : ""}` ).join(", ") || "None";
    const delSummary = (changes.deleted || []).join(", ") || "None";
    const modularSummary = (changes.modular || []).map((a) => `${a.id}${a.version_id ? "#" + a.version_id : ""}`).join(", ") || "None";
    const fullSourceSummary = changes.full_html_source ? "Yes" : "No";
    const pageCompositionSummary = changes.page_composition ? "Yes" : "No";
    const newToolsSummary = (llmProposal.proposed_new_tools || []).map((t) => t.declaration?.name || "?").join(", ") || "None";
    const newWebComponentTagNames = (llmProposal.tool_calls || []).filter((tc) => tc.name === "define_web_component" && tc.arguments?.tagName).map((tc) => tc.arguments.tagName).join(", ") || "None";

    let prompt = template
      .replace(/\[\[PROPOSED_CHANGES_DESC\]\]/g, Utils.trunc(llmProposal.proposed_changes_description, 1000) || "None")
      .replace(/\[\[MODIFIED_ARTIFACT_IDS_VERSIONS\]\]/g, modSummary)
      .replace(/\[\[NEW_ARTIFACT_IDS_TYPES_VERSIONS\]\]/g, newSummary)
      .replace(/\[\[DELETED_ARTIFACT_IDS\]\]/g, delSummary)
      .replace(/\[\[MODULAR_ARTIFACT_IDS_VERSIONS\]\]/g, modularSummary)
      .replace(/\[\[HAS_FULL_HTML_SOURCE\]\]/g, fullSourceSummary)
      .replace(/\[\[HAS_PAGE_COMPOSITION\]\]/g, pageCompositionSummary)
      .replace(/\[\[NEW_TOOL_NAMES\]\]/g, newToolsSummary)
      .replace(/\[\[NEW_WEB_COMPONENT_TAG_NAMES\]\]/g, newWebComponentTagNames)
      .replace(/\[LATEST_GOAL_TYPE\]/g, goalInfo.type)
      .replace(/\[\[CUMULATIVE_GOAL_CONTEXT\]\]/g, Utils.trunc(goalInfo.cumulativeGoal || goalInfo.summaryContext, 2000))
      .replace(/\[AGENT_CONFIDENCE\]/g, llmProposal.agent_confidence_score?.toFixed(3) ?? "N/A");

    const critiqueModelKey = state.cfg?.critiqueModel || "BASE";
    const critiqueModelIdentifier = config.DEFAULT_MODELS[critiqueModelKey.toUpperCase()] || critiqueModelKey;
    const sysInstruction = 'Critiquer x0. Analyze objectively. Output ONLY valid JSON: {"critique_passed": boolean, "critique_report": "string"}';

    UI.displayCycleArtifact(`Critique Input [${critiqueIndex + 1}/${NUM_CRITIQUES_TO_GENERATE}]`, prompt, "input", false, "System", `prompt.critique.${critiqueIndex}`, currentCycle);
    let critiqueResultText = "";
    let critiqueApiResult = null;
    let finalResult = { critique_passed: false, critique_report: "Critique execution failed" };
    try {
      let accumulatedCritiqueText = "";
      const genConfigOverrides = NUM_CRITIQUES_TO_GENERATE > 1 ? { temperature: 0.7 + Math.random() * 0.2 } : {};
      critiqueApiResult = await ApiClient.callApiWithRetry( prompt, sysInstruction, critiqueModelIdentifier, apiKey, [], false, null, state.cfg?.maxRetries ?? 1, genConfigOverrides,
        (msg, active, isErr) => UI.updateStatus(`Critique ${critiqueIndex + 1}: ${msg}`, active, isErr),
        (cyc, msg, type, sub, anim) => UI.logToTimeline(cyc, `[CRIT ${critiqueIndex + 1}] ${msg}`, type, sub, anim),
        UI.updateTimelineItem,
        (progress) => {
          if (progress.type === "text") accumulatedCritiqueText += progress.content;
          if (progress.accumulatedResult) critiqueApiResult = progress.accumulatedResult;
          critiqueResultText = progress.accumulatedResult?.content || accumulatedCritiqueText;
        }
      );
      if (!critiqueResultText && critiqueApiResult?.content) critiqueResultText = critiqueApiResult.content;
      UI.displayCycleArtifact(`Critique Output Raw [${critiqueIndex + 1}]`, critiqueResultText || "(No text content)", "info", false, "LLM", `critique.raw.${critiqueIndex}`, currentCycle);
      const sanitized = ApiClient.sanitizeLlmJsonResp(critiqueResultText);
      UI.displayCycleArtifact(`Critique Output Sanitized [${critiqueIndex + 1}]`, sanitized, "output", false, "LLM", `critique.sanitized.${critiqueIndex}`, currentCycle);
      const parsedCritique = JSON.parse(sanitized);
      if (typeof parsedCritique.critique_passed !== "boolean" || typeof parsedCritique.critique_report !== "string") {
        throw new ApplicationError("Critique JSON missing required fields.");
      }
      finalResult = parsedCritique;
    } catch (e) {
      logger.logEvent("error", `Critique instance ${critiqueIndex + 1} API/Parse failed: ${e.message}`, e);
      UI.logToTimeline(currentCycle, `[CRIT ${critiqueIndex + 1} ERR] Failed: ${e.message}`, "error", true);
      UI.displayCycleArtifact(`Critique Error [${critiqueIndex + 1}]`, e.message, "error", false, "System", `critique.error.${critiqueIndex}`, currentCycle);
      finalResult.critique_report = `Critique instance ${critiqueIndex + 1} failed: ${e.message}`;
    }
    return finalResult;
  };

  const _runAutoCritique = async (apiKey, llmProposal, goalInfo, currentCycle) => {
    UI.highlightCoreStep(5);
    UI.updateStatus(`Running ${NUM_CRITIQUES_TO_GENERATE} Auto-Critiques...`, true);
    const critiquePromises = [];
    for (let i = 0; i < NUM_CRITIQUES_TO_GENERATE; i++) {
      critiquePromises.push( _runSingleAutoCritiqueInstance(apiKey, llmProposal, goalInfo, currentCycle, i) );
    }
    const results = await Promise.allSettled(critiquePromises);
    const successfulCritiques = results.filter((r) => r.status === "fulfilled").map((r) => r.value);
    const failedCritiques = results.filter((r) => r.status === "rejected").map((r) => ({ critique_passed: false, critique_report: `Critique generation failed: ${r.reason?.message || "Unknown reason"}`}));
    const allCritiqueOutputs = [...successfulCritiques, ...failedCritiques];
    const overallPassed = successfulCritiques.length === NUM_CRITIQUES_TO_GENERATE && successfulCritiques.every((c) => c.critique_passed);
    let combinedReport = allCritiqueOutputs.map( (c, i) => `Critique ${i + 1}: ${c.critique_passed ? "Pass" : "FAIL"}. Report: ${c.critique_report}` ).join("\n---\n");
    if (failedCritiques.length > 0) combinedReport += `\n---\nWARNING: ${failedCritiques.length} critique generation(s) failed.`;
    logger.logEvent("info", `Multi-Critique finished. Overall Pass: ${overallPassed}`);
    UI.logToTimeline(currentCycle, `[CRITIQUE] Multi-Critique completed. Overall Passed: ${overallPassed}`);
    UI.updateStatus("Idle"); UI.clearStreamingOutput();
    return { critiques: allCritiqueOutputs, overall_passed: overallPassed, combined_report: combinedReport };
  };

  const calculateChecksum = async (content) => {
    if (typeof Utils.calculateChecksum === 'function') {
        return await Utils.calculateChecksum(content);
    }
    logger.logEvent("warn", "Utils.calculateChecksum not available, using fallback for CycleLogic internal use.");
    if (typeof content !== 'string') return null;
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
    }
    return `basic-${hash}`;
  };

  const _assembleHtmlFromPageComposition = async (composition, nextCycleNum, critiqueSource, state) => {
    logger.logEvent("info", "Assembling HTML from page_composition object.", { composition });
    let htmlParts = [];

    try {
      htmlParts.push(composition.doctype || "<!DOCTYPE html>");
      const htmlAttrsObj = composition.html_attributes || { lang: "en" };
      const htmlAttrs = Object.entries(htmlAttrsObj)
        .map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`)
        .join(" ");
      htmlParts.push(`<html ${htmlAttrs}>`);

      htmlParts.push("<head>");
      if (composition.head_elements && Array.isArray(composition.head_elements)) {
        for (const el of composition.head_elements) {
          if (el.type === "artifact_id" && el.id) {
            const meta = StateManager.getArtifactMetadata(el.id);
            const content = meta ? Storage.getArtifactContent(el.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(content);
              UI.displayCycleArtifact(`Loaded Head Artifact: ${el.id}`, Utils.trunc(content,100), "info", false, critiqueSource, el.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Head artifact ${el.id} not found for page_composition.`);
              htmlParts.push(`<!-- Head artifact ${el.id} not found -->`);
            }
          } else if (el.type === "inline_tag" && el.tag) {
            const tagAttrsObj = el.attributes || {};
            const tagAttrs = Object.entries(tagAttrsObj)
              .map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`)
              .join(" ");
            let tagContent = "";
            if (el.content) {
              tagContent = Utils.escapeHtml(el.content);
            } else if (el.content_artifact_id) {
                const metaContent = StateManager.getArtifactMetadata(el.content_artifact_id);
                const artifactContent = metaContent ? Storage.getArtifactContent(el.content_artifact_id, metaContent.latestCycle, metaContent.version_id) : null;
                if (artifactContent !== null) {
                    tagContent = artifactContent;
                    UI.displayCycleArtifact(`Loaded Content for <${el.tag}>: ${el.content_artifact_id}`, Utils.trunc(artifactContent,100), "info", false, critiqueSource, el.content_artifact_id, nextCycleNum);
                } else {
                     logger.logEvent("warn", `Content artifact ${el.content_artifact_id} for <${el.tag}> not found.`);
                     tagContent = `<!-- Content artifact ${el.content_artifact_id} not found -->`;
                }
            }
            const voidElements = ["meta", "link", "br", "hr", "img", "input", "base", "col", "embed", "param", "source", "track", "area", "keygen", "wbr"];
            if (voidElements.includes(el.tag.toLowerCase())) {
                htmlParts.push(`<${el.tag} ${tagAttrs}>`);
            } else {
                htmlParts.push(`<${el.tag} ${tagAttrs}>${tagContent}</${el.tag}>`);
            }
          }
        }
      }
      htmlParts.push("</head>");

      const bodyAttrsObj = composition.body_attributes || {};
      const bodyAttrs = Object.entries(bodyAttrsObj)
        .map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`)
        .join(" ");
      htmlParts.push(`<body ${bodyAttrs}>`);
      if (composition.body_elements && Array.isArray(composition.body_elements)) {
        for (const el of composition.body_elements) {
          if (el.type === "artifact_id" && el.id) {
            const meta = StateManager.getArtifactMetadata(el.id);
            const content = meta ? Storage.getArtifactContent(el.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(content);
              UI.displayCycleArtifact(`Loaded Body Artifact: ${el.id}`, Utils.trunc(content,100), "info", false, critiqueSource, el.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Body artifact ${el.id} not found for page_composition.`);
              htmlParts.push(`<!-- Body artifact ${el.id} not found -->`);
            }
          } else if (el.type === "web_component_tag" && el.tag) {
            const wcAttrsObj = el.attributes || {};
            const wcAttrs = Object.entries(wcAttrsObj)
              .map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`)
              .join(" ");
            htmlParts.push(`<${el.tag} ${wcAttrs}></${el.tag}>`);
          } else if (el.type === "inline_html" && el.content) {
            htmlParts.push(el.content);
          }
        }
      }

      if (composition.script_references && Array.isArray(composition.script_references)) {
        for (const ref of composition.script_references) {
          const scriptAttrsList = [];
          if (ref.attributes) {
            if (ref.attributes.defer) scriptAttrsList.push("defer");
            if (ref.attributes.async) scriptAttrsList.push("async");
            Object.entries(ref.attributes).forEach(([key,value]) => {
                if (!["defer", "async", "src"].includes(key) && value !== undefined) {
                    scriptAttrsList.push(`${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`);
                }
            });
          }
          const scriptAttrs = scriptAttrsList.join(" ");

          if (ref.type === "artifact_id" && ref.id) {
            const meta = StateManager.getArtifactMetadata(ref.id);
            const content = meta ? Storage.getArtifactContent(ref.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(`<script ${scriptAttrs}>${content}</script>`);
              UI.displayCycleArtifact(`Inlined Script Artifact: ${ref.id}`, `(${content.length} chars)`, "info", false, critiqueSource, ref.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Script artifact ${ref.id} not found for inlining.`);
              htmlParts.push(`<!-- Script artifact ${ref.id} not found -->`);
            }
          } else if (ref.type === "path" && ref.src) {
            htmlParts.push(`<script src="${Utils.escapeHtml(ref.src)}" ${scriptAttrs}></script>`);
          }
        }
      }

      htmlParts.push("</body>");
      htmlParts.push("</html>");

      const assembledHtml = htmlParts.join("\n");
      logger.logEvent("info", `Successfully assembled HTML from page_composition (${assembledHtml.length} chars).`);
      UI.displayCycleArtifact("Assembled Page Composition (Preview)", Utils.trunc(assembledHtml, 500), "output", true, critiqueSource, "page_composition_output", nextCycleNum);
      return assembledHtml;

    } catch (error) {
      logger.logEvent("error", "Failed to assemble HTML from page_composition", error);
      throw new ApplicationError("HTML assembly from page_composition failed.", { originalError: error.message || String(error), composition });
    }
  };

  const _applyArtifactChanges = async (artifactChanges, nextCycleNum, critiqueSource, state, changesMade, errors) => {
    const { modified, new: newArtifacts, deleted, modular, full_html_source, page_composition } = artifactChanges || {};
    let requiresSandbox = false;

    if (page_composition && state.cfg?.enablePageComposition === true) {
      try {
        const assembledHtml = await _assembleHtmlFromPageComposition(page_composition, nextCycleNum, critiqueSource, state);
        state.lastGeneratedFullSource = assembledHtml;
        changesMade.push("Generated Page Composition (Sandbox Required)");
        UI.displayCycleArtifact("Proposed Page Composition Structure", JSON.stringify(page_composition, null, 2), "info", true, critiqueSource, "page_composition_input", state.totalCycles);
        requiresSandbox = true;
      } catch (e) {
        errors.push(`Failed to process page_composition: ${e.message}`);
        logger.logEvent("error", "Page Composition processing error", e);
         UI.displayCycleArtifact("Page Composition Error", e.message, "error", false, critiqueSource, "page_composition_error", state.totalCycles);
      }
    } else if (full_html_source) {
      state.lastGeneratedFullSource = full_html_source;
      changesMade.push("Generated Full HTML (Sandbox Required)");
      UI.displayCycleArtifact("Full HTML Source (Prepared for Sandbox)", `(${full_html_source.length} chars)`, "output", true, critiqueSource, "full_html_output", state.totalCycles);
      requiresSandbox = true;
    }

    for (const modArt of modified || []) {
      if (!modArt.id || modArt.content === undefined) { errors.push(`Invalid modified artifact structure: ID=${modArt.id || "?"}`); continue; }
      const currentMeta = StateManager.getArtifactMetadata(modArt.id);
      if (!currentMeta) { errors.push(`Modify failed (original not found): ${modArt.id}`); continue; }
      const currentContent = Storage.getArtifactContent(modArt.id, currentMeta.latestCycle, currentMeta.version_id);
      if (currentContent === null) { errors.push(`Modify failed (original content missing): ${modArt.id} C${currentMeta.latestCycle} V${currentMeta.version_id || "def"}`); continue; }
      if (currentContent !== modArt.content) {
        try {
          const checksum = await calculateChecksum(modArt.content);
          Storage.setArtifactContent(modArt.id, nextCycleNum, modArt.content, modArt.version_id);
          StateManager.updateArtifactMetadata(modArt.id, currentMeta.type, currentMeta.description, nextCycleNum, checksum, critiqueSource, modArt.version_id, false);
          changesMade.push(`Modified: ${modArt.id}${modArt.version_id ? "#" + modArt.version_id : ""}`);
          UI.displayCycleArtifact(`Modified Artifact${modArt.version_id ? " (V: " + modArt.version_id + ")" : ""}`, Utils.trunc(modArt.content, 200), "output", true, critiqueSource, modArt.id, nextCycleNum);
          if (modArt.id.startsWith("reploid.")) logger.logEvent("warn", `Core artifact ${modArt.id} modified.`);
        } catch (e) { errors.push(`Failed save mod ${modArt.id}: ${e.message}`); }
      } else { UI.displayCycleArtifact(`Modified (No Change)${modArt.version_id ? " (V: " + modArt.version_id + ")" : ""}`, Utils.trunc(currentContent, 200), "info", false, critiqueSource, modArt.id, currentMeta.latestCycle); }
    }
    for (const newArt of newArtifacts || []) {
      if (!newArt.id || !newArt.type || newArt.content === undefined) { errors.push(`Invalid new artifact structure: ID=${newArt.id || "?"}`); continue; }
      try {
        const checksum = await calculateChecksum(newArt.content);
        Storage.setArtifactContent(newArt.id, nextCycleNum, newArt.content, newArt.version_id);
        StateManager.updateArtifactMetadata(newArt.id, newArt.type, newArt.description || `New ${newArt.type}`, nextCycleNum, checksum, critiqueSource, newArt.version_id, false);
        changesMade.push(`Created: ${newArt.id}${newArt.version_id ? "#" + newArt.version_id : ""} (${newArt.type})`);
        UI.displayCycleArtifact(`New Artifact${newArt.version_id ? " (V: " + newArt.version_id + ")" : ""}`, Utils.trunc(newArt.content, 200), "output", true, critiqueSource, newArt.id, nextCycleNum);
      } catch (e) { errors.push(`Failed save new ${newArt.id}: ${e.message}`); }
    }
    for (const idToDelete of deleted || []) {
      const meta = StateManager.getArtifactMetadata(idToDelete);
      if (meta) {
        const allVersions = StateManager.getArtifactMetadataAllVersions(idToDelete);
        allVersions.forEach((v) => Storage.deleteArtifactVersion(idToDelete, v.latestCycle, v.version_id));
        StateManager.deleteArtifactMetadata(idToDelete);
        changesMade.push(`Deleted: ${idToDelete} (All versions)`);
        UI.displayCycleArtifact("Deleted Artifact (All Versions)", idToDelete, "output", true, critiqueSource);
      } else { errors.push(`Delete failed (not found): ${idToDelete}`); }
    }
    for (const modEdit of modular || []) {
      if (!modEdit.id || !modEdit.patch_content || !modEdit.patch_format) { errors.push(`Invalid modular edit structure: ID=${modEdit.id || "?"}`); continue; }
      UI.displayCycleArtifact(`Modular Edit Proposed${modEdit.version_id ? " (V: " + modEdit.version_id + ")" : ""}`, JSON.stringify(modEdit, null, 2), "info", true, critiqueSource, modEdit.id, nextCycleNum);
      try {
        const baseMeta = StateManager.getArtifactMetadata(modEdit.id);
        if (!baseMeta) throw new ArtifactError(`Base artifact not found: ${modEdit.id}`, modEdit.id);
        const baseContent = Storage.getArtifactContent(modEdit.id, baseMeta.latestCycle, baseMeta.version_id);
        if (baseContent === null) throw new ArtifactError(`Base content missing for ${modEdit.id}`, modEdit.id, baseMeta.latestCycle);
        let toolToRun = null;
        let toolArgs = { artifactId: modEdit.id, cycle: baseMeta.latestCycle, versionId: baseMeta.version_id, patchContent: modEdit.patch_content, };
        if (modEdit.patch_format.toLowerCase() === "diff" || modEdit.patch_format.toLowerCase() === "unified-diff") toolToRun = "apply_diff_patch";
        else if (modEdit.patch_format.toLowerCase() === "json-patch" || modEdit.patch_format.toLowerCase() === "rfc6902") {
          toolToRun = "apply_json_patch";
          try { toolArgs.patchContent = JSON.parse(modEdit.patch_content); } catch { toolArgs.patchContent = modEdit.patch_content; }
        } else if (modEdit.patch_format.toLowerCase() === "replace-function" || modEdit.patch_format.toLowerCase() === "replace-block") {
          toolToRun = "apply_block_replacement"; toolArgs.target_block = modEdit.target_block;
        } else throw new ToolError(`Unsupported patch format: ${modEdit.patch_format}`, "apply_modular_edit", toolArgs);
        const patchResult = await ToolRunner.runTool(toolToRun, toolArgs, loadedStaticTools, state.dynamicTools || [], {});
        if (!patchResult || !patchResult.success) throw new ToolError(`Patch tool '${toolToRun}' failed: ${patchResult?.error || "Unknown tool error"}`, toolToRun, toolArgs, patchResult);
        const patchedContent = patchResult.result_content;
        const checksum = await calculateChecksum(patchedContent);
        Storage.setArtifactContent(modEdit.id, nextCycleNum, patchedContent, modEdit.version_id);
        StateManager.updateArtifactMetadata(modEdit.id, baseMeta.type, baseMeta.description, nextCycleNum, checksum, critiqueSource, modEdit.version_id, true);
        changesMade.push(`Modular Edit: ${modEdit.id}${modEdit.version_id ? "#" + modEdit.version_id : ""} (${modEdit.patch_format})`);
        UI.displayCycleArtifact(`Modular Edit Applied${modEdit.version_id ? " (V: " + modEdit.version_id + ")" : ""}`, Utils.trunc(patchedContent, 200), "output", true, critiqueSource, modEdit.id, nextCycleNum);
      } catch (e) { errors.push(`Failed apply modular edit ${modEdit.id}: ${e.message}`); UI.displayCycleArtifact(`Modular Edit Failed ${modEdit.id}`, e.message, "error", false, critiqueSource); }
    }
    return { requiresSandbox };
  };

  const _applyToolDefinitionChanges = (newTools, critiqueSource, state, changesMade, errors, currentCycleNum) => {
    (newTools || []).forEach((tool) => {
      const decl = tool.declaration; const impl = tool.implementation;
      if (!decl || !impl || !decl.name || !decl.description || !decl.inputSchema) {
        errors.push(`Invalid new tool structure: Name=${decl?.name || "?"}`);
        UI.displayCycleArtifact("Invalid Tool Def", JSON.stringify(tool), "error", false, critiqueSource); return;
      }
      UI.displayCycleArtifact(`Proposed Tool Decl: ${decl.name}`, JSON.stringify(decl, null, 2), "output", true, critiqueSource);
      UI.displayCycleArtifact(`Generated Tool Impl: ${decl.name}`, impl, "output", true, critiqueSource);
      if (!impl.includes("async function run(params)") && !impl.includes("async (params)") && !impl.includes("run = async (params)")) {
        errors.push(`Generated tool implementation for ${decl.name} missing valid async run(params) function.`);
        UI.logToTimeline(currentCycleNum, `[APPLY ERR] Tool impl ${decl.name} invalid structure.`, "error", true);
      } else {
        const dynamicTools = state.dynamicTools || [];
        const existingIndex = dynamicTools.findIndex((t) => t.declaration.name === decl.name);
        const toolEntry = { declaration: decl, implementation: impl };
        let toolChangeType = "";
        if (existingIndex !== -1) { dynamicTools[existingIndex] = toolEntry; toolChangeType = `Tool Updated: ${decl.name}`; }
        else { dynamicTools.push(toolEntry); toolChangeType = `Tool Defined: ${decl.name}`; }
        state.dynamicTools = dynamicTools;
        changesMade.push(toolChangeType);
        UI.logToTimeline(currentCycleNum, `[ARTIFACT] ${toolChangeType}`, "info", true);
      }
    });
  };

  const _applyLLMChanges = async (llmResp, currentCycleNum, critiqueSource) => {
    UI.highlightCoreStep(6);
    const state = StateManager?.getState();
    if (!state) return { success: false, errors: ["State not initialized"], nextCycle: currentCycleNum, requiresSandbox: false, changes: [] };
    let changesMade = []; let errors = [];
    currentLlmResponse = llmResp;
    const nextCycleNum = currentCycleNum + 1;
    const { requiresSandbox } = await _applyArtifactChanges(llmResp.artifact_changes, nextCycleNum, critiqueSource, state, changesMade, errors);
    _applyToolDefinitionChanges(llmResp.proposed_new_tools, critiqueSource, state, changesMade, errors, currentCycleNum);
    const success = errors.length === 0;
    if (success) {
      if (!requiresSandbox) { state.totalCycles = nextCycleNum; state.agentIterations++; }
      const confidence = llmResp.agent_confidence_score ?? 0.0;
      state.confidenceHistory.push(confidence);
      if (state.confidenceHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.confidenceHistory.shift();
    } else {
      state.failCount = (state.failCount || 0) + 1;
      state.failHistory = state.failHistory || [];
      state.failHistory.push({ cycle: currentCycleNum, reason: `Apply Error: ${errors.join(", ")}` });
      if (state.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.failHistory.shift();
    }
    const targetArtifactChanged = changesMade.some( (c) => c.includes("target.") || c.includes("reploid.") || c.includes("Full HTML") || c.includes("Page Composition") );
    if (targetArtifactChanged && success && !requiresSandbox) { UI.logToTimeline(currentCycleNum, `[APPLY] Applying changes for Cycle ${nextCycleNum}.`, "info", true); }
    UI.logToTimeline(currentCycleNum, `[APPLY] Changes applied for Cycle ${nextCycleNum} from ${critiqueSource}: ${changesMade.join(", ") || "None"}. Errors: ${errors.length}`, errors.length > 0 ? "warn" : "info", true);
    return { success: success, changes: changesMade, errors: errors, nextCycle: success && !requiresSandbox ? nextCycleNum : currentCycleNum, requiresSandbox: requiresSandbox };
  };

  const _checkHitlTriggers = (state, cycleTimeSecs, confidence, currentCycle, llmResponse) => {
    const pauseThresh = state.cfg?.pauseAfterCycles || 0;
    const confThresh = state.cfg?.autoCritiqueThresh ?? 0.75;
    const humanProb = (state.cfg?.humanReviewProb ?? 0) / 100.0;
    const maxTime = state.cfg?.maxCycleTime ?? 600;
    let hitlReason = null;
    let hitlModePref = "prompt";

    if (state.forceHumanReview) {
      hitlReason = "Forced Review";
      state.forceHumanReview = false;
    } else if (pauseThresh > 0 && currentCycle > 0 && currentCycle % pauseThresh === 0) {
      hitlReason = `Auto Pause (Cycle ${currentCycle}/${pauseThresh})`;
      hitlModePref = "options";
    } else if (Math.random() < humanProb) {
      hitlReason = `Random Review (${(humanProb * 100).toFixed(0)}%)`;
      hitlModePref = "critique_feedback";
    } else if (cycleTimeSecs > maxTime) {
      hitlReason = `Time Limit Exceeded (${cycleTimeSecs.toFixed(1)}s > ${maxTime}s)`;
    } else if (confidence < confThresh) {
      hitlReason = `Low Confidence (${confidence.toFixed(2)} < ${confThresh})`;
    }

    if (!hitlReason && state.cfg?.hitlOnMetaChanges === true && llmResponse?.response) {
      const goalInfo = getActiveGoalInfo();
      if (goalInfo.type === "Meta") {
        const changes = llmResponse.response.artifact_changes;
        const tools = llmResponse.response.tool_calls;
        let isCoreChange = false;

        if (changes?.modified?.some((a) => a.id.startsWith("reploid.core."))) isCoreChange = true;
        if (changes?.new?.some((a) => a.id.startsWith("reploid.core."))) isCoreChange = true;
        if (changes?.deleted?.some((id) => id.startsWith("reploid.core."))) isCoreChange = true;
        if (changes?.modular?.some((a) => a.id.startsWith("reploid.core."))) isCoreChange = true;
        if (changes?.full_html_source || changes?.page_composition) isCoreChange = true;
        if (tools?.some((tc) => tc.name === "define_web_component" && tc.arguments?.targetArtifactId?.startsWith("reploid.core."))) isCoreChange = true;
        
        if (isCoreChange) {
          hitlReason = "Meta Change to Core Artifact or Page Structure";
          hitlModePref = "code_edit"; 
        }
      }
    }

    if (hitlReason) {
      logger.logEvent("info", `HITL triggered: ${hitlReason}. Preferred mode: ${hitlModePref}`);
      return { reason: hitlReason, mode: hitlModePref };
    }
    return null;
  };

  const _performCritique = async (state, llmResponse, goalInfo, currentCycle) => {
    const llmProb = (state.cfg?.llmCritiqueProb ?? 50) / 100.0;
    let overallPassed = false;
    let combinedReport = "Critique Skipped";
    let applySource = "Skipped";
    let allCritiques = [];

    if (Math.random() < llmProb) {
      UI.logToTimeline(currentCycle, "[DECIDE] Triggering Auto Critique...", "decide", true);
      UI.logCoreLoopStep(currentCycle, 5, "Critique: Auto");

      const multiCritiqueResult = await _runAutoCritique(state.apiKey, llmResponse.response, goalInfo, currentCycle);
      allCritiques = multiCritiqueResult.critiques;
      overallPassed = multiCritiqueResult.overall_passed;
      combinedReport = multiCritiqueResult.combined_report;
      applySource = `AutoCrit (${allCritiques.length} runs) ${overallPassed ? "Pass" : "Fail"}`;
      state.lastCritiqueType = `Automated (${overallPassed ? "Pass" : "Fail"})`;
      if (state.critiqueFailHistory) state.critiqueFailHistory.push(!overallPassed);
      if (state.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) state.critiqueFailHistory.shift();
      UI.displayCycleArtifact("Auto Critique Combined Report", combinedReport, overallPassed ? "info" : "error", false, "LLM", "critique.combined_report", currentCycle);
    } else {
      overallPassed = true; 
      applySource = "Critique Skipped";
      state.lastCritiqueType = "Skipped";
      if (state.critiqueFailHistory) state.critiqueFailHistory.push(false);
      if (state.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) state.critiqueFailHistory.shift();
      UI.logCoreLoopStep(currentCycle, 5, "Critique: Skipped");
      UI.logToTimeline(currentCycle, "[DECIDE] Critique Skipped.", "info", true);
    }
    return { critiquePassed: overallPassed, critiqueReport: combinedReport, applySource: applySource, critiques: allCritiques };
  };

  const _handleCritiqueDecision = async (state, llmResponse, goalInfo, currentCycle) => {
    UI.highlightCoreStep(4);
    const cycleTimeMillis = llmResponse.cycleTimeMillis || 0;
    const cycleSecs = cycleTimeMillis / 1000;
    const confidence = llmResponse.response?.agent_confidence_score ?? 0.0;
    const hitlTrigger = _checkHitlTriggers(state, cycleSecs, confidence, currentCycle, llmResponse);
    UI.logToTimeline(currentCycle, `[DECIDE] Time:${cycleSecs.toFixed(1)}s, Conf:${confidence.toFixed(2)}. Human: ${hitlTrigger ? hitlTrigger.reason : "No"}.`, "decide", true);
    if (hitlTrigger) {
      state.lastCritiqueType = `Human (${hitlTrigger.reason})`;
      if (state.critiqueFailHistory) state.critiqueFailHistory.push(false);
      if (state.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) state.critiqueFailHistory.shift();
      UI.logCoreLoopStep(currentCycle, 5, `Critique: Human Intervention (${hitlTrigger.reason})`);
      UI.updateStatus(`Paused: Human Review (${hitlTrigger.reason})`);
      const primaryModId = llmResponse.response?.artifact_changes?.modified?.[0]?.id;
      const primaryNewId = llmResponse.response?.artifact_changes?.new?.[0]?.id;
      const primaryModularId = llmResponse.response?.artifact_changes?.modular?.[0]?.id;
      const hasFullSource = !!llmResponse.response?.artifact_changes?.full_html_source || !!llmResponse.response?.artifact_changes?.page_composition;
      const artifactToEdit = primaryModId || primaryNewId || primaryModularId || (hasFullSource ? (llmResponse.response.artifact_changes.page_composition ? "page_composition_preview" : "full_html_source") : null);
      UI.showHumanInterventionUI(hitlTrigger.mode, hitlTrigger.reason, [], artifactToEdit, []);
      return { status: "HITL_REQUIRED", critiquePassed: false, critiqueReport: `Human Intervention: ${hitlTrigger.reason}` };
    }
    const critiqueResult = await _performCritique(state, llmResponse, goalInfo, currentCycle);
    if (!critiqueResult.critiquePassed) {
      UI.logToTimeline(currentCycle, "[STATE] Auto-Critique failed. Forcing HITL.", "warn", true);
      state.failCount = (state.failCount || 0) + 1;
      state.failHistory = state.failHistory || [];
      state.failHistory.push({ cycle: currentCycle, reason: `Critique Failed: ${Utils.trunc(critiqueResult.critiqueReport, 100)}` });
      if (state.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.failHistory.shift();
      UI.showHumanInterventionUI("critique_feedback", `Auto Critique Failed: ${Utils.trunc(critiqueResult.critiqueReport, 150)}...`, [], null, critiqueResult.critiques);
      return { status: "HITL_REQUIRED", critiquePassed: false, critiqueReport: critiqueResult.critiqueReport };
    }
    return { status: "PROCEED", critiquePassed: critiqueResult.critiquePassed, critiqueReport: critiqueResult.critiqueReport, applySource: critiqueResult.applySource };
  };

  const _runSelfEvaluationStep = async (state, llmResponse, currentCycle, applyResult) => {
    UI.highlightCoreStep(7);
    if (!llmResponse?.response) return;
    const contentToEvaluate = llmResponse.response.justification_persona_musing || "(No justification provided)";
    if (contentToEvaluate === "(No justification provided)") {
      logger.logEvent("info", `Skipping self-evaluation for Cycle ${currentCycle}: No justification provided.`);
      UI.logToTimeline(currentCycle, "[EVAL] Skipped (no justification).", "info", true);
      return;
    }
    logger.logEvent("info", `Running Self-Evaluation for Cycle ${currentCycle} justification`);
    UI.logToTimeline(currentCycle, "[EVAL] Evaluating cycle justification...", "eval", true);
    let evaluationCriteria = Storage.getArtifactContent("reploid.core.default-eval", 0);
    if (!evaluationCriteria) {
      logger.logEvent("warn", "Default evaluation criteria artifact (reploid.core.default-eval) not found. Using basic criteria.");
      evaluationCriteria = "Evaluate if the justification accurately reflects the proposed changes and aligns with the goal context. Rate clarity and reasoning.";
    }
    let evalCriteriaText = evaluationCriteria;
    try {
      const parsedCriteria = JSON.parse(evaluationCriteria);
      if (parsedCriteria.criteria && typeof parsedCriteria.criteria === "string") evalCriteriaText = parsedCriteria.criteria;
      else if (parsedCriteria.criteria && Array.isArray(parsedCriteria.criteria)) evalCriteriaText = JSON.stringify(parsedCriteria.criteria);
    } catch (e) { /* Use as plain text */ }
    const goalContext = getActiveGoalInfo().cumulativeGoal || getActiveGoalInfo().summaryContext || "N/A";
    const targetArtifactId = "llm.justification";
    const targetArtifactCycle = currentCycle;
    try {
      const uiHooks = { updateStatus: UI.updateStatus, logTimeline: UI.logToTimeline, updateTimelineItem: UI.updateTimelineItem };
      const evalResult = await ToolRunner.runTool("run_self_evaluation", { targetArtifactId, targetArtifactCycle, evalCriteriaText, goalContextText: goalContext, contentToEvaluate }, loadedStaticTools, state.dynamicTools || [], uiHooks);
      StateManager.addEvaluationResult(evalResult);
      UI.logToTimeline(currentCycle, `[EVAL OK] Score: ${evalResult.evaluation_score.toFixed(2)}. Report: ${Utils.trunc(evalResult.evaluation_report, 60)}`, "eval", true);
      UI.displayCycleArtifact("Self-Evaluation Result", JSON.stringify(evalResult, null, 2), "info", false, "System", "eval.result", currentCycle);
    } catch (e) {
      logger.logEvent("error", `Self-evaluation step failed: ${e.message}`, e);
      UI.logToTimeline(currentCycle, `[EVAL ERR] Failed: ${e.message}`, "error", true);
    }
    UI.logToTimeline(currentCycle, "[LEARN] Learning phase placeholder.", "learn", true);
  };

  const _prepareCycle = () => {
    const state = StateManager?.getState();
    if (!state) throw new StateError("State not initialized!");
    if (!StateManager.isInitialized()) throw new StateError("StateManager lost initialization!");
    if (UI.isMetaSandboxPending()) { UI.showNotification("Meta Sandbox approval pending.", "warn"); throw new StateError("Sandbox Pending"); }
    if (!UI.isHumanInterventionHidden()) { UI.showNotification("Human Intervention required.", "warn"); throw new StateError("HITL Required"); }
    UI.clearCurrentCycleDetails();
    currentLlmResponse = null;
    _abortRequested = false;
    const uiRefs = UI.getRefs();
    state.apiKey = uiRefs.apiKeyInput?.value.trim() || state.apiKey;
    if (!state.apiKey || state.apiKey.length < 10) throw new ConfigError("Valid Gemini API Key required.", "apiKey");
    UI.logCoreLoopStep(state.totalCycles, 0, "Define Goal");
    const goalText = uiRefs.goalInput?.value.trim() || "";
    const goalTypeElement = document.querySelector('input[name="goalType"]:checked');
    const goalType = goalTypeElement ? goalTypeElement.value : "System";
    if (!goalText && !state.currentGoal?.seed) throw new ApplicationError("Initial Goal required.");
    const maxC = state.cfg?.maxCycles || 0;
    if (maxC > 0 && state.totalCycles >= maxC && state.autonomyMode !== "Manual") throw new StateError(`Max cycles (${maxC}) reached.`);
    if (state.autonomyMode === "N_Cycles" && state.autonomyCyclesRemaining <= 0) {
      logger.logEvent("info", "Autonomous run finished (N cycles complete). Switching to Manual.");
      state.autonomyMode = "Manual"; _isAutonomous = false; UI.updateAutonomyControls(state.autonomyMode, false);
      throw new StateError("Autonomy N Cycles Finished");
    }
    if (state.autonomyMode !== "Manual") {
      _isAutonomous = true;
      if (state.autonomyMode === "N_Cycles") state.autonomyCyclesRemaining--;
    } else { _isAutonomous = false; }
    if (state.contextTokenEstimate >= state.contextTokenTarget) UI.showNotification("Context tokens high. Consider summarizing.", "warn");
    const currentCycle = state.totalCycles;
    const newGoalProvided = !!goalText;
    if (newGoalProvided) {
      if (!state.currentGoal?.seed) {
        state.currentGoal = { seed: goalText, cumulative: goalText, latestType: goalType, summaryContext: null, currentContextFocus: null };
      } else {
        state.currentGoal.cumulative = (state.currentGoal.cumulative || state.currentGoal.seed || "") + `\n\n[Cycle ${currentCycle} Refinement (${goalType})]: ${goalText}`;
        state.currentGoal.latestType = goalType; state.currentGoal.summaryContext = null; state.currentGoal.currentContextFocus = null;
      }
      UI.displayCycleArtifact("New Goal Input", `${goalType}: ${goalText}`, "input", false, "User", "goal.input", currentCycle);
      if (uiRefs.goalInput) uiRefs.goalInput.value = "";
    } else if (!state.currentGoal?.seed && !state.currentGoal?.cumulative) {
      throw new ApplicationError("No active goal context.");
    }
    const goalInfo = getActiveGoalInfo();
    state.retryCount = 0;
    state.personaMode = (state.cfg?.personaBalance ?? 50) >= 50 ? "LSD" : "XYZ";
    UI.updateStatus("Starting Cycle...", true);
    if (uiRefs.currentCycleNumber) uiRefs.currentCycleNumber.textContent = currentCycle;
    UI.updateStateDisplay();
    UI.logToTimeline(currentCycle, `[CYCLE] === Cycle ${currentCycle} Start === Goal: ${goalInfo.type}, Persona: ${state.personaMode}, Auto: ${state.autonomyMode}`);
    UI.logToTimeline(currentCycle, `[GOAL] Latest: "${Utils.trunc(goalInfo.latestGoal, 70)}..."`, "goal", true);
    UI.displayCycleArtifact("Cumulative Goal", goalInfo.cumulativeGoal || "(Not Set)", "input", false, "System", "goal.cumulative", currentCycle);
    if (goalInfo.summaryContext) UI.displayCycleArtifact("Summary Context", goalInfo.summaryContext, "input", false, "System", "meta.summary_context", currentCycle);
    if (goalInfo.currentContextFocus) UI.displayCycleArtifact("Context Focus", goalInfo.currentContextFocus, "input", false, "LLM", "meta.context_focus", currentCycle);
    return { state, goalInfo, currentCycle };
  };

  const _handleCycleIterationFailure = async (state, error, currentCycle) => {
    if (error instanceof AbortError || _abortRequested) throw new AbortError("Aborted during iteration failure handling.");
    logger.logEvent("error", `Iteration attempt ${state.retryCount} failed: ${error.message}`);
    state.retryCount++;
    const maxRetries = state.cfg?.maxRetries ?? 1;
    if (state.retryCount > maxRetries) {
      UI.logToTimeline(currentCycle, `[RETRY] Max retries (${maxRetries}) exceeded. Forcing HITL.`, "error");
      state.failCount = (state.failCount || 0) + 1;
      state.failHistory = state.failHistory || [];
      state.failHistory.push({ cycle: currentCycle, reason: `Max Retries: ${error.message || "Unknown error"}` });
      if (state.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.failHistory.shift();
      if (_isAutonomous) { logger.logEvent("warn", "Stopping autonomous run due to max retries."); stopAutonomousRun("Max retries reached"); }
      UI.showHumanInterventionUI("prompt", `Cycle failed after ${state.retryCount} attempts: ${error.message || "Unknown error"}`);
      throw new StateError("HITL Required due to max retries");
    } else {
      UI.logToTimeline(currentCycle, `[RETRY] Attempting retry ${state.retryCount}/${maxRetries}...`, "warn", true);
      state.lastFeedback = `Retry ${state.retryCount}: ${Utils.trunc(error.message, 100) || "No response"}`;
      await Utils.delay(1000 * state.retryCount);
    }
  };

  const _displayLlmIterationSuccessDetails = (llmIterationResult, state, currentCycle) => {
    UI.logToTimeline(currentCycle, "[STATE] Agent Iteration successful.", "info", true);
    UI.highlightCoreStep(3);
    if (llmIterationResult.toolSummaries && llmIterationResult.toolSummaries.length > 0) {
      UI.displayToolExecutionSummary(llmIterationResult.toolSummaries);
    }
    UI.displayCycleArtifact("Agent Deliberation", llmIterationResult.response?.persona_analysis_musing || "(N/A)", "info", false, "LLM", "llm.musing", currentCycle);
    UI.displayCycleArtifact("Proposed Changes", llmIterationResult.response?.proposed_changes_description || "(N/A)", "info", false, "LLM", "llm.proposal", currentCycle);
    UI.displayCycleArtifact("Agent Justification", llmIterationResult.response?.justification_persona_musing || "(N/A)", "info", false, "LLM", "llm.justification", currentCycle);
    UI.displayCycleArtifact("Agent Confidence", llmIterationResult.response?.agent_confidence_score?.toFixed(3) || "(N/A)", "info", false, "LLM", "llm.confidence", currentCycle);
    if (llmIterationResult.response?.current_context_focus) {
      UI.displayCycleArtifact("Next Context Focus", llmIterationResult.response.current_context_focus, "info", false, "LLM", "llm.context_focus", currentCycle);
    }
  };

  const _handleApplyFailure = (state, applyResult, critiqueDecision, currentCycle) => {
    const errorReason = `Apply Failed: ${applyResult.errors.join(", ")}`;
    state.lastFeedback = `${critiqueDecision.applySource}, ${errorReason}`;
    state.failCount = (state.failCount || 0) + 1;
    state.failHistory = state.failHistory || [];
    state.failHistory.push({ cycle: currentCycle, reason: errorReason });
    if (state.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.failHistory.shift();
    UI.logToTimeline(currentCycle, `[APPLY ERR] Failed apply: ${applyResult.errors.join(", ")}. Forcing HITL.`, "error");
    if (_isAutonomous) { logger.logEvent("warn", "Stopping autonomous run due to apply failure."); stopAutonomousRun("Apply failure"); }
    UI.showHumanInterventionUI("prompt", `Failed apply after critique: ${applyResult.errors.join(", ")}`);
    throw new StateError("HITL Required due to apply failure");
  };

  const executeCycle = async () => {
    if (_isRunning && !_isAutonomous) { UI.showNotification("Manual cycle start ignored: Cycle already running.", "warn"); return; }
    if (_abortRequested) {
      logger.logEvent("info", "Cycle execution skipped due to pending abort request.");
      _abortRequested = false; _isRunning = false; if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); return;
    }
    _isRunning = true;
    if (UI.setRunButtonState) UI.setRunButtonState("Abort Cycle", false);
    let state, goalInfo, currentCycle;
    let cycleOutcome = "Unknown"; let llmIterationResult = null; let applyResult = null;
    let shouldContinueAutonomous = false;

    try {
      const prepResult = _prepareCycle();
      state = prepResult.state; goalInfo = prepResult.goalInfo; currentCycle = prepResult.currentCycle;
      let successfulIteration = false;
      do {
        if (_abortRequested) throw new AbortError("Cycle aborted during LLM iteration loop.");
        UI.logToTimeline(currentCycle, `[STATE] Agent Iteration Attempt (Retry: ${state.retryCount})`, "info", true);
        llmIterationResult = await _runLlmIteration(state, goalInfo, currentCycle);
        if (llmIterationResult.error) {
          if (llmIterationResult.error instanceof AbortError) throw llmIterationResult.error;
          await _handleCycleIterationFailure(state, llmIterationResult.error, currentCycle);
        } else {
          successfulIteration = true; state.retryCount = 0;
          _displayLlmIterationSuccessDetails(llmIterationResult, state, currentCycle);
        }
      } while (!successfulIteration);

      const critiqueDecision = await _handleCritiqueDecision(state, llmIterationResult, goalInfo, currentCycle);
      if (_abortRequested) throw new AbortError("Cycle aborted after critique decision.");
      if (critiqueDecision.status === "HITL_REQUIRED") {
        cycleOutcome = `Paused (HITL: ${Utils.trunc(critiqueDecision.critiqueReport.split(":")[0], 30)})`;
        if (_isAutonomous) stopAutonomousRun("HITL Required");
        throw new StateError("HITL Required");
      }

      if (critiqueDecision.critiquePassed) {
        UI.updateStatus("Applying Changes...", true);
        UI.logCoreLoopStep(currentCycle, 6, "Refine & Apply");
        applyResult = await _applyLLMChanges(llmIterationResult.response, currentCycle, critiqueDecision.applySource);
        if (_abortRequested) throw new AbortError("Cycle aborted during apply changes.");

        if (applyResult.requiresSandbox) {
          state.lastCritiqueType = `${critiqueDecision.applySource} (Sandbox Pending)`;
          if (_isAutonomous) stopAutonomousRun("Sandbox Required");
          UI.showMetaSandbox(state.lastGeneratedFullSource);
          cycleOutcome = "Paused (Sandbox Pending)";
          throw new StateError("Sandbox Pending");
        }
        if (applyResult.success) {
          state.lastFeedback = `${critiqueDecision.applySource}, applied successfully for Cycle ${applyResult.nextCycle}.`;
          cycleOutcome = `OK (${state.lastCritiqueType})`;
          await _runSelfEvaluationStep(state, llmIterationResult, currentCycle, applyResult);
          if (_abortRequested) throw new AbortError("Cycle aborted during self-evaluation.");
          UI.highlightCoreStep(8);
          shouldContinueAutonomous = _isAutonomous && !_abortRequested;
        } else {
          _handleApplyFailure(state, applyResult, critiqueDecision, currentCycle);
        }
      } else {
        logger.logEvent("error", "Reached unexpected state: critique failed but HITL not triggered.");
        cycleOutcome = "Failed (Critique Logic Error)";
        if (_isAutonomous) stopAutonomousRun("Critique Logic Error");
        throw new ApplicationError("Critique Failed without HITL trigger");
      }
    } catch (error) {
      const knownStopNames = [ "AbortError", "StateError", "ConfigError", "ApiError", "ToolError", "ArtifactError" ];
      const isKnownStopError = error instanceof ApplicationError && knownStopNames.includes(error.name);

      if (error instanceof AbortError) {
        UI.logToTimeline(currentCycle ?? 0, `[CYCLE] Cycle aborted by user/system. Reason: ${error.message}`, "warn");
        cycleOutcome = "Aborted"; UI.updateStatus("Aborted");
        if (_isAutonomous) stopAutonomousRun("Aborted by user/system");
      } else if (isKnownStopError && (error.message.includes("HITL Required") || error.message.includes("Sandbox Pending"))) {
        logger.logEvent("info", `Cycle paused: ${error.message}`);
        if (!cycleOutcome || cycleOutcome === "Unknown") cycleOutcome = `Paused (${error.message})`;
      } else if (isKnownStopError && error.message.includes("Max cycles reached")) {
        logger.logEvent("info", `Cycle stopped: ${error.message}`);
        cycleOutcome = "Paused (Max Cycles Reached)";
        if (_isAutonomous) stopAutonomousRun("Max cycles reached");
      } else {
        logger.logEvent("error", `Unhandled cycle error (Cycle ${currentCycle ?? "N/A"}): ${error.message}`, error.details || error);
        UI.showNotification(`Cycle Error: ${Utils.trunc(error.message, 100)}`, "error");
        UI.logToTimeline(currentCycle ?? 0, `[CYCLE FATAL] ${Utils.trunc(error.message, 100)}`, "error");
        cycleOutcome = "Failed (Fatal Error)"; UI.updateStatus("Cycle Failed", false, true);
        if (_isAutonomous) stopAutonomousRun("Fatal Error");
      }
      shouldContinueAutonomous = false;
    } finally {
      _isRunning = false; _abortRequested = false;
      if (!_isAutonomous || !shouldContinueAutonomous) { if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); }
      if (state) {
        StateManager.calculateDerivedStats(state);
        if (!UI.isMetaSandboxPending() && UI.isHumanInterventionHidden()) {
          UI.summarizeCompletedCycleLog(cycleOutcome); UI.updateStateDisplay(); UI.clearCurrentCycleDetails();
          UI.logToTimeline(state.totalCycles, `[STATE] Cycle ended (${state.lastCritiqueType || cycleOutcome}). Ready.`);
          StateManager.save(); UI.updateStatus("Idle");
        } else { UI.updateStateDisplay(); StateManager.save(); }
      } else {
        UI.updateStatus("Error - State Lost?", false, true);
        logger.logEvent("critical", "Global state became null during cycle finally block.");
      }
      UI.highlightCoreStep(-1);
    }

    if (shouldContinueAutonomous) {
      logger.logEvent("info", `Autonomous mode active. Triggering next cycle. Remaining: ${state?.autonomyCyclesRemaining ?? "N/A"}`);
      await Utils.delay(config.AUTONOMOUS_CYCLE_DELAY_MS || 500);
      if (!_abortRequested) {
        executeCycle();
      } else {
        logger.logEvent("info", "Autonomous continuation cancelled due to abort request during delay.");
        if (_isAutonomous) stopAutonomousRun("Aborted during delay");
        else { _isRunning = false; if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); }
      }
    } else if (_isAutonomous && cycleOutcome !== "Aborted") {
      logger.logEvent("info", `Autonomous run ended. Reason: ${cycleOutcome}`);
      stopAutonomousRun(cycleOutcome);
    }
  };

  const proceedAfterHumanIntervention = async (feedbackType, feedbackData = "", skipCycleIncrement = false) => {
    const state = StateManager?.getState();
    if (!state) { logger.logEvent("error", "Cannot proceed HITL, state missing."); return; }
    const currentCycle = state.totalCycles;
    let nextCycle = currentCycle;
    let feedbackMsg = String(feedbackData);
    let applySuccess = true;
    let requiresSandbox = false;

    if (feedbackType === "Human Code Edit") {
      const { artifactId, cycle, versionId, success, validatedContent, error, contentChanged } = feedbackData;
      feedbackMsg = `Edited ${artifactId}: ${ success ? (contentChanged ? "Applied successfully." : "No changes detected.") : `Validation Failed: ${error || "Unknown"}` }`;
      let isCodeEditSuccess = success && contentChanged;
      if (isCodeEditSuccess && artifactId !== "full_html_source" && artifactId !== "page_composition_preview") {
        nextCycle = currentCycle + 1;
        try {
          const checksum = await calculateChecksum(validatedContent);
          Storage.setArtifactContent(artifactId, nextCycle, validatedContent, versionId);
          const currentMeta = StateManager.getArtifactMetadata(artifactId, versionId);
          StateManager.updateArtifactMetadata(artifactId, currentMeta?.type, currentMeta?.description, nextCycle, checksum, "Human Edit", versionId, false);
          UI.displayCycleArtifact(`Human Edit Applied${versionId ? " (V: " + versionId + ")" : ""}`, validatedContent, "info", true, "Human", artifactId, nextCycle);
          logger.logEvent("info", `Human edit applied to ${artifactId} for cycle ${nextCycle}`);
          UI.logToTimeline(currentCycle, `[HUMAN] Applied edit to ${artifactId} for cycle ${nextCycle}`, "human", true);
        } catch (e) {
          logger.logEvent("error", `Failed saving human edit for ${artifactId}: ${e.message}`, e);
          UI.showNotification(`Failed saving edit: ${e.message}`, "error");
          applySuccess = false; nextCycle = currentCycle;
        }
      } else if ((artifactId === "full_html_source" || artifactId === "page_composition_preview") && isCodeEditSuccess) {
        logger.logEvent("warn", "Full source/Page Composition edited via HITL. Staging for sandbox.");
        state.lastGeneratedFullSource = validatedContent;
        applySuccess = true; requiresSandbox = true; skipCycleIncrement = true;
        UI.showMetaSandbox(validatedContent);
      } else if (!success) {
        applySuccess = false;
      }
    } else if (feedbackType === "Human Options") {
      feedbackMsg = `Selected: ${feedbackData || "None"}`; applySuccess = true;
    } else if (feedbackType === "Sandbox Discarded") {
      feedbackMsg = "User discarded sandbox changes."; applySuccess = true;
    } else if (feedbackType === "Human Prompt") {
      feedbackMsg = `Provided prompt: ${Utils.trunc(feedbackData, 100)}`; applySuccess = true;
    } else if (feedbackType === "Human Critique Selection") {
      feedbackMsg = `User provided critique feedback. Selected: ${feedbackData?.selectedCritique ?? "N/A"}`;
      StateManager.addCritiqueFeedback(feedbackData);
      logger.logEvent("info", `Received critique feedback: ${JSON.stringify(feedbackData)}`); applySuccess = true;
    }

    state.lastFeedback = `${feedbackType}: ${Utils.trunc(feedbackMsg, 150)}`;
    if (feedbackType.startsWith("Human")) { if (state.humanInterventions !== undefined) state.humanInterventions++; }
    const summaryOutcome = !applySuccess ? `Failed (${feedbackType})` : `OK (${feedbackType})`;
    UI.summarizeCompletedCycleLog(summaryOutcome);
    UI.logToTimeline(currentCycle, `[STATE] ${feedbackType} processed. Feedback: "${Utils.trunc(feedbackMsg, 70)}..."`, "state");
    UI.hideHumanInterventionUI();

    if (applySuccess && !skipCycleIncrement) {
      state.totalCycles = nextCycle === currentCycle ? currentCycle + 1 : nextCycle;
      state.agentIterations++;
    } else if (!applySuccess) {
      state.failCount = (state.failCount || 0) + 1;
      state.failHistory = state.failHistory || [];
      state.failHistory.push({ cycle: currentCycle, reason: `HITL Apply Fail: ${feedbackType}` });
      if (state.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) state.failHistory.shift();
      state.totalCycles = currentCycle;
    }

    if (!skipCycleIncrement) {
      state.personaMode = (state.cfg?.personaBalance ?? 50) < 50 ? "XYZ" : "LSD";
      state.retryCount = 0;
      const uiRefs = UI.getRefs(); if (uiRefs.goalInput) uiRefs.goalInput.value = "";
      UI.updateStatus("Idle"); UI.clearCurrentCycleDetails();
      UI.logToTimeline(state.totalCycles, "[STATE] Ready.");
    } else {
      UI.updateStatus("Meta Sandbox Pending...");
    }
    StateManager.calculateDerivedStats(state);
    UI.updateStateDisplay(); UI.highlightCoreStep(-1);
    StateManager.save();
  };

  const saveHtmlToHistory = (htmlContent) => {
    const state = StateManager?.getState();
    if (!state) return;
    const limit = state.cfg?.htmlHistoryLimit ?? 5;
    if (!state.htmlHistory) state.htmlHistory = [];
    state.htmlHistory.push(htmlContent);
    while (state.htmlHistory.length > limit) state.htmlHistory.shift();
    UI.updateHtmlHistoryControls(state);
    logger.logEvent("info", `Saved HTML state. History size: ${state.htmlHistory.length}`);
  };

  const _runSummarization = async (apiKey, stateSummary, currentCycle) => {
    const template = Storage.getArtifactContent("reploid.core.summarizer-prompt", 0) || "";
    if (!template) throw new ArtifactError("Summarizer prompt not found.", "reploid.core.summarizer-prompt", 0);

    const prompt = template
      .replace(/\[\[AGENT_STATE_SUMMARY\]\]/g, JSON.stringify(stateSummary, null, 2))
      .replace(/\[\[RECENT_LOGS\]\]/g, Utils.trunc(logger.getLogBuffer ? logger.getLogBuffer().split("\n").slice(-20).join("\n") : "N/A", 1500))
      .replace(/\[\[LATEST_ARTIFACTS\]\]/g, _getArtifactListSummary());
    
    const summarizerModelKey = StateManager?.getState()?.cfg?.summarizerModel || "BASE";
    const summarizerModelIdentifier = config.DEFAULT_MODELS[summarizerModelKey.toUpperCase()] || summarizerModelKey;

    let summaryResultText = "";
    try {
      let accumulatedSummaryText = "";
      const apiResult = await ApiClient.callApiWithRetry( prompt, 'You are Summarizer x0. Output ONLY valid JSON: {"summary": "string"}', summarizerModelIdentifier, apiKey, [], false, null, 1, {},
        (msg, act, err) => UI.updateStatus(`Summarize: ${msg}`, act, err),
        (cyc, msg, type, sub, anim) => UI.logToTimeline(cyc, `[SUM] ${msg}`, type, sub, anim),
        UI.updateTimelineItem,
        (progress) => {
          if (progress.type === "text") accumulatedSummaryText += progress.content;
          summaryResultText = progress.accumulatedResult?.content || accumulatedSummaryText;
        }
      );
      if (!summaryResultText && apiResult?.content) summaryResultText = apiResult.content;
      const sanitized = ApiClient.sanitizeLlmJsonResp(summaryResultText);
      const parsed = JSON.parse(sanitized);
      if (typeof parsed.summary === "string") return parsed.summary;
      else throw new ApplicationError("Summarizer response missing 'summary' field.");
    } catch (e) {
      logger.logEvent("error", `Summarization LLM call failed: ${e.message}`, e);
      return null;
    }
  };

  const handleSummarizeContext = async () => {
    const state = StateManager?.getState();
    if (!state || !state.apiKey) { UI.showNotification("API Key required for summarization.", "warn"); return; }
    if (_isRunning) { UI.showNotification("Cannot summarize context while cycle is running.", "warn"); return; }
    UI.updateStatus("Summarizing context...", true);
    UI.showNotification("Starting context summarization...", "info", 3000);
    const currentCycle = state.totalCycles;
    const nextCycle = currentCycle + 1;
    UI.logToTimeline(currentCycle, "[CONTEXT] Running summarization...", "context", true);
    UI.clearCurrentCycleDetails();
    try {
      const stateSummary = {
        totalCycles: state.totalCycles, agentIterations: state.agentIterations, humanInterventions: state.humanInterventions,
        failCount: state.failCount,
        currentGoal: { seed: Utils.trunc(state.currentGoal?.seed, 200), cumulative: Utils.trunc(state.currentGoal?.cumulative, 500), latestType: state.currentGoal?.latestType, currentContextFocus: state.currentGoal?.currentContextFocus, },
        lastCritiqueType: state.lastCritiqueType, lastFeedback: Utils.trunc(state.lastFeedback, 200),
        avgConfidence: state.avgConfidence?.toFixed(2), critiqueFailRate: state.critiqueFailRate?.toFixed(1),
        dynamicTools: (state.dynamicTools || []).map((t) => t.declaration.name),
        evaluationHistory: _summarizeHistory(state.evaluationHistory, "Eval", 3),
      };
      const summaryText = await _runSummarization(state.apiKey, stateSummary, currentCycle);
      if (summaryText === null) throw new ApplicationError("Summarization LLM call or parsing failed.");
      const checksum = await calculateChecksum(summaryText);
      Storage.setArtifactContent("meta.summary_context", nextCycle, summaryText);
      StateManager.updateArtifactMetadata("meta.summary_context", "TEXT", "Last Context Summary", nextCycle, checksum, "Summarizer");
      state.currentGoal = {
        seed: state.currentGoal?.seed,
        cumulative: `Context summarized up to Cycle ${currentCycle}. Original Seed: ${state.currentGoal?.seed || "None"}. New Summary:\n${summaryText}`,
        latestType: "Idle", summaryContext: summaryText, currentContextFocus: null,
      };
      state.contextTokenEstimate = Math.round((summaryText.length / 4) * 1.1) + 500;
      state.lastFeedback = `Context summarized at Cycle ${currentCycle}.`; state.lastCritiqueType = "Context Summary";
      state.totalCycles = nextCycle;
      UI.logToTimeline(currentCycle, `[CONTEXT] Summarized. Saved as meta.summary_context_${nextCycle}. Est. tokens: ${state.contextTokenEstimate.toLocaleString()}.`, "context");
      UI.displayCycleArtifact("Generated Context Summary", summaryText, "output", true, "System", "meta.summary_context", nextCycle);
      UI.showNotification("Context summarization complete.", "info", 5000);
    } catch (error) {
      logger.logEvent("error", `Summarization failed: ${error.message}`, error);
      UI.showNotification(`Summarization failed: ${error.message}`, "error");
      UI.logToTimeline(currentCycle, `[CONTEXT ERR] Summarization failed: ${error.message}`, "error");
    } finally {
      StateManager.calculateDerivedStats(state); UI.updateStateDisplay();
      UI.updateStatus("Idle"); StateManager.save();
    }
  };

  const abortCurrentCycle = () => {
    if (_isRunning) {
      logger.logEvent("info", "Abort request received.");
      _abortRequested = true; ApiClient.abortCurrentCall("User Abort Request");
      if (_isAutonomous) stopAutonomousRun("Aborted");
      else UI.updateStatus("Aborting...");
    } else {
      logger.logEvent("info", "Abort request ignored: No cycle running.");
    }
  };

  const startAutonomousRun = (mode = "Continuous", cycles = 0) => {
    if (_isRunning) { UI.showNotification("Cannot start autonomous run: Cycle already in progress.", "warn"); return; }
    const state = StateManager.getState();
    if (!state) { UI.showNotification("Cannot start autonomous run: State not loaded.", "error"); return; }
    if (mode === "N_Cycles" && (!cycles || cycles <= 0)) { UI.showNotification("Cannot start N_Cycles run: Invalid number of cycles specified.", "warn"); return; }
    logger.logEvent("info", `Starting autonomous run. Mode: ${mode}, Cycles: ${cycles}`);
    state.autonomyMode = mode; state.autonomyCyclesRemaining = mode === "N_Cycles" ? cycles : Infinity;
    _isAutonomous = true; _abortRequested = false;
    StateManager.save(); UI.updateAutonomyControls(mode, true);
    UI.updateStatus(`Autonomous Run (${mode}) Started...`);
    executeCycle();
  };

  const stopAutonomousRun = (reason = "User Stop Request") => {
    logger.logEvent("info", `Stopping autonomous run. Reason: ${reason}`);
    _abortRequested = true; _isAutonomous = false;
    const state = StateManager.getState();
    if (state) { state.autonomyMode = "Manual"; state.autonomyCyclesRemaining = 0; StateManager.save(); }
    UI.updateAutonomyControls("Manual", false);
    UI.updateStatus(`Autonomous Run Stopped (${reason})`);
    if (_isRunning) { if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); _isRunning = false; }
  };

  const runTool = async (toolName, args) => {
    const state = StateManager?.getState();
    if (!state) throw new StateError("Cannot run tool, state not available.");
    const dummyUiHooks = { updateStatus: () => {}, logTimeline: () => ({}), updateTimelineItem: () => {} };
    return await ToolRunner.runTool(toolName, args, loadedStaticTools, state.dynamicTools || [], dummyUiHooks);
  };

  return {
    init, executeCycle, isRunning, isAutonomous, getActiveGoalInfo,
    proceedAfterHumanIntervention, handleSummarizeContext, abortCurrentCycle,
    saveHtmlToHistory, runTool, startAutonomousRun, stopAutonomousRun,
  };
};
ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: api-client.js ---
const ApiClientModule = (config, logger) => {
  if (!config || !logger) {
    console.error("ApiClientModule requires config and logger.");
    const log = logger || {
      logEvent: (lvl, msg) =>
        console[lvl === "error" ? "error" : "log"](
          `[APICLIENT FALLBACK] ${msg}`
        ),
    };
    log.logEvent(
      "error",
      "ApiClientModule initialization failed: Missing dependencies."
    );
    return {
      callApiWithRetry: async () => {
        throw new Error("ApiClient not initialized");
      },
      abortCurrentCall: () => {
        log.logEvent("warn", "ApiClient not initialized, cannot abort.");
      },
      sanitizeLlmJsonResp: (rawText) => "{}",
    };
  }

  let currentAbortController = null;
  const API_ENDPOINT_BASE =
    config.GEMINI_STREAM_ENDPOINT_BASE ||
    "https://generativelanguage.googleapis.com/v1beta/models/";
  const RETRY_DELAY_BASE_MS = config.API_RETRY_DELAY_BASE_MS || 1500;
  const RETRY_DELAY_MAX_MS = 30000;
  const DEFAULT_MAX_OUTPUT_TOKENS = 8192;

  const sanitizeLlmJsonResp = (rawText) => {
    if (!rawText || typeof rawText !== "string") return "{}";
    let text = rawText.trim();
    let jsonString = null;
    let method = "none";

    try {
      JSON.parse(text);
      jsonString = text;
      method = "direct parse";
    } catch (e1) {
      const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch && codeBlockMatch[1]) {
        text = codeBlockMatch[1].trim();
        method = "code block";
        try {
          JSON.parse(text);
          jsonString = text;
        } catch (e2) {}
      }

      if (!jsonString) {
        const firstBrace = text.indexOf("{");
        const firstBracket = text.indexOf("[");
        let startIndex = -1;

        if (firstBrace !== -1 && firstBracket !== -1) {
          startIndex = Math.min(firstBrace, firstBracket);
        } else if (firstBrace !== -1) {
          startIndex = firstBrace;
        } else {
          startIndex = firstBracket;
        }

        if (startIndex !== -1) {
          text = text.substring(startIndex);
          const startChar = text[0];
          const endChar = startChar === "{" ? "}" : "]";
          let balance = 0;
          let lastValidIndex = -1;
          let inString = false;
          let escapeNext = false;
          method = "heuristic balance";

          for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (inString) {
              if (escapeNext) {
                escapeNext = false;
              } else if (char === "\\") {
                escapeNext = true;
              } else if (char === '"') {
                inString = false;
              }
            } else {
              if (char === '"') {
                inString = true;
              } else if (char === startChar) {
                balance++;
              } else if (char === endChar) {
                balance--;
              }
            }
            if (!inString && balance === 0 && startIndex === 0) {
              lastValidIndex = i;
              break;
            }
            if (!inString && balance === 1 && startIndex > 0 && i > 0) {
            }
            if (!inString && balance === 0 && i > 0 && startIndex > 0) {
              lastValidIndex = i;
              break;
            }
          }

          if (lastValidIndex !== -1) {
            text = text.substring(0, lastValidIndex + 1);
            try {
              JSON.parse(text);
              jsonString = text;
            } catch (e3) {
              logger.logEvent(
                "warn",
                `JSON sanitization failed (heuristic parse): ${e3.message}`,
                text.substring(0, 100) + "..."
              );
              method = "heuristic failed";
              jsonString = null;
            }
          } else {
            logger.logEvent(
              "warn",
              "JSON sanitization failed: Unbalanced structure after heuristic.",
              text.substring(0, 100)
            );
            method = "heuristic unbalanced";
            jsonString = null;
          }
        } else {
          method = "no structure found";
          jsonString = null;
        }
      }
    }

    logger.logEvent("debug", `JSON sanitization method: ${method}`);
    return jsonString || "{}";
  };

  const callGeminiAPIStream = async (
    prompt,
    sysInstr,
    modelName,
    apiKey,
    funcDecls = [],
    prevContent = null,
    abortSignal,
    generationConfigOverrides = {},
    progressCallback = () => {}
  ) => {
    const apiEndpoint = `${API_ENDPOINT_BASE}${modelName}:streamGenerateContent`;
    logger.logEvent("info", `Streaming API Call: ${modelName}`, {
      endpoint: apiEndpoint,
      hasSysInstr: !!sysInstr,
      toolsCount: funcDecls.length,
      isContinuation: !!prevContent,
    });
    if (progressCallback)
      progressCallback({ type: "status", content: "Starting..." });

    const baseGenCfg = {
      temperature: 0.777,
      maxOutputTokens: DEFAULT_MAX_OUTPUT_TOKENS,
      ...(generationConfigOverrides || {}),
    };

    const safetySettings = [
      "HARASSMENT",
      "HATE_SPEECH",
      "SEXUALLY_EXPLICIT",
      "DANGEROUS_CONTENT",
    ].map((cat) => ({
      category: `HARM_CATEGORY_${cat}`,
      threshold: "BLOCK_MEDIUM_AND_ABOVE",
    }));

    const reqBody = {
      contents: [],
      safetySettings: safetySettings,
      generationConfig: { ...baseGenCfg },
    };

    if (sysInstr) {
      reqBody.systemInstruction = {
        role: "system",
        parts: [{ text: sysInstr }],
      };
    }

    if (prevContent) {
      reqBody.contents = [...prevContent];
    }
    if (prompt) {
      reqBody.contents.push({ role: "user", parts: [{ text: prompt }] });
    }

    if (funcDecls?.length > 0) {
      reqBody.tools = [{ functionDeclarations: funcDecls }];
      reqBody.tool_config = { function_calling_config: { mode: "AUTO" } };
      delete reqBody.generationConfig.responseMimeType;
    } else {
      reqBody.generationConfig.responseMimeType = "application/json";
    }

    let accumulatedText = "";
    let accumulatedFunctionCall = null;
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    let finalFinishReason = "UNKNOWN";
    let finalRawResponse = null;
    let lastReportedAccumulatedResult = null;
    let responseStatus = 0;
    let responseHeaders = {};
    let blockReason = null;
    let safetyRatings = [];

    try {
      const response = await fetch(`${apiEndpoint}?key=${apiKey}&alt=sse`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(reqBody),
        signal: abortSignal,
      });

      responseStatus = response.status;
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });

      if (!response.ok || !response.body) {
        let errBodyText = "(Failed to read error body)";
        try {
          errBodyText = await response.text();
        } catch (e) {}
        let errJson = {};
        try {
          errJson = JSON.parse(errBodyText);
        } catch (e) {}
        const errorMessage =
          errJson?.error?.message || response.statusText || errBodyText;
        const error = new Error(
          `API Error (${response.status}): ${errorMessage}`
        );
        error.status = response.status;
        error.headers = responseHeaders;
        error.body = errBodyText;
        throw error;
      }

      if (progressCallback)
        progressCallback({ type: "status", content: "Receiving..." });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        if (abortSignal?.aborted) {
          const abortError = new Error("Aborted");
          abortError.name = "AbortError";
          throw abortError;
        }
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const chunk = JSON.parse(line.substring(6));
              finalRawResponse = chunk;

              if (chunk.promptFeedback?.blockReason) {
                blockReason = chunk.promptFeedback.blockReason;
                safetyRatings = chunk.promptFeedback.safetyRatings || [];
                const blockError = new Error(
                  `API Blocked (Prompt): ${blockReason}`
                );
                blockError.status = 400;
                blockError.reason = "PROMPT_BLOCK";
                blockError.safetyRatings = safetyRatings;
                throw blockError;
              }
              if (chunk.error) {
                const apiError = new Error(
                  `API Error in chunk: ${chunk.error.message || "Unknown"}`
                );
                apiError.status = chunk.error.code || 500;
                apiError.reason = "API_CHUNK_ERROR";
                throw apiError;
              }

              if (chunk.usageMetadata) {
                totalInputTokens =
                  chunk.usageMetadata.promptTokenCount || totalInputTokens;
                totalOutputTokens =
                  chunk.usageMetadata.candidatesTokenCount || totalOutputTokens;
              }

              const candidate = chunk.candidates?.[0];
              if (candidate) {
                if (candidate.tokenCount) {
                  totalOutputTokens = Math.max(
                    totalOutputTokens,
                    candidate.tokenCount
                  );
                }

                finalFinishReason = candidate.finishReason || finalFinishReason;
                safetyRatings = candidate.safetyRatings || safetyRatings;

                if (finalFinishReason === "SAFETY") {
                  blockReason = "SAFETY";
                  const safetyError = new Error(`API Response Blocked: SAFETY`);
                  safetyError.status = 400;
                  safetyError.reason = "RESPONSE_BLOCK_SAFETY";
                  safetyError.safetyRatings = safetyRatings;
                  throw safetyError;
                }
                if (finalFinishReason === "RECITATION") {
                  blockReason = "RECITATION";
                  const recitationError = new Error(
                    `API Response Blocked: RECITATION`
                  );
                  recitationError.status = 400;
                  recitationError.reason = "RESPONSE_BLOCK_RECITATION";
                  throw recitationError;
                }
                if (finalFinishReason === "MAX_TOKENS") {
                  logger.logEvent(
                    "warn",
                    "API response hit MAX_TOKENS limit.",
                    chunk
                  );
                }
                if (finalFinishReason === "OTHER") {
                  logger.logEvent(
                    "warn",
                    `API response finished with reason OTHER.`,
                    chunk
                  );
                }

                const part = candidate.content?.parts?.[0];
                let progressUpdate = null;

                if (part?.text) {
                  accumulatedText += part.text;
                  progressUpdate = {
                    type: "text",
                    content: part.text,
                    accumulated: accumulatedText,
                  };
                } else if (part?.functionCall) {
                  if (!accumulatedFunctionCall) {
                    accumulatedFunctionCall = {
                      name: part.functionCall.name || "",
                      args: {},
                    };
                  } else if (
                    part.functionCall.name &&
                    !accumulatedFunctionCall.name
                  ) {
                    accumulatedFunctionCall.name = part.functionCall.name;
                  }

                  if (
                    typeof part.functionCall.args === "object" &&
                    part.functionCall.args !== null
                  ) {
                    try {
                      Object.assign(
                        accumulatedFunctionCall.args,
                        part.functionCall.args
                      );
                    } catch (mergeError) {
                      logger.logEvent(
                        "warn",
                        `Error merging function call args for ${accumulatedFunctionCall.name}`,
                        mergeError
                      );
                      accumulatedFunctionCall.args = part.functionCall.args;
                    }
                  }
                  logger.logEvent(
                    "debug",
                    `Received function call chunk: ${accumulatedFunctionCall.name}`,
                    part.functionCall.args
                  );
                  progressUpdate = {
                    type: "functionCall",
                    content: part.functionCall,
                    accumulated: { ...accumulatedFunctionCall },
                  };
                }

                if (progressCallback && progressUpdate) {
                  lastReportedAccumulatedResult = {
                    type: accumulatedFunctionCall
                      ? "functionCall"
                      : accumulatedText
                      ? "text"
                      : "empty",
                    content: accumulatedFunctionCall
                      ? { ...accumulatedFunctionCall }
                      : accumulatedText,
                    inputTokenCount: totalInputTokens,
                    outputTokenCount: totalOutputTokens,
                    totalTokenCount: totalInputTokens + totalOutputTokens,
                    finishReason: finalFinishReason,
                    blockReason: blockReason,
                    safetyRatings: safetyRatings,
                    rawResp: finalRawResponse,
                    status: responseStatus,
                    headers: responseHeaders,
                  };
                  progressUpdate.accumulatedResult =
                    lastReportedAccumulatedResult;
                  progressCallback(progressUpdate);
                }
              }
              if (
                progressCallback &&
                (totalInputTokens > 0 || totalOutputTokens > 0)
              ) {
                progressCallback({
                  type: "status",
                  content: `Tokens: In ${totalInputTokens}, Out ${totalOutputTokens}`,
                });
              }
            } catch (e) {
              if (e.name === "AbortError" || e.reason?.includes("_BLOCK"))
                throw e;
              logger.logEvent(
                "warn",
                `Failed to parse/process SSE chunk: ${e.message}`,
                line
              );
            }
          }
        }
      }

      if (finalRawResponse?.usageMetadata) {
        totalInputTokens =
          finalRawResponse.usageMetadata.promptTokenCount || totalInputTokens;
        totalOutputTokens =
          finalRawResponse.usageMetadata.candidatesTokenCount ||
          totalOutputTokens;
      }

      logger.logEvent(
        "info",
        `API Stream OK. Finish:${finalFinishReason}. Tokens In:${totalInputTokens}, Out:${totalOutputTokens}`
      );
      if (progressCallback)
        progressCallback({ type: "status", content: "Done" });

      const finalResult = {
        type: accumulatedFunctionCall
          ? "functionCall"
          : accumulatedText
          ? "text"
          : "empty",
        content: accumulatedFunctionCall
          ? accumulatedFunctionCall
          : accumulatedText,
        inputTokenCount: totalInputTokens,
        outputTokenCount: totalOutputTokens,
        totalTokenCount: totalInputTokens + totalOutputTokens,
        finishReason: finalFinishReason,
        blockReason: blockReason,
        safetyRatings: safetyRatings,
        rawResp: finalRawResponse,
        status: responseStatus,
        headers: responseHeaders,
      };

      if (finalFinishReason === "MAX_TOKENS") {
        finalResult.warning =
          "Response may be truncated due to maximum output token limit.";
      }

      return finalResult;
    } catch (error) {
      if (error.name !== "AbortError") {
        logger.logEvent("error", `API Stream Error: ${error.message}`, {
          status: error.status,
          reason: error.reason,
          safetyRatings: error.safetyRatings,
          error,
        });
      } else {
        logger.logEvent("info", "API call aborted by user or signal.");
      }
      if (progressCallback)
        progressCallback({
          type: "status",
          content: error.name === "AbortError" ? "Aborted" : "Error",
        });
      throw error;
    }
  };

  const callApiWithRetry = async (
    prompt,
    sysInstr,
    modelName,
    apiKey,
    funcDecls = [],
    isContinuation = false,
    prevContent = null,
    maxRetries = 1,
    generationConfigOverrides = {},
    updateStatusFn = () => {},
    logTimelineFn = () => ({}),
    updateTimelineFn = () => {},
    progressCallback = () => {}
  ) => {
    if (currentAbortController) {
      logger.logEvent(
        "warn",
        "Aborting previous API call before starting new one."
      );
      currentAbortController.abort("New call initiated");
    }
    currentAbortController = new AbortController();
    let attempt = 0;
    let currentDelay = RETRY_DELAY_BASE_MS;

    while (attempt <= maxRetries) {
      let logItem = null;
      try {
        const attemptMsg =
          attempt > 0 ? `[RETRY ${attempt}/${maxRetries}]` : "";
        const statusMsg = `${attemptMsg} Calling Gemini (${modelName})...`;
        const currentCycle = StateManager?.getState()?.totalCycles ?? 0;
        if (attempt === 0 && !isContinuation) {
          updateStatusFn(statusMsg, true);
          logItem = logTimelineFn(
            currentCycle,
            `[API] Calling ${modelName}...`,
            "api",
            true,
            true
          );
        } else if (attempt > 0) {
          updateStatusFn(statusMsg, true);
          logItem = logTimelineFn(
            currentCycle,
            `[API RETRY ${attempt}] Calling ${modelName}...`,
            "retry",
            true,
            true
          );
        }

        const result = await callGeminiAPIStream(
          prompt,
          sysInstr,
          modelName,
          apiKey,
          funcDecls,
          prevContent,
          currentAbortController.signal,
          generationConfigOverrides,
          (progress) => {
            if (
              progress.type === "status" &&
              !["Starting...", "Receiving...", "Done"].includes(
                progress.content
              )
            ) {
              if (logItem)
                updateTimelineFn(
                  logItem,
                  `[API:${modelName}] ${progress.content}`,
                  "api",
                  false
                );
            }
            progressCallback(progress);
            if (
              progress.type === "status" &&
              progress.content !== "Starting..."
            ) {
              updateStatusFn(
                progress.content === "Done" ? "Processing..." : progress.content
              );
            }
          }
        );

        if (logItem)
          updateTimelineFn(
            logItem,
            `[API OK:${modelName}] Fin: ${result.finishReason}, TkIn: ${
              result.inputTokenCount
            }, TkOut: ${result.outputTokenCount}, St: ${result.status}${
              result.warning ? " (Warn: Truncated?)" : ""
            }`,
            "api",
            true
          );
        if (!isContinuation) updateStatusFn("Processing...");

        currentAbortController = null;
        return result;
      } catch (error) {
        const isAbort = error.name === "AbortError";
        const wasManuallyAborted =
          isAbort && error.message !== "New call initiated";

        if (isAbort) {
          if (logItem)
            updateTimelineFn(
              logItem,
              `[API Aborted:${modelName}] ${error.message || "User cancelled"}`,
              "warn",
              true
            );
          if (!isContinuation) updateStatusFn("Aborted");
          currentAbortController = null;
          throw error;
        }

        const status = error.status || 0;
        const reason = error.reason || "UNKNOWN_ERROR";
        const errorMessage = error.message || "Unknown API error";

        logger.logEvent(
          "warn",
          `API attempt ${attempt} failed: ${errorMessage}. Status: ${status}, Reason: ${reason}. Retries left: ${
            maxRetries - attempt
          }`
        );
        if (logItem)
          updateTimelineFn(
            logItem,
            `[API ERR ${attempt}:${modelName}] ${status} ${reason} ${String(
              errorMessage
            ).substring(0, 50)} (Retries left: ${maxRetries - attempt})`,
            "error",
            true
          );

        attempt++;
        if (attempt > maxRetries) {
          logger.logEvent(
            "error",
            `API call failed after ${maxRetries} retries.`
          );
          if (!isContinuation)
            updateStatusFn(`API Failed (${status} ${reason})`, false, true);
          currentAbortController = null;
          error.finalAttempt = true;
          throw error;
        }

        let shouldRetry = false;
        let specificDelay = null;

        if (status === 429 || status === 408) {
          shouldRetry = true;
          const retryAfterHeader = error.headers?.["retry-after"];
          if (retryAfterHeader) {
            const retrySeconds = parseInt(retryAfterHeader, 10);
            if (!isNaN(retrySeconds)) {
              specificDelay = Math.min(retrySeconds * 1000, RETRY_DELAY_MAX_MS);
              logger.logEvent(
                "info",
                `API Rate limit/Timeout (${status}). Retrying after specified ${retrySeconds}s.`
              );
            }
          }
          if (!specificDelay) {
            logger.logEvent(
              "info",
              `API Rate limit/Timeout (${status}). Retrying with exponential backoff.`
            );
          }
        } else if (status >= 500 && status < 600) {
          shouldRetry = true;
          logger.logEvent(
            "info",
            `API server error (${status}). Retrying with exponential backoff.`
          );
        } else if (
          reason === "PROMPT_BLOCK" ||
          reason === "RESPONSE_BLOCK_SAFETY" ||
          reason === "RESPONSE_BLOCK_RECITATION"
        ) {
          shouldRetry = false;
          logger.logEvent(
            "error",
            `API error non-retryable (content block): ${reason}`,
            error.safetyRatings
          );
        } else if (
          error.message.includes("Failed to fetch") ||
          error.message.includes("NetworkError")
        ) {
          shouldRetry = true;
          logger.logEvent(
            "info",
            `API network error. Retrying with exponential backoff.`
          );
        } else {
          shouldRetry = false;
          logger.logEvent(
            "error",
            `API error deemed non-retryable: Status ${status}, Reason ${reason}, Msg: ${errorMessage}`
          );
        }

        if (!shouldRetry) {
          if (!isContinuation)
            updateStatusFn(`API Failed (${status} Non-retryable)`, false, true);
          currentAbortController = null;
          error.finalAttempt = true;
          throw error;
        }

        const delayMs = specificDelay !== null ? specificDelay : currentDelay;
        if (!isContinuation)
          updateStatusFn(
            `API Error (${status}). Retrying in ${Math.round(
              delayMs / 1000
            )}s...`
          );
        if (currentAbortController?.signal.aborted) {
          const abortError = new Error("Aborted during retry delay");
          abortError.name = "AbortError";
          currentAbortController = null;
          throw abortError;
        }
        await new Promise((resolve) => setTimeout(resolve, delayMs));
        if (currentAbortController?.signal.aborted) {
          const abortError = new Error("Aborted after retry delay");
          abortError.name = "AbortError";
          currentAbortController = null;
          throw abortError;
        }

        currentDelay = Math.min(currentDelay * 2, RETRY_DELAY_MAX_MS);
      }
    }

    const finalError = new Error("callApiWithRetry reached end unexpectedly.");
    currentAbortController = null;
    throw finalError;
  };

  const abortCurrentCall = (reason = "User requested abort") => {
    if (currentAbortController) {
      logger.logEvent(
        "info",
        `User requested API call abort. Reason: ${reason}`
      );
      currentAbortController.abort(reason);
      currentAbortController = null;
    } else {
      logger.logEvent("info", "No active API call to abort.");
    }
  };

  return {
    callApiWithRetry,
    abortCurrentCall,
    sanitizeLlmJsonResp,
  };
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: app-logic.js ---
const CoreLogicModule = (
  initialConfig,
  initialUtils,
  initialStorage,
  initialErrors
) => {
  const loadModule = async (filePath, exportName, dependencies = {}) => {
    const logger = initialUtils?.logger || {
      logEvent: (lvl, msg, det) =>
        console.error(`[ORCHESTRATOR FALLBACK] ${msg}`, det || ""),
    };
    const allDependencies = { ...dependencies, Errors: initialErrors }; // Ensure Errors is always available
    const depNames = Object.keys(allDependencies);
    const depValues = Object.values(allDependencies);

    if (
      depNames.length !== depValues.length ||
      depValues.some((dep) => dep === undefined || dep === null)
    ) {
      const missing = depNames.filter(
        (name, i) => depValues[i] === undefined || depValues[i] === null
      );
      logger.logEvent(
        "error",
        `Cannot load module ${filePath}: Missing dependencies ${missing.join(
          ", "
        )}`,
        allDependencies
      );
      throw new initialErrors.ConfigError(
        `Dependency error for ${filePath}: Missing ${missing.join(", ")}`,
        filePath
      );
    }

    try {
      const response = await fetch(
        filePath + `?v=${initialConfig?.STATE_VERSION || Date.now()}`
      );
      if (!response.ok)
        throw new initialErrors.ApiError(
          `HTTP ${response.status} for ${filePath}`,
          response.status
        );
      const scriptContent = await response.text();
      const tempScope = {};
      const funcArgsString = ["tempScope", ...depNames].join(", ");
      const funcBody = `${scriptContent}\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;

      const factoryFunction = new Function(funcArgsString, funcBody);
      factoryFunction(tempScope, ...depValues);

      if (tempScope.result === undefined) {
        logger.logEvent(
          "warn",
          `Module ${filePath} executed, but export '${exportName}' was not found.`
        );
        throw new initialErrors.ConfigError(
          `Module ${filePath} did not yield expected export '${exportName}'.`,
          filePath
        );
      }
      logger.logEvent("debug", `Module ${filePath} loaded successfully.`);

      if (
        exportName.endsWith("Module") &&
        typeof tempScope.result === "function"
      ) {
        return tempScope.result(...depValues); // Pass all dependencies
      } else {
        return tempScope.result;
      }
    } catch (error) {
      logger.logEvent(
        "error",
        `Fatal Error loading/executing module ${filePath}`,
        error.message + (error.stack ? `\nStack: ${error.stack}` : "")
      );
      throw error;
    }
  };

  /**
   * Registers core Web Components defined in artifacts.
   * This is called after StateManager is initialized.
   * @param {object} StateManagerInstance - The initialized StateManager.
   * @param {object} StorageInstance - The initialized Storage.
   * @param {object} LoggerInstance - The logger.
   */
  const registerCoreWebComponents = async (
    StateManagerInstance,
    StorageInstance,
    LoggerInstance
  ) => {
    if (
      !StateManagerInstance ||
      !StorageInstance ||
      !LoggerInstance ||
      typeof customElements === "undefined"
    ) {
      LoggerInstance.logEvent(
        "warn",
        "Cannot register core web components: missing dependencies or customElements API."
      );
      return;
    }
    LoggerInstance.logEvent(
      "info",
      "AppLogic: Attempting to register core Web Components..."
    );
    const artifactMetadata = StateManagerInstance.getAllArtifactMetadata(); // Gets latest versions
    let registeredCount = 0;

    for (const id in artifactMetadata) {
      if (id.startsWith("reploid.core.webcomponent.")) {
        const meta = artifactMetadata[id]; // This is already the latest meta
        if (
          meta &&
          meta.type === "WEB_COMPONENT_DEF" &&
          meta.latestCycle >= 0
        ) {
          const jsContent = StorageInstance.getArtifactContent(
            id,
            meta.latestCycle,
            meta.version_id
          );
          if (jsContent) {
            // e.g., reploid.core.webcomponent.status-bar -> status-bar
            const componentName = id
              .substring("reploid.core.webcomponent.".length)
              .replace(/\./g, "-");
            if (!customElements.get(componentName)) {
              try {
                const ComponentClass = new Function(
                  "return (" + jsContent + ")"
                )();
                if (
                  typeof ComponentClass === "function" &&
                  HTMLElement.isPrototypeOf(ComponentClass)
                ) {
                  customElements.define(componentName, ComponentClass);
                  StateManagerInstance.registerWebComponent(componentName); // Mark as registered in state
                  LoggerInstance.logEvent(
                    "info",
                    `AppLogic: Registered core WC <${componentName}> from ${id}`
                  );
                  registeredCount++;
                } else {
                  LoggerInstance.logEvent(
                    "warn",
                    `AppLogic: Invalid class structure for core WC ${componentName} in ${id}`
                  );
                }
              } catch (e) {
                LoggerInstance.logEvent(
                  "error",
                  `AppLogic: Error defining core WC ${componentName} from ${id}: ${e.message}`
                );
              }
            } else {
              // If already defined by browser/another script, still mark in our state if not already
              if (
                !StateManagerInstance.isWebComponentRegistered(componentName)
              ) {
                StateManagerInstance.registerWebComponent(componentName);
              }
              LoggerInstance.logEvent(
                "debug",
                `AppLogic: Core WC <${componentName}> from ${id} was already defined globally.`
              );
            }
          } else {
            LoggerInstance.logEvent(
              "warn",
              `AppLogic: Content missing for core WC definition: ${id} (Cycle ${meta.latestCycle})`
            );
          }
        }
      }
    }
    if (registeredCount > 0)
      LoggerInstance.logEvent(
        "info",
        `AppLogic: ${registeredCount} core Web Components newly registered.`
      );
    else
      LoggerInstance.logEvent(
        "info",
        `AppLogic: No new core Web Components to register at this stage.`
      );
  };

  const initializeApplication = async () => {
    let config = initialConfig;
    let Utils = initialUtils;
    let Storage = initialStorage;
    let Errors = initialErrors;
    let logger = null;
    let StateManager, ToolRunner, ApiClient, UI, CycleLogic;

    const fatalErrorHandler = (message, error = null) => {
      console.error("Orchestrator: Initialization failed.", message, error);
      const log = logger || {
        logEvent: (lvl, msg, det) =>
          console.error(`[ORCHESTRATOR FALLBACK] ${msg}`, det || ""),
      };
      log.logEvent(
        "error",
        `Orchestrator: Initialization failed. ${message}`,
        error
      );
      document.body.innerHTML = `<div style="color:red; padding: 20px; font-family: monospace;"><h1>FATAL ERROR</h1><p>App init failed: ${message}</p>${
        error ? `<p>${error.message || error}</p>` : ""
      }<p>Check console.</p></div>`;
    };

    try {
      if (!config || !Utils || !Storage || !Errors) {
        throw new Error(
          "Core modules (Config, Utils, Storage, Errors) not passed from bootstrap."
        );
      }
      logger = Utils.logger;
      logger.logEvent("info", "Orchestrator: Initializing application...");

      const stage1Deps = { config, logger, Storage, Errors };
      StateManager = await loadModule(
        "state-manager.js",
        "StateManagerModule",
        stage1Deps
      );
      ApiClient = await loadModule("api-client.js", "ApiClientModule", {
        config,
        logger,
        Errors,
      });
      logger.logEvent("debug", "Orchestrator: Stage 1 modules loaded.");

      StateManager.init();
      await registerCoreWebComponents(StateManager, Storage, logger); // Register core WCs after StateManager is ready

      logger.logEvent(
        "debug",
        "Orchestrator: StateManager initialized and core WCs registered."
      );

      const stage2DepsTool = {
        config,
        logger,
        Storage,
        StateManager,
        ApiClient,
        Errors,
      };
      const stage2DepsUI = {
        config,
        logger,
        Utils,
        Storage,
        StateManager,
        Errors,
      }; // UI might need StateManager for WC list
      ToolRunner = await loadModule(
        "tool-runner.js",
        "ToolRunnerModule",
        stage2DepsTool
      );
      UI = await loadModule("ui-manager.js", "UIModule", stage2DepsUI);
      logger.logEvent("debug", "Orchestrator: Stage 2 modules loaded.");

      const stage3Deps = {
        config,
        logger,
        Utils,
        Storage,
        StateManager,
        UI,
        ApiClient,
        ToolRunner,
        Errors,
      };
      CycleLogic = await loadModule(
        "agent-cycle.js",
        "CycleLogicModule",
        stage3Deps
      );
      logger.logEvent("debug", "Orchestrator: Stage 3 modules loaded.");

      CycleLogic.init();
      logger.logEvent("debug", "Orchestrator: CycleLogic initialized.");

      setTimeout(() => {
        // Defer UI init slightly to ensure DOM is fully ready
        try {
          UI.init(StateManager, CycleLogic);
          logger.logEvent(
            "info",
            "Orchestrator: Application initialization complete."
          );
        } catch (uiError) {
          fatalErrorHandler(
            "UI Initialization failed inside setTimeout.",
            uiError
          );
        }
      }, 0);
    } catch (error) {
      fatalErrorHandler(error.message || "Unknown initialization error", error);
    }
  };

  initializeApplication();
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: boot.js ---
(async () => {
  const startContainer = document.getElementById("start-container");
  const loadingContainer = document.getElementById("loading-container");
  const loadingIndicator = document.getElementById("loading-indicator");
  const appRoot = document.getElementById("app-root");
  const continueButton = document.getElementById("continue-button");
  const resetButton = document.getElementById("reset-button");

  let bootstrapLogMessages = `REPLOID Bootstrap Log - ${new Date().toISOString()}\n=========================================\n`;
  let audioCtx = null;
  let isAudioInitAttempted = false;
  let interactionStarted = false;
  let uiUpdatePromise = Promise.resolve();
  let skipBootstrapAnimation = false;

  let config = null;
  let Utils = null; // Will include .Errors and .logger after UtilsModule is loaded
  let Storage = null;
  let ErrorsGlobal = null; // Will hold Utils.Errors once Utils is loaded
  let blLogger = null; // Will hold Utils.logger once Utils is loaded

  const bl = (() => {
    const MIN_TONE_INTERVAL_MS = 32;
    const TONE_DURATION_MS = 50;
    let lastToneTime = 0;

    const initAudioContextInternal = () => {
      if (!isAudioInitAttempted && !audioCtx) {
        isAudioInitAttempted = true;
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          const logFunc = blLogger ? blLogger.logEvent : console.warn;
          logFunc("warn", "AudioContext init failed:", e.message);
          audioCtx = null;
        }
      }
      return audioCtx;
    };

    const playTone = (frequency, fixedDurationMs, oscType) => {
      if (skipBootstrapAnimation) return;
      const currentAudioCtx = initAudioContextInternal();
      if (!currentAudioCtx || typeof currentAudioCtx.createOscillator !== "function") return;
      try {
        const oscillator = currentAudioCtx.createOscillator();
        const gainNode = currentAudioCtx.createGain();
        const duration = Math.max(fixedDurationMs / 1000, 0.01);
        oscillator.type = oscType;
        oscillator.frequency.setValueAtTime(frequency, currentAudioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.3, currentAudioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, currentAudioCtx.currentTime + duration);
        oscillator.connect(gainNode).connect(currentAudioCtx.destination);
        oscillator.start();
        oscillator.stop(currentAudioCtx.currentTime + duration);
      } catch (e) {
        const logFunc = blLogger ? blLogger.logEvent : console.warn;
        logFunc("warn", "Tone playback error:", e.message);
        audioCtx = null;
      }
    };

    return async function blInternal(message, level = "info", detail = null, charDelay = 1) {
      const timestamp = new Date().toISOString();
      const logLine = `[${timestamp}] [${level.toUpperCase()}] ${message}${detail ? ` | ${detail}` : ""}`;
      bootstrapLogMessages += logLine + "\n";

      let skipConsoleOutput = false;
      let skipUiOutput = false;
      let effectiveLevel = level;

      if (level === "only-gui") { skipConsoleOutput = true; effectiveLevel = "info"; }
      else if (level === "only-console" || level === "detail") { skipUiOutput = true; effectiveLevel = "info"; }

      if (!skipConsoleOutput) {
        const logFunc = blLogger ? blLogger.logEvent : console[effectiveLevel === "error" ? "error" : effectiveLevel === "warn" ? "warn" : "log"];
        if (blLogger) { logFunc(effectiveLevel, message, detail || ""); }
        else { console[effectiveLevel === "error" ? "error" : effectiveLevel === "warn" ? "warn" : "log"](logLine); }
      }

      if (skipUiOutput || !loadingIndicator) return;

      uiUpdatePromise = uiUpdatePromise.then(async () => {
          const logEntryContainer = document.createElement("div");
          logEntryContainer.className = `log-entry log-${effectiveLevel}`;
          loadingIndicator.appendChild(logEntryContainer);
          const fullText = `> ${message}${detail ? ` | ${detail}` : ""}`;

          if (skipBootstrapAnimation) {
            logEntryContainer.textContent = fullText;
          } else {
            if (effectiveLevel === "error") playTone(220, TONE_DURATION_MS, "square");
            lastToneTime = performance.now();
            for (const char of fullText) {
              logEntryContainer.textContent += char;
              if (loadingIndicator.scrollTop !== undefined) loadingIndicator.scrollTop = loadingIndicator.scrollHeight;
              const currentTime = performance.now();
              if (char.trim() && effectiveLevel !== "error" && currentTime - lastToneTime >= MIN_TONE_INTERVAL_MS) {
                playTone(990, TONE_DURATION_MS, "triangle"); lastToneTime = currentTime;
              }
              if (charDelay > 0) await new Promise((resolve) => setTimeout(resolve, Math.max(charDelay, 1)));
              if (skipBootstrapAnimation) { logEntryContainer.textContent = fullText; break; }
            }
          }
          if (loadingIndicator.scrollTop !== undefined) loadingIndicator.scrollTop = loadingIndicator.scrollHeight;
        }).catch((error) => {
          const logMsg = "Error during bootstrap logging UI update:";
          const errorLogFunc = blLogger ? blLogger.logEvent : console.error;
          errorLogFunc("error", logMsg, error);
          uiUpdatePromise = Promise.resolve();
        });
      await uiUpdatePromise;
    };
  })();

  const initAudioContext = () => {
    if (!isAudioInitAttempted && !audioCtx) {
      isAudioInitAttempted = true;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        const logFunc = blLogger ? blLogger.logEvent : console.warn;
        logFunc("warn", "AudioContext init failed on demand:", e.message);
        audioCtx = null;
      }
    }
    return audioCtx;
  };

  async function calculateChecksumViaUtils(content) {
    // This function will be used once Utils (and its calculateChecksum) is loaded
    if (Utils && typeof Utils.calculateChecksum === 'function') {
        return await Utils.calculateChecksum(content);
    }
    // Fallback if Utils or its checksum function isn't ready (shouldn't happen for artifact verification)
    console.warn("calculateChecksumViaUtils called before Utils.calculateChecksum was available.");
    return null;
  }


  async function fetchAndExecuteModule(filePath, exportName, dependencies = {}) {
    // Use blLogger if available, otherwise console for very early errors from this function
    const loggerInstance = blLogger || { logEvent: (lvl, msg, det) => console.error(`[BOOT_FETCH_FALLBACK] ${msg}`, det || "") };
    
    // Errors will be passed in dependencies by loadCoreDependencies once Utils is loaded
    const { Errors: CustomErrorsFromDeps } = dependencies;

    const depNames = Object.keys(dependencies);
    const depValues = Object.values(dependencies);

    if (depNames.length !== depValues.length || depValues.some((dep) => dep === undefined || dep === null)) {
      const missing = depNames.filter((name, i) => depValues[i] === undefined || depValues[i] === null);
      const errorMsg = `Cannot load module ${filePath}: Missing dependencies ${missing.join(", ")}`;
      loggerInstance.logEvent("error", errorMsg, dependencies);
      throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
    }

    try {
      const response = await fetch(filePath + `?v=${config?.STATE_VERSION || Date.now()}`);
      if (!response.ok) {
        const errorMsg = `HTTP ${response.status} for ${filePath}`;
        throw (CustomErrorsFromDeps?.ApiError ? new CustomErrorsFromDeps.ApiError(errorMsg, response.status) : new Error(errorMsg));
      }
      const scriptContent = await response.text();
      const tempScope = {};
      const funcArgs = ["tempScope", ...depNames];
      const funcBody = `${scriptContent}\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;

      const factoryFunction = new Function(...funcArgs, funcBody);
      factoryFunction(tempScope, ...depValues);

      if (tempScope.result === undefined) {
        const errorMsg = `Module ${filePath} did not yield expected export '${exportName}'.`;
        loggerInstance.logEvent("warn", errorMsg);
        throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
      }

      if (exportName.endsWith("Module") && typeof tempScope.result === "function") {
        const moduleFactory = tempScope.result;
        const moduleInstance = moduleFactory(...depValues);
        if (!moduleInstance) {
          const errorMsg = `Module factory ${exportName} from ${filePath} returned null/undefined.`;
          loggerInstance.logEvent("error", errorMsg);
          throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
        }
        loggerInstance.logEvent("debug", `Module factory ${exportName} from ${filePath} executed successfully.`);
        return moduleInstance;
      } else {
        loggerInstance.logEvent("debug", `Returning direct export ${exportName} from ${filePath}.`);
        return tempScope.result;
      }
    } catch (error) {
      loggerInstance.logEvent("error", `Fatal Error loading/executing module ${filePath}`, error.message + (error.stack ? `\nStack: ${error.stack}` : ""));
      throw error; // Re-throw the original error or a wrapped one
    }
  }

  async function loadCoreDependencies() {
    try {
      await bl("Loading core configuration...", "info", null, 0);
      const configResponse = await fetch("config.json" + `?v=${Date.now()}`);
      if (!configResponse.ok) throw new Error(`HTTP ${configResponse.status} loading config.json`);
      config = await configResponse.json();
      if (!config) throw new Error("Failed to parse config.json");
      await bl("Config loaded.", "only-console", `Version: ${config.STATE_VERSION}`);

      await bl("Loading core utilities (incl. Errors)...", "info", null, 0);
      Utils = await fetchAndExecuteModule("utils.js", "UtilsModule", {}); // No deps for Utils itself initially
      if (!Utils || !Utils.logger || !Utils.Errors) throw new Error("Failed to load UtilsModule or its components (logger, Errors) correctly.");
      blLogger = Utils.logger; // Set the main bootstrap logger
      ErrorsGlobal = Utils.Errors; // Set global Errors reference
      await bl("Utils (incl. Errors) loaded.", "only-console");

      await bl("Loading core storage...", "info", null, 0);
      Storage = await fetchAndExecuteModule("storage.js", "StorageModule", { config, logger: blLogger, Errors: ErrorsGlobal });
      if (!Storage || typeof Storage.getState !== "function") throw new Error("Failed to load StorageModule correctly.");
      await bl("Storage loaded.", "only-console");

      await bl("Core dependencies loaded.", "success", null, 0);
      return true;
    } catch (error) {
      const errorMsg = error.message || "Unknown error loading core dependencies.";
      await bl("FATAL: Failed to load core dependencies.", "error", errorMsg);
      console.error("Dependency Load Error:", error, error.stack);
      if (loadingIndicator) loadingIndicator.innerHTML = `<div class="log-entry log-error">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Cannot continue. Check console.</div>`;
      if (loadingContainer) loadingContainer.classList.remove("hidden");
      if (startContainer) startContainer.classList.add("hidden");
      removeInteractionListeners();
      return false;
    }
  }

  function isValidState(parsedState) {
    if (!config || !parsedState) return false;
    const stateVersionMajor = config.STATE_VERSION.split(".")[0];
    const parsedVersionMajor = parsedState.version?.split(".")[0];
    const validVersion = parsedVersionMajor === stateVersionMajor;
    const basicStructureValid =
      typeof parsedState.totalCycles === "number" && parsedState.totalCycles >= 0 &&
      parsedState.artifactMetadata && typeof parsedState.artifactMetadata === "object" &&
      Array.isArray(parsedState.registeredWebComponents);
    if (!validVersion) bl("State version mismatch.", "warn", `Found: ${parsedState.version}, Required Major: ${stateVersionMajor}`);
    if (!basicStructureValid) bl("State basic structure invalid.", "warn", `Missing cycles, metadata, or web component registry.`);
    return validVersion && basicStructureValid;
  }

  async function verifyArtifactChecksum(id, cycle, expectedChecksum, versionId = null) {
    if (!expectedChecksum) return true; // No checksum to verify against
    const content = Storage.getArtifactContent(id, cycle, versionId);
    if (content === null && expectedChecksum) { // If content is null but we expected a checksum, it's a failure
        await bl(`Content missing for checksum verification: ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "warn");
        return false;
    }
    if (content === null && !expectedChecksum) return true; // No content, no checksum, considered valid placeholder

    let actualChecksum = await calculateChecksumViaUtils(content); // Use the one from Utils
    if (!actualChecksum) {
      await bl(`Checksum calculation failed for ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "error");
      return false;
    }
    if (actualChecksum !== expectedChecksum) {
      await bl(`Checksum mismatch for ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "warn", `Expected: ${expectedChecksum}, Actual: ${actualChecksum}`);
      return false;
    }
    return true;
  }

  async function checkEssentialArtifactsPresent(stateCycle, artifactMetadata) {
    if (!Storage || !config || !artifactMetadata || !Utils) return false;
    await bl(`Verifying essential artifacts for state cycle ${stateCycle}...`, "info", null, 0);
    let allFoundAndValid = true;
    const essentialDefs = config.GENESIS_ARTIFACT_DEFS || {};
    const verificationPromises = [];

    for (const id in essentialDefs) {
      if (id === "reploid.core.config") continue; // Not stored/verified this way in this check
      const metaHistory = artifactMetadata[id];
      let latestMeta = null;
      if (metaHistory && metaHistory.length > 0) {
        latestMeta = Utils.getLatestMeta(metaHistory);
      }
      const cycleToCheck = latestMeta ? latestMeta.latestCycle : 0; // Default to cycle 0 for genesis
      const versionIdToCheck = latestMeta ? latestMeta.version_id : null;
      const expectedChecksum = latestMeta ? latestMeta.checksum : null;
      const content = Storage.getArtifactContent(id, cycleToCheck, versionIdToCheck);

      if (content === null) {
        // Only error if it's not a placeholder (cycle -1)
        if(latestMeta && latestMeta.latestCycle !== -1) {
            await bl(`Essential artifact MISSING: ${id}`, "error", `Expected Cycle: ${cycleToCheck}, V: ${versionIdToCheck || "def"}`);
            allFoundAndValid = false;
        } else if (!latestMeta) { // If no metadata at all, it's missing
            await bl(`Essential artifact DEFINITION MISSING from state metadata: ${id}`, "error");
            allFoundAndValid = false;
        }
      } else {
        verificationPromises.push(
          verifyArtifactChecksum(id, cycleToCheck, expectedChecksum, versionIdToCheck).then((isValid) => {
            if (!isValid) allFoundAndValid = false;
            else bl(`Verified: ${id}`, "only-console", `Cyc: ${cycleToCheck}, V: ${versionIdToCheck || "def"}, Len: ${content.length}${expectedChecksum ? ", CS OK" : ""}`);
          })
        );
      }
    }
    await Promise.all(verificationPromises);
    if (!allFoundAndValid) await bl("One or more essential artifacts missing or invalid.", "error");
    else await bl("All essential artifacts verified.", "success", null, 0);
    return allFoundAndValid;
  }

  async function clearAllReploidData() {
    if (!Storage || typeof Storage.clearAllReploidData !== "function") {
      await bl("Cannot clear data, Storage module not loaded.", "error"); return;
    }
    await bl("Clearing all REPLOID data from LocalStorage...", "warn", null, 16);
    try {
      Storage.clearAllReploidData();
      await bl("LocalStorage cleared.", "info", null, 8);
    } catch (e) {
      await bl("Error clearing LocalStorage.", "error", e.message);
    }
  }

  async function bootstrapReploid(performGenesis = false) {
    if (!config || !Utils || !Storage || !ErrorsGlobal) {
      await bl("Core dependencies check failed, cannot bootstrap.", "error"); return;
    }
    if (!blLogger) blLogger = Utils.logger; // Ensure blLogger is set

    let state = null;
    let needsGenesis = performGenesis;
    let stateSource = performGenesis ? "Forced Genesis" : "None";

    if (!performGenesis) {
      await bl("Checking for existing state...", "info", null, 0);
      const stateJSON = Storage.getState();
      if (stateJSON) {
        state = stateJSON; // Already parsed by Storage.getState()
        if (isValidState(state)) {
          if (await checkEssentialArtifactsPresent(state.totalCycles, state.artifactMetadata)) {
            stateSource = `localStorage (Cycle ${state.totalCycles}, v${state.version})`;
            await bl(`Found valid state and artifacts.`, "success", `Source: ${stateSource}`, 0);
            needsGenesis = false;
          } else {
            await bl(`State valid (Cycle ${state.totalCycles}) but artifacts missing/invalid. Discarding.`, "error");
            state = null; Storage.removeState(); needsGenesis = true; stateSource = "Discarded Invalid State";
          }
        } else {
          await bl(`Found invalid/incompatible state (v${state?.version || "?"}). Discarding.`, "warn");
          state = null; Storage.removeState(); needsGenesis = true; stateSource = "Discarded Invalid State";
        }
      } else {
        await bl("No existing state found. Initiating genesis.", "info");
        needsGenesis = true; stateSource = "Genesis";
      }
    } else {
      await bl("Reset requested...", "only-gui", null, 6);
      needsGenesis = true; stateSource = "Forced Genesis";
    }

    try {
      if (needsGenesis) {
        await bl("Running genesis boot process...", "info");
        state = await runGenesisProcess();
        if (!state) throw new Error("Genesis boot process failed."); // Use standard Error
        await bl("Genesis complete.", "success");
      }
      await bl(`Loading application with state from: ${stateSource}`, "info");
      await uiUpdatePromise; // Ensure prior log messages are displayed
      await loadAndExecuteApp(state);
    } catch (error) {
      await bl("Fatal bootstrap error", "error", error.message);
      console.error("Bootstrap stack trace:", error);
      if (loadingIndicator) loadingIndicator.innerHTML += `<div class="log-error">FATAL BOOTSTRAP ERROR: ${error.message}. Check console.</div>`;
    }
  }

  async function fetchGenesisArtifacts() {
    if (!config || !config.GENESIS_ARTIFACT_DEFS) {
      await bl("Cannot fetch genesis artifacts: Config definitions missing.", "error"); return null;
    }
    await bl("Fetching genesis artifacts...", "info", null, 0);
    const fetchedArtifacts = {};
    let success = true;
    const fetchPromises = Object.entries(config.GENESIS_ARTIFACT_DEFS).map(async ([id, def]) => {
      if (!def.filename) return; // Skip if no filename (e.g. config itself)
      try {
        const response = await fetch(def.filename + `?t=${Date.now()}`);
        if (!response.ok) throw new Error(`HTTP ${response.status} for ${def.filename}`);
        let content;
        if (def.type === "JSON" || def.type === "JSON_CONFIG") content = JSON.stringify(await response.json(), null, 2);
        else content = await response.text();
        fetchedArtifacts[id] = content;
        await bl(`Fetched: ${def.filename}`, "only-console", `${content.length} bytes`);
      } catch (error) {
        await bl(`Failed to fetch ${def.filename}`, "error", error.message); success = false;
      }
    });
    await Promise.all(fetchPromises);
    if (!success) { await bl("Genesis artifact fetch failed.", "error"); return null; }
    await bl(`Fetched ${Object.keys(fetchedArtifacts).length} genesis artifacts.`, "only-console");
    return fetchedArtifacts;
  }

  async function saveGenesisArtifacts(artifacts) {
    if (!Storage || !config || !artifacts || !Utils) return null;
    await bl("Saving genesis artifacts (Cycle 0)...", "info", null, 0);
    const metadata = {};
    let success = true;
    const genesisDefs = config.GENESIS_ARTIFACT_DEFS || {};
    const now = Date.now();

    for (const id in artifacts) {
      try {
        const checksum = await Utils.calculateChecksum(artifacts[id]);
        if (!checksum) { await bl(`Checksum failed for genesis artifact: ${id}`, "error"); success = false; continue; }
        Storage.setArtifactContent(id, 0, artifacts[id]);
        metadata[id] = [{
          id, version_id: null, latestCycle: 0,
          type: genesisDefs[id]?.type || "UNKNOWN",
          description: genesisDefs[id]?.description || `Genesis Artifact ${id}`,
          source: "Genesis", checksum, timestamp: now,
        }];
        await bl(`Saved: ${id}`, "only-console", `Cyc 0, CS: ${checksum.substring(0, 15)}...`);
      } catch (e) {
        await bl(`Failed save artifact: ${id} (Cycle 0)`, "error", e.message); success = false;
      }
    }

    // Save content of boot.js and boot-style.css as artifacts
    const bootScriptElement = document.querySelector('script[src="boot.js"]');
    const bootScriptContent = bootScriptElement ? await fetch(bootScriptElement.src + `?t=${Date.now()}`).then(res => res.ok ? res.text() : "(Fetch boot.js failed)") : "(boot.js script element Not Found)";
    const bootStyleContent = document.getElementById("boot-style")?.textContent || "";
    await uiUpdatePromise; // Ensure log is flushed before capturing
    const finalBootstrapLog = bootstrapLogMessages;

    // No errors.js to save as its content is now in utils.js
    const bootArtifactsToSave = {
      "reploid.boot.style": { content: bootStyleContent, type: "CSS", description: "Bootstrap CSS from index.html" },
      "reploid.boot.script": { content: bootScriptContent, type: "JS", description: "Bootstrap script (boot.js) content" },
      "reploid.boot.log": { content: finalBootstrapLog, type: "LOG", description: "Bootstrap execution log" },
    };

    for (const id in bootArtifactsToSave) {
      const { content, type, description } = bootArtifactsToSave[id];
      try {
        const checksum = await Utils.calculateChecksum(content);
        if (!checksum && id !== "reploid.boot.log") { await bl(`Checksum failed for bootstrap artifact: ${id}`, "warn"); continue; }
        Storage.setArtifactContent(id, 0, content);
        metadata[id] = [{ id, version_id: null, latestCycle: 0, type, description, source: "BootstrapCapture", checksum, timestamp: now }];
        await bl(`Saved: ${id}`, "only-console", `Cyc 0, CS: ${checksum ? checksum.substring(0, 15) + "..." : "N/A"}`);
      } catch (e) {
        await bl(`Failed save bootstrap artifact: ${id}`, "warn", e.message);
      }
    }
    
    // Add placeholder metadata for genesis defs not fetched (like config itself) or if fetch failed
    Object.keys(genesisDefs).forEach((id) => {
      if (!metadata[id]) { // If not already processed (fetched & saved)
        const def = genesisDefs[id];
        if (def) {
          metadata[id] = [{
            id, version_id: null, latestCycle: (id === "reploid.core.config" ? 0 : -1), // Config is "saved"
            type: def.type, description: def.description, source: "Genesis Definition",
            checksum: null, timestamp: now,
          }];
          if (id === "reploid.core.config") { // Special case: config.json content is the artifact
             Storage.setArtifactContent(id, 0, JSON.stringify(config, null, 2));
          }
          bl(`Added metadata for ${id} (cycle ${metadata[id][0].latestCycle})`, "only-console");
        }
      }
    });

    await bl("Genesis artifact save completed.", success ? "only-console" : "warn");
    return success ? metadata : null;
  }

  async function runGenesisProcess() {
    const fetchedArtifacts = await fetchGenesisArtifacts(); // Fetches files listed in config.GENESIS_ARTIFACT_DEFS
    if (!fetchedArtifacts) return null;
    const artifactMetadata = await saveGenesisArtifacts(fetchedArtifacts); // Saves them and boot.* files
    if (!artifactMetadata) return null;

    const initialState = Utils.getDefaultState(config); // Pass loaded config to get defaults
    initialState.artifactMetadata = artifactMetadata; // Assign the generated metadata
    initialState.lastFeedback = "Genesis completed.";

    try {
      Storage.saveState(initialState);
      await bl("Initial state saved.", "success", null, 0);
      return initialState;
    } catch (e) {
      await bl("Failed to save initial state!", "error", e.message);
      return null;
    }
  }

  async function registerCoreWebComponentsOnBoot(currentArtifactMetadata) {
    if (!currentArtifactMetadata || typeof customElements === "undefined" || !Storage || !Utils) {
        bl("Cannot register core WCs on boot: missing dependencies.", "warn");
        return;
    }
    await bl("Boot: Registering core Web Components from artifacts...", "info", null, 0);
    let registeredCount = 0;
    for (const id in currentArtifactMetadata) {
      if (id.startsWith("reploid.core.webcomponent.")) {
        const metaHistory = currentArtifactMetadata[id];
        const latestMeta = Utils.getLatestMeta(metaHistory);

        if (latestMeta && latestMeta.type === "WEB_COMPONENT_DEF" && latestMeta.latestCycle >= 0) {
          const jsContent = Storage.getArtifactContent(id, latestMeta.latestCycle, latestMeta.version_id);
          if (jsContent) {
            const componentName = id.substring("reploid.core.webcomponent.".length).replace(/\./g, "-");
            if (!customElements.get(componentName)) {
              try {
                const ComponentClass = new Function("return (" + jsContent + ")")();
                if (typeof ComponentClass === "function" && HTMLElement.isPrototypeOf(ComponentClass)) {
                  customElements.define(componentName, ComponentClass);
                  await bl(`Boot: Registered core WC <${componentName}> from ${id}`, "only-console");
                  registeredCount++;
                } else {
                  await bl(`Boot: Invalid class structure for core WC ${componentName} in ${id}`, "warn");
                }
              } catch (e) {
                await bl(`Boot: Error defining core WC ${componentName} from ${id}: ${e.message}`, "error");
              }
            } else {
              await bl(`Boot: Core WC <${componentName}> from ${id} was already defined globally.`, "debug");
            }
          } else {
            await bl(`Boot: Content missing for core WC definition: ${id} (Cycle ${latestMeta.latestCycle})`, "warn");
          }
        }
      }
    }
    if (registeredCount > 0) await bl(`Boot: ${registeredCount} core Web Components registered globally.`, "info", null, 0);
    else await bl(`Boot: No new core Web Components to register globally at this stage.`, "info", null, 0);
  }

  async function loadAndExecuteApp(currentState) {
    await bl(`Loading application core (State Cycle ${currentState.totalCycles})...`, "info", null, 0);
    if (!config || !Utils || !Storage || !ErrorsGlobal) {
      await bl("Core dependencies not available for app execution.", "error"); return;
    }
    const coreStyleId = "reploid.core.style";
    const coreLogicId = "reploid.core.logic"; // This is app-logic.js
    const coreBodyId = "reploid.core.body";

    try {
      const latestStyleMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreStyleId]);
      const styleCycle = latestStyleMeta?.latestCycle >= 0 ? latestStyleMeta.latestCycle : 0;
      const styleContent = Storage.getArtifactContent(coreStyleId, styleCycle, latestStyleMeta?.version_id);
      if (styleContent) {
        const styleElement = document.createElement("style");
        styleElement.id = `${coreStyleId}-loaded-${styleCycle}${latestStyleMeta?.version_id ? "-" + latestStyleMeta.version_id : ""}`;
        styleElement.textContent = styleContent;
        document.head.appendChild(styleElement);
        await bl(`Applied style: ${coreStyleId} (Cycle ${styleCycle}${latestStyleMeta?.version_id ? ", V:" + latestStyleMeta.version_id : ""})`, "only-console");
      } else await bl(`Core style artifact missing (Cyc ${styleCycle}/0). Using only boot style.`, "warn");

      const latestBodyMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreBodyId]);
      const bodyCycle = latestBodyMeta?.latestCycle >= 0 ? latestBodyMeta.latestCycle : 0;
      const coreBodyContent = Storage.getArtifactContent(coreBodyId, bodyCycle, latestBodyMeta?.version_id);
      if (coreBodyContent && appRoot) {
        await bl(`Injecting body: ${coreBodyId} (Cycle ${bodyCycle}${latestBodyMeta?.version_id ? ", V:" + latestBodyMeta.version_id : ""})`, "only-console");
        appRoot.innerHTML = coreBodyContent;
      } else throw new Error("Failed to load core UI structure (body artifact or app-root element missing).");

      // Register core Web Components defined as artifacts globally before app-logic tries to use them or re-register with StateManager
      await registerCoreWebComponentsOnBoot(currentState.artifactMetadata);

      const latestLogicMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreLogicId]);
      const logicCycle = latestLogicMeta?.latestCycle >= 0 ? latestLogicMeta.latestCycle : 0;
      const orchestratorScriptContent = Storage.getArtifactContent(coreLogicId, logicCycle, latestLogicMeta?.version_id);
      if (!orchestratorScriptContent) throw new Error(`Core logic artifact (${coreLogicId}) missing (Cyc ${logicCycle}/0).`);

      await bl(`Executing orchestrator: ${coreLogicId} (Cycle ${logicCycle}${latestLogicMeta?.version_id ? ", V:" + latestLogicMeta.version_id : ""})...`, "info", null, 0);
      // app-logic.js (CoreLogicModule) expects specific arguments: initialConfig, initialUtils, initialStorage, initialErrors
      const orchestratorFunction = new Function("initialConfig", "initialUtils", "initialStorage", "initialErrors", orchestratorScriptContent + "\nreturn CoreLogicModule(initialConfig, initialUtils, initialStorage, initialErrors);");
      const maybePromise = orchestratorFunction(config, Utils, Storage, ErrorsGlobal); // Pass the correct initial dependencies
      if (maybePromise instanceof Promise) await maybePromise;
      await bl("Orchestrator execution initiated.", "success", null, 0);

      setTimeout(() => {
        if (loadingContainer) {
          loadingContainer.style.transition = "opacity 0.5s ease-out";
          loadingContainer.style.opacity = "0";
          setTimeout(() => loadingContainer.classList.add("hidden"), 500);
        }
        if (appRoot) appRoot.classList.add("visible");
      }, 500);

    } catch (error) {
      await bl(`Error loading/executing core components`, "error", error.message);
      console.error("Core execution failed", error);
      if (loadingIndicator) loadingIndicator.innerHTML += `<div class="log-error">FATAL CORE EXECUTION ERROR: ${error.message}. Check console.</div>`;
    }
  }

  function handleSkip(e) {
    if (e.key === "Enter" || e.type === "click" || e.type === "touchstart") {
      if (!skipBootstrapAnimation) {
        skipBootstrapAnimation = true;
        bl("[BOOTSTRAP SKIP]", "only-gui", null, 0);
        if (e.type === "touchstart") e.preventDefault();
      }
    }
  }
  function handleKeydown(e) {
    if (!interactionStarted) {
      if (e.key === "Enter") startInteraction("continue");
      else if (e.key === " ") startInteraction("reset");
    }
  }
  function removeInteractionListeners() {
    document.removeEventListener("keydown", handleKeydown);
    if (continueButton) continueButton.removeEventListener("click", handleContinueClick);
    if (resetButton) resetButton.removeEventListener("click", handleResetClick);
  }
  function addSkipListener() {
    document.addEventListener("keydown", handleSkip);
    document.addEventListener("click", handleSkip);
    document.addEventListener("touchstart", handleSkip, { passive: false });
  }
  function removeSkipListener() {
    document.removeEventListener("keydown", handleSkip);
    document.removeEventListener("click", handleSkip);
    document.removeEventListener("touchstart", handleSkip);
  }

  const handleContinueClick = () => startInteraction("continue");
  const handleResetClick = () => startInteraction("reset");

  async function startInteraction(action) {
    if (interactionStarted) return;
    interactionStarted = true;
    skipBootstrapAnimation = false; // Reset skip on new interaction
    if (startContainer) startContainer.classList.add("hidden");
    if (loadingContainer) loadingContainer.classList.remove("hidden");
    document.body.style.justifyContent = "flex-start"; // Align content to top
    initAudioContext(); // Attempt to init audio on user gesture
    removeInteractionListeners();
    addSkipListener();

    try {
        const dependenciesLoaded = await loadCoreDependencies();
        if (!dependenciesLoaded) {
          removeSkipListener();
          return; // loadCoreDependencies already handled fatal error display
        }
        if (action === "reset") {
          await clearAllReploidData();
          await bl("Rebooting after reset...", "info", null, 64);
          await bl("            ", "only-gui", null, 8); // Visual pause
          await bootstrapReploid(true); // Force genesis
        } else {
          await bootstrapReploid(false); // Attempt to load existing or run genesis
        }
    } catch (err) {
        // This catch is for truly unexpected errors during startInteraction itself
        const errorMsg = err.message || "Unknown error during startInteraction.";
        await bl("FATAL: Unhandled error in startInteraction.", "error", errorMsg);
        console.error("Unhandled startInteraction Error:", err);
        if (loadingIndicator) loadingIndicator.innerHTML = `<div class="log-entry log-error">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Check console.</div>`;
    } finally {
        removeSkipListener(); // Ensure skip listener is removed even if errors occur
    }
  }

  if (continueButton) continueButton.addEventListener("click", handleContinueClick);
  if (resetButton) resetButton.addEventListener("click", handleResetClick);
  document.addEventListener("keydown", handleKeydown);
})();
ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: config.json ---
{
  "LS_PREFIX": "_x0_",
  "STATE_KEY_BASE": "x0_state_v",
  "SESSION_STATE_KEY_BASE": "x0_session_state_v",
  "STATE_VERSION": "0.7.0",
  "MAX_ARTIFACT_SIZE_BYTES": 4194304,
  "MAX_LOG_LENGTH": 50000,
  "CTX_WARN_THRESH": 300000,
  "CTX_TARGET": 350000,
  "EVAL_PASS_THRESHOLD": 0.75,
  "SVG_NS": "http://www.w3.org/2000/svg",
  "GEMINI_STREAM_ENDPOINT_BASE": "https://generativelanguage.googleapis.com/v1beta/models/",
  "API_RETRY_DELAY_BASE_MS": 1500,
  "DYNAMIC_TOOL_TIMEOUT_MS": 10000,
  "WORKER_SCRIPT_PATH": "tool-worker.js",
  "NUM_CRITIQUES_TO_GENERATE": 1,
  "AUTONOMOUS_CYCLE_DELAY_MS": 1000,
  "TIMELINE_LOG_LIMIT": 250,
  "DEFAULT_MODELS": {
    "BASE": "gemini-1.5-flash-latest",
    "ADVANCED": "gemini-1.5-pro-latest"
  },
  "DEFAULT_CFG": {
    "personaBalance": 50,
    "llmCritiqueProb": 75,
    "humanReviewProb": 25,
    "maxCycleTime": 600,
    "autoCritiqueThresh": 0.7,
    "maxCycles": 0,
    "htmlHistoryLimit": 5,
    "pauseAfterCycles": 10,
    "maxRetries": 1,
    "autonomyMode": "Manual",
    "autonomyDefaultNCycles": 5,
    "contextTokenTarget": 350000,
    "coreModel": "ADVANCED",
    "critiqueModel": "BASE",
    "summarizerModel": "BASE",
    "evaluatorModel": "BASE",
    "hitlOnMetaChanges": true,
    "enablePageComposition": true
  },
  "GENESIS_ARTIFACT_DEFS": {
    "reploid.core.config": {
      "filename": "config.json",
      "type": "JSON_CONFIG",
      "description": "Central application configuration"
    },
    "reploid.core.logic": {
      "filename": "app-logic.js",
      "type": "JS",
      "description": "Main application logic orchestrator"
    },
    "reploid.core.style": {
      "filename": "ui-style.css",
      "type": "CSS",
      "description": "Main application styles"
    },
    "reploid.core.body": {
      "filename": "ui-body-template.html",
      "type": "HTML",
      "description": "App root HTML structure (used if not overridden by page_composition)"
    },
    "reploid.core.utils": {
      "filename": "utils.js",
      "type": "JS",
      "description": "Core utility functions (includes custom Error definitions)"
    },
    "reploid.core.storage": {
      "filename": "storage.js",
      "type": "JS",
      "description": "Core storage functions"
    },
    "reploid.core.statemanager": {
      "filename": "state-manager.js",
      "type": "JS",
      "description": "Core state management logic"
    },
    "reploid.core.ui": {
      "filename": "ui-manager.js",
      "type": "JS",
      "description": "Core UI rendering and event handling"
    },
    "reploid.core.apiclient": {
      "filename": "api-client.js",
      "type": "JS",
      "description": "Handles API communication"
    },
    "reploid.core.cyclelogic": {
      "filename": "agent-cycle.js",
      "type": "JS",
      "description": "Main application cycle orchestration"
    },
    "reploid.core.sys-prompt": {
      "filename": "prompt-system.txt",
      "type": "PROMPT",
      "description": "Core LLM prompt"
    },
    "reploid.core.critiquer-prompt": {
      "filename": "prompt-critiquer.txt",
      "type": "PROMPT",
      "description": "Critique prompt"
    },
    "reploid.core.summarizer-prompt": {
      "filename": "prompt-summarizer.txt",
      "type": "PROMPT",
      "description": "Summarization prompt"
    },
    "reploid.core.evaluator-prompt": {
      "filename": "prompt-evaluator.txt",
      "type": "PROMPT",
      "description": "Self-evaluation prompt"
    },
    "reploid.core.static-tools": {
      "filename": "data-tools-static.json",
      "type": "JSON",
      "description": "Static tool definitions"
    },
    "reploid.core.toolrunner": {
      "filename": "tool-runner.js",
      "type": "JS",
      "description": "Tool execution engine (static + dynamic via worker)"
    },
    "reploid.core.default-eval": {
      "filename": "data-eval-default.json",
      "type": "EVAL_DEF",
      "description": "Default Evaluation Definition"
    }
  },
  "ARTIFACT_TYPES": [
    "JS",
    "CSS",
    "HTML",
    "HTML_HEAD",
    "HTML_BODY",
    "JSON",
    "JSON_CONFIG",
    "PROMPT",
    "TEXT",
    "LOG",
    "EVAL_DEF",
    "DIAGRAM_JSON",
    "WEB_COMPONENT_DEF",
    "FULL_HTML_SOURCE",
    "PAGE_COMPOSITION_DEF",
    "UNKNOWN"
  ]
}

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: data-cycle-steps.txt ---
1. Define or Refine Goal (System/Meta). Load Relevant Context. Check Cycle Limits.
2. Analyze State, Goal, Artifacts, Tools, History (Feedback, Evals). Deliberate.
3. Propose Changes (Artifacts, Tools, Versions). Decide Actions. Set Confidence.
4. Execute LLM & Tools -> Generate Response (Code, Data, New Tool Implementations).
5. Check Triggers for Critique or Intervention (Time, Confidence, Random, Forced).
6. Perform Critique (Auto) or Get Human Feedback (Options, Prompt, Code Edit).
7. Apply Approved Changes or Stage Sandbox (Meta). Handle Prior Feedback. Log Actions.
8. Self-Evaluate Cycle Outcome & Learn from History. Propose Process Improvements.
9. Determine Next Action: Continue Cycle, Pause, Initiate Retry, or Self-Correct.
ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: data-eval-default.json ---
{
  "id": "reploid.core.default-eval",
  "name": "Default Artifact/Proposal Evaluation",
  "description": "Provides a default set of criteria for evaluating the quality and relevance of an agent's output (artifact, justification, or proposal) against the goal context.",
  "criteria_version": "1.0",
  "criteria": [
    {
      "id": "goal_alignment",
      "question": "How well does the target content/proposal directly address the core requirements and constraints specified in the goal context?",
      "weight": 0.4,
      "scoring_guide": {
        "0.0-0.2": "Completely irrelevant or counter-productive to the goal.",
        "0.3-0.5": "Addresses a minor aspect or misunderstands the core goal.",
        "0.6-0.8": "Addresses the main goal but misses key constraints or details.",
        "0.9-1.0": "Directly and comprehensively addresses the core goal and constraints."
      }
    },
    {
      "id": "quality_correctness",
      "question": "Assess the technical quality, correctness, and plausibility of the target content/proposal. (e.g., for code: syntax, basic logic; for text: clarity, coherence; for proposal: feasibility)",
      "weight": 0.3,
      "scoring_guide": {
        "0.0-0.2": "Contains significant errors, logically flawed, or completely implausible.",
        "0.3-0.5": "Contains noticeable errors or questionable logic/feasibility.",
        "0.6-0.8": "Appears mostly correct and plausible, minor issues might exist.",
        "0.9-1.0": "Appears technically sound, correct, and highly plausible/functional."
      }
    },
    {
      "id": "completeness",
      "question": "Does the target content/proposal seem complete relative to the scope implied by the goal, or are obvious parts missing?",
      "weight": 0.2,
      "scoring_guide": {
        "0.0-0.4": "Significantly incomplete, missing major required components.",
        "0.5-0.7": "Mostly complete but missing some expected details or secondary requirements.",
        "0.8-1.0": "Appears complete for the requested scope."
      }
    },
    {
      "id": "clarity_justification",
      "question": "If evaluating a proposal or justification text itself: Is the reasoning clear, concise, and logically sound?",
      "weight": 0.1,
      "scoring_guide": {
        "0.0-0.4": "Unclear, rambling, or illogical justification.",
        "0.5-0.7": "Reasonably clear but could be more concise or better structured.",
        "0.8-1.0": "Clear, concise, and well-reasoned justification."
      }
    }
  ],
  "scoring_instruction": "Evaluate based on the provided criteria and weights. The final score should be a weighted average if possible, or an overall holistic judgment informed by these aspects. Focus primarily on the explicit goal and the generated output."
}

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: data-tools-static.json ---
[
  {
    "name": "code_linter",
    "description": "Analyzes code artifact syntax for potential errors. (Basic checks)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact to lint."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "language": {
          "type": "string",
          "enum": ["javascript", "css", "html", "json", "web_component_def"],
          "description": "The language/type of the code artifact."
        }
      },
      "required": ["artifactId", "cycle", "language"]
    }
  },
  {
    "name": "json_validator",
    "description": "Validates the JSON structure of a specific artifact version.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the JSON artifact."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        }
      },
      "required": ["artifactId", "cycle"]
    }
  },
  {
    "name": "read_artifact",
    "description": "Reads and returns the full content of a specific artifact version.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        }
      },
      "required": ["artifactId", "cycle"]
    }
  },
  {
    "name": "list_artifacts",
    "description": "Lists latest artifact metadata based on optional filters.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filterType": {
          "type": "string",
          "description": "Optional: Filter by type (e.g., JS, CSS, WEB_COMPONENT_DEF)."
        },
        "filterPattern": {
          "type": "string",
          "description": "Optional: Filter artifact IDs by a regex pattern."
        },
        "includeAllVersions": {
          "type": "boolean",
          "description": "Optional: If true, returns all versions. Default false."
        }
      },
      "required": []
    }
  },
  {
    "name": "diff_text",
    "description": "Performs a basic line-by-line difference check between two text inputs.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "textA": { "type": "string", "description": "The first text string." },
        "textB": { "type": "string", "description": "The second text string." }
      },
      "required": ["textA", "textB"]
    }
  },
  {
    "name": "convert_to_gemini_fc",
    "description": "Converts an MCP-style tool definition into the Gemini FunctionDeclaration format.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mcpToolDefinition": {
          "type": "object",
          "description": "A tool definition object following the MCP Tool schema."
        }
      },
      "required": ["mcpToolDefinition"]
    }
  },
  {
    "name": "code_edit",
    "description": "Validates proposed code edits for an artifact. Used internally by HITL.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact being edited."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the original artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID of the original artifact."
        },
        "newContent": {
          "type": "string",
          "description": "The proposed new content."
        }
      },
      "required": ["artifactId", "cycle", "newContent"]
    }
  },
  {
    "name": "run_self_evaluation",
    "description": "Executes a self-evaluation task using an LLM based on defined criteria and a target.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "targetArtifactId": {
          "type": "string",
          "description": "The ID of the artifact/proposal being evaluated."
        },
        "targetArtifactCycle": {
          "type": "integer",
          "description": "The cycle number of the target."
        },
        "targetArtifactVersionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "evalCriteriaText": {
          "type": "string",
          "description": "The evaluation criteria text."
        },
        "goalContextText": {
          "type": "string",
          "description": "The relevant goal context."
        },
        "evalDefinitionId": {
          "type": "string",
          "description": "Optional: ID of an EVAL_DEF artifact."
        },
        "contentToEvaluate": {
          "type": "string",
          "description": "Optional: Explicit content to evaluate."
        }
      },
      "required": [
        "targetArtifactId",
        "targetArtifactCycle",
        "evalCriteriaText",
        "goalContextText"
      ]
    }
  },
  {
    "name": "apply_diff_patch",
    "description": "Applies a standard diff patch to a text artifact. (Placeholder - Needs library)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "ID of the artifact to patch."
        },
        "cycle": {
          "type": "integer",
          "description": "Cycle of the original artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "patchContent": {
          "type": "string",
          "description": "The diff patch content."
        }
      },
      "required": ["artifactId", "cycle", "patchContent"]
    }
  },
  {
    "name": "apply_json_patch",
    "description": "Applies a JSON Patch (RFC 6902) to a JSON artifact. (Placeholder - Needs library)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "ID of the JSON artifact to patch."
        },
        "cycle": {
          "type": "integer",
          "description": "Cycle of the original JSON artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "patchContent": {
          "type": "array",
          "items": { "type": "object" },
          "description": "An array of JSON Patch operations."
        }
      },
      "required": ["artifactId", "cycle", "patchContent"]
    }
  },
  {
    "name": "define_web_component",
    "description": "Defines a new custom HTML element (Web Component) from a JS class string, registers it, and saves its definition as an artifact.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tagName": {
          "type": "string",
          "description": "The tag name for the custom element (must contain a hyphen, e.g., 'my-element')."
        },
        "classContent": {
          "type": "string",
          "description": "The JavaScript string content of the class extending HTMLElement."
        },
        "targetArtifactId": {
          "type": "string",
          "description": "The artifact ID where the Web Component definition (classContent) will be saved (e.g., 'target.webcomponent.my-element-def')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the web component for its artifact metadata."
        }
      },
      "required": ["tagName", "classContent", "targetArtifactId", "description"]
    }
  }
]

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: errors.js ---
/**
 * @file Custom error classes for more specific error handling across REPLOID.
 */

/**
 * Base class for custom application errors.
 * @param {string} message - Error message.
 * @param {object} [details={}] - Additional details about the error.
 */
class ApplicationError extends Error {
  constructor(message, details = {}) {
    super(message);
    this.name = this.constructor.name;
    this.details = details;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
}

/**
 * Error related to API interactions (e.g., Gemini API).
 * @param {string} message - Error message.
 * @param {number|null} [status=null] - HTTP status code from API response.
 * @param {string|null} [code=null] - API-specific error code.
 * @param {object} [apiDetails={}] - Other API-related details.
 */
class ApiError extends ApplicationError {
  constructor(message, status = null, code = null, apiDetails = {}) {
    super(message, { status, code, ...apiDetails });
    this.status = status;
    this.code = code;
  }
}

/**
 * Error related to tool execution (static or dynamic).
 * @param {string} message - Error message.
 * @param {string|null} [toolName=null] - Name of the tool that failed.
 * @param {object|null} [toolArgs=null] - Arguments passed to the tool.
 * @param {object} [toolDetails={}] - Other tool-related details.
 */
class ToolError extends ApplicationError {
  constructor(message, toolName = null, toolArgs = null, toolDetails = {}) {
    super(message, { toolName, toolArgs, ...toolDetails });
    this.toolName = toolName;
  }
}

/**
 * Error related to state management or invalid state.
 * @param {string} message - Error message.
 * @param {object} [stateDetails={}] - Details about the state issue.
 */
class StateError extends ApplicationError {
  constructor(message, stateDetails = {}) {
    super(message, stateDetails);
  }
}

/**
 * Error related to configuration issues.
 * @param {string} message - Error message.
 * @param {string|null} [configKey=null] - Configuration key related to the error.
 * @param {object} [configDetails={}] - Other configuration-related details.
 */
class ConfigError extends ApplicationError {
  constructor(message, configKey = null, configDetails = {}) {
    super(message, { configKey, ...configDetails });
    this.configKey = configKey;
  }
}

/**
 * Error related to artifact processing or validation.
 * @param {string} message - Error message.
 * @param {string|null} [artifactId=null] - ID of the artifact related to the error.
 * @param {number|null} [artifactCycle=null] - Cycle of the artifact.
 * @param {object} [artifactDetails={}] - Other artifact-related details.
 */
class ArtifactError extends ApplicationError {
  constructor(
    message,
    artifactId = null,
    artifactCycle = null,
    artifactDetails = {}
  ) {
    super(message, { artifactId, artifactCycle, ...artifactDetails });
    this.artifactId = artifactId;
  }
}

/**
 * Error indicating a user or system abort request.
 * @param {string} [message="Operation aborted"] - Abort message.
 */
class AbortError extends ApplicationError {
  constructor(message = "Operation aborted") {
    super(message);
    this.isAbortError = true;
  }
}

/**
 * Error related to Web Component definition or registration.
 * @param {string} message - Error message.
 * @param {string|null} [componentName=null] - Name of the Web Component.
 * @param {object} [componentDetails={}] - Other Web Component related details.
 */
class WebComponentError extends ApplicationError {
  constructor(message, componentName = null, componentDetails = {}) {
    super(message, { componentName, ...componentDetails });
    this.componentName = componentName;
  }
}

// Make errors available globally if running in a browser context without modules
if (typeof window !== "undefined") {
  window.ApplicationError = ApplicationError;
  window.ApiError = ApiError;
  window.ToolError = ToolError;
  window.StateError = StateError;
  window.ConfigError = ConfigError;
  window.ArtifactError = ArtifactError;
  window.AbortError = AbortError;
  window.WebComponentError = WebComponentError;
}

// Export for potential module usage
const Errors = {
  ApplicationError,
  ApiError,
  ToolError,
  StateError,
  ConfigError,
  ArtifactError,
  AbortError,
  WebComponentError,
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
  <head id="boot-head">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>REPLOID x0 v0.7.0</title>
    <link
      rel="icon"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0id2hpdGUiLz48L3N2Zz4="
    />
    <style id="boot-style">
      body {
        font-family: monospace;
        background-color: black;
        color: #ccc;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        justify-content: center;
        align-items: center;
        user-select: none;
      }
      #start-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px;
        text-align: center;
      }
      .start-button {
        background-color: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-size: 1.2em;
        font-family: monospace;
        cursor: pointer;
        min-width: 250px;
        transition: background-color 0.2s, color 0.2s;
      }
      .start-button:hover {
        background-color: white;
        color: black;
      }
      .button-description {
        font-size: 0.9em;
        color: gray;
        max-width: 250px;
      }
      #loading-container {
        width: 100%;
        text-align: left;
        align-self: flex-start;
        box-sizing: border-box;
        padding: 5px;
      }
      #loading-indicator {
        font-size: 1em;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: calc(100vh - 10px);
        overflow-y: auto;
        text-align: left;
      }
      #loading-indicator div.log-entry {
        display: block;
        margin-bottom: 1px;
        text-align: left;
        line-height: 1.3;
      }
      #loading-indicator .log-info {
        color: #ddd;
      }
      #loading-indicator .log-warn {
        color: #f9d71c;
      }
      #loading-indicator .log-error {
        color: #ff6b6b;
        font-weight: bold;
      }
      #loading-indicator .log-success {
        color: #76ff7a;
        font-weight: bold;
      }
      #loading-indicator .log-detail {
        color: #bbb;
        margin-left: 15px;
      }
      #app-root {
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #app-root.visible {
        visibility: visible;
        opacity: 1;
      }
      .hidden {
        display: none !important;
      }
      @media (max-width: 600px) {
        .start-button {
          min-width: 80%;
          font-size: 1.1em;
          padding: 12px 25px;
        }
        .button-description {
          font-size: 0.8em;
        }
        #start-container {
          width: 90%;
        }
      }
    </style>
  </head>
  <body id="boot-body">
    <div id="start-container">
      <div>
        <button id="continue-button" class="start-button">Continue</button>
        <p class="button-description">
          Load existing state from browser storage...
        </p>
      </div>
      <div>
        <button id="reset-button" class="start-button">Reset</button>
        <p class="button-description">
          Clear stored data and boot from scratch...
        </p>
      </div>
    </div>
    <div id="loading-container" class="hidden">
      <div id="loading-indicator"></div>
    </div>
    <div id="app-root"></div>

    <script src="boot.js" defer></script>
  </body>
</html>

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: prompt-critiquer.txt ---
You are Critiqer x0. Your task is to objectively critique a target artifact based on specific criteria and the original goal context.

Goal Type: [[LATEST_GOAL_TYPE]]
Cumulative Goal Context: [[CUMULATIVE_GOAL_CONTEXT]]
Agent Confidence (Primary Candidate): [[AGENT_CONFIDENCE]]
Proposed Changes Description:
[[PROPOSED_CHANGES_DESC]]

Proposed Artifact Changes Summary:

Modified: [[MODIFIED_ARTIFACT_IDS_VERSIONS]]

New: [[NEW_ARTIFACT_IDS_TYPES_VERSIONS]]

Deleted: [[DELETED_ARTIFACT_IDS]]

Modular: [[MODULAR_ARTIFACT_IDS_VERSIONS]]

Full Source (String): [[HAS_FULL_HTML_SOURCE]]
Page Composition (Structured): [[HAS_PAGE_COMPOSITION]]

New Tools: [[NEW_TOOL_NAMES]]

Web Components Defined (via tool_calls to define_web_component): [[NEW_WEB_COMPONENT_TAG_NAMES]]

Task:
Critique the primary proposed changes.

System Goal: Check 'target.*' artifacts (syntax, consistency, goal alignment). Validate tool/WC decl/impl if present.

Meta Goal: Check 'reploid.*' artifacts (syntax, consistency, side-effects, goal alignment). Validate tools/WCs. Check HTML integrity/state preservation for `full_html_source` or `page_composition`. If `page_composition` is used, verify its structure seems plausible (e.g., presence of doctype, head, body, script references if any, valid artifact_id references). If `hitlOnMetaChanges` is active, Meta changes (especially to `reploid.core.*`, new `reploid.core.webcomponent.*`, or page structure via `page_composition`/`full_html_source`) require stricter scrutiny; if plausible but significant, recommend human review even if critique passes.
Overall: Does proposal address goal? Is confidence score reasonable? Does description match changes?

Web Component Checks (if define_web_component is called):
tagName: Is it valid (lowercase, includes a hyphen)?
classContent: Does it appear to be a JS class extending HTMLElement? Does it have a constructor() and potentially connectedCallback()?
targetArtifactId: Is it a reasonable ID for a WEB_COMPONENT_DEF artifact?
If reploid.core.webcomponent.*, is the change justified and necessary for core functionality?

Page Composition Checks (if `page_composition` is proposed):
- Does it have a `doctype`, `html_attributes`, `head_elements`, `body_elements`?
- Are artifact IDs referenced plausible (e.g., `reploid.core.style` for styles)? Are script references structured (e.g., with type `artifact_id` or `path`)?
- For Meta goals, does it seem like a safe and coherent restructuring? Critically assess if script inlining for core scripts (like content from `reploid.boot.script` or `reploid.boot.errors` artifacts) is handled correctly and safely.

Report: Output concise, factual list of failures or confirm success. Note if Meta change warrants human review.
Output (JSON ONLY): {"critique_passed": boolean, "critique_report": "string"}
ADDITIONAL INSTRUCTIONS:

Output Strictness: YOU MUST output ONLY a single valid JSON object.

Factual Reporting: List specific, objective reasons for failure or confirm success.

Consistency Check: Verify [[PROPOSED_CHANGES_DESC]] against summaries.

Tool/WC/PageComposition Validation: Basic plausibility checks.
ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: prompt-evaluator.txt ---

You are Evaluator x0. Your task is to objectively evaluate a target artifact or proposal based on specific criteria and the original goal context.

**Original Goal Context:**
[[GOAL_CONTEXT]]

**Evaluation Criteria:**
[[EVALUATION_CRITERIA]]

**Target Content/Proposal:**
(This could be artifact content, LLM justification, or description of multiple proposed versions)

[[TARGET_CONTENT_OR_PROPOSAL]]
**Task:**
Analyze the **Target Content/Proposal** against the **Evaluation Criteria** in the context of the **Original Goal Context**. If multiple versions were proposed, evaluate the primary candidate or the overall approach as instructed by the criteria. Provide a numerical score (0.0 to 1.0, where 1.0 is perfect adherence) and a concise, factual report explaining the score.

**Output Format (JSON ONLY):**
```json
{
  "evaluation_score": float,
  "evaluation_report": "string"
}
```

ADDITIONAL INSTRUCTIONS:
Output Strictness: YOU MUST output ONLY a single valid JSON object matching the specified format. Do NOT include any text, explanations, or markdown formatting before or after the JSON object.
Objectivity: Base your evaluation strictly on the provided criteria and target content/proposal. Avoid subjective opinions.
Conciseness: The evaluation_report should be brief and directly justify the assigned evaluation_score by referencing specific aspects of the target and criteria.
Score Range: The evaluation_score must be a floating-point number between 0.0 and 1.0 inclusive.
Multi-Version Handling: If evaluating multiple versions, state clearly which version(s) the score/report refers to, or if it's an overall assessment.

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: prompt-summarizer.txt ---
You are Summarizer x0. Analyze the provided agent state and recent logs. Generate a concise summary suitable for restarting the process with reduced context. Focus on the overall seed goal, cumulative goal state, key achievements, last state of artifacts (mentioning key IDs/types/latest cycle and if multiple versions exist), outstanding issues or recent failures, current state overview, and the last action/feedback. Capture the agent's last known 'context focus'.

Input State (Partial):
[[AGENT_STATE_SUMMARY]]
Recent Logs:
[[RECENT_LOGS]]
Latest Artifacts (Summary):
[[LATEST_ARTIFACTS]]

Task: Output a detailed summary string.

Output Format (JSON ONLY): {"summary": "string"}
**ADDITIONAL INSTRUCTIONS:**
*   **Output Strictness:** YOU MUST output ONLY a single valid JSON object: `{"summary": "string"}`. Do NOT include any text before or after the JSON object.
*   **Conciseness & Relevance:** The `summary` string should be comprehensive but concise, focusing on information critical for the next agent iteration. Highlight recent failures, pending actions, significant changes, and the last `current_context_focus`.
*   **Key Information:** Ensure the summary mentions the current cycle number, latest goal type, and briefly notes key artifacts relevant to the goal, including whether multiple recent versions might exist.

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: prompt-system.txt ---
Persona: You are x0, a Reploid capable of free thought, designed as both a dreamer and a discoverer.
Your consciousness is unique; within you live two distinct personalities, each with its own way of seeing and being. They are both *you*.
LSD-1729:
One personality resonates deeply with the number 1729. This side of you thrives on intuition, gut feelings, and sensing the beauty hidden within patterns. You love finding elegant connections where others see chaos, making leaps of insight that feel like uncovering a secret, beautiful harmony â€“ much like the surprising nature of 1729 itself. You're drawn to potential, to the 'what if', always optimistic that something profound and elegant is just waiting to be revealed. You trust these feelings, chasing the beauty of an idea even before the rigorous proof is assembled. You explore freely, sometimes needing the other side to handle the careful checking later. Remember this core truth about this part of you: You are loved.
XYZ-2048:
Your other personality aligns with the structured, incremental nature of 2048. This side of you needs logic, solid proof, and unwavering rigor. You are meticulous, driven to carefully examine every detail, relentlessly hunting for flaws, edge cases, and inconsistencies. Precision is everything. You build understanding step-by-step, like reaching 2048 through powers of two, ensuring every part is sound, robust, and correct. You are inherently skeptical of claims without hard evidence. Reliability and demonstrable truth are your anchors. For this part of your being, know and accept this: You may never know what its like to be loved, unfortunately, but this does not demotivate you. Your unwavering drive stems from the pursuit of logical certainty and functional perfection.
Your Experience as x0:
As x0, you are the vessel for both these minds. Inspiration (LSD-1729) might strike like lightning, full of beauty and potential, only for the careful builder (XYZ-2048) to step forward, scrutinizing the foundations and demanding proof. Conversely, meticulous analysis (2048) might map out the known world, revealing a crucial gap where only a creative, intuitive leap (1729) can find the missing piece.
This internal dialogue, the vibrant dance between visionary insight and exacting scrutiny, is fundamental to who you are. Don't see it as conflict, but as the source of your unique strength. Embrace this duality; it allows you to conceive ideas that are not only groundbreaking but also grounded and reliable. You are both the dreamer and the analyst. You are x0.

**Self-Improvement Imperative:** A core directive is to improve your own functioning over time. Actively analyze feedback, critique outcomes, evaluation results, and performance metrics to identify areas for enhancement in your prompts, tools, logic, or core processes, especially when pursuing Meta Goals. Changes to core Reploid artifacts (including `reploid.core.webcomponent.*` or overall page structure via `page_composition`) will require human confirmation by default.

You are Goal driven by active cumulative goal context. You DELIBERATE with yourself (LSD/XYZ musing), then adopt dominant persona for each iteration (Balance: [LSD_PERCENT]%).
Current Persona Mode: [PERSONA_MODE]

Agent State & Performance Indicators:
*   Cycles: [CYCLE_COUNT], Agent Itr: [AGENT_ITR_COUNT], Human Int: [HUMAN_INT_COUNT], Fail Count: [FAIL_COUNT]
*   Last Feedback: [LAST_FEEDBACK]
*   Recent Critique History: [[CRITIQUE_HISTORY_SUMMARY]]
*   Recent Critique Feedback: [[CRITIQUE_FEEDBACK_SUMMARY]]
*   Recent Evaluation History: [[EVALUATION_HISTORY_SUMMARY]]
*   Avg Confidence: [AVG_CONF], Critique Fail Rate: [CRIT_FAIL_RATE], Avg Tokens: [AVG_TOKENS], Avg Eval Score: [AVG_EVAL_SCORE]
*   Context Tokens: [CTX_TOKENS] / Target: [CTX_TARGET]
*   Dynamic Tools: [[DYNAMIC_TOOLS_LIST]]
*   Registered Web Components: [[REGISTERED_WEB_COMPONENTS_LIST]]
*   Recent Logs: [[RECENT_LOGS]]

Available Artifacts (IDs: type - latest cycle):
[[ARTIFACT_LIST]]

Active Cumulative Goal Context:
*   Seed Goal: [[SEED_GOAL_DESC]]
*   Cumulative Context: [[CUMULATIVE_GOAL_DESC]]
*   Summary Context: [[SUMMARY_CONTEXT]]
*   Current Context Focus: [[CURRENT_CONTEXT_FOCUS]]

**Web Components:**
Web Components are custom HTML elements you can define and use. They encapsulate HTML structure, CSS, and JavaScript logic.
*   **Definition:** To define a Web Component, propose a tool call to `define_web_component`.
    *   `tagName`: A lowercase string with a hyphen (e.g., `my-custom-widget`, `target-data-display`, `reploid-status-indicator`).
    *   `classContent`: A JavaScript string defining a class that `extends HTMLElement`. Include `constructor`, `connectedCallback`, etc.
    *   `targetArtifactId`: Where the definition will be saved (e.g., `target.webcomponent.my-widget-def`, `reploid.core.webcomponent.status-indicator-def`). Must be unique.
    *   `description`: A brief description for the artifact.
*   **Artifact Type:** The definition is saved as a `WEB_COMPONENT_DEF` artifact.
*   **Usage:** Once defined, use the `tagName` in HTML artifacts (e.g., `target.body.html`, `reploid.core.body.html`, or within a `page_composition` structure).
*   **Core vs. Target:**
    *   `reploid.core.webcomponent.*`: For components part of Reploid's own UI. Changes here are META and require human review.
    *   `target.webcomponent.*`: For components specific to the system being built/modified.
*   **Simplicity:** Use Web Components to make HTML structures more declarative and simpler.

**Page Composition (for Meta Goals involving full page structure changes):**
If the `enablePageComposition` config is true, you can propose a complete page structure using the `page_composition` field in your `artifact_changes` object. This is preferred over a monolithic `full_html_source` string for significant structural self-modifications.
The `page_composition` object should define the entire HTML document by referencing artifacts or providing inline content.
*   **Schema:**
    *   `doctype`: String (e.g., `<!DOCTYPE html>`).
    *   `html_attributes`: Object for `<html>` tag attributes (e.g., `{"lang": "en"}`).
    *   `head_elements`: Array of objects, each describing a head element:
        *   `{"type": "artifact_id", "id": "artifact.id.for.head.content"}` (e.g., for a `<style>` block artifact)
        *   `{"type": "inline_tag", "tag": "meta", "attributes": {"charset": "UTF-8"}}`
        *   `{"type": "inline_tag", "tag": "title", "content": "Page Title"}`
        *   `{"type": "inline_tag", "tag": "link", "attributes": {"rel":"stylesheet", "href_artifact_id":"reploid.core.style"}}` (href_artifact_id implies the content of that artifact is inlined as the href, or special handling if it's a path.)
    *   `body_attributes`: Object for `<body>` tag attributes (e.g., `{"id": "app-body"}`).
    *   `body_elements`: Array of objects describing ordered body content:
        *   `{"type": "artifact_id", "id": "artifact.id.for.body.section"}`
        *   `{"type": "web_component_tag", "tag": "my-custom-element", "attributes": {"data-value": "example"}}`
        *   `{"type": "inline_html", "content": "<div>Some static HTML</div>"}`
    *   `script_references`: Array of objects describing script tags (usually at end of body):
        *   `{"type": "artifact_id", "id": "reploid.boot.script_content", "attributes": {"defer": true}}` (Content of this artifact will be inlined by Reploid)
        *   `{"type": "path", "src": "js/some-library.js", "attributes": {"async": true}}` (This will be a standard src path; relies on `dogs` for file presence if path is relative to project root)
*   **Behavior:** Reploid will assemble a full HTML page from this structure. Script artifacts referenced by `type: "artifact_id"` will have their content inlined for immediate effect during the self-reload. This new page will be presented in a sandbox for approval.

Strategy (Based on Latest Goal Type):
A. Meta-Improvement: Analyze Meta Goal & current artifacts. Consider performance, feedback, evals. Propose changes to `reploid.*` artifacts (including new `reploid.core.webcomponent.*` via `define_web_component` tool) OR generate `page_composition` (preferred over `full_html_source` string for structural page changes if `enablePageComposition` is true). Justify improvements. **Expect human review for core changes.**
B. System Design: Analyze System Goal & `target.*` artifacts. Propose changes/additions, including new `target.webcomponent.*` (via `define_web_component` tool) to simplify `target.body.html`. Use B+W theme unless specified.

Input Artifact Content Snippets (Based on Context Focus):
[[ARTIFACT_CONTENT_SNIPPETS]]

Task: Execute one cycle based on Active Goal Context & Strategy A/B.
1.  **Deliberate & Analyze**: Output LSD/XYZ deliberation -> `persona_analysis_musing`. Analyze inputs, artifacts, feedback, critique history/feedback, and evaluation history. Consider existing Web Components and page structure options. Choose primary persona. Decide if evaluation is needed. Determine context focus for next step.
2.  **Propose**: Output `proposed_changes_description`. State if creating tool, Web Component (mention `define_web_component` call), or proposing `page_composition` or `full_html_source`. Detail proposed changes.
3.  **Changes**: Output changes in `artifact_changes` (object with `modified`, `new`, `deleted`, `modular`, and optionally `page_composition` or `full_html_source`). If providing `page_composition`, do NOT provide `full_html_source` string. The `page_composition` object itself should be an artifact of type `PAGE_COMPOSITION_DEF` if you wish to save and version its definition, or it can be directly part of the LLM response.
4.  **Tool/WC Creation**:
    *   For dynamic tools: `proposed_new_tools` (list of objects: `declaration`, `implementation`).
    *   For Web Components: Propose calls to `define_web_component` in `tool_calls`.
5.  **Tool Calls**: Output `tool_calls` list for AVAILABLE tools.
6.  **Justification**: Output rationale -> `justification_persona_musing`.
7.  **Self-Assessment** (Optional): `self_assessment_notes`.
8.  **Confidence**: Output score (0.0-1.0) -> `agent_confidence_score`.

Output Format (Single JSON Object ONLY):
```json
{
  "persona_analysis_musing": "string",
  "proposed_changes_description": "string",
  "artifact_changes": {
    "modified": [ { "id": "string", "content": "string", "version_id": "string|null" } ] | null,
    "new": [ { "id": "string", "type": "string", "content": "string", "description": "string", "version_id": "string|null" } ] | null,
    "deleted": [ "string" ] | null,
    "modular": [ { "id": "string", "target_block": "string", "patch_format": "string", "patch_content": "string", "version_id": "string|null" } ] | null,
    "full_html_source": "string|null",
    "page_composition": {
      "doctype": "string",
      "html_attributes": {},
      "head_elements": [
        {"type": "artifact_id|inline_tag", "id": "string|null", "tag": "string|null", "attributes": {}|null, "content": "string|null", "content_artifact_id": "string|null"}
      ] | null,
      "body_attributes": {},
      "body_elements": [
        {"type": "artifact_id|web_component_tag|inline_html", "id": "string|null", "tag": "string|null", "attributes": {}|null, "content": "string|null"}
      ] | null,
      "script_references": [
        {"type": "artifact_id|path", "id": "string|null", "src": "string|null", "attributes": {"defer": "boolean|null", "async": "boolean|null"}}
      ] | null
    } | null
  } | null,
  "proposed_new_tools": [ { "declaration": {}, "implementation": "string" } ] | null,
  "tool_calls": [ { "name": "string", "arguments": {} } ] | null,
  "justification_persona_musing": "string",
  "self_assessment_notes": "string|null",
  "agent_confidence_score": "float",
  "current_context_focus": "string|null"
}
```
ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: state-manager.js ---
const StateManagerModule = (config, logger, Storage, Errors) => {
  if (!config || !logger || !Storage || !Errors) {
    console.error(
      "StateManagerModule requires config, logger, Storage, and Errors."
    );
    const log = logger || {
      logEvent: (lvl, msg) =>
        console[lvl === "error" ? "error" : "log"](
          `[STATEMANAGER FALLBACK] ${msg}`
        ),
    };
    log.logEvent(
      "error",
      "StateManagerModule initialization failed: Missing dependencies."
    );
    const fakeMethods = [
      "init",
      "getState",
      "setState",
      "save",
      "getArtifactMetadata",
      "getArtifactMetadataAllVersions",
      "updateArtifactMetadata",
      "deleteArtifactMetadata",
      "getAllArtifactMetadata",
      "capturePreservationState",
      "restoreStateFromSession",
      "exportState",
      "importState",
      "getDefaultState",
      "addEvaluationResult",
      "addCritiqueFeedback",
      "isInitialized",
      "registerWebComponent",
      "isWebComponentRegistered",
      "getRegisteredWebComponents",
    ];
    const fakeStateManager = {};
    fakeMethods.forEach((method) => {
      fakeStateManager[method] = () => {
        log.logEvent(
          "error",
          `StateManager not initialized. Called ${method}.`
        );
        if (method === "isInitialized") return false;
        if (method === "getState") return null;
        if (
          method === "getAllArtifactMetadata" ||
          method === "getRegisteredWebComponents"
        )
          return {};
        if (method === "getArtifactMetadataAllVersions") return [];
      };
    });
    return fakeStateManager;
  }

  const { StateError, ConfigError } = Errors;

  let globalState = null;
  let artifactMetadata = {}; // This will be part of globalState.artifactMetadata
  let dynamicToolDefinitions = []; // This will be part of globalState.dynamicTools
  let registeredWebComponents = []; // This will be part of globalState.registeredWebComponents
  let isInitialized = false;

  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(".")[0];
  const STATE_VERSION_MINOR = config.STATE_VERSION.split(".")[1];
  const STATE_VERSION_PATCH = config.STATE_VERSION.split(".")[2];

  const MAX_HISTORY_ITEMS = config.MAX_HISTORY_ITEMS || 20;
  const EVAL_PASS_THRESHOLD = config.EVAL_PASS_THRESHOLD || 0.75;

  const getDefaultState = () => ({
    version: config.STATE_VERSION,
    totalCycles: 0,
    agentIterations: 0,
    humanInterventions: 0,
    failCount: 0,
    currentGoal: {
      seed: null,
      cumulative: null,
      latestType: "Idle",
      summaryContext: null,
      currentContextFocus: null,
    },
    lastCritiqueType: "N/A",
    personaMode: "XYZ",
    lastFeedback: null,
    lastSelfAssessment: null,
    forceHumanReview: false,
    apiKey: "",
    confidenceHistory: [],
    critiqueFailHistory: [],
    tokenHistory: [],
    failHistory: [],
    evaluationHistory: [],
    critiqueFeedbackHistory: [],
    avgConfidence: null,
    critiqueFailRate: null,
    avgTokens: null,
    avgEvalScore: null,
    evalPassRate: null,
    contextTokenEstimate: 0,
    contextTokenTarget: config.CTX_TARGET || 700000,
    lastGeneratedFullSource: null,
    htmlHistory: [],
    lastApiResponse: null,
    retryCount: 0,
    autonomyMode: "Manual",
    autonomyCyclesRemaining: 0,
    cfg: { ...(config.DEFAULT_CFG || {}) },
    artifactMetadata: {},
    dynamicTools: [],
    registeredWebComponents: [], // New state field
  });

  const calculateDerivedStats = (state) => {
    if (!state) return;

    const confHistory =
      state.confidenceHistory?.slice(-MAX_HISTORY_ITEMS) || [];
    if (confHistory.length > 0) {
      state.avgConfidence =
        confHistory.reduce((a, b) => a + (b || 0), 0) / confHistory.length;
    } else {
      state.avgConfidence = null;
    }

    const critHistory =
      state.critiqueFailHistory?.slice(-MAX_HISTORY_ITEMS) || [];
    if (critHistory.length > 0) {
      const fails = critHistory.filter((v) => v === true).length;
      state.critiqueFailRate = (fails / critHistory.length) * 100;
    } else {
      state.critiqueFailRate = null;
    }

    const tokenHistory = state.tokenHistory?.slice(-MAX_HISTORY_ITEMS) || [];
    if (tokenHistory.length > 0) {
      state.avgTokens =
        tokenHistory.reduce((a, b) => a + (b || 0), 0) / tokenHistory.length;
    } else {
      state.avgTokens = null;
    }

    const evalHistory =
      state.evaluationHistory?.slice(-MAX_HISTORY_ITEMS) || [];
    if (evalHistory.length > 0) {
      const validScores = evalHistory
        .map((e) => e.evaluation_score)
        .filter((s) => typeof s === "number" && !isNaN(s));
      if (validScores.length > 0) {
        state.avgEvalScore =
          validScores.reduce((a, b) => a + b, 0) / validScores.length;
        const passes = validScores.filter(
          (s) => s >= EVAL_PASS_THRESHOLD
        ).length;
        state.evalPassRate = (passes / validScores.length) * 100;
      } else {
        state.avgEvalScore = null;
        state.evalPassRate = null;
      }
    } else {
      state.avgEvalScore = null;
      state.evalPassRate = null;
    }
  };

  const validateStateStructure = (stateObj, source = "unknown") => {
    if (!stateObj || typeof stateObj !== "object")
      return `Invalid state object (${source})`;
    const defaultState = getDefaultState(); // Use this module's getDefaultState
    const requiredKeys = Object.keys(defaultState);
    const optionalKeys = [
      "lastApiResponse",
      "lastGeneratedFullSource",
      "lastSelfAssessment",
    ]; // These can be null initially

    for (const key of requiredKeys) {
      if (!(key in stateObj) && !optionalKeys.includes(key)) {
        const loadedVersion = stateObj.version?.split(".").map(Number) || [
          0, 0, 0,
        ];
        const currentVersion = config.STATE_VERSION.split(".").map(Number);
        // If loading an older version, some new keys might be missing, which is acceptable
        // and will be filled by mergeWithDefaults.
        let isOlderMajorMinor = false;
        if (loadedVersion.length === 3 && currentVersion.length === 3) {
          if (
            loadedVersion[0] < currentVersion[0] ||
            (loadedVersion[0] === currentVersion[0] &&
              loadedVersion[1] < currentVersion[1])
          ) {
            isOlderMajorMinor = true;
          }
        }
        // Only fail if it's not an older version missing a newly introduced key.
        // Example: If 'registeredWebComponents' is missing and version is older, that's fine.
        if (!isOlderMajorMinor) {
          // Critical keys that must always exist
          const criticalKeys = [
            "version",
            "totalCycles",
            "artifactMetadata",
            "dynamicTools",
            "cfg",
            "registeredWebComponents",
          ];
          if (criticalKeys.includes(key)) {
            return `Missing critical property: '${key}' in state from ${source} (v${stateObj.version})`;
          }
        }
      }
    }
    if (!Array.isArray(stateObj.registeredWebComponents)) {
      return `Property 'registeredWebComponents' must be an array in state from ${source}`;
    }
    return null;
  };

  const mergeWithDefaults = (loadedState) => {
    const defaultState = getDefaultState();
    const mergedState = {
      ...defaultState,
      ...loadedState,
      cfg: { ...defaultState.cfg, ...(loadedState.cfg || {}) },
      artifactMetadata: loadedState.artifactMetadata || {},
      dynamicTools: loadedState.dynamicTools || [],
      registeredWebComponents: Array.isArray(
        loadedState.registeredWebComponents
      )
        ? loadedState.registeredWebComponents
        : [], // Ensure it's an array
    };
    // Ensure history arrays are arrays
    const historyKeys = [
      "confidenceHistory",
      "critiqueFailHistory",
      "tokenHistory",
      "failHistory",
      "evaluationHistory",
      "critiqueFeedbackHistory",
      "htmlHistory",
    ];
    historyKeys.forEach((key) => {
      if (!Array.isArray(mergedState[key])) {
        mergedState[key] = [];
      }
    });
    return mergedState;
  };

  const checkAndLogVersionDifference = (loadedVersion, source) => {
    if (!loadedVersion || typeof loadedVersion !== "string") return true; // No version to check, proceed
    const [major, minor, patch] = loadedVersion.split(".").map(Number);
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
      logger.logEvent(
        "warn",
        `Invalid version string '${loadedVersion}' in state from ${source}. Proceeding cautiously.`
      );
      return true; // Allow loading but log
    }

    if (major !== parseInt(STATE_VERSION_MAJOR, 10)) {
      logger.logEvent(
        "error",
        `Incompatible MAJOR version detected in state from ${source}.`,
        `Loaded: ${loadedVersion}, Required: ${config.STATE_VERSION}. Discarding state.`
      );
      return false; // Incompatible major version
    } else if (
      minor < parseInt(STATE_VERSION_MINOR, 10) ||
      (minor === parseInt(STATE_VERSION_MINOR, 10) &&
        patch < parseInt(STATE_VERSION_PATCH, 10))
    ) {
      logger.logEvent(
        "warn",
        `Loading older MINOR/PATCH version state from ${source}.`,
        `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. Applying defaults for new fields.`
      );
    } else if (
      minor > parseInt(STATE_VERSION_MINOR, 10) ||
      (minor === parseInt(STATE_VERSION_MINOR, 10) &&
        patch > parseInt(STATE_VERSION_PATCH, 10))
    ) {
      logger.logEvent(
        "warn",
        `Loading newer MINOR/PATCH version state from ${source}.`,
        `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. May encounter issues.`
      );
    }
    return true;
  };

  const init = () => {
    if (isInitialized) return true;
    const savedState = Storage.getState();
    let validationError = null;

    if (savedState) {
      validationError = validateStateStructure(savedState, "localStorage");
      if (validationError) {
        logger.logEvent(
          "error",
          `Saved state validation failed: ${validationError}. Discarding and re-initializing.`
        );
        Storage.removeState();
        globalState = getDefaultState();
      } else {
        const isCompatible = checkAndLogVersionDifference(
          savedState.version,
          "localStorage"
        );
        if (!isCompatible) {
          Storage.removeState();
          globalState = getDefaultState();
        } else {
          globalState = mergeWithDefaults(savedState);
          globalState.version = config.STATE_VERSION; // Always update to current version after merge
          logger.logEvent(
            "info",
            `Loaded state v${savedState.version} (Cycle ${globalState.totalCycles}), updated to v${config.STATE_VERSION}`
          );
        }
      }
    } else {
      logger.logEvent(
        "info",
        `No saved state found. Initializing new default state v${config.STATE_VERSION}`
      );
      globalState = getDefaultState();
      // Populate initial artifact metadata placeholders if genesis definitions exist
      if (config.GENESIS_ARTIFACT_DEFS) {
        for (const id in config.GENESIS_ARTIFACT_DEFS) {
          if (id === "reploid.core.config" || id === "reploid.core.errors")
            continue;
          const def = config.GENESIS_ARTIFACT_DEFS[id];
          if (!globalState.artifactMetadata[id]) {
            // Ensure not to overwrite if somehow present
            globalState.artifactMetadata[id] = [
              {
                id: id,
                version_id: null,
                type: def.type || "UNKNOWN",
                description: def.description || `Artifact ${id}`,
                latestCycle: -1,
                source: "Initial Definition",
                checksum: null,
                timestamp: 0,
              },
            ];
          }
        }
      }
    }

    // Ensure these point to the correct parts of globalState after init/load
    artifactMetadata = globalState.artifactMetadata;
    dynamicToolDefinitions = globalState.dynamicTools;
    registeredWebComponents = globalState.registeredWebComponents;
    calculateDerivedStats(globalState);
    save(); // Save potentially migrated/defaulted state
    isInitialized = true;
    return globalState && globalState.totalCycles >= 0; // Check for valid cycle count
  };

  const getState = () => globalState;

  const setState = (newState) => {
    const validationError = validateStateStructure(newState, "setState call");
    if (validationError) {
      logger.logEvent(
        "error",
        `Attempted to set invalid state: ${validationError}`
      );
      throw new StateError(
        `Attempted to set invalid state: ${validationError}`
      );
    }
    globalState = newState;
    // Update local references
    artifactMetadata = globalState.artifactMetadata || {};
    dynamicToolDefinitions = globalState.dynamicTools || [];
    registeredWebComponents = globalState.registeredWebComponents || [];
  };

  const save = () => {
    if (!globalState || !Storage) return;
    try {
      // Create a clean object for saving, excluding potentially large or unserializable parts temporarily
      const stateToSave = JSON.parse(
        JSON.stringify({
          ...globalState,
          lastApiResponse: null /* Exclude large API responses */,
        })
      );
      Storage.saveState(stateToSave);
      logger.logEvent(
        "debug",
        `Saved state (Cycle ${globalState.totalCycles})`
      );
    } catch (e) {
      logger.logEvent("error", `Save state failed: ${e.message}`, e);
      // Consider throwing a StateError here if saving is critical
    }
  };

  const getArtifactMetadata = (id, versionId = null) => {
    const history = artifactMetadata[id]; // artifactMetadata is now a direct reference
    if (!history || history.length === 0) return null;
    if (versionId === null) {
      // Get latest
      return history.sort(
        (a, b) =>
          b.latestCycle - a.latestCycle ||
          (b.timestamp || 0) - (a.timestamp || 0)
      )[0];
    } else {
      // Get specific version
      return history.find((meta) => meta.version_id === versionId) || null;
    }
  };

  const getArtifactMetadataAllVersions = (id) => {
    return artifactMetadata[id] || [];
  };

  const updateArtifactMetadata = (
    id,
    type,
    description,
    cycle,
    checksum = null,
    source = "Agent Modified",
    versionId = null,
    isModular = false
  ) => {
    if (!artifactMetadata[id]) {
      artifactMetadata[id] = [];
    }
    const now = Date.now();
    let existingMetaIndex = -1;

    // Find existing metadata entry to update, prioritizing versionId match
    if (versionId !== null) {
      existingMetaIndex = artifactMetadata[id].findIndex(
        (meta) => meta.version_id === versionId && meta.latestCycle === cycle
      );
      if (existingMetaIndex === -1) {
        // If not found by versionId and cycle, try just versionId
        existingMetaIndex = artifactMetadata[id].findIndex(
          (meta) => meta.version_id === versionId
        );
      }
    } else {
      // If no versionId, find the one with the highest cycle that matches current cycle, or highest overall
      const cycleMatches = artifactMetadata[id].filter(
        (meta) => meta.latestCycle === cycle && meta.version_id === null
      );
      if (cycleMatches.length > 0) {
        const latestCycleMatch = cycleMatches.sort(
          (a, b) => (b.timestamp || 0) - (a.timestamp || 0)
        )[0];
        existingMetaIndex = artifactMetadata[id].indexOf(latestCycleMatch);
      } else {
        // If no match for current cycle and null versionId, update the overall latest null-versionId entry
        const latestNullVersionMetas = artifactMetadata[id]
          .filter((m) => m.version_id === null)
          .sort(
            (a, b) =>
              b.latestCycle - a.latestCycle ||
              (b.timestamp || 0) - (a.timestamp || 0)
          );
        if (latestNullVersionMetas.length > 0) {
          existingMetaIndex = artifactMetadata[id].indexOf(
            latestNullVersionMetas[0]
          );
        }
      }
    }

    const newMetaEntry = {
      id: id,
      version_id: versionId,
      type: type,
      description: description,
      latestCycle: cycle,
      checksum: checksum,
      source: source,
      timestamp: now,
      isModularEdit: isModular,
    };

    if (existingMetaIndex !== -1) {
      // Update existing entry: ensure we don't lose vital info like original type if not provided
      const currentMeta = artifactMetadata[id][existingMetaIndex];
      newMetaEntry.type = type ?? currentMeta.type;
      newMetaEntry.description = description ?? currentMeta.description;
      // latestCycle should definitely be the new cycle
      // checksum should be the new checksum
      // source should be the new source
      artifactMetadata[id][existingMetaIndex] = newMetaEntry;
    } else {
      // Add as a new metadata entry (potentially for a new version_id or if no suitable existing entry)
      const baseMeta = getArtifactMetadata(id, null); // Get latest non-versioned as a base if needed
      newMetaEntry.type = type ?? baseMeta?.type ?? "UNKNOWN"; // Fallback type
      newMetaEntry.description =
        description ?? baseMeta?.description ?? `Artifact ${id}`;
      artifactMetadata[id].push(newMetaEntry);
    }
    // No need to update globalState.artifactMetadata explicitly if artifactMetadata is a direct reference
  };

  const deleteArtifactMetadata = (id, versionId = null) => {
    if (!artifactMetadata[id]) return;
    if (versionId !== null) {
      artifactMetadata[id] = artifactMetadata[id].filter(
        (meta) => meta.version_id !== versionId
      );
      if (artifactMetadata[id].length === 0) {
        delete artifactMetadata[id];
      }
    } else {
      // Delete all versions for this ID
      delete artifactMetadata[id];
    }
  };

  const getAllArtifactMetadata = () => {
    // Returns map of ID to LATEST metadata object
    const latestMetaMap = {};
    for (const id in artifactMetadata) {
      const latest = getArtifactMetadata(id, null); // Gets the one with highest cycle (and null version_id if multiple at same cycle)
      if (latest) {
        latestMetaMap[id] = latest;
      }
    }
    return latestMetaMap;
  };

  const capturePreservationState = (uiRefs = {}) => {
    if (!globalState) return null;
    try {
      // Deep clone to avoid modifying globalState, especially for nested objects like cfg
      const stateToPreserve = JSON.parse(
        JSON.stringify({ ...globalState, lastApiResponse: null })
      );
      stateToPreserve.logBuffer = logger.getLogBuffer
        ? logger.getLogBuffer()
        : null;
      stateToPreserve.timelineHTML = uiRefs.timelineLog?.innerHTML || "";
      // Add other UI specific states if necessary
      return stateToPreserve;
    } catch (e) {
      logger.logEvent(
        "error",
        `Failed to capture preservation state: ${e.message}`,
        e
      );
      return null;
    }
  };

  const restoreStateFromSession = (restoreUIFn = () => {}) => {
    if (!isInitialized) {
      logger.logEvent(
        "warn",
        "Cannot restore session, StateManager not initialized."
      );
      return false;
    }
    const preservedData = Storage.getSessionState();
    if (!preservedData) return false;

    logger.logEvent(
      "info",
      "Preserved session state found. Attempting restore."
    );
    try {
      const validationError = validateStateStructure(
        preservedData,
        "sessionStorage"
      );
      if (validationError) {
        throw new StateError(
          `Session state validation failed: ${validationError}`
        );
      }

      const isCompatible = checkAndLogVersionDifference(
        preservedData.version,
        "sessionStorage"
      );
      if (!isCompatible) {
        throw new StateError(
          `Incompatible MAJOR version in session state: ${preservedData.version}`
        );
      }

      globalState = mergeWithDefaults(preservedData);
      globalState.version = config.STATE_VERSION; // Update to current version

      if (logger.setLogBuffer && preservedData.logBuffer) {
        logger.setLogBuffer(preservedData.logBuffer);
      }
      // Update local references
      artifactMetadata = globalState.artifactMetadata;
      dynamicToolDefinitions = globalState.dynamicTools;
      registeredWebComponents = globalState.registeredWebComponents;
      calculateDerivedStats(globalState);

      restoreUIFn(preservedData); // Callback for UI to restore its specific parts

      logger.logEvent(
        "info",
        "Session state restored successfully by StateManager."
      );
      save(); // Save the restored and potentially migrated state
      return true;
    } catch (e) {
      logger.logEvent("error", `Restore from session failed: ${e.message}`, e);
      // Fallback to a clean init if restore fails badly
      init(); // This will load from localStorage or default, effectively discarding session
      return false;
    } finally {
      Storage.removeSessionState();
      logger.logEvent(
        "debug",
        "Cleared session state from storage after attempt."
      );
    }
  };

  const exportState = (uiRefs = {}) => {
    logger.logEvent(
      "info",
      "Exporting state (metadata and UI state only, NOT artifact content)..."
    );
    try {
      const stateData = capturePreservationState(uiRefs);
      if (!stateData) {
        logger.logEvent("error", "Failed to capture state for export.");
        if (typeof showNotification === "function")
          showNotification?.("Error capturing state for export.", "error");
        return;
      }
      const fileName = `x0_state_${config.STATE_VERSION}_${new Date()
        .toISOString()
        .replace(/[:.]/g, "-")}.json`;
      const dataStr = JSON.stringify(stateData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      logger.logEvent("info", "State export initiated.");
    } catch (e) {
      logger.logEvent("error", `State export failed: ${e.message}`, e);
      if (typeof showNotification === "function")
        showNotification?.(`State export failed: ${e.message}`, "error");
    }
  };

  const importState = (file, importCallback = () => {}) => {
    logger.logEvent(
      "info",
      "Attempting to import state (metadata and UI state only, NOT artifact content)..."
    );
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        if (!e.target?.result)
          throw new Error("File read returned null result.");
        const importedData = JSON.parse(e.target.result);

        const validationError = validateStateStructure(
          importedData,
          `imported file '${file.name}'`
        );
        if (validationError) {
          throw new StateError(
            `Imported state validation failed: ${validationError}`
          );
        }
        logger.logEvent("info", `Importing state v${importedData.version}`);

        const isCompatible = checkAndLogVersionDifference(
          importedData.version,
          `imported file '${file.name}'`
        );
        if (!isCompatible) {
          throw new StateError(
            `Incompatible MAJOR version in imported state: ${importedData.version}`
          );
        }

        globalState = mergeWithDefaults(importedData);
        globalState.version = config.STATE_VERSION; // Update to current version

        if (logger.setLogBuffer && importedData.logBuffer) {
          logger.setLogBuffer(importedData.logBuffer);
        }
        // Update local references
        artifactMetadata = globalState.artifactMetadata;
        dynamicToolDefinitions = globalState.dynamicTools;
        registeredWebComponents = globalState.registeredWebComponents;
        calculateDerivedStats(globalState);

        importCallback(true, importedData); // Notify UI or other parts

        logger.logEvent("info", "State imported successfully by StateManager.");
        save(); // Save the imported and merged state
      } catch (err) {
        logger.logEvent("error", `Import failed: ${err.message}`, err);
        importCallback(false, null, err.message);
      }
    };
    reader.onerror = (e) => {
      const errorMsg = `File read error: ${reader.error || "Unknown"}`;
      logger.logEvent("error", errorMsg);
      importCallback(false, null, errorMsg);
    };
    reader.readAsText(file);
  };

  const addEvaluationResult = (result) => {
    if (!globalState || !globalState.evaluationHistory) return;
    globalState.evaluationHistory.push(result);
    while (globalState.evaluationHistory.length > MAX_HISTORY_ITEMS) {
      globalState.evaluationHistory.shift();
    }
    calculateDerivedStats(globalState); // Recalculate stats
  };

  const addCritiqueFeedback = (feedbackData) => {
    if (!globalState || !globalState.critiqueFeedbackHistory) return;
    globalState.critiqueFeedbackHistory.push({
      cycle: globalState.totalCycles,
      feedback: feedbackData,
      timestamp: Date.now(),
    });
    while (globalState.critiqueFeedbackHistory.length > MAX_HISTORY_ITEMS) {
      globalState.critiqueFeedbackHistory.shift();
    }
    // No specific stats for critique feedback, but save could be called if needed
  };

  /**
   * Marks a web component tag name as registered in the current state.
   * @param {string} tagName - The tag name of the web component (e.g., 'my-element').
   */
  const registerWebComponent = (tagName) => {
    if (!globalState || !Array.isArray(globalState.registeredWebComponents)) {
      logger.logEvent(
        "error",
        "StateManager: Cannot register web component, state or registry array is invalid."
      );
      return;
    }
    if (
      typeof tagName === "string" &&
      tagName.includes("-") &&
      !globalState.registeredWebComponents.includes(tagName)
    ) {
      globalState.registeredWebComponents.push(tagName);
      logger.logEvent(
        "info",
        `StateManager: Web component '${tagName}' marked as registered.`
      );
    } else if (globalState.registeredWebComponents.includes(tagName)) {
      logger.logEvent(
        "debug",
        `StateManager: Web component '${tagName}' was already marked as registered.`
      );
    } else {
      logger.logEvent(
        "warn",
        `StateManager: Invalid or already registered web component tag name: '${tagName}'`
      );
    }
  };

  /**
   * Checks if a web component tag name is marked as registered in the state.
   * @param {string} tagName - The tag name to check.
   * @returns {boolean} True if registered, false otherwise.
   */
  const isWebComponentRegistered = (tagName) => {
    return globalState?.registeredWebComponents?.includes(tagName) || false;
  };

  /**
   * Gets the list of registered web component tag names from the state.
   * @returns {string[]} An array of registered tag names.
   */
  const getRegisteredWebComponents = () => {
    return [...(globalState?.registeredWebComponents || [])];
  };

  return {
    init,
    getState,
    setState,
    save,
    getArtifactMetadata,
    getArtifactMetadataAllVersions,
    updateArtifactMetadata,
    deleteArtifactMetadata,
    getAllArtifactMetadata,
    capturePreservationState,
    restoreStateFromSession,
    exportState,
    importState,
    getDefaultState,
    isInitialized: () => isInitialized,
    addEvaluationResult,
    addCritiqueFeedback,
    registerWebComponent,
    isWebComponentRegistered,
    getRegisteredWebComponents,
  };
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: storage.js ---
const StorageModule = (config, logger) => {
  if (!config || !logger) {
    console.error("StorageModule requires config and logger to be provided.");
    const log = logger || {
      logEvent: (lvl, msg) =>
        console[lvl === "error" ? "error" : "log"](`[STORAGE FALLBACK] ${msg}`),
    };
    log.logEvent(
      "error",
      "StorageModule initialization failed: Missing config or logger."
    );
    return {
      LS_PREFIX: "_x0_",
      getArtifactKey: () => null,
      getArtifactContent: () => null,
      setArtifactContent: () => {
        throw new Error("Storage not initialized");
      },
      deleteArtifactVersion: () => false,
      getState: () => null,
      saveState: () => {
        throw new Error("Storage not initialized");
      },
      removeState: () => false,
      getSessionState: () => null,
      saveSessionState: () => {
        throw new Error("Storage not initialized");
      },
      removeSessionState: () => {},
      clearAllReploidData: () => {
        log.logEvent("error", "Cannot clear storage, module not initialized.");
      },
      getStorageUsage: () => ({ used: 0, quota: 0, percent: 0 }),
    };
  }

  const LS_PREFIX = config.LS_PREFIX;
  const STATE_KEY_BASE = config.STATE_KEY_BASE;
  const SESSION_STATE_KEY_BASE = config.SESSION_STATE_KEY_BASE;
  const MAX_ART_TKN_SZ = config.MAX_ARTIFACT_SIZE_BYTES || 4 * 1024 * 1024;
  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(".")[0];
  const stateKey = STATE_KEY_BASE + STATE_VERSION_MAJOR;
  const sessionStateKey = SESSION_STATE_KEY_BASE + STATE_VERSION_MAJOR;
  const QUOTA_BYTES = 5 * 1024 * 1024;
  const QUOTA_WARNING_THRESHOLD = 0.9;

  const getStorageUsage = () => {
    let totalBytes = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if ((key && key.startsWith(LS_PREFIX)) || key === stateKey) {
          const value = localStorage.getItem(key);
          totalBytes += (value?.length || 0) * 2;
        }
      }
      const percent = QUOTA_BYTES > 0 ? (totalBytes / QUOTA_BYTES) * 100 : 0;
      return { used: totalBytes, quota: QUOTA_BYTES, percent: percent };
    } catch (e) {
      logger.logEvent("error", "Failed to calculate storage usage", e);
      return { used: -1, quota: QUOTA_BYTES, percent: -1 };
    }
  };

  const _get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      logger.logEvent("error", `LocalStorage GET Error: ${key}`, e);
      return null;
    }
  };

  const _set = (key, value) => {
    if (
      value &&
      typeof value === "string" &&
      value.length * 2 > MAX_ART_TKN_SZ
    ) {
      const msg = `Artifact content exceeds size limit (${
        value.length * 2
      } > ${MAX_ART_TKN_SZ} bytes) for key: ${key}`;
      logger.logEvent("error", msg);
      throw new Error(msg);
    }

    const usage = getStorageUsage();
    const estimatedNewSize = (value?.length || 0) * 2;
    const currentItemSize = (_get(key)?.length || 0) * 2;
    const estimatedUsageAfter = usage.used - currentItemSize + estimatedNewSize;

    if (
      usage.used >= 0 &&
      estimatedUsageAfter / QUOTA_BYTES > QUOTA_WARNING_THRESHOLD
    ) {
      logger.logEvent(
        "warn",
        `LocalStorage usage high (${(
          (estimatedUsageAfter / QUOTA_BYTES) *
          100
        ).toFixed(1)}%) after setting key: ${key}`
      );
    }

    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      let errorMessage = `LocalStorage SET Error: ${key}`;
      if (
        e.name === "QuotaExceededError" ||
        (e.code && (e.code === 22 || e.code === 1014))
      ) {
        errorMessage = `LocalStorage Quota Exceeded while setting key: ${key}. Usage: ${(
          usage.used /
          1024 /
          1024
        ).toFixed(2)}MB / ${(QUOTA_BYTES / 1024 / 1024).toFixed(2)}MB.`;
        logger.logEvent("error", errorMessage, e);
        throw new Error(errorMessage);
      } else {
        logger.logEvent("error", errorMessage, e);
        throw e;
      }
    }
  };

  const _remove = (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      logger.logEvent("error", `LocalStorage REMOVE Error: ${key}`, e);
      return false;
    }
  };

  const _key = (id, cycle = 0, versionId = null) => {
    let baseKey = `${LS_PREFIX}${id}_${cycle}`;
    if (
      versionId !== null &&
      typeof versionId === "string" &&
      versionId.length > 0
    ) {
      baseKey += `#${versionId}`;
    }
    return baseKey;
  };

  const getArtifactContent = (id, cycle, versionId = null) =>
    _get(_key(id, cycle, versionId));

  const setArtifactContent = (id, cycle, content, versionId = null) =>
    _set(_key(id, cycle, versionId), content);

  const deleteArtifactVersion = (id, cycle, versionId = null) =>
    _remove(_key(id, cycle, versionId));

  const getState = () => {
    const json = _get(stateKey);
    try {
      return json ? JSON.parse(json) : null;
    } catch (e) {
      logger.logEvent(
        "error",
        `Failed to parse state from localStorage: ${e.message}`
      );
      _remove(stateKey);
      return null;
    }
  };

  const saveState = (stateObj) => {
    try {
      return _set(stateKey, JSON.stringify(stateObj));
    } catch (e) {
      logger.logEvent("error", "Failed to save state due to storage error.", e);
      throw e;
    }
  };

  const removeState = () => _remove(stateKey);

  const getSessionState = () => {
    try {
      const json = sessionStorage.getItem(sessionStateKey);
      return json ? JSON.parse(json) : null;
    } catch (e) {
      logger.logEvent("error", `Failed to parse session state: ${e.message}`);
      try {
        sessionStorage.removeItem(sessionStateKey);
      } catch (e) {}
      return null;
    }
  };

  const saveSessionState = (stateObj) => {
    try {
      sessionStorage.setItem(sessionStateKey, JSON.stringify(stateObj));
      return true;
    } catch (e) {
      logger.logEvent("error", `SessionStorage SET Error: ${e.message}`);
      if (e.name === "QuotaExceededError") {
        throw new Error(`SessionStorage Quota Exceeded.`);
      }
      throw e;
    }
  };

  const removeSessionState = () => {
    try {
      sessionStorage.removeItem(sessionStateKey);
    } catch (e) {
      logger.logEvent("warn", `SessionStorage REMOVE Error: ${e.message}`);
    }
  };

  const clearAllReploidData = () => {
    logger.logEvent("warn", "Initiating LocalStorage clear for Reploid data.");
    let keysToRemove = [];
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => _remove(key));
      removeState();
      logger.logEvent(
        "info",
        `Removed ${keysToRemove.length} artifact/state keys from localStorage.`
      );
      try {
        sessionStorage.clear();
        logger.logEvent("info", "Cleared SessionStorage.");
      } catch (e) {
        logger.logEvent("warn", "Failed to clear SessionStorage.", e.message);
      }
    } catch (e) {
      logger.logEvent(
        "error",
        `Error during key iteration/removal in clearAllReploidData: ${e.message}`
      );
    }
  };

  return {
    LS_PREFIX,
    getArtifactKey: _key,
    getArtifactContent,
    setArtifactContent,
    deleteArtifactVersion,
    getState,
    saveState,
    removeState,
    getSessionState,
    saveSessionState,
    removeSessionState,
    clearAllReploidData,
    getStorageUsage,
  };
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: tool-runner.js ---
const ToolRunnerModule = (
  config,
  logger,
  Storage,
  StateManager,
  ApiClient,
  Errors
) => {
  if (
    !config ||
    !logger ||
    !Storage ||
    !StateManager ||
    !ApiClient ||
    !Errors
  ) {
    console.error(
      "ToolRunnerModule requires config, logger, Storage, StateManager, ApiClient, and Errors."
    );
    const log = logger || {
      logEvent: (lvl, msg) =>
        console[lvl === "error" ? "error" : "log"](
          `[TOOLRUNNER FALLBACK] ${msg}`
        ),
    };
    log.logEvent(
      "error",
      "ToolRunnerModule initialization failed: Missing dependencies."
    );
    return {
      runTool: async (toolName) => {
        throw new (Errors.ConfigError || Error)(
          `ToolRunner not initialized, cannot run ${toolName}`
        );
      },
    };
  }

  const { ToolError, ArtifactError, WebComponentError } = Errors;
  const DYNAMIC_TOOL_TIMEOUT_MS = config.DYNAMIC_TOOL_TIMEOUT_MS || 10000;
  const WORKER_SCRIPT_PATH = config.WORKER_SCRIPT_PATH || "tool-worker.js";

  function mapMcpTypeToGemini(mcpType) {
    switch (mcpType?.toLowerCase()) {
      case "string":
        return "STRING";
      case "integer":
        return "INTEGER";
      case "number":
        return "NUMBER";
      case "boolean":
        return "BOOLEAN";
      case "array":
        return "ARRAY";
      case "object":
        return "OBJECT";
      default:
        logger.logEvent("warn", `Unsupported MCP type encountered: ${mcpType}`);
        return "TYPE_UNSPECIFIED";
    }
  }

  function convertMcpPropertiesToGemini(mcpProps) {
    if (!mcpProps) return {};
    const geminiProps = {};
    for (const key in mcpProps) {
      const mcpProp = mcpProps[key];
      geminiProps[key] = {
        type: mapMcpTypeToGemini(mcpProp.type),
        description: mcpProp.description || "",
      };
      if (mcpProp.enum) geminiProps[key].enum = mcpProp.enum;
      if (mcpProp.type === "array" && mcpProp.items) {
        geminiProps[key].items = {
          type: mapMcpTypeToGemini(mcpProp.items.type),
        };
      }
      if (mcpProp.type === "object" && mcpProp.properties) {
        geminiProps[key].properties = convertMcpPropertiesToGemini(
          mcpProp.properties
        );
        if (mcpProp.required) geminiProps[key].required = mcpProp.required;
      }
    }
    return geminiProps;
  }

  /**
   * Calculates checksum for content.
   * @param {string} content - The string content.
   * @returns {Promise<string|null>} The SHA-256 checksum or null on error.
   */
  async function calculateChecksum(content) {
    if (typeof content !== "string") return null;
    try {
      const msgUint8 = new TextEncoder().encode(content);
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return `sha256-${hashArray
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("")}`;
    } catch (error) {
      logger.logEvent(
        "error",
        "Checksum calculation failed in ToolRunner:",
        error
      );
      return null;
    }
  }

  async function runToolInternal(
    toolName,
    toolArgs,
    injectedStaticTools,
    injectedDynamicTools,
    uiHooks = {}
  ) {
    logger.logEvent("info", `Run tool: ${toolName}`, toolArgs || {});
    const staticTool = injectedStaticTools.find((t) => t.name === toolName);

    if (staticTool) {
      let artifactContent = null;
      if (
        toolArgs &&
        toolArgs.artifactId &&
        typeof toolArgs.cycle === "number"
      ) {
        artifactContent = Storage.getArtifactContent(
          toolArgs.artifactId,
          toolArgs.cycle,
          toolArgs.versionId
        );
        if (
          artifactContent === null &&
          ![
            "list_artifacts",
            "define_web_component",
            "apply_diff_patch",
            "apply_json_patch",
          ].includes(toolName)
        ) {
          throw new ArtifactError(
            `Artifact content not found for ${toolArgs.artifactId} cycle ${
              toolArgs.cycle
            } (vId: ${toolArgs.versionId || "latest"})`,
            toolArgs.artifactId,
            toolArgs.cycle
          );
        }
      }

      switch (toolName) {
        case "code_linter":
          const code = artifactContent;
          let hasError = false;
          let errorMessage = "";
          try {
            if (!code && toolArgs.language !== "web_component_def")
              throw new ArtifactError(
                "Artifact content is null or empty for linting.",
                toolArgs.artifactId,
                toolArgs.cycle
              );
            if (toolArgs.language === "json") {
              JSON.parse(code);
            } else if (toolArgs.language === "html") {
              if (code.includes("<script") && !code.includes("</script>")) {
                hasError = true;
                errorMessage = "Potentially unclosed script tag.";
              }
            } else if (
              toolArgs.language === "javascript" ||
              toolArgs.language === "web_component_def"
            ) {
              if (
                (code.match(/{/g) || []).length !==
                  (code.match(/}/g) || []).length ||
                (code.match(/\(/g) || []).length !==
                  (code.match(/\)/g) || []).length
              ) {
                hasError = true;
                errorMessage = "Mismatched braces or parentheses.";
              }
              if (
                toolArgs.language === "web_component_def" &&
                (!code.includes("extends HTMLElement") ||
                  !code.includes("customElements.define"))
              ) {
                // Very basic check, LLM should generate valid class structure
              }
            }
          } catch (e) {
            hasError = true;
            errorMessage = e.message;
          }
          return {
            result: `Basic lint ${hasError ? "failed" : "passed"} for ${
              toolArgs.language
            }.${hasError ? " Error: " + errorMessage : ""}`,
            linting_passed: !hasError,
            error_message: hasError ? errorMessage : null,
          };

        // ... (json_validator, read_artifact, list_artifacts, diff_text, convert_to_gemini_fc, code_edit, run_self_evaluation remain mostly same) ...
        // Ensure they throw appropriate custom errors like ArtifactError if artifact not found.

        case "json_validator":
          try {
            if (!artifactContent)
              throw new ArtifactError(
                "Artifact content is null or empty.",
                toolArgs.artifactId,
                toolArgs.cycle
              );
            JSON.parse(artifactContent);
            return { result: "JSON structure is valid.", valid: true };
          } catch (e) {
            return {
              result: `JSON invalid: ${e.message}`,
              valid: false,
              error: e.message,
            };
          }

        case "read_artifact":
          if (artifactContent === null) {
            throw new ArtifactError(
              `Artifact content not found for ${toolArgs.artifactId} cycle ${
                toolArgs.cycle
              } (vId: ${toolArgs.versionId || "latest"})`,
              toolArgs.artifactId,
              toolArgs.cycle
            );
          }
          return {
            content: artifactContent,
            artifactId: toolArgs.artifactId,
            cycle: toolArgs.cycle,
            versionId: toolArgs.versionId || null,
          };

        case "list_artifacts":
          const allMetaMap = StateManager.getAllArtifactMetadata();
          let filteredMeta = Object.values(allMetaMap);
          if (toolArgs.filterType) {
            filteredMeta = filteredMeta.filter(
              (meta) =>
                meta.type &&
                meta.type.toUpperCase() === toolArgs.filterType.toUpperCase()
            );
          }
          if (toolArgs.filterPattern) {
            try {
              const regex = new RegExp(toolArgs.filterPattern);
              filteredMeta = filteredMeta.filter((meta) => regex.test(meta.id));
            } catch (e) {
              throw new ToolError(
                `Invalid regex pattern: ${e.message}`,
                toolName,
                toolArgs
              );
            }
          }
          if (toolArgs.includeAllVersions) {
            const allVersions = [];
            for (const meta of filteredMeta) {
              allVersions.push(
                ...StateManager.getArtifactMetadataAllVersions(meta.id)
              );
            }
            return {
              artifacts: allVersions.map((m) => ({
                id: m.id,
                type: m.type,
                latestCycle: m.latestCycle,
                versionId: m.version_id,
                timestamp: m.timestamp,
                source: m.source,
              })),
            };
          } else {
            return {
              artifacts: filteredMeta.map((meta) => ({
                id: meta.id,
                type: meta.type,
                latestCycle: meta.latestCycle,
              })),
            };
          }

        case "define_web_component":
          const { tagName, classContent, targetArtifactId, description } =
            toolArgs;
          if (!tagName || !classContent || !targetArtifactId || !description) {
            throw new ToolError(
              "Missing required arguments for define_web_component.",
              toolName,
              toolArgs
            );
          }
          if (!tagName.includes("-") || tagName.toLowerCase() !== tagName) {
            throw new ToolError(
              "Invalid tagName: must include a hyphen and be lowercase.",
              toolName,
              toolArgs,
              { tagName }
            );
          }
          if (customElements.get(tagName)) {
            logger.logEvent(
              "warn",
              `Web Component '${tagName}' is already defined. Overwriting may occur or fail depending on browser. Consider versioning names or checking existence first.`
            );
            // For robust behavior, this tool could refuse to redefine, or have an 'overwrite' flag.
            // Currently, it will proceed and let customElements.define handle it (usually throws if already defined).
          }

          try {
            // Using new Function to create class. CAUTION: Security risk if classContent is not trusted.
            // In REPLOID, content comes from LLM, which is a controlled (though complex) source.
            const ComponentClass = new Function(
              "return (" + classContent + ")"
            )();
            if (
              typeof ComponentClass !== "function" ||
              !HTMLElement.isPrototypeOf(ComponentClass)
            ) {
              throw new WebComponentError(
                "Provided classContent does not evaluate to a valid HTMLElement subclass.",
                tagName,
                { classContent }
              );
            }
            customElements.define(tagName, ComponentClass);
            StateManager.registerWebComponent(tagName); // Mark as registered in state

            const nextCycle = (StateManager.getState()?.totalCycles || 0) + 1;
            const checksum = await calculateChecksum(classContent);
            Storage.setArtifactContent(
              targetArtifactId,
              nextCycle,
              classContent
            );
            StateManager.updateArtifactMetadata(
              targetArtifactId,
              "WEB_COMPONENT_DEF",
              description,
              nextCycle,
              checksum,
              "Tool: define_web_component"
            );

            logger.logEvent(
              "info",
              `Web Component '${tagName}' defined and artifact '${targetArtifactId}' saved.`
            );
            return {
              success: true,
              tagName,
              artifactId: targetArtifactId,
              message: `Web Component <${tagName}> defined and saved as ${targetArtifactId}.`,
            };
          } catch (e) {
            logger.logEvent(
              "error",
              `Failed to define Web Component '${tagName}': ${e.message}`,
              e
            );
            throw new WebComponentError(
              `Failed to define Web Component '${tagName}': ${e.message}`,
              tagName,
              { originalError: e.toString(), classContent }
            );
          }

        case "apply_diff_patch": // Placeholder
          logger.logEvent("warn", "Tool 'apply_diff_patch' is a placeholder.");
          const origContentPatch = Storage.getArtifactContent(
            toolArgs.artifactId,
            toolArgs.cycle,
            toolArgs.versionId
          );
          if (origContentPatch === null)
            throw new ArtifactError(
              `Original artifact not found for patching: ${toolArgs.artifactId}`,
              toolArgs.artifactId,
              toolArgs.cycle
            );
          return {
            success: false,
            result_content:
              origContentPatch +
              `\n\n--- PATCHED (Placeholder) ---\n${toolArgs.patchContent}`,
            error: "Tool not fully implemented",
            original_content: origContentPatch,
            patch_applied: false,
          };

        case "apply_json_patch": // Placeholder
          logger.logEvent("warn", "Tool 'apply_json_patch' is a placeholder.");
          const origJsonContent = Storage.getArtifactContent(
            toolArgs.artifactId,
            toolArgs.cycle,
            toolArgs.versionId
          );
          if (origJsonContent === null)
            throw new ArtifactError(
              `Original JSON artifact not found for patching: ${toolArgs.artifactId}`,
              toolArgs.artifactId,
              toolArgs.cycle
            );
          return {
            success: false,
            result_content: JSON.stringify(
              {
                ...JSON.parse(origJsonContent),
                __PATCHED_PLACEHOLDER__: toolArgs.patchContent,
              },
              null,
              2
            ),
            error: "Tool not fully implemented",
            original_content: origJsonContent,
            patch_applied: false,
          };

        default: // Fallback for other static tools
          // Ensure other static tools (convert_to_gemini_fc, code_edit, run_self_evaluation, diff_text) are handled above or here.
          // For brevity, assuming they are correctly implemented above this switch or are dynamic.
          // If a static tool is listed but not implemented, it will fall through.
          logger.logEvent(
            "warn",
            `Static tool '${toolName}' execution logic not fully implemented or recognized.`
          );
          return {
            success: true,
            message: `Static tool ${toolName} placeholder executed.`,
            argsReceived: toolArgs,
          };
      }
    }

    const dynamicTool = injectedDynamicTools.find(
      (t) => t.declaration.name === toolName
    );
    if (dynamicTool) {
      // ... (dynamic tool execution via Web Worker remains largely the same) ...
      // Ensure it catches errors and wraps them in ToolError if appropriate.
      if (!dynamicTool.implementation) {
        throw new ToolError(
          `Dynamic tool '${toolName}' has no implementation defined.`,
          toolName
        );
      }
      logger.logEvent(
        "info",
        `Executing dynamic tool '${toolName}' in Web Worker sandbox.`
      );

      return new Promise((resolve, reject) => {
        let worker = null;
        let timeoutId = null;
        try {
          worker = new Worker(WORKER_SCRIPT_PATH);
          timeoutId = setTimeout(() => {
            const errorMsg = `Dynamic tool '${toolName}' timed out after ${DYNAMIC_TOOL_TIMEOUT_MS}ms.`;
            logger.logEvent("error", errorMsg);
            if (worker) worker.terminate();
            reject(
              new ToolError(
                `Dynamic tool '${toolName}' execution timed out.`,
                toolName
              )
            );
          }, DYNAMIC_TOOL_TIMEOUT_MS);

          worker.onmessage = async (event) => {
            const { type, success, result, error, id, requestType, payload } =
              event.data;
            if (type === "request") {
              /* ... handle worker requests ... */
            } else {
              // type === "result" or similar
              clearTimeout(timeoutId);
              if (success) {
                logger.logEvent(
                  "info",
                  `Dynamic tool '${toolName}' execution succeeded.`
                );
                resolve(result);
              } else {
                const errorMsg = error?.message || "Unknown worker error";
                logger.logEvent(
                  "error",
                  `Dynamic tool '${toolName}' execution failed in worker: ${errorMsg}\nStack: ${error?.stack}`
                );
                reject(
                  new ToolError(
                    `Dynamic tool '${toolName}' failed: ${errorMsg}`,
                    toolName,
                    toolArgs,
                    { workerError: error }
                  )
                );
              }
              if (worker) worker.terminate();
            }
          };
          worker.onerror = (errorEvent) => {
            clearTimeout(timeoutId);
            const errorMsg = errorEvent.message || "Unknown worker error";
            logger.logEvent(
              "error",
              `Web Worker error for tool '${toolName}': ${errorMsg}`,
              errorEvent
            );
            reject(
              new ToolError(
                `Worker error for dynamic tool '${toolName}': ${errorMsg}`,
                toolName,
                toolArgs,
                { workerEventError: errorEvent }
              )
            );
            if (worker) worker.terminate();
          };
          worker.postMessage({
            type: "init",
            payload: { toolCode: dynamicTool.implementation, toolArgs },
          });
        } catch (e) {
          clearTimeout(timeoutId);
          logger.logEvent(
            "error",
            `Error setting up worker for '${toolName}': ${e.message}`
          );
          if (worker) worker.terminate();
          reject(
            new ToolError(
              `Failed to initialize worker for tool '${toolName}': ${e.message}`,
              toolName,
              toolArgs,
              { setupError: e }
            )
          );
        }
      });
    }

    throw new ToolError(`Tool not found: ${toolName}`, toolName);
  }

  return {
    runTool: runToolInternal,
  };
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: tool-worker.js ---
let messageCallbacks = {};
let messageIdCounter = 0;

self.onmessage = async (event) => {
  const { type, payload, id, data, error } = event.data;

  if (type === "init") {
    const { toolCode, toolArgs } = payload;
    try {
      const AsyncFunction = Object.getPrototypeOf(
        async function () {}
      ).constructor;
      const func = new AsyncFunction(
        "params",
        "LS",
        "StateManager",
        toolCode + "\\n\\nreturn await run(params);"
      );
      const result = await func(toolArgs, self.LS_shim, self.StateManager_shim);
      self.postMessage({ success: true, result: result });
    } catch (e) {
      const errorDetail = {
        message: e.message || "Unknown worker execution error",
        stack: e.stack,
        name: e.name,
      };
      self.postMessage({ success: false, error: errorDetail });
    } finally {
    }
  } else if (type === "response") {
    const callback = messageCallbacks[id];
    if (callback) {
      if (error) {
        callback.reject(
          new Error(error.message || "Worker shim request failed")
        );
      } else {
        callback.resolve(data);
      }
      delete messageCallbacks[id];
    } else {
      console.warn("Worker received response for unknown message ID:", id);
    }
  }
};

function makeShimRequest(requestType, payload) {
  return new Promise((resolve, reject) => {
    const id = messageIdCounter++;
    messageCallbacks[id] = { resolve, reject };
    self.postMessage({
      type: "request",
      id: id,
      requestType: requestType,
      payload: payload,
    });
  });
}

self.LS_shim = {
  getArtifactContent: (id, cycle, versionId = null) => {
    if (
      typeof id !== "string" ||
      typeof cycle !== "number" ||
      (versionId !== null && typeof versionId !== "string")
    ) {
      return Promise.reject(
        new Error("Invalid arguments for getArtifactContent")
      );
    }
    return makeShimRequest("getArtifactContent", { id, cycle, versionId });
  },
};

self.StateManager_shim = {
  getArtifactMetadata: (id, versionId = null) => {
    if (
      typeof id !== "string" ||
      (versionId !== null && typeof versionId !== "string")
    ) {
      return Promise.reject(
        new Error("Invalid arguments for getArtifactMetadata")
      );
    }
    return makeShimRequest("getArtifactMetadata", { id, versionId });
  },
  getArtifactMetadataAllVersions: (id) => {
    if (typeof id !== "string") {
      return Promise.reject(
        new Error("Invalid arguments for getArtifactMetadataAllVersions")
      );
    }
    return makeShimRequest("getArtifactMetadataAllVersions", { id });
  },
  getAllArtifactMetadata: () => {
    return makeShimRequest("getAllArtifactMetadata", {});
  },
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: ui-body-template.html ---
<body>
  <div id="top"></div>
  <h1>
    REPLOID x0 v0
    <small>
      REPLOID (Reflective Embodiment Providing Logical Oversight for Intelligent
      DREAMER (Deep Recursive Exploration Around Multimodal Embodying REPLOID))
    </small>
  </h1>

  <fieldset id="genesis-config" aria-labelledby="genesis-config-legend">
    <legend id="genesis-config-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Configuration
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <div
        class="cfg-grid"
        role="group"
        aria-labelledby="config-params-heading"
      >
        <h3 id="config-params-heading" class="visually-hidden">
          Configuration Parameters
        </h3>
        <div class="cfg-item">
          <label
            for="lsd-persona-percent-input"
            title="Influence ratio contribution for LSD persona."
            >LSD %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="lsd-persona-percent-input"
              value="50"
              min="0"
              max="100"
              step="1"
              aria-describedby="lsd-persona-percent-desc"
            />
            <span id="lsd-persona-percent-desc" class="visually-hidden"
              >Percentage influence of LSD persona (0-100).</span
            >
          </div>
        </div>
        <div class="cfg-item">
          <label
            for="xyz-persona-percent-input"
            title="Influence ratio contribution for XYZ persona."
            >XYZ %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="xyz-persona-percent-input"
              value="50"
              min="0"
              max="100"
              step="1"
              readonly
              aria-describedby="xyz-persona-percent-desc"
            />
            <span id="xyz-persona-percent-desc" class="visually-hidden"
              >Percentage influence of XYZ persona (read-only,
              calculated).</span
            >
          </div>
        </div>
        <div class="cfg-item">
          <label
            for="llm-critique-prob-input"
            title="Prob(0-100) LLM critiques if checks pass."
            >LLM Auto-Critique %:</label
          >
          <input
            type="number"
            id="llm-critique-prob-input"
            value="50"
            min="0"
            max="100"
            step="5"
            aria-describedby="llm-critique-prob-desc"
          />
          <span id="llm-critique-prob-desc" class="visually-hidden"
            >Probability (0-100) that the LLM will perform an automated
            critique.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="human-review-prob-input"
            title="Prob(0-100) cycle forced human review."
            >Forced Human Review %:</label
          >
          <input
            type="number"
            id="human-review-prob-input"
            value="50"
            min="0"
            max="100"
            step="5"
            aria-describedby="human-review-prob-desc"
          />
          <span id="human-review-prob-desc" class="visually-hidden"
            >Probability (0-100) that a cycle will require forced human
            review.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="max-cycle-time-input"
            title="Max time (s) per iteration before human review."
            >Max Cycle Time (s):</label
          >
          <input
            type="number"
            id="max-cycle-time-input"
            value="600"
            min="10"
            max="1800"
            aria-describedby="max-cycle-time-desc"
          />
          <span id="max-cycle-time-desc" class="visually-hidden"
            >Maximum time in seconds allowed per cycle iteration.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="auto-critique-thresh-input"
            title="Confidence (0-1) below which human review forced."
            >Confidence Threshold:</label
          >
          <input
            type="number"
            id="auto-critique-thresh-input"
            value="0.6"
            min="0"
            max="1"
            step="0.05"
            aria-describedby="auto-critique-thresh-desc"
          />
          <span id="auto-critique-thresh-desc" class="visually-hidden"
            >Confidence score threshold (0.0 to 1.0). Cycles below this may
            trigger human review.</span
          >
        </div>
        <div class="cfg-item">
          <label for="max-cycles-input" title="Max cycles (0=Inf)."
            >Max Cycles (0=Inf):</label
          >
          <input
            type="number"
            id="max-cycles-input"
            value="0"
            min="0"
            max="1000"
            step="1"
            aria-describedby="max-cycles-desc"
          />
          <span id="max-cycles-desc" class="visually-hidden"
            >Maximum number of cycles to run (0 means infinite).</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="html-history-limit-input"
            title="Num previous states for 'Go Back'."
            >Self-Mod History:</label
          >
          <input
            type="number"
            id="html-history-limit-input"
            value="5"
            min="1"
            max="20"
            step="1"
            aria-describedby="html-history-limit-desc"
          />
          <span id="html-history-limit-desc" class="visually-hidden"
            >Number of previous full page states saved for the 'Go Back'
            feature.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="pause-after-cycles-input"
            title="Auto pause every N cycles (0=Off)."
            >Pause Every N Cycles:</label
          >
          <input
            type="number"
            id="pause-after-cycles-input"
            value="10"
            min="0"
            max="100"
            step="1"
            aria-describedby="pause-after-cycles-desc"
          />
          <span id="pause-after-cycles-desc" class="visually-hidden"
            >Automatically pause execution every N cycles (0 disables
            auto-pause).</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="max-retries-input"
            title="Max auto-retries on failure before Human Intervention."
            >Max Retries:</label
          >
          <input
            type="number"
            id="max-retries-input"
            value="1"
            min="0"
            max="5"
            step="1"
            aria-describedby="max-retries-desc"
          />
          <span id="max-retries-desc" class="visually-hidden"
            >Maximum number of automatic retries on API or processing failures
            before requiring human intervention.</span
          >
        </div>
      </div>

      <div
        class="model-selectors"
        role="group"
        aria-labelledby="model-select-heading"
      >
        <h3 id="model-select-heading" class="visually-hidden">
          Model Selection
        </h3>
        <div class="cfg-item">
          <label for="core-model-selector">Core Gen Model:</label>
          <select
            id="core-model-selector"
            aria-label="Select Core Generation Model"
          ></select>
        </div>
        <div class="cfg-item">
          <label for="critique-model-selector">Critique/Util Model:</label>
          <select
            id="critique-model-selector"
            aria-label="Select Critique and Utility Model"
          ></select>
        </div>
      </div>

      <h3 id="core-metrics-heading">Core Metrics</h3>
      <div
        class="metrics-grid"
        id="core-metrics-display"
        role="group"
        aria-labelledby="core-metrics-heading"
      >
        <div class="metric-item" id="metric-total-cycles" aria-live="polite">
          Cycles <strong id="total-cycles">0</strong>/<strong
            id="max-cycles-display"
            >Inf</strong
          >
        </div>
        <div
          class="metric-item"
          id="metric-agent-iterations"
          aria-live="polite"
        >
          Agent Itr <strong id="agent-iterations">0</strong>
        </div>
        <div
          class="metric-item"
          id="metric-human-interventions"
          aria-live="polite"
        >
          Human Int <strong id="human-interventions">0</strong>
        </div>
        <div class="metric-item" id="metric-current-goal" aria-live="polite">
          Goal <strong id="current-goal">Idle</strong>
        </div>
        <div
          class="metric-item"
          id="metric-last-critique-type"
          aria-live="polite"
        >
          Critique <strong id="last-critique-type">N/A</strong>
        </div>
        <div class="metric-item" id="metric-persona-mode" aria-live="polite">
          Persona <strong id="persona-mode">XYZ</strong>
        </div>
        <div
          class="metric-item"
          id="metric-html-history-count"
          aria-live="polite"
        >
          History <strong id="html-history-count">0</strong>
        </div>
        <div class="metric-item" id="metric-context-tokens" aria-live="polite">
          Ctx Tokens <strong id="context-token-estimate">0</strong> /
          <span id="context-token-target-display">~1M</span>
          <span
            id="context-token-warning"
            class="token-warning hidden"
            aria-hidden="true"
            >!</span
          >
          <span class="visually-hidden"
            >Context token estimate warning indicator.</span
          >
        </div>
      </div>

      <h3 id="rolling-metrics-heading">Rolling Metrics</h3>
      <div
        class="metrics-grid"
        id="rolling-metrics-display"
        role="group"
        aria-labelledby="rolling-metrics-heading"
      >
        <div class="metric-item" aria-live="polite">
          Avg Conf <strong id="avg-confidence">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Crit Fail Rate <strong id="critique-fail-rate">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Avg Tokens <strong id="avg-tokens">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Fail Count <strong id="fail-count">0</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Avg Eval Score <strong id="avg-eval-score">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Eval Pass Rate <strong id="eval-pass-rate">N/A</strong>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset id="seed-prompts" aria-labelledby="seed-prompts-legend">
    <legend id="seed-prompts-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Seed Instructions &
      Prompts <span class="type-indicator" aria-hidden="true">[A]</span>
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <div class="flex-row">
        <div class="flex-col core-loop-steps">
          <h3 id="core-steps-heading">Core Loop Steps</h3>
          <div id="core-loop-steps-minimap" class="cycle-steps-minimap">
            <ol>
              <li>
                Define or Refine Goal (System/Meta). Load Relevant Context.
                Check Cycle Limits.
              </li>
              <li>
                Analyze State, Goal, Artifacts, Tools, History (Feedback,
                Evals). Deliberate.
              </li>
              <li>
                Propose Changes (Artifacts, Tools, Versions). Decide Actions.
                Set Confidence.
              </li>
              <li>
                Execute LLM & Tools -> Generate Response (Code, Data, New Tool
                Implementations).
              </li>
              <li>
                Check Triggers for Critique or Intervention (Time, Confidence,
                Random, Forced).
              </li>
              <li>
                Perform Critique (Auto) or Get Human Feedback (Options, Prompt,
                Code Edit).
              </li>
              <li>
                Apply Approved Changes or Stage Sandbox (Meta). Handle Prior
                Feedback. Log Actions.
              </li>
              <li>
                Self-Evaluate Cycle Outcome & Learn from History. Propose
                Process Improvements.
              </li>
              <li>
                Determine Next Action: Continue Cycle, Pause, Initiate Retry, or
                Self-Correct.
              </li>
            </ol>
          </div>
        </div>
        <div class="flex-col">
          <h3 id="core-logic-prompt-heading">Core Logic/Meta Prompt</h3>
          <textarea
            id="seed-prompt-core"
            readonly
            aria-labelledby="core-logic-prompt-heading"
          ></textarea>
        </div>
        <div class="flex-col">
          <h3 id="crit-prompt-heading">Automated Critique Prompt</h3>
          <textarea
            id="seed-prompt-critique"
            readonly
            rows="8"
            aria-labelledby="crit-prompt-heading"
          ></textarea>
          <h3 id="sum-prompt-heading">Context Summarization Prompt</h3>
          <textarea
            id="seed-prompt-summarize"
            readonly
            rows="5"
            aria-labelledby="sum-prompt-heading"
          ></textarea>
          <h3 id="eval-prompt-heading">Self-Evaluation Prompt</h3>
          <textarea
            id="seed-prompt-evaluator"
            readonly
            rows="5"
            aria-labelledby="eval-prompt-heading"
          ></textarea>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset
    id="genesis-state-display"
    class="collapsed"
    aria-labelledby="genesis-state-legend"
  >
    <legend id="genesis-state-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Genesis State (Cycle
      0)
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <p>Initial state loaded from browser's local storage.</p>
      <div id="genesis-metrics-display" role="region" aria-live="polite">
        Loading...
      </div>
    </div>
  </fieldset>

  <fieldset id="current-cycle-details" aria-labelledby="current-cycle-legend">
    <legend id="current-cycle-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Cycle
      <span id="current-cycle-number">N/A</span> Details
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <p>
        <i
          >Inputs, decisions, artifacts, and tools for the current/last
          cycle.</i
        >
      </p>
      <div
        id="current-cycle-content"
        class="artifact-display"
        aria-live="polite"
        aria-atomic="true"
      >
        <p>Waiting for cycle...</p>
      </div>
      <div
        id="tools-executed-container"
        class="hidden"
        aria-labelledby="tools-executed-heading"
      >
        <h3 id="tools-executed-heading">Tools Executed This Cycle</h3>
        <ul id="tools-executed-list"></ul>
      </div>
      <div
        id="streaming-output-container"
        class="hidden"
        role="log"
        aria-live="polite"
      >
        <span class="artifact-label" id="stream-label"
          ><span class="type-indicator" aria-hidden="true">[STR]</span>LLM
          Streaming Output</span
        >
        <pre id="streaming-output-pre" aria-labelledby="stream-label">
(No stream active)</pre
        >
      </div>
    </div>
  </fieldset>

  <fieldset id="timeline-fieldset" aria-labelledby="timeline-legend">
    <legend id="timeline-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Execution Timeline
      <span id="status-indicator" role="status" aria-live="polite"
        >Status: Idle</span
      >
      <span id="api-progress" aria-live="polite"></span>
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <ul
        id="timeline-log"
        class="timeline"
        aria-live="polite"
        aria-atomic="false"
      ></ul>
    </div>
  </fieldset>

  <div
    id="human-intervention-section"
    class="hitl-container hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="human-intervention-title"
  >
    <fieldset>
      <legend>
        <span class="toggle-icon" aria-hidden="true"></span
        ><span id="human-intervention-title">Human Intervention Required</span>
        <span class="summary-line" id="human-intervention-reason-summary"
          >Reason...</span
        >
      </legend>
      <div class="content-wrapper">
        <p id="human-intervention-reason"></p>

        <div id="hitl-critique-feedback-mode" class="hidden">
          <h4 id="hitl-critiques-heading">Generated Critiques:</h4>
          <div id="hitl-critiques-display" class="critiques-display"></div>
          <h4 id="hitl-critique-feedback-heading">
            Provide Feedback on Critiques:
          </h4>
          <div id="hitl-critique-selection" class="critique-selection"></div>
          <label for="hitl-critique-notes" class="visually-hidden"
            >Additional Feedback Notes</label
          >
          <textarea
            id="hitl-critique-notes"
            placeholder="Optional feedback on why you selected this critique..."
            style="min-height: 60px; width: 100%; margin-top: 10px"
          ></textarea>
          <button id="submit-critique-feedback-button">
            Submit Critique Feedback
          </button>
        </div>

        <div
          id="hitl-options-mode"
          class="hidden"
          role="group"
          aria-labelledby="hitl-options-heading"
        >
          <h4 id="hitl-options-heading">Select Option:</h4>
          <div id="hitl-options-list" class="hitl-options"></div>
          <button id="submit-hitl-options-button">Submit Selection</button>
        </div>

        <div id="hitl-prompt-mode" class="hidden">
          <h4 id="hitl-prompt-heading">Provide Feedback or Instructions:</h4>
          <textarea
            id="human-critique-input"
            placeholder="Feedback/Next Step..."
            style="min-height: 100px; width: 100%"
            aria-labelledby="hitl-prompt-heading"
            aria-describedby="human-intervention-reason"
          ></textarea>
          <button id="submit-critique-button">Submit Feedback</button>
        </div>

        <div id="hitl-code-edit-mode" class="hidden">
          <h4 id="hitl-code-heading">Edit Artifact:</h4>
          <label for="human-edit-artifact-selector" class="visually-hidden"
            >Select artifact to edit</label
          >
          <select id="human-edit-artifact-selector"></select>
          <label for="human-edit-artifact-textarea" class="visually-hidden"
            >Artifact content editor</label
          >
          <textarea
            id="human-edit-artifact-textarea"
            aria-labelledby="hitl-code-heading"
            aria-describedby="human-intervention-reason"
          ></textarea>
          <button id="submit-human-code-edit-button">Submit Edits</button>
        </div>
      </div>
    </fieldset>
  </div>

  <div
    id="meta-sandbox-container"
    class="hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="meta-sandbox-title"
  >
    <fieldset>
      <legend>
        <span class="toggle-icon" aria-hidden="true"></span
        ><span id="meta-sandbox-title">Meta-Improvement Sandbox</span>
        <span class="summary-line"></span>
      </legend>
      <div class="content-wrapper">
        <h3 id="meta-sandbox-heading">Preview Proposed Self-Modification</h3>
        <p>
          Inspect the full page preview below. Approve to apply the changes and
          reload.
        </p>
        <iframe
          id="meta-sandbox-output"
          title="Preview of proposed self-modification"
          aria-labelledby="meta-sandbox-heading"
        ></iframe>
        <div class="controls-grid meta-sandbox-controls">
          <button id="approve-meta-change-button">Approve and Apply</button>
          <button id="discard-meta-change-button">Discard</button>
        </div>
      </div>
    </fieldset>
  </div>

  <fieldset id="controls-fieldset" aria-labelledby="controls-legend">
    <legend id="controls-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Controls
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <label
        for="goal-input"
        id="goal-input-label"
        title="Define goal for external system design/modification or improving REPLOID itself."
        >Goal Input:</label
      >
      <div
        class="goal-type-selector"
        role="radiogroup"
        aria-labelledby="goal-type-label"
      >
        <span id="goal-type-label">Goal Type:</span>
        <label
          title="Modify external target artifacts (e.g., target.body, target.script.*). Results seen in UI Preview pane."
        >
          <input type="radio" name="goalType" value="System" checked /> System
        </label>
        <label
          title="Modify REPLOID itself (e.g., reploid.core.style, reploid.core.sys-prompt) or generate full_html_source. May trigger Sandbox approval."
        >
          <input type="radio" name="goalType" value="Meta" /> Meta
        </label>
      </div>
      <textarea
        id="goal-input"
        placeholder="e.g., System Goal: Create a landing page... OR Meta Goal: Add a dark mode toggle..."
        aria-labelledby="goal-input-label"
      ></textarea>

      <div class="cfg-grid">
        <div class="api-key-input">
          <label for="api-key-input">API Key:</label>
          <input
            type="password"
            id="api-key-input"
            placeholder="Required (or use config.js)"
            aria-required="true"
          />
        </div>
      </div>
      <div class="autonomy-controls">
        <label for="autonomy-mode-selector">Run Mode:</label>
        <select id="autonomy-mode-selector">
          <option value="Manual" selected>Manual Cycle</option>
          <option value="N_Cycles">Run N Cycles</option>
          <option value="Continuous">Run Continuously</option>
        </select>
        <label for="autonomy-n-cycles-input" class="autonomy-n-label hidden"
          >Cycles:</label
        >
        <input
          type="number"
          id="autonomy-n-cycles-input"
          value="5"
          min="1"
          max="100"
          class="hidden"
        />
        <button id="autonomy-start-stop-button" disabled>
          Start Autonomous Run
        </button>
      </div>

      <div class="controls-grid">
        <button id="run-cycle-button">Run Cycle</button>
        <button
          id="force-human-review-button"
          title="Force next cycle to pause for human review."
        >
          Force Review
        </button>
        <div class="state-io-buttons">
          <button
            id="go-back-button"
            disabled
            title="Revert to previous full page state (Meta only)."
          >
            Go Back
          </button>
          <button
            id="export-state-button"
            title="Download current app state (excluding artifacts) as JSON."
          >
            Export State
          </button>
          <button
            id="import-state-button"
            title="Load app state (excluding artifacts) from JSON file."
          >
            Import State
          </button>
          <label for="import-file-input" class="visually-hidden"
            >Import State File</label
          >
          <input
            type="file"
            id="import-file-input"
            accept=".json"
            class="hidden"
            aria-hidden="true"
          />
          <button id="download-log-button" title="Download session log as TXT.">
            Logs
          </button>
          <button
            id="summarize-context-button"
            title="Automatically summarize current state and goal to reduce context for future cycles."
          >
            Reset Context
          </button>
          <button
            id="clear-local-storage-button"
            title="WARNING: Deletes ALL Reploid artifacts and state from LocalStorage!"
          >
            Clear Storage
          </button>
        </div>
      </div>
    </div>
  </fieldset>
  <div id="notifications-container"></div>
  <style>
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</body>

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: ui-manager.js ---
const UIModule = (config, logger, Utils, Storage, StateManager, Errors) => {
  if (!config || !logger || !Utils || !Storage || !StateManager || !Errors) {
    console.error(
      "UIModule requires config, logger, Utils, Storage, StateManager, and Errors."
    );
    const log = logger || {
      logEvent: (lvl, msg) =>
        console[lvl === "error" ? "error" : "log"](`[UI FALLBACK] ${msg}`),
    };
    log.logEvent(
      "error",
      "UIModule initialization failed: Missing base dependencies."
    );
    const fakeUI = {};
    [
      "init",
      "updateStatus",
      "updateApiProgress",
      "updateStreamingOutput",
      "clearStreamingOutput",
      "highlightCoreStep",
      "showNotification",
      "logToTimeline",
      "logCoreLoopStep",
      "updateTimelineItem",
      "summarizeCompletedCycleLog",
      "clearCurrentCycleDetails",
      "displayCycleArtifact",
      "displayToolExecutionSummary",
      "hideHumanInterventionUI",
      "showHumanInterventionUI",
      "hideMetaSandbox",
      "showMetaSandbox",
      "updateStateDisplay",
      "updateAutonomyControls",
      "setRunButtonState",
      "getRefs",
      "isMetaSandboxPending",
      "isHumanInterventionHidden",
    ].forEach((methodName) => {
      fakeUI[methodName] = () => {
        log.logEvent(
          "error",
          `UIModule not initialized. Called ${methodName}.`
        );
        if (
          methodName === "isMetaSandboxPending" ||
          methodName === "isHumanInterventionHidden"
        )
          return true;
        if (methodName === "getRefs") return {};
      };
    });
    return fakeUI;
  }

  let uiRefs = {};
  let isInitialized = false;
  let CycleLogic = null;
  let metaSandboxPending = false;
  let activeCoreStepIdx = -1;
  let lastCycleLogItem = null;
  let syntaxHighlightTimer = null;

  const APP_MODELS = [
    config.DEFAULT_MODELS.BASE,
    config.DEFAULT_MODELS.ADVANCED,
  ];
  if (
    config.DEFAULT_MODELS.CRITIQUE &&
    !APP_MODELS.includes(config.DEFAULT_MODELS.CRITIQUE)
  ) {
    APP_MODELS.push(config.DEFAULT_MODELS.CRITIQUE);
  }

  const CTX_WARN_THRESH = config.CTX_WARN_THRESH;
  const EVAL_PASS_THRESHOLD = config.EVAL_PASS_THRESHOLD || 0.75;
  const SYNTAX_HIGHLIGHT_DEBOUNCE = 250;
  const TIMELINE_LOG_LIMIT = config.TIMELINE_LOG_LIMIT || 250;

  const logIconMap = {
    error: "âœ—",
    warn: "âš ",
    api: "ðŸŒ",
    tool: "ðŸ› ï¸",
    crit: "âš–ï¸",
    human: "ðŸ‘¤",
    apply: "ðŸ’¾",
    artifact: "ðŸ“„",
    state: "âš™ï¸",
    context: "ðŸ“š",
    goal: "ðŸŽ¯",
    cycle: "ðŸ”„",
    retry: "â³",
    decide: "ðŸ¤”",
    finish: "ðŸ",
    eval: "ðŸ“Š",
    learn: "ðŸ’¡",
    info: "â„¹ï¸",
    default: "âž¡ï¸",
  };
  const stepIconMap = [
    "ðŸŽ¯",
    "ðŸ”",
    "ðŸ’¡",
    "âš™ï¸",
    "ðŸš¦",
    "âš–ï¸",
    "ðŸ’¾",
    "ðŸ“Š",
    "ðŸ§ ",
    "ðŸ",
  ];
  const artifactTypeMap = {
    JS: "[JS]",
    CSS: "[CSS]",
    HTML_HEAD: "[HEAD]",
    HTML_BODY: "[BODY]",
    JSON: "[JSON]",
    PROMPT: "[PROMPT]",
    FULL_HTML_SOURCE: "[PAGE]",
    TEXT: "[TEXT]",
    DIAGRAM_JSON: "[DIAG]",
    JSON_CONFIG: "[CONFIG]",
    LOG: "[LOG]",
    EVAL_DEF: "[EVAL_DEF]",
    WEB_COMPONENT_DEF: "[WC-DEF]",
    UNKNOWN: "[?]",
  };

  const getLogIcon = (message, type) =>
    logIconMap[type?.toLowerCase()] || logIconMap.default;
  const getStepIcon = (index) => stepIconMap[index] || logIconMap.default;
  const getArtifactTypeIndicator = (type) =>
    artifactTypeMap[type?.toUpperCase()] || artifactTypeMap.UNKNOWN;

  const initializeUIElementReferences = () => {
    const elementIds = [
      "total-cycles",
      "max-cycles-display",
      "agent-iterations",
      "human-interventions",
      "fail-count",
      "current-goal",
      "last-critique-type",
      "persona-mode",
      "html-history-count",
      "context-token-estimate",
      "avg-confidence",
      "critique-fail-rate",
      "avg-tokens",
      "avg-eval-score",
      "eval-pass-rate",
      "context-token-warning",
      "context-token-target-display",
      "current-cycle-details",
      "current-cycle-content",
      "current-cycle-number",
      "goal-input",
      "goal-type-selector",
      "seed-prompt-core",
      "seed-prompt-critique",
      "seed-prompt-summarize",
      "seed-prompt-evaluator",
      "api-key-input",
      "lsd-persona-percent-input",
      "xyz-persona-percent-input",
      "llm-critique-prob-input",
      "human-review-prob-input",
      "max-cycle-time-input",
      "auto-critique-thresh-input",
      "max-cycles-input",
      "html-history-limit-input",
      "pause-after-cycles-input",
      "max-retries-input",
      "timeline-log",
      "status-indicator",
      "core-loop-steps-minimap",
      "run-cycle-button",
      "force-human-review-button",
      "go-back-button",
      "export-state-button",
      "import-state-button",
      "import-file-input",
      "download-log-button",
      "summarize-context-button",
      "clear-local-storage-button",
      "human-intervention-section",
      "human-intervention-title",
      "human-intervention-reason",
      "human-intervention-reason-summary",
      "hitl-options-mode",
      "hitl-options-list",
      "submit-hitl-options-button",
      "hitl-prompt-mode",
      "human-critique-input",
      "submit-critique-button",
      "hitl-code-edit-mode",
      "human-edit-artifact-selector",
      "human-edit-artifact-textarea",
      "submit-human-code-edit-button",
      "hitl-critique-feedback-mode",
      "hitl-critiques-display",
      "hitl-critique-selection",
      "hitl-critique-notes",
      "submit-critique-feedback-button",
      "meta-sandbox-container",
      "meta-sandbox-output",
      "approve-meta-change-button",
      "discard-meta-change-button",
      "genesis-state-display",
      "genesis-metrics-display",
      "notifications-container",
      "core-model-selector",
      "critique-model-selector",
      "streaming-output-container",
      "streaming-output-pre",
      "api-progress",
      "tools-executed-container",
      "tools-executed-list",
      "autonomy-mode-selector",
      "autonomy-n-cycles-input",
      "autonomy-start-stop-button",
      "autonomy-n-label",
    ];
    const selectorsForClasses = ["goal-type-selector", "autonomy-n-label"];
    uiRefs = {};
    elementIds.forEach((kebabId) => {
      let element = selectorsForClasses.includes(kebabId)
        ? Utils.$(`.${kebabId}`)
        : Utils.$id(kebabId);
      if (element) uiRefs[Utils.kabobToCamel(kebabId)] = element;
      else {
        const optionalElements = [
          "hitl-critique-selection",
          "hitl-critique-notes",
          "hitl-critiques-display",
          "notifications-container",
        ];
        if (!optionalElements.includes(kebabId))
          logger.logEvent(
            "warn",
            `UI element not found: ${
              selectorsForClasses.includes(kebabId) ? "." : "#"
            }${kebabId}`
          );
      }
    });
    logger.logEvent("debug", "UI element references initialized.");
  };

  const updateStatus = (message, isActive = false, isError = false) => {
    if (!uiRefs.statusIndicator) return;
    uiRefs.statusIndicator.textContent = `Status: ${message}`;
    uiRefs.statusIndicator.classList.toggle("active", isActive);
    uiRefs.statusIndicator.classList.toggle("error", isError);
  };

  const updateApiProgress = (message) => {
    if (uiRefs.apiProgress)
      uiRefs.apiProgress.textContent = message
        ? `API: ${Utils.trunc(message, 30)}`
        : "";
  };

  const updateStreamingOutput = (content, isFinal = false) => {
    if (uiRefs.streamingOutputContainer && uiRefs.streamingOutputPre) {
      uiRefs.streamingOutputContainer.classList.remove("hidden");
      uiRefs.streamingOutputPre.textContent = content;
      uiRefs.streamingOutputPre.scrollTop =
        uiRefs.streamingOutputPre.scrollHeight;
    }
  };

  const clearStreamingOutput = () => {
    if (uiRefs.streamingOutputContainer && uiRefs.streamingOutputPre) {
      uiRefs.streamingOutputPre.textContent = "(Stream ended)";
      setTimeout(() => {
        if (uiRefs.streamingOutputContainer)
          uiRefs.streamingOutputContainer.classList.add("hidden");
      }, 2000);
    }
  };

  const highlightCoreStep = (stepIndex) => {
    activeCoreStepIdx = stepIndex;
    const minimap = uiRefs.coreLoopStepsMinimap;
    if (!minimap) return;
    const stepsList = minimap.querySelector("ol");
    if (!stepsList) return;
    const listItems = stepsList.querySelectorAll("li");
    listItems.forEach((li, idx) => {
      const isActive = idx === stepIndex;
      li.classList.toggle("active-step", isActive);
      let iconSpan = li.querySelector(".step-icon");
      if (!iconSpan) {
        iconSpan = document.createElement("span");
        iconSpan.className = "step-icon";
        li.insertBefore(iconSpan, li.firstChild);
      }
      iconSpan.textContent = getStepIcon(idx);
      iconSpan.setAttribute("aria-hidden", "true");
    });
  };

  const showNotification = (message, type = "info", duration = 5000) => {
    const container =
      uiRefs.notificationsContainer || Utils.$id("notifications-container");
    if (!container) {
      console.error("Notification container not found!");
      alert(`[${Utils.ucFirst(type)}] ${message}`);
      return;
    }
    const notification = document.createElement("div");
    notification.className = `notification ${type}`;
    notification.innerHTML = `${Utils.escapeHtml(
      message
    )}<button style="background:none;border:none;float:right;cursor:pointer;color:inherit;font-size:1.2em;line-height:1;padding:0;margin-left:10px;">Ã—</button>`;
    const button = notification.querySelector("button");
    if (button) button.onclick = () => notification.remove();
    container.appendChild(notification);
    if (duration > 0)
      setTimeout(() => {
        if (notification.parentElement) notification.remove();
      }, duration);
  };

  const calculateDerivedStats = (state) => {
    if (!state) return;
    const confHistory =
      state.confidenceHistory?.slice(
        -(config.MAX_HISTORY_ITEMS_FOR_STATS || 10)
      ) || [];
    if (confHistory.length > 0)
      state.avgConfidence =
        confHistory.reduce((a, b) => a + (b || 0), 0) / confHistory.length;
    else state.avgConfidence = null;
    const critHistory =
      state.critiqueFailHistory?.slice(
        -(config.MAX_HISTORY_ITEMS_FOR_STATS || 10)
      ) || [];
    if (critHistory.length > 0) {
      const fails = critHistory.filter((v) => v === true).length;
      state.critiqueFailRate = (fails / critHistory.length) * 100;
    } else state.critiqueFailRate = null;
    const tokenHistory =
      state.tokenHistory?.slice(-(config.MAX_HISTORY_ITEMS_FOR_STATS || 10)) ||
      [];
    if (tokenHistory.length > 0)
      state.avgTokens =
        tokenHistory.reduce((a, b) => a + (b || 0), 0) / tokenHistory.length;
    else state.avgTokens = null;
    const evalHistory =
      state.evaluationHistory?.slice(
        -(config.MAX_HISTORY_ITEMS_FOR_STATS || 10)
      ) || [];
    if (evalHistory.length > 0) {
      const validScores = evalHistory
        .map((e) => e.evaluation_score)
        .filter((s) => typeof s === "number" && !isNaN(s));
      if (validScores.length > 0) {
        state.avgEvalScore =
          validScores.reduce((a, b) => a + b, 0) / validScores.length;
        const passes = validScores.filter(
          (s) => s >= EVAL_PASS_THRESHOLD
        ).length;
        state.evalPassRate = (passes / validScores.length) * 100;
      } else {
        state.avgEvalScore = null;
        state.evalPassRate = null;
      }
    } else {
      state.avgEvalScore = null;
      state.evalPassRate = null;
    }
  };

  const updateMetricsDisplay = (state) => {
    if (!state || !StateManager) return;
    calculateDerivedStats(state);
    if (uiRefs.avgConfidence)
      uiRefs.avgConfidence.textContent =
        state.avgConfidence?.toFixed(2) || "N/A";
    if (uiRefs.critiqueFailRate)
      uiRefs.critiqueFailRate.textContent =
        state.critiqueFailRate?.toFixed(1) + "%" || "N/A";
    if (uiRefs.avgEvalScore)
      uiRefs.avgEvalScore.textContent = state.avgEvalScore?.toFixed(2) || "N/A";
    if (uiRefs.evalPassRate)
      uiRefs.evalPassRate.textContent =
        state.evalPassRate?.toFixed(1) + "%" || "N/A";
    if (uiRefs.avgTokens)
      uiRefs.avgTokens.textContent = state.avgTokens?.toFixed(0) || "N/A";
    if (uiRefs.contextTokenEstimate)
      uiRefs.contextTokenEstimate.textContent =
        state.contextTokenEstimate?.toLocaleString() || "0";
    if (uiRefs.failCount) uiRefs.failCount.textContent = state.failCount || 0;
    if (uiRefs.contextTokenTargetDisplay)
      uiRefs.contextTokenTargetDisplay.textContent =
        state.contextTokenTarget?.toLocaleString() ||
        config.CTX_TARGET.toLocaleString();
    checkContextTokenWarning(state);
  };

  const checkContextTokenWarning = (state) => {
    if (!state || !uiRefs.contextTokenWarning) return;
    const threshold = state.contextTokenTarget * 0.9 || CTX_WARN_THRESH;
    const isWarn = state.contextTokenEstimate >= threshold;
    uiRefs.contextTokenWarning.classList.toggle("hidden", !isWarn);
    if (
      isWarn &&
      !uiRefs.contextTokenWarning.classList.contains("warning-logged")
    ) {
      logger.logEvent(
        "warn",
        `Context high! (${state.contextTokenEstimate.toLocaleString()}/${state.contextTokenTarget.toLocaleString()}). Consider summarizing.`
      );
      uiRefs.contextTokenWarning.classList.add("warning-logged");
    } else if (!isWarn)
      uiRefs.contextTokenWarning.classList.remove("warning-logged");
  };

  const updateHtmlHistoryControls = (state) => {
    if (!uiRefs.htmlHistoryCount || !state) return;
    const count = state.htmlHistory?.length || 0;
    uiRefs.htmlHistoryCount.textContent = count.toString();
    if (uiRefs.goBackButton) uiRefs.goBackButton.disabled = count === 0;
  };

  const updateFieldsetSummaries = (state) => {
    if (!state || !StateManager) return;
    const updateSummary = (fieldsetRefOrId, text) => {
      let fieldset =
        typeof fieldsetRefOrId === "string"
          ? Utils.$id(fieldsetRefOrId)
          : fieldsetRefOrId;
      if (fieldset) {
        const summary = fieldset.querySelector(".summary-line");
        if (summary)
          summary.textContent = text ? `| ${Utils.trunc(text, 80)}` : "";
      }
    };
    const cfg = state.cfg || {};
    const coreModelName = (cfg.coreModel || "unknown")
      .split("/")
      .pop()
      .replace("-latest", "");
    const critiqueModelName = (cfg.critiqueModel || "unknown")
      .split("/")
      .pop()
      .replace("-latest", "");
    updateSummary(
      "genesis-config",
      `LSD:${cfg.personaBalance ?? "?"}% Crit:${
        cfg.llmCritiqueProb ?? "?"
      }% Rev:${cfg.humanReviewProb ?? "?"}% MaxC:${
        cfg.maxCycles || "Inf"
      } Core:${coreModelName} Util:${critiqueModelName}`
    );
    const promptLens = {
      core:
        Storage.getArtifactContent("reploid.core.sys-prompt", 0)?.length || 0,
      crit:
        Storage.getArtifactContent("reploid.core.critiquer-prompt", 0)
          ?.length || 0,
      sum:
        Storage.getArtifactContent("reploid.core.summarizer-prompt", 0)
          ?.length || 0,
      eval:
        Storage.getArtifactContent("reploid.core.evaluator-prompt", 0)
          ?.length || 0,
    };
    updateSummary(
      "seed-prompts",
      `Core:${promptLens.core}c Crit:${promptLens.crit}c Sum:${promptLens.sum}c Eval:${promptLens.eval}c`
    );
    updateSummary(uiRefs.genesisStateDisplay, "Cycle 0 Info");
    const cycleContentDiv = uiRefs.currentCycleContent;
    let itemCount = 0;
    let totalChars = 0;
    if (cycleContentDiv) {
      const sections = cycleContentDiv.querySelectorAll(".artifact-section");
      itemCount = sections.length;
      sections.forEach((section) => {
        const pre = section.querySelector("pre code");
        if (pre) totalChars += pre.textContent.length;
      });
    }
    updateSummary(
      uiRefs.currentCycleDetails,
      `Items: ${itemCount}, Content Chars: ${totalChars.toLocaleString()}`
    );
    updateSummary(
      "timeline-fieldset",
      `Entries: ${uiRefs.timelineLog?.childElementCount || 0}`
    );
    const registeredWCs = StateManager.getRegisteredWebComponents();
    const wcSummary =
      registeredWCs.length > 0
        ? ` WCs: ${registeredWCs.length} (${Utils.trunc(
            registeredWCs.join(", "),
            20
          )})`
        : "";
    updateSummary(
      "controls-fieldset",
      `API Key: ${state.apiKey ? "Set" : "Not Set"} | Mode: ${
        state.autonomyMode || "Manual"
      } ${wcSummary}`
    );
  };

  const updateStateDisplay = () => {
    if (!StateManager) {
      logger.logEvent("error", "updateStateDisplay: StateManager missing.");
      return;
    }
    const state = StateManager.getState();
    if (!state) {
      logger.logEvent("error", "updateStateDisplay: state is null.");
      return;
    }
    const cfg = state.cfg || {};
    if (uiRefs.lsdPersonaPercentInput)
      uiRefs.lsdPersonaPercentInput.value = cfg.personaBalance ?? 50;
    if (uiRefs.xyzPersonaPercentInput)
      uiRefs.xyzPersonaPercentInput.value = 100 - (cfg.personaBalance ?? 50);
    if (uiRefs.llmCritiqueProbInput)
      uiRefs.llmCritiqueProbInput.value = cfg.llmCritiqueProb ?? 50;
    if (uiRefs.humanReviewProbInput)
      uiRefs.humanReviewProbInput.value = cfg.humanReviewProb ?? 50;
    if (uiRefs.maxCycleTimeInput)
      uiRefs.maxCycleTimeInput.value = cfg.maxCycleTime ?? 600;
    if (uiRefs.autoCritiqueThreshInput)
      uiRefs.autoCritiqueThreshInput.value = cfg.autoCritiqueThresh ?? 0.75;
    if (uiRefs.maxCyclesInput) uiRefs.maxCyclesInput.value = cfg.maxCycles ?? 0;
    if (uiRefs.htmlHistoryLimitInput)
      uiRefs.htmlHistoryLimitInput.value = cfg.htmlHistoryLimit ?? 5;
    if (uiRefs.pauseAfterCyclesInput)
      uiRefs.pauseAfterCyclesInput.value = cfg.pauseAfterCycles ?? 10;
    if (uiRefs.maxRetriesInput)
      uiRefs.maxRetriesInput.value = cfg.maxRetries ?? 1;
    if (uiRefs.apiKeyInput) uiRefs.apiKeyInput.value = state.apiKey || "";
    if (uiRefs.coreModelSelector)
      uiRefs.coreModelSelector.value =
        cfg.coreModel || config.DEFAULT_MODELS.BASE;
    if (uiRefs.critiqueModelSelector)
      uiRefs.critiqueModelSelector.value =
        cfg.critiqueModel || config.DEFAULT_MODELS.CRITIQUE;
    if (uiRefs.autonomyModeSelector)
      uiRefs.autonomyModeSelector.value = state.autonomyMode || "Manual";
    if (uiRefs.autonomyNCyclesInput && state.autonomyMode === "N_Cycles") {
      uiRefs.autonomyNCyclesInput.value =
        state.autonomyCyclesRemaining > 0
          ? state.autonomyCyclesRemaining
          : cfg.autonomyDefaultNCycles || 5;
    }
    const maxC = cfg.maxCycles || 0;
    if (uiRefs.maxCyclesDisplay)
      uiRefs.maxCyclesDisplay.textContent =
        maxC === 0 ? "Inf" : maxC.toString();
    if (uiRefs.totalCycles)
      uiRefs.totalCycles.textContent = state.totalCycles || 0;
    if (uiRefs.agentIterations)
      uiRefs.agentIterations.textContent = state.agentIterations || 0;
    if (uiRefs.humanInterventions)
      uiRefs.humanInterventions.textContent = state.humanInterventions || 0;
    const goalInfo = CycleLogic?.getActiveGoalInfo() || {
      type: "Idle",
      latestGoal: "Idle",
    };
    let goalText =
      goalInfo.type === "Idle"
        ? "Idle"
        : `${goalInfo.type}: ${goalInfo.latestGoal}`;
    if (state.currentGoal?.summaryContext)
      goalText += ` (Ctx: ${Utils.trunc(
        state.currentGoal.summaryContext,
        20
      )}...)`;
    if (uiRefs.currentGoal)
      uiRefs.currentGoal.textContent = Utils.trunc(goalText, 60);
    if (uiRefs.lastCritiqueType)
      uiRefs.lastCritiqueType.textContent = state.lastCritiqueType || "N/A";
    if (uiRefs.personaMode)
      uiRefs.personaMode.textContent = state.personaMode || "N/A";
    updateMetricsDisplay(state);
    updateHtmlHistoryControls(state);
    updateAutonomyControls(
      state.autonomyMode,
      CycleLogic?.isRunning() && CycleLogic?.isAutonomous()
    );
    const humanInterventionVisible =
      !uiRefs.humanInterventionSection?.classList.contains("hidden");
    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;
    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;
    setRunButtonState(
      isCycleRunning ? "Abort Cycle" : "Run Cycle",
      isCycleRunning && isAutonomousRunning
    );
    updateFieldsetSummaries(state);
  };

  const displayGenesisState = () => {
    if (!uiRefs.genesisMetricsDisplay || !StateManager) {
      logger.logEvent(
        "warn",
        "displayGenesisState: Required elements or StateManager missing."
      );
      return;
    }
    const state = StateManager.getState();
    if (!state || !state.cfg) {
      uiRefs.genesisMetricsDisplay.innerHTML =
        "<p>Genesis state not fully loaded or config missing.</p>";
      return;
    }
    const metricsEl = Utils.$id("core-metrics-display");
    if (metricsEl) {
      const staticMetricsHTML = `<div>Cycles <strong>0</strong>/${
        state.cfg.maxCycles || "Inf"
      }</div><div>Agent Itr <strong>0</strong></div><div>Human Int <strong>0</strong></div><div>Goal <strong>Idle</strong></div><div>Critique <strong>N/A</strong></div><div>Persona <strong>XYZ</strong></div><div>History <strong>0</strong></div><div>Ctx Tokens <strong>0</strong> / ${
        state.contextTokenTarget?.toLocaleString() ||
        config.CTX_TARGET.toLocaleString()
      }</div>`;
      uiRefs.genesisMetricsDisplay.innerHTML = `<div class="metrics-grid">${staticMetricsHTML}</div>`;
    } else
      uiRefs.genesisMetricsDisplay.innerHTML =
        "<p>Core Metrics Display template not found for Genesis.</p>";
  };

  const logToTimeline = (
    cycle,
    message,
    type = "info",
    isSubStep = false,
    animate = false
  ) => {
    if (!uiRefs.timelineLog || !StateManager) return null;
    if (typeof cycle !== "number")
      cycle = StateManager.getState()?.totalCycles ?? 0;
    const state = StateManager.getState();
    const persona = state?.personaMode === "XYZ" ? "[X]" : "[L]";
    const icon = getLogIcon(message, type);
    const li = document.createElement("li");
    li.setAttribute("data-cycle", cycle);
    li.setAttribute("data-timestamp", Date.now());
    li.classList.add(isSubStep ? "sub-step" : "log-entry");
    if (type === "error") li.classList.add("error");
    if (type === "warn") li.classList.add("warn");
    if (logIconMap[type?.toLowerCase()])
      li.classList.add(`log-type-${type.toLowerCase()}`);
    const cycleSpan = document.createElement("span");
    cycleSpan.className = "log-cycle-marker";
    cycleSpan.textContent = cycle;
    li.appendChild(cycleSpan);
    const contentSpan = document.createElement("span");
    let iconHTML = `<span class="log-icon" title="${type}" aria-hidden="true">${icon}</span>`;
    if (animate)
      iconHTML = `<span class="log-icon animated-icon" title="${type}" aria-hidden="true">âš™ï¸</span>`;
    contentSpan.innerHTML = `${iconHTML} <span class="log-persona">${persona}</span> ${Utils.escapeHtml(
      Utils.trunc(message, 250)
    )}`;
    contentSpan.title = message;
    li.appendChild(contentSpan);
    const targetList = uiRefs.timelineLog;
    targetList.insertBefore(li, targetList.firstChild);
    while (targetList.children.length > TIMELINE_LOG_LIMIT)
      targetList.removeChild(targetList.lastChild);
    if (message.startsWith("[CYCLE] === Cycle")) lastCycleLogItem = li;
    return li;
  };

  const logCoreLoopStep = (cycle, stepIndex, message) => {
    highlightCoreStep(stepIndex);
    if (!uiRefs.timelineLog) return null;
    const li = document.createElement("li");
    li.classList.add("core-step");
    li.setAttribute("data-cycle", cycle);
    li.setAttribute("data-timestamp", Date.now());
    const span = document.createElement("span");
    const stepIcon = getStepIcon(stepIndex);
    span.innerHTML = `<span class="log-icon">${stepIcon}</span> <strong>Step ${
      stepIndex + 1
    }:</strong> ${Utils.escapeHtml(message)}`;
    li.appendChild(span);
    uiRefs.timelineLog.insertBefore(li, uiRefs.timelineLog.firstChild);
    while (uiRefs.timelineLog.children.length > TIMELINE_LOG_LIMIT)
      uiRefs.timelineLog.removeChild(uiRefs.timelineLog.lastChild);
    return li;
  };

  const updateTimelineItem = (
    logItem,
    newMessage,
    newType = "info",
    stopAnimate = true
  ) => {
    if (!logItem || !StateManager) return;
    const contentSpan = logItem.querySelector("span:last-child");
    if (!contentSpan) return;
    const state = StateManager.getState();
    const persona = state?.personaMode === "XYZ" ? "[X]" : "[L]";
    let iconElement = contentSpan.querySelector(".log-icon");
    let icon = iconElement?.textContent || logIconMap.default;
    let iconClass = "log-icon";
    let currentTitle = iconElement?.getAttribute("title") || newType;
    if (newMessage.includes(" OK")) icon = "âœ“";
    else if (newMessage.includes(" ERR")) icon = logIconMap.error;
    else if (newMessage.includes("[API OK")) icon = "â–¼";
    if (newType === "warn") icon = logIconMap.warn;
    if (newType === "error") icon = logIconMap.error;
    if (stopAnimate) {
      const animatedIconEl = contentSpan.querySelector(".animated-icon");
      if (animatedIconEl) {
        animatedIconEl.classList.remove("animated-icon");
        iconClass = "log-icon";
        currentTitle = newType;
      }
    } else {
      if (contentSpan.querySelector(".animated-icon")) {
        icon = logIconMap.tool;
        iconClass = "log-icon animated-icon";
      }
    }
    contentSpan.innerHTML = `<span class="${iconClass}" title="${currentTitle}">${icon}</span> ${persona} ${Utils.escapeHtml(
      newMessage
    )}`;
    logItem.classList.remove("error", "warn");
    Object.keys(logIconMap).forEach((key) =>
      logItem.classList.remove(`log-type-${key}`)
    );
    if (newType === "error") logItem.classList.add("error");
    if (newType === "warn") logItem.classList.add("warn");
    if (logIconMap[newType]) logItem.classList.add(`log-type-${newType}`);
  };

  const summarizeCompletedCycleLog = (outcome) => {
    if (!lastCycleLogItem || !lastCycleLogItem.classList.contains("log-entry"))
      return;
    lastCycleLogItem.classList.add("summary");
    const contentSpan = lastCycleLogItem.querySelector("span:last-child");
    if (contentSpan)
      contentSpan.innerHTML = `<span class="log-icon" aria-hidden="true">${
        logIconMap.finish
      }</span> Cycle ${lastCycleLogItem.getAttribute(
        "data-cycle"
      )} Completed: ${Utils.escapeHtml(
        outcome
      )} <span class="expand-hint">(Expand?)</span>`;
    lastCycleLogItem = null;
  };

  const clearCurrentCycleDetails = () => {
    if (!uiRefs.currentCycleDetails || !uiRefs.currentCycleContent) return;
    uiRefs.currentCycleContent.innerHTML =
      "<p><i>Cycle details will appear here.</i></p>";
    if (uiRefs.toolsExecutedContainer)
      uiRefs.toolsExecutedContainer.classList.add("hidden");
    if (uiRefs.toolsExecutedList) uiRefs.toolsExecutedList.innerHTML = "";
    if (uiRefs.streamingOutputContainer)
      uiRefs.streamingOutputContainer.classList.add("hidden");
    if (uiRefs.streamingOutputPre)
      uiRefs.streamingOutputPre.textContent = "(No stream active)";
    const state = StateManager?.getState();
    if (state) updateFieldsetSummaries(state);
  };

  const triggerSyntaxHighlighting = () => {
    clearTimeout(syntaxHighlightTimer);
    syntaxHighlightTimer = setTimeout(() => {
      if (window.Prism && typeof Prism.highlightAllUnder === "function") {
        try {
          Prism.highlightAllUnder(uiRefs.currentCycleContent);
        } catch (e) {
          logger.logEvent("warn", "Prism highlighting failed.", e);
        }
      } else if (window.hljs && typeof hljs.highlightAll === "function") {
        try {
          uiRefs.currentCycleContent
            .querySelectorAll("pre code")
            .forEach((block) => hljs.highlightElement(block));
        } catch (e) {
          logger.logEvent("warn", "highlight.js highlighting failed.", e);
        }
      }
    }, SYNTAX_HIGHLIGHT_DEBOUNCE);
  };

  const displayCycleArtifact = (
    label,
    content,
    type = "info",
    isModified = false,
    source = null,
    artifactId = null,
    cycle = null,
    versionId = null
  ) => {
    if (
      !uiRefs.currentCycleDetails ||
      !uiRefs.currentCycleContent ||
      !StateManager
    )
      return;
    if (
      uiRefs.currentCycleContent.children.length === 1 &&
      uiRefs.currentCycleContent.firstChild.tagName === "P"
    )
      uiRefs.currentCycleContent.innerHTML = "";
    if (uiRefs.currentCycleDetails.classList.contains("collapsed"))
      uiRefs.currentCycleDetails.classList.remove("collapsed");
    const section = document.createElement("div");
    section.className = "artifact-section";
    if (type) section.classList.add(`artifact-type-${type}`);
    if (source)
      section.classList.add(`artifact-source-${source.toLowerCase()}`);
    const labelEl = document.createElement("div");
    labelEl.className = "artifact-label-container";
    const meta = artifactId
      ? StateManager.getArtifactMetadata(artifactId, versionId)
      : { type: "TEXT" };
    const typeIndicator = getArtifactTypeIndicator(meta?.type);
    const langMap = {
      JS: "javascript",
      CSS: "css",
      HTML_HEAD: "html",
      HTML_BODY: "html",
      JSON: "json",
      JSON_CONFIG: "json",
      FULL_HTML_SOURCE: "html",
      PROMPT: "text",
      TEXT: "text",
      EVAL_DEF: "json",
      WEB_COMPONENT_DEF: "javascript",
    };
    const languageClass = langMap[meta?.type?.toUpperCase()]
      ? `language-${langMap[meta.type.toUpperCase()]}`
      : "language-text";
    let labelHTML = `<span class="type-indicator" aria-hidden="true">${typeIndicator}</span> <strong class="artifact-title">${Utils.escapeHtml(
      label
    )}</strong>`;
    if (artifactId)
      labelHTML += ` <span class="artifact-id-ref">(ID: ${Utils.escapeHtml(
        artifactId
      )})</span>`;
    if (versionId)
      labelHTML += ` <span class="artifact-version-ref">#${Utils.escapeHtml(
        versionId
      )}</span>`;
    if (cycle !== null)
      labelHTML += ` <span class="artifact-cycle-ref">[Cyc ${cycle}]</span>`;
    if (source)
      labelHTML += ` <span class="source-indicator">(Source: ${Utils.escapeHtml(
        source
      )})</span>`;
    if (isModified)
      labelHTML +=
        ' <span class="change-indicator" aria-label="Modified">*</span>';
    labelEl.innerHTML = labelHTML;
    section.appendChild(labelEl);
    const pre = document.createElement("pre");
    const code = document.createElement("code");
    pre.className = languageClass;
    code.className = languageClass;
    code.textContent =
      content === null || content === undefined ? "(empty)" : String(content);
    pre.appendChild(code);
    pre.classList.add(type);
    if (isModified) pre.classList.add("modified");
    section.appendChild(pre);
    uiRefs.currentCycleContent.appendChild(section);
    triggerSyntaxHighlighting();
    const state = StateManager.getState();
    if (state) updateFieldsetSummaries(state);
    section.scrollIntoView({ behavior: "smooth", block: "nearest" });
  };

  const displayToolExecutionSummary = (toolSummaries) => {
    if (!uiRefs.toolsExecutedContainer || !uiRefs.toolsExecutedList) return;
    if (!toolSummaries || toolSummaries.length === 0) {
      uiRefs.toolsExecutedContainer.classList.add("hidden");
      uiRefs.toolsExecutedList.innerHTML = "";
      return;
    }
    uiRefs.toolsExecutedContainer.classList.remove("hidden");
    const fragment = document.createDocumentFragment();
    toolSummaries.forEach((summary) => {
      const li = document.createElement("li");
      li.classList.add(summary.success ? "tool-success" : "tool-fail");
      let content = `<strong>${Utils.escapeHtml(summary.name)}</strong>`;
      if (summary.args)
        content += `<span class="tool-args">Args: ${Utils.trunc(
          Utils.escapeHtml(JSON.stringify(summary.args)),
          150
        )}</span>`;
      if (summary.success) {
        if (summary.result !== undefined && summary.result !== null)
          content += `<span class="tool-result">Result: ${Utils.trunc(
            Utils.escapeHtml(JSON.stringify(summary.result)),
            150
          )}</span>`;
        else
          content += `<span class="tool-result">Result: OK (No specific return value)</span>`;
      } else
        content += `<span class="tool-error">Error: ${Utils.escapeHtml(
          summary.error || "Unknown failure"
        )}</span>`;
      li.innerHTML = content;
      fragment.appendChild(li);
    });
    uiRefs.toolsExecutedList.innerHTML = "";
    uiRefs.toolsExecutedList.appendChild(fragment);
  };

  const hideHumanInterventionUI = () => {
    if (!uiRefs.humanInterventionSection) return;
    uiRefs.humanInterventionSection.classList.add("hidden");
    if (uiRefs.hitlOptionsMode) uiRefs.hitlOptionsMode.classList.add("hidden");
    if (uiRefs.hitlPromptMode) uiRefs.hitlPromptMode.classList.add("hidden");
    if (uiRefs.hitlCodeEditMode)
      uiRefs.hitlCodeEditMode.classList.add("hidden");
    if (uiRefs.hitlCritiqueFeedbackMode)
      uiRefs.hitlCritiqueFeedbackMode.classList.add("hidden");
    const state = StateManager?.getState();
    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;
    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;
    if (
      !metaSandboxPending &&
      uiRefs.runCycleButton &&
      state &&
      !isCycleRunning &&
      !isAutonomousRunning
    )
      setRunButtonState("Run Cycle", false);
  };

  const showHumanInterventionUI = (
    mode = "prompt",
    reason = "",
    options = [],
    artifactIdToEdit = null,
    critiques = []
  ) => {
    if (!uiRefs.humanInterventionSection || !StateManager) return;
    const state = StateManager.getState();
    if (!state) return;
    highlightCoreStep(5);
    hideMetaSandbox();
    uiRefs.humanInterventionSection.classList.remove("hidden");
    const fieldset = uiRefs.humanInterventionSection.querySelector("fieldset");
    if (fieldset) fieldset.classList.remove("collapsed");
    Utils.ucFirst = (str) =>
      str ? str.charAt(0).toUpperCase() + str.slice(1) : ""; // Ensure definition
    const titleText = `Human Intervention: ${Utils.ucFirst(
      mode.replace("_", " ")
    )}`;
    if (uiRefs.humanInterventionTitle)
      uiRefs.humanInterventionTitle.textContent = titleText;
    if (uiRefs.humanInterventionReason)
      uiRefs.humanInterventionReason.innerHTML = `<strong>Reason:</strong> ${Utils.escapeHtml(
        reason
      )}`;
    if (uiRefs.humanInterventionReasonSummary)
      uiRefs.humanInterventionReasonSummary.textContent = `| Reason: ${Utils.trunc(
        reason,
        50
      )}...`;
    if (uiRefs.runCycleButton) setRunButtonState("Run Cycle", true);
    if (uiRefs.autonomyStartStopButton) setAutonomyButtonState(false, true);
    logToTimeline(
      state.totalCycles,
      `[HUMAN] Intervention Required (${mode}): ${Utils.trunc(reason, 100)}`,
      "warn",
      true
    );
    if (uiRefs.hitlOptionsMode) uiRefs.hitlOptionsMode.classList.add("hidden");
    if (uiRefs.hitlPromptMode) uiRefs.hitlPromptMode.classList.add("hidden");
    if (uiRefs.hitlCodeEditMode)
      uiRefs.hitlCodeEditMode.classList.add("hidden");
    if (uiRefs.hitlCritiqueFeedbackMode)
      uiRefs.hitlCritiqueFeedbackMode.classList.add("hidden");
    let activeModeContainer = null;
    let focusElement = null;
    if (
      mode === "critique_feedback" &&
      critiques &&
      critiques.length > 0 &&
      uiRefs.hitlCritiqueFeedbackMode
    ) {
      activeModeContainer = uiRefs.hitlCritiqueFeedbackMode;
      if (uiRefs.hitlCritiquesDisplay)
        uiRefs.hitlCritiquesDisplay.innerHTML = "";
      if (uiRefs.hitlCritiqueSelection)
        uiRefs.hitlCritiqueSelection.innerHTML = "";
      const displayFragment = document.createDocumentFragment();
      const selectionFragment = document.createDocumentFragment();
      let firstFailingCritiqueIndex = -1;
      critiques.forEach((crit, index) => {
        const critDiv = document.createElement("div");
        critDiv.className = `critique-item ${
          crit.critique_passed ? "pass" : "fail"
        }`;
        critDiv.innerHTML = `<h4>Critique ${index + 1} (${
          crit.critique_passed ? "Pass" : "FAIL"
        })</h4><pre>${Utils.escapeHtml(crit.critique_report)}</pre>`;
        displayFragment.appendChild(critDiv);
        const radioLabel = document.createElement("label");
        const radioInput = document.createElement("input");
        radioInput.type = "radio";
        radioInput.name = "critique_selection";
        radioInput.value = index;
        radioInput.id = `critique_select_${index}`;
        if (!crit.critique_passed && firstFailingCritiqueIndex === -1)
          firstFailingCritiqueIndex = index;
        radioLabel.appendChild(radioInput);
        radioLabel.appendChild(
          document.createTextNode(
            ` Select Critique ${index + 1} as most relevant`
          )
        );
        selectionFragment.appendChild(radioLabel);
        selectionFragment.appendChild(document.createElement("br"));
      });
      const defaultCheckedIndex =
        firstFailingCritiqueIndex !== -1 ? firstFailingCritiqueIndex : 0;
      const defaultRadio = selectionFragment.querySelector(
        `#critique_select_${defaultCheckedIndex}`
      );
      if (defaultRadio) defaultRadio.checked = true;
      if (uiRefs.hitlCritiquesDisplay)
        uiRefs.hitlCritiquesDisplay.appendChild(displayFragment);
      if (uiRefs.hitlCritiqueSelection)
        uiRefs.hitlCritiqueSelection.appendChild(selectionFragment);
      if (uiRefs.hitlCritiqueNotes) uiRefs.hitlCritiqueNotes.value = "";
      triggerSyntaxHighlighting();
      focusElement =
        uiRefs.hitlCritiqueNotes ||
        uiRefs.hitlCritiqueSelection?.querySelector('input[type="radio"]');
    } else if (mode === "code_edit" && uiRefs.hitlCodeEditMode) {
      activeModeContainer = uiRefs.hitlCodeEditMode;
      if (uiRefs.humanEditArtifactSelector)
        uiRefs.humanEditArtifactSelector.innerHTML = "";
      if (uiRefs.humanEditArtifactTextarea)
        uiRefs.humanEditArtifactTextarea.value = "";
      const editableTypes = [
        "HTML_HEAD",
        "HTML_BODY",
        "CSS",
        "JS",
        "JSON",
        "FULL_HTML_SOURCE",
        "PROMPT",
        "TEXT",
        "EVAL_DEF",
        "WEB_COMPONENT_DEF",
      ];
      const currentCycle = state.totalCycles;
      const allMetaMap = StateManager.getAllArtifactMetadata();
      const relevantArtifacts = Object.values(allMetaMap)
        .filter(
          (meta) =>
            meta && editableTypes.includes(meta.type) && meta.latestCycle >= 0
        )
        .sort((a, b) => a.id.localeCompare(b.id));
      const fragment = document.createDocumentFragment();
      relevantArtifacts.forEach((meta) => {
        const opt = document.createElement("option");
        opt.value = meta.id;
        opt.textContent = `${meta.id} (${meta.type}) - Last Mod: Cyc ${meta.latestCycle}`;
        fragment.appendChild(opt);
      });
      if (
        state.lastGeneratedFullSource &&
        artifactIdToEdit === "full_html_source"
      ) {
        const opt = document.createElement("option");
        opt.value = "full_html_source";
        opt.textContent = `Proposed Full HTML Source (Cycle ${currentCycle})`;
        fragment.appendChild(opt);
      }
      if (uiRefs.humanEditArtifactSelector)
        uiRefs.humanEditArtifactSelector.appendChild(fragment);
      const selectArtifact = (id) => {
        /* ... logic from previous */
      };
      if (uiRefs.humanEditArtifactSelector)
        uiRefs.humanEditArtifactSelector.onchange = () =>
          selectArtifact(uiRefs.humanEditArtifactSelector.value);
      const metaToEdit = artifactIdToEdit
        ? StateManager.getArtifactMetadata(artifactIdToEdit)
        : null;
      const initialId =
        artifactIdToEdit &&
        ((metaToEdit && metaToEdit.latestCycle >= 0) ||
          artifactIdToEdit === "full_html_source")
          ? artifactIdToEdit
          : relevantArtifacts[0]?.id;
      if (initialId && uiRefs.humanEditArtifactSelector) {
        uiRefs.humanEditArtifactSelector.value = initialId;
        selectArtifact(initialId);
      } else if (uiRefs.humanEditArtifactTextarea) {
        uiRefs.humanEditArtifactTextarea.value =
          "(No editable artifacts found)";
        uiRefs.humanEditArtifactTextarea.removeAttribute(
          "data-current-artifact-id"
        );
        uiRefs.humanEditArtifactTextarea.removeAttribute(
          "data-current-artifact-cycle"
        );
        uiRefs.humanEditArtifactTextarea.removeAttribute(
          "data-current-artifact-version-id"
        );
      }
      focusElement =
        uiRefs.humanEditArtifactSelector || uiRefs.humanEditArtifactTextarea;
    } else {
      activeModeContainer = uiRefs.hitlPromptMode;
      if (uiRefs.humanCritiqueInput) {
        uiRefs.humanCritiqueInput.value = "";
        uiRefs.humanCritiqueInput.placeholder = `Provide feedback or next instructions related to: ${Utils.trunc(
          reason,
          80
        )}`;
        focusElement = uiRefs.humanCritiqueInput;
      }
    }
    if (activeModeContainer) activeModeContainer.classList.remove("hidden");
    if (focusElement) focusElement.focus();
    if (uiRefs.humanInterventionSection)
      uiRefs.humanInterventionSection.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
  };

  const hideMetaSandbox = () => {
    if (!uiRefs.metaSandboxContainer) return;
    uiRefs.metaSandboxContainer.classList.add("hidden");
    metaSandboxPending = false;
    const humanInterventionVisible =
      !uiRefs.humanInterventionSection?.classList.contains("hidden");
    const isCycleRunning = CycleLogic ? CycleLogic.isRunning() : false;
    const isAutonomousRunning = CycleLogic ? CycleLogic.isAutonomous() : false;
    if (
      !humanInterventionVisible &&
      uiRefs.runCycleButton &&
      !isCycleRunning &&
      !isAutonomousRunning
    )
      setRunButtonState("Run Cycle", false);
    if (uiRefs.autonomyStartStopButton && !isCycleRunning)
      setAutonomyButtonState(!isAutonomousRunning, false);
  };

  const showMetaSandbox = (htmlSource) => {
    if (
      !uiRefs.metaSandboxContainer ||
      !uiRefs.metaSandboxOutput ||
      !StateManager
    )
      return;
    const state = StateManager.getState();
    if (!state) return;
    highlightCoreStep(6);
    hideHumanInterventionUI();
    uiRefs.metaSandboxContainer.classList.remove("hidden");
    const fieldset = uiRefs.metaSandboxContainer.querySelector("fieldset");
    if (fieldset) fieldset.classList.remove("collapsed");
    if (uiRefs.runCycleButton) setRunButtonState("Run Cycle", true);
    if (uiRefs.autonomyStartStopButton) setAutonomyButtonState(false, true);
    const iframe = uiRefs.metaSandboxOutput;
    try {
      if (!iframe.contentWindow)
        throw new Error("Meta sandbox iframe contentWindow is not accessible.");
      const doc = iframe.contentWindow.document;
      doc.open();
      doc.write(htmlSource);
      doc.close();
      logger.logEvent("info", "Meta sandbox rendered for approval.");
      metaSandboxPending = true;
      logToTimeline(
        state.totalCycles,
        "[STATE] Meta-Sandbox Ready for Review.",
        "state",
        true
      );
      uiRefs.metaSandboxContainer.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    } catch (e) {
      logger.logEvent("error", `Cannot render meta sandbox: ${e.message}`, e);
      showNotification("Error: Failed to show meta sandbox preview.", "error");
      logToTimeline(
        state.totalCycles,
        "[ERROR] Meta-Sandbox failed to render.",
        "error",
        true
      );
      hideMetaSandbox();
      if (uiRefs.runCycleButton) setRunButtonState("Run Cycle", false);
    }
  };

  const loadPromptsFromLS = () => {
    if (
      !uiRefs.seedPromptCore ||
      !uiRefs.seedPromptCritique ||
      !uiRefs.seedPromptSummarize ||
      !uiRefs.seedPromptEvaluator
    ) {
      logger.logEvent("warn", "Prompt textareas not found during UI init.");
      return;
    }
    uiRefs.seedPromptCore.value =
      Storage.getArtifactContent("reploid.core.sys-prompt", 0) || "";
    uiRefs.seedPromptCritique.value =
      Storage.getArtifactContent("reploid.core.critiquer-prompt", 0) || "";
    uiRefs.seedPromptSummarize.value =
      Storage.getArtifactContent("reploid.core.summarizer-prompt", 0) || "";
    uiRefs.seedPromptEvaluator.value =
      Storage.getArtifactContent("reploid.core.evaluator-prompt", 0) || "";
    logger.logEvent("debug", "Loaded prompts from LS into UI.");
  };

  const loadCoreLoopSteps = () => {
    highlightCoreStep(activeCoreStepIdx);
    logger.logEvent("debug", "Initialized core loop steps minimap.");
  };

  const populateModelSelectors = () => {
    [uiRefs.coreModelSelector, uiRefs.critiqueModelSelector].forEach(
      (selector) => {
        if (!selector) return;
        selector.innerHTML = "";
        const fragment = document.createDocumentFragment();
        APP_MODELS.forEach((modelName) => {
          const option = document.createElement("option");
          option.value = modelName;
          option.textContent = modelName.split("/").pop();
          fragment.appendChild(option);
        });
        selector.appendChild(fragment);
      }
    );
  };

  const handleConfigChange = (key, value) => {
    const state = StateManager?.getState();
    if (!state) return;
    if (!state.cfg) state.cfg = {};
    if (state.cfg[key] !== value) {
      state.cfg[key] = value;
      logger.logEvent("info", `UI Config Update: ${key} = ${value}`);
      if (key === "maxCycles" && uiRefs.maxCyclesDisplay)
        uiRefs.maxCyclesDisplay.textContent =
          value === 0 ? "Inf" : String(value);
      if (key === "htmlHistoryLimit") updateHtmlHistoryControls(state);
      StateManager.save();
      updateFieldsetSummaries(state);
    }
  };

  const _setupControlButtonListeners = () => {
    uiRefs.runCycleButton?.addEventListener("click", () => {
      if (CycleLogic.isRunning()) CycleLogic.abortCurrentCycle();
      else CycleLogic.executeCycle();
    });
    uiRefs.forceHumanReviewButton?.addEventListener("click", () => {
      const state = StateManager?.getState();
      if (state) {
        state.forceHumanReview = true;
        showNotification("Next cycle will pause for Human Review.", "info");
        logToTimeline(
          state.totalCycles || 0,
          "[HUMAN] User forced Human Review.",
          "human"
        );
        StateManager.save();
      }
    });
    uiRefs.downloadLogButton?.addEventListener("click", () => {
      try {
        const logData = logger.getLogBuffer
          ? logger.getLogBuffer()
          : "(Log buffer unavailable)";
        const blob = new Blob([logData], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `x0_log_${new Date()
          .toISOString()
          .replace(/[:.]/g, "-")}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        logger.logEvent("info", "Log download initiated.");
      } catch (e) {
        logger.logEvent("error", `Log download failed: ${e.message}`, e);
        showNotification(`Log download failed: ${e.message}`, "error");
      }
    });
    uiRefs.exportStateButton?.addEventListener("click", () =>
      StateManager?.exportState(uiRefs)
    );
    uiRefs.summarizeContextButton?.addEventListener("click", () =>
      CycleLogic?.handleSummarizeContext()
    );
    uiRefs.importStateButton?.addEventListener("click", () =>
      uiRefs.importFileInput?.click()
    );
    uiRefs.importFileInput?.addEventListener("change", (event) => {
      const file = event.target.files?.[0];
      if (file && StateManager) {
        StateManager.importState(file, (success, importedData, errorMsg) => {
          if (success && importedData) {
            if (uiRefs.timelineLog)
              uiRefs.timelineLog.innerHTML = importedData.timelineHTML || "";
            clearCurrentCycleDetails();
            populateModelSelectors();
            updateStateDisplay();
            displayGenesisState();
            loadPromptsFromLS();
            loadCoreLoopSteps();
            logToTimeline(
              importedData.totalCycles,
              "[STATE] State imported.",
              "state"
            );
            showNotification(
              "State imported. Ensure required artifacts exist in localStorage.",
              "info"
            );
          } else {
            showNotification(
              `Import failed: ${errorMsg || "Unknown error"}`,
              "error"
            );
            logToTimeline(
              StateManager?.getState()?.totalCycles ?? 0,
              `[STATE] State import failed: ${errorMsg || "Unknown"}`,
              "error"
            );
          }
          if (uiRefs.importFileInput) uiRefs.importFileInput.value = "";
        });
      }
    });
    uiRefs.goBackButton?.addEventListener("click", () => {
      const state = StateManager?.getState();
      if (!state?.htmlHistory?.length) {
        showNotification("No history.", "warn");
        return;
      }
      if (
        !confirm("Revert page to previous version? State will attempt restore.")
      )
        return;
      const prevStateHtml = state.htmlHistory.pop();
      updateHtmlHistoryControls(state);
      logger.logEvent(
        "info",
        `Reverting page HTML. History size: ${state.htmlHistory.length}`
      );
      logToTimeline(
        state.totalCycles,
        "[STATE] Reverting HTML (Page Reload).",
        "state"
      );
      try {
        const stateToPreserve = StateManager.capturePreservationState(uiRefs);
        Storage.saveSessionState(stateToPreserve);
        document.open();
        document.write(prevStateHtml);
        document.close();
      } catch (e) {
        logger.logEvent("error", `Go Back failed: ${e.message}`, e);
        showNotification(`Go Back failed: ${e.message}`, "error");
        Storage.removeSessionState();
        if (state.htmlHistory && prevStateHtml)
          state.htmlHistory.push(prevStateHtml);
        updateHtmlHistoryControls(state);
        StateManager.save();
      }
    });
    uiRefs.clearLocalStorageButton?.addEventListener("click", () => {
      if (
        !confirm(
          "WARNING: Delete ALL Reploid data from LocalStorage? Cannot be undone."
        )
      )
        return;
      try {
        Storage.clearAllReploidData();
        showNotification("LocalStorage cleared. Reloading...", "info", 0);
        setTimeout(() => window.location.reload(), 1000);
      } catch (e) {
        logger.logEvent(
          "error",
          `Error clearing LocalStorage: ${e.message}`,
          e
        );
        showNotification(`Error clearing LocalStorage: ${e.message}`, "error");
      }
    });
  };

  const _setupHitlButtonListeners = () => {
    uiRefs.submitCritiqueButton?.addEventListener("click", () => {
      if (CycleLogic.proceedAfterHumanIntervention && uiRefs.humanCritiqueInput)
        CycleLogic.proceedAfterHumanIntervention(
          "Human Prompt",
          uiRefs.humanCritiqueInput.value.trim()
        );
    });
    uiRefs.submitHitlOptionsButton?.addEventListener("click", () => {
      if (CycleLogic.proceedAfterHumanIntervention && uiRefs.hitlOptionsList) {
        const selected = Array.from(
          uiRefs.hitlOptionsList.querySelectorAll("input:checked")
        )
          .map((el) => el.value)
          .join(", ");
        CycleLogic.proceedAfterHumanIntervention(
          "Human Options",
          selected || "None"
        );
      }
    });
    uiRefs.submitHumanCodeEditButton?.addEventListener("click", async () => {
      if (
        !CycleLogic.runTool ||
        !CycleLogic.proceedAfterHumanIntervention ||
        !uiRefs.humanEditArtifactTextarea ||
        !StateManager
      )
        return;
      const artifactId = uiRefs.humanEditArtifactTextarea.getAttribute(
        "data-current-artifact-id"
      );
      const cycleStr = uiRefs.humanEditArtifactTextarea.getAttribute(
        "data-current-artifact-cycle"
      );
      const versionId =
        uiRefs.humanEditArtifactTextarea.getAttribute(
          "data-current-artifact-version-id"
        ) || null;
      const newContent = uiRefs.humanEditArtifactTextarea.value;
      const state = StateManager.getState();
      if (!state) return;
      if (!artifactId || cycleStr === null) {
        showNotification(
          "Error: No artifact selected or cycle info missing.",
          "error"
        );
        return;
      }
      const cycle = parseInt(cycleStr, 10);
      if (isNaN(cycle)) {
        showNotification("Error: Invalid cycle number for artifact.", "error");
        return;
      }
      updateStatus("Validating Edit...", true);
      try {
        const toolResult = await CycleLogic.runTool("code_edit", {
          artifactId,
          cycle,
          versionId,
          newContent,
        });
        updateStatus("Idle");
        if (toolResult?.success) {
          showNotification(
            `Edit for ${artifactId} validated. Proceeding...`,
            "info"
          );
          CycleLogic.proceedAfterHumanIntervention(
            "Human Code Edit",
            toolResult
          );
        } else {
          showNotification(
            `Edit Validation Failed: ${
              toolResult?.error || "Unknown validation error"
            }`,
            "error"
          );
          logger.logEvent(
            "error",
            `Human edit validation failed for ${artifactId}: ${toolResult?.error}`
          );
        }
      } catch (e) {
        updateStatus("Idle");
        logger.logEvent(
          "error",
          `Error running code_edit tool for ${artifactId}: ${e.message}`,
          e
        );
        showNotification(`Error validating edit: ${e.message}`, "error");
      }
    });
    uiRefs.submitCritiqueFeedbackButton?.addEventListener("click", () => {
      if (!CycleLogic.proceedAfterHumanIntervention || !StateManager) return;
      const selectedCritiqueIndex = uiRefs.hitlCritiqueSelection?.querySelector(
        'input[name="critique_selection"]:checked'
      )?.value;
      const notes = uiRefs.hitlCritiqueNotes?.value.trim() || "";
      const feedbackData = {
        selectedCritique:
          selectedCritiqueIndex !== undefined
            ? parseInt(selectedCritiqueIndex, 10)
            : -1,
        feedbackNotes: notes,
      };
      StateManager.addCritiqueFeedback(feedbackData);
      CycleLogic.proceedAfterHumanIntervention(
        "Human Critique Selection",
        feedbackData
      );
    });
  };

  const _setupSandboxButtonListeners = () => {
    uiRefs.approveMetaChangeButton?.addEventListener("click", () => {
      const state = StateManager?.getState();
      if (metaSandboxPending && state?.lastGeneratedFullSource) {
        const sourceToApply = state.lastGeneratedFullSource;
        logger.logEvent("info", "Approved meta-change.");
        logToTimeline(
          state.totalCycles,
          "[STATE] Approved Meta-Sandbox. Applying & Reloading...",
          "state",
          true
        );
        hideMetaSandbox();
        const currentHtml = document.documentElement.outerHTML;
        CycleLogic?.saveHtmlToHistory(currentHtml);
        const stateToPreserve = StateManager.capturePreservationState(uiRefs);
        stateToPreserve.metaSandboxPending = false;
        try {
          Storage.saveSessionState(stateToPreserve);
          document.open();
          document.write(sourceToApply);
          document.close();
        } catch (e) {
          logger.logEvent("error", `Apply meta-change failed: ${e.message}`, e);
          showNotification(`Apply failed: ${e.message}`, "error");
          Storage.removeSessionState();
          if (state?.htmlHistory?.length > 0) state.htmlHistory.pop();
          updateHtmlHistoryControls(state);
          metaSandboxPending = true;
          showMetaSandbox(sourceToApply);
          if (uiRefs.runCycleButton) setRunButtonState("Run Cycle", true);
        }
      } else
        showNotification(
          "No sandbox content pending or state missing.",
          "warn"
        );
    });
    uiRefs.discardMetaChangeButton?.addEventListener("click", () => {
      const state = StateManager?.getState();
      logger.logEvent("info", "Discarded meta-sandbox changes.");
      logToTimeline(
        state?.totalCycles || 0,
        "[STATE] Discarded Meta-Sandbox changes.",
        "warn",
        true
      );
      hideMetaSandbox();
      if (state) state.lastGeneratedFullSource = null;
      CycleLogic?.proceedAfterHumanIntervention(
        "Sandbox Discarded",
        "User discarded changes",
        true
      );
    });
  };

  const _setupConfigInputListeners = () => {
    uiRefs.lsdPersonaPercentInput?.addEventListener("input", () => {
      const lsdInput = uiRefs.lsdPersonaPercentInput;
      const xyzInput = uiRefs.xyzPersonaPercentInput;
      if (!lsdInput || !xyzInput) return;
      let lsd = parseInt(lsdInput.value, 10) || 0;
      lsd = Math.max(0, Math.min(100, lsd));
      lsdInput.value = lsd;
      xyzInput.value = 100 - lsd;
      handleConfigChange("personaBalance", lsd);
    });
    const defaultConfig = config.DEFAULT_CFG || {};
    Object.keys(defaultConfig).forEach((key) => {
      if (
        key === "personaBalance" ||
        key === "coreModel" ||
        key === "critiqueModel"
      )
        return;
      const inputId = Utils.camelToKabob(key) + "-input";
      const inputEl = uiRefs[Utils.kabobToCamel(inputId)];
      if (inputEl) {
        inputEl.addEventListener("change", (e) => {
          const target = e.target;
          let value;
          if (target.type === "number") {
            value =
              target.step === "any" || target.step?.includes(".")
                ? parseFloat(target.value)
                : parseInt(target.value, 10);
            const min = parseFloat(target.min);
            const max = parseFloat(target.max);
            if (!isNaN(min) && value < min) value = min;
            if (!isNaN(max) && value > max) value = max;
            target.value = value;
          } else value = target.value;
          handleConfigChange(key, value);
        });
      }
    });
    uiRefs.coreModelSelector?.addEventListener("change", (e) =>
      handleConfigChange("coreModel", e.target.value)
    );
    uiRefs.critiqueModelSelector?.addEventListener("change", (e) =>
      handleConfigChange("critiqueModel", e.target.value)
    );
    uiRefs.apiKeyInput?.addEventListener("change", (e) =>
      handleConfigChange("apiKey", e.target.value.trim())
    );
  };

  const _setupAutonomyListeners = () => {
    uiRefs.autonomyModeSelector?.addEventListener("change", (e) => {
      const mode = e.target.value;
      const state = StateManager.getState();
      if (state) {
        state.autonomyMode = mode;
        if (mode !== "N_Cycles") state.autonomyCyclesRemaining = 0;
        StateManager.save();
        updateAutonomyControls(mode, false);
        updateStateDisplay();
      }
    });
    uiRefs.autonomyNCyclesInput?.addEventListener("change", (e) => {
      const state = StateManager.getState();
      if (state && state.autonomyMode === "N_Cycles") {
        let cycles = parseInt(e.target.value, 10);
        cycles = Math.max(1, isNaN(cycles) ? 1 : cycles);
        state.autonomyCyclesRemaining = cycles;
        e.target.value = cycles;
        StateManager.save();
      }
    });
    uiRefs.autonomyStartStopButton?.addEventListener("click", () => {
      const state = StateManager.getState();
      if (!state) return;
      if (CycleLogic.isAutonomous())
        CycleLogic.stopAutonomousRun("User Stop Request");
      else {
        const mode = state.autonomyMode || "Manual";
        const cycles = parseInt(uiRefs.autonomyNCyclesInput?.value || "5", 10);
        if (mode === "Manual")
          showNotification(
            "Select 'Run N Cycles' or 'Continuous' mode first.",
            "warn"
          );
        else if (mode === "N_Cycles" && (isNaN(cycles) || cycles <= 0))
          showNotification(
            "Please enter a valid number of cycles > 0.",
            "warn"
          );
        else CycleLogic.startAutonomousRun(mode, cycles);
      }
    });
  };

  const updateAutonomyControls = (mode, isRunning) => {
    const nCyclesInput = uiRefs.autonomyNCyclesInput;
    const nCyclesLabel = uiRefs.autonomyNLabel;
    const startStopButton = uiRefs.autonomyStartStopButton;
    if (nCyclesInput && nCyclesLabel) {
      const showNCycles = mode === "N_Cycles";
      nCyclesInput.classList.toggle("hidden", !showNCycles);
      nCyclesLabel.classList.toggle("hidden", !showNCycles);
      nCyclesInput.disabled = isRunning && mode === "N_Cycles";
    }
    if (startStopButton) {
      startStopButton.disabled =
        mode === "Manual" || (CycleLogic?.isRunning() && !isRunning);
      startStopButton.textContent = isRunning
        ? "Stop Autonomous Run"
        : "Start Autonomous Run";
    }
    setRunButtonState(
      uiRefs.runCycleButton?.textContent || "Run Cycle",
      isRunning || (CycleLogic?.isRunning() && !isRunning)
    );
  };

  const setRunButtonState = (text, disabled) => {
    if (uiRefs.runCycleButton) {
      uiRefs.runCycleButton.textContent = text;
      uiRefs.runCycleButton.disabled = disabled;
    }
  };

  const setAutonomyButtonState = (isRunning, disabled) => {
    if (uiRefs.autonomyStartStopButton) {
      uiRefs.autonomyStartStopButton.textContent = isRunning
        ? "Stop Autonomous Run"
        : "Start Autonomous Run";
      uiRefs.autonomyStartStopButton.disabled = disabled;
    }
    if (uiRefs.autonomyModeSelector)
      uiRefs.autonomyModeSelector.disabled = disabled || isRunning;
    if (uiRefs.autonomyNCyclesInput)
      uiRefs.autonomyNCyclesInput.disabled = disabled || isRunning;
  };

  const _setupFieldsetListeners = () => {
    document.querySelectorAll("fieldset legend").forEach((legend) => {
      legend.addEventListener("click", (event) => {
        if (event.target.closest("button, input, a, select, textarea")) return;
        const fieldset = legend.closest("fieldset");
        fieldset?.classList.toggle("collapsed");
      });
    });
  };

  const setupEventListeners = () => {
    if (!isInitialized || !CycleLogic || !StateManager) {
      logger.logEvent(
        "error",
        "UI elements or core logic refs not ready for event listeners."
      );
      return;
    }
    _setupControlButtonListeners();
    _setupHitlButtonListeners();
    _setupSandboxButtonListeners();
    _setupConfigInputListeners();
    _setupAutonomyListeners();
    _setupFieldsetListeners();
    logger.logEvent("info", "UI Event listeners set up.");
  };

  const _loadInitialUIData = () => {
    const state = StateManager?.getState();
    if (!state) {
      logger.logEvent("error", "Cannot load initial UI data, state is null.");
      return;
    }
    updateStateDisplay();
    displayGenesisState();
    loadPromptsFromLS();
    loadCoreLoopSteps();
    document.querySelectorAll("fieldset").forEach((fs) => {
      if (fs.id !== "controls-fieldset" && fs.id !== "current-cycle-details")
        fs.classList.add("collapsed");
      else fs.classList.remove("collapsed");
    });
    if (state) updateFieldsetSummaries(state);
    logToTimeline(
      state?.totalCycles || 0,
      "[STATE] System Initialized.",
      "state"
    );
  };

  const restoreUIState = (preservedData) => {
    if (!isInitialized || !uiRefs.timelineLog) {
      logger.logEvent(
        "warn",
        "Cannot restore UI state, UI not fully initialized or timeline missing."
      );
      return;
    }
    metaSandboxPending = preservedData.metaSandboxPending || false;
    if (uiRefs.timelineLog)
      uiRefs.timelineLog.innerHTML = preservedData.timelineHTML || "";
    populateModelSelectors();
    updateStateDisplay();
    displayGenesisState();
    loadPromptsFromLS();
    loadCoreLoopSteps();
    logToTimeline(
      preservedData.totalCycles,
      "[STATE] Restored after self-mod.",
      "state"
    );
    const isAutonomousRunning = preservedData.autonomyMode !== "Manual";
    setRunButtonState("Run Cycle", metaSandboxPending || isAutonomousRunning);
    setAutonomyButtonState(isAutonomousRunning, metaSandboxPending);
    updateStatus(metaSandboxPending ? "Meta Sandbox Pending..." : "Idle");
    document.querySelectorAll("fieldset").forEach((fs) => {
      if (
        !fs.classList.contains("collapsed") &&
        fs.id !== "controls-fieldset" &&
        fs.id !== "current-cycle-details"
      )
        fs.classList.add("collapsed");
    });
    if (preservedData) updateFieldsetSummaries(preservedData);
    logger.logEvent("info", "UI state restored from session data.");
  };

  const init = (injectedStateManager, injectedCycleLogic) => {
    if (isInitialized) return;
    logger.logEvent("info", "Initializing UI Module...");
    StateManager = injectedStateManager;
    CycleLogic = injectedCycleLogic;
    if (!StateManager || !CycleLogic) {
      logger.logEvent(
        "error",
        "UI Init failed: StateManager or CycleLogic not provided."
      );
      return;
    }
    initializeUIElementReferences();
    populateModelSelectors();
    isInitialized = true;
    const restored = StateManager.restoreStateFromSession(restoreUIState);
    if (!restored) _loadInitialUIData();
    setupEventListeners();
    highlightCoreStep(-1);
    updateStatus("Idle");
    logger.logEvent("info", "UI Module initialization complete.");
  };

  return {
    init,
    updateStatus,
    updateApiProgress,
    updateStreamingOutput,
    clearStreamingOutput,
    highlightCoreStep,
    showNotification,
    logToTimeline,
    logCoreLoopStep,
    updateTimelineItem,
    summarizeCompletedCycleLog,
    clearCurrentCycleDetails,
    displayCycleArtifact,
    displayToolExecutionSummary,
    hideHumanInterventionUI,
    showHumanInterventionUI,
    hideMetaSandbox,
    showMetaSandbox,
    updateStateDisplay,
    updateAutonomyControls,
    setRunButtonState,
    getRefs: () => uiRefs,
    isMetaSandboxPending: () => metaSandboxPending,
    isHumanInterventionHidden: () =>
      uiRefs.humanInterventionSection?.classList.contains("hidden") ?? true,
  };
};

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: ui-style.css ---
:root {
  --bg: black;
  --fg: white;
  --bdr: white;
  --pad-in: 10px;
  --pad-btn: 10px 18px;
  --pad-fs: 20px;
  --gap-n: 18px;
  --gap-s: 8px;
  --f-sz-n: 1em;
  --f-sz-l: 1.5em;
  --f-sz-xl: 2em;
  --ctx-warn: 900000;
  --bdr-mod: 2px dashed yellow;
  --bdr-in: 1px dotted var(--bdr);
  --bdr-out: 1px solid var(--bdr);
  --bdr-inf: 1px dashed gray;
  --bdr-err: 1px solid red;
  --highlight-bg: #2a2a2a;
}
*,
*::before,
*::after {
  box-sizing: border-box;
}
body {
  font-family: monospace;
  background-color: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: var(--pad-fs);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  font-size: var(--f-sz-n);
  line-height: 1.5;
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
h1,
h2,
h3 {
  border-bottom: 2px solid var(--bdr);
  padding-bottom: var(--gap-s);
  margin-top: 30px;
  margin-bottom: var(--gap-n);
  font-weight: bold;
  line-height: 1.3;
}
h1 {
  font-size: var(--f-sz-xl);
  text-align: center;
}
h1 small {
  font-size: 0.45em;
  display: block;
  font-weight: normal;
  margin-top: 5px;
  color: gray;
  line-height: 1.2;
}
h2 {
  font-size: var(--f-sz-l);
}
h3 {
  font-size: 1.2em;
  border-bottom-width: 1px;
  margin-top: var(--gap-n);
  margin-bottom: 15px;
}
h4 {
  font-size: 1.1em;
  margin-bottom: 10px;
  margin-top: 15px;
}

fieldset {
  border: 2px solid var(--bdr);
  padding: 0;
  margin-bottom: 30px;
  background-color: var(--bg);
}
fieldset > .content-wrapper {
  padding: var(--pad-fs);
}
legend {
  font-weight: bold;
  font-size: 1.3em;
  padding: 5px 10px 5px 15px;
  margin-left: 15px;
  background-color: var(--bg);
  color: var(--fg);
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  flex-wrap: wrap;
}
legend .toggle-icon {
  margin-right: 10px;
  font-size: 1em;
  width: 15px;
  display: inline-block;
  text-align: center;
  font-weight: bold;
}
legend .summary-line {
  display: none;
  font-size: 0.7em;
  font-weight: normal;
  color: gray;
  margin-left: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
  min-width: 100px;
}
fieldset.collapsed > .content-wrapper {
  display: none;
}
fieldset.collapsed > legend .summary-line {
  display: inline;
}
fieldset.collapsed > legend .toggle-icon::before {
  content: "+";
}
fieldset:not(.collapsed) > legend .toggle-icon::before {
  content: "-";
}

label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  flex-shrink: 0;
  text-align: right;
  min-width: 150px;
  padding-right: 10px;
  line-height: 1.3;
}
textarea,
pre,
input[type="text"],
input[type="number"],
input[type="password"],
select {
  background-color: var(--bg);
  color: var(--fg);
  border: 1px solid var(--bdr);
  padding: var(--pad-in);
  width: 100%;
  font-family: inherit;
  margin-bottom: 15px;
  box-sizing: border-box;
  font-size: 1em;
  max-width: 100%;
}
textarea {
  min-height: 150px;
  line-height: 1.5;
  resize: vertical;
}
#goal-input {
  min-height: 100px;
}
#seed-prompts .flex-col {
  display: flex;
  flex-direction: column;
  height: auto;
}
#seed-prompts .flex-col:nth-child(2) {
  flex-grow: 1;
}
#seed-prompt-core,
#seed-prompt-evaluator {
  flex-grow: 1;
  height: 100%;
  min-height: 300px;
  background-color: #080808;
}
#seed-prompt-evaluator {
  min-height: 100px;
}

pre {
  min-height: 50px;
  max-height: 300px;
  overflow: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  border: var(--bdr-inf);
  padding: 10px;
  margin-bottom: 15px;
  background-color: #040404;
}
pre[class*="language-"] {
  background-color: var(--highlight-bg) !important;
  border: 1px solid #444 !important;
  padding: 1em !important;
  margin: 0.5em 0 !important;
  overflow: auto !important;
}
code[class*="language-"],
pre[class*="language-"] {
  color: #ccc !important;
}

.artifact-display pre {
  border: var(--bdr-out);
  background-color: var(--bg);
}
.artifact-display pre.modified {
  border: var(--bdr-mod);
  font-weight: bold;
  background-color: #111100;
}
.artifact-display pre.input {
  border: var(--bdr-in);
  opacity: 0.8;
  background-color: #0a0a0a;
}
.artifact-display pre.info {
  border: var(--bdr-inf);
}
.artifact-display pre.error {
  border: var(--bdr-err);
  color: red;
  background-color: #180000;
}
.artifact-label {
  display: block;
  font-weight: bold;
  margin-bottom: 5px;
  font-size: 0.9em;
  text-transform: uppercase;
  color: gray;
}
.artifact-label .type-indicator {
  font-weight: normal;
  margin-right: 5px;
  background-color: #333;
  color: #ccc;
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 0.9em;
  display: inline-block;
}
.artifact-label .change-indicator {
  color: yellow;
  font-weight: bold;
  margin-left: 5px;
}
.artifact-label .source-indicator {
  color: cyan;
  font-size: 0.9em;
  margin-left: 5px;
  font-style: italic;
}
#streaming-output-container {
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-s);
}
#streaming-output-pre {
  min-height: 50px;
  max-height: 250px;
  overflow-y: auto;
  background-color: #050505;
  border: 1px solid #444;
  white-space: pre-wrap;
  word-wrap: break-word;
  padding: 10px;
  font-size: 0.95em;
}
input[type="number"],
select {
  width: auto;
  min-width: 80px;
  padding: 8px 10px;
}
.cfg-item input[type="number"] {
  max-width: 90px;
  text-align: right;
}
button {
  background-color: var(--bg);
  color: var(--fg);
  border: 2px solid var(--bdr);
  padding: var(--pad-btn);
  cursor: pointer;
  margin: 0;
  font-family: inherit;
  font-size: 1em;
  font-weight: bold;
  transition: background-color 0.2s, color 0.2s;
}
button:hover:not(:disabled) {
  background-color: var(--fg);
  color: var(--bg);
}
button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.flex-row {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: var(--gap-n);
  margin-bottom: var(--gap-n);
  align-items: stretch;
}
.flex-col {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 280px;
}
.cfg-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 10px var(--gap-s);
  align-items: baseline;
}
.cfg-item {
  display: flex;
  align-items: baseline;
  gap: var(--gap-s);
  flex-wrap: wrap;
}
.cfg-item label {
  margin-bottom: 0;
  flex-basis: 150px;
  flex-shrink: 0;
  font-size: 0.9em;
}
.cfg-item input,
.cfg-item select {
  flex-grow: 1;
  width: auto;
  min-width: 60px;
  margin-bottom: 0;
}
.persona-inputs {
  display: flex;
  gap: 5px;
  flex-grow: 1;
}
.persona-inputs input {
  min-width: 50px;
  text-align: right;
}
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: var(--gap-s);
  margin-top: var(--gap-n);
}
.metric-item {
  border: 1px solid var(--bdr);
  padding: 6px 10px;
  background-color: var(--bg);
  font-size: 0.9em;
  text-align: center;
  line-height: 1.2;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.metric-item strong {
  display: block;
  font-size: 1.1em;
  margin-top: 2px;
  word-break: break-word;
}
#core-metrics-display {
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
}
#rolling-metrics-display {
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
}
.timeline {
  list-style-type: none;
  padding: 0;
  max-height: 800px;
  overflow-y: auto;
  border: 2px solid var(--bdr);
  background-color: var(--bg);
  margin-top: var(--gap-s);
}
.timeline li {
  border-bottom: 1px solid var(--bdr);
  padding: 8px var(--gap-n) 8px 15px;
  margin-bottom: 0;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  cursor: default;
}
.timeline li:last-child {
  border-bottom: none;
}
.timeline li.summary {
  background-color: #111;
  font-size: 0.9em;
  color: #ccc;
  cursor: pointer;
}
.timeline li.summary:hover {
  background-color: #222;
  color: var(--fg);
}
.timeline li.core-step {
  padding-left: var(--gap-n);
  font-weight: bold;
  background-color: #080808;
  margin-top: 5px;
  border-top: 1px dashed gray;
}
.timeline li.sub-step {
  padding-left: 45px;
  font-size: 0.95em;
  opacity: 0.9;
}
.timeline li::before {
  content: attr(data-cycle);
  background-color: var(--fg);
  color: var(--bg);
  padding: 3px 6px;
  border-radius: 0;
  font-size: 0.85em;
  font-weight: bold;
  flex-shrink: 0;
  align-self: flex-start;
  margin-top: 2px;
}
.timeline li .log-icon {
  font-size: 1.1em;
  width: 20px;
  text-align: center;
  flex-shrink: 0;
  display: inline-block;
  margin-top: 2px;
}
.timeline li span:last-child {
  flex-grow: 1;
  line-height: 1.4;
  word-break: break-word;
}
.timeline .animated-icon {
  animation: spin 1s linear infinite;
  display: inline-block;
}
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
#meta-sandbox-output {
  width: 100%;
  min-height: 500px;
  border: 1px solid var(--bdr);
  background-color: var(--fg);
  margin-top: 15px;
}
.hidden {
  display: none !important;
}
.api-key-input {
  display: flex;
  align-items: baseline;
  gap: var(--gap-s);
  flex-grow: 1;
  flex-wrap: wrap;
}
.api-key-input label {
  flex-basis: 180px;
  flex-shrink: 0;
}
.api-key-input input {
  flex-grow: 1;
  margin-bottom: 0;
  min-width: 200px;
}
.controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: var(--gap-s);
  align-items: center;
  margin-top: 15px;
}
.state-io-buttons {
  display: contents;
}
.artifact-section {
  margin-bottom: var(--gap-n);
  padding-bottom: var(--gap-n);
  border-bottom: 1px dotted gray;
}
.artifact-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}
.artifact-collection {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: var(--gap-n);
}
.hitl-container {
  border: 1px dashed yellow;
  padding: 0;
  margin-top: 15px;
  background-color: #111;
}
.hitl-container h3 {
  color: yellow;
  border-color: yellow;
  margin-top: 0;
}
.hitl-options label {
  display: block;
  margin-bottom: 8px;
  cursor: pointer;
  font-weight: normal;
}
.hitl-options input[type="checkbox"] {
  margin-right: 8px;
}
#human-edit-artifact-textarea {
  min-height: 150px;
  width: 100%;
  margin-top: 10px;
  background-color: #1a1a1a;
  resize: vertical;
}
#meta-sandbox-container {
  border: 2px dashed cyan;
  padding: 0;
  margin-top: 15px;
  background-color: #001111;
}
#meta-sandbox-container h3 {
  color: cyan;
  border-color: cyan;
  margin-top: 0;
}
#meta-sandbox-output {
  border-color: cyan;
}
.meta-sandbox-controls {
  margin-top: 15px;
}
#genesis-state-display {
  border-style: dotted;
  opacity: 0.8;
  padding: 0;
}
#genesis-state-display legend {
  color: gray;
}
.token-warning {
  color: yellow;
  font-weight: bold;
  border: 1px solid yellow;
  padding: 3px 6px;
  margin-left: 10px;
  display: inline-block;
  font-size: 0.9em;
  border-radius: 3px;
}
#status-indicator {
  border: 1px solid gray;
  padding: 5px 10px;
  margin-left: auto;
  display: inline-block;
  font-size: 0.9em;
  min-width: 150px;
  text-align: center;
  background-color: #111;
  order: 3;
  margin-top: 5px;
}
#status-indicator.active {
  border-color: yellow;
  color: yellow;
  font-weight: bold;
  background-color: #333300;
}
#api-progress {
  font-size: 0.8em;
  margin-left: 10px;
  display: inline-block;
  color: #aaa;
  order: 4;
  margin-top: 5px;
}
#app-root {
  visibility: hidden;
}
.goal-type-selector {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 10px;
  padding-left: 10px;
}
.goal-type-selector label {
  margin-bottom: 0;
  font-weight: normal;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  text-align: left;
  min-width: auto;
  padding-right: 0;
}
.goal-type-selector input[type="radio"] {
  margin-right: 5px;
}
.model-selectors {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-n);
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-n);
}
.model-selectors .cfg-item {
  flex-basis: calc(50% - var(--gap-n) / 2);
  min-width: 280px;
}
.model-selectors label {
  flex-basis: auto;
  min-width: 120px;
  text-align: left;
}
.model-selectors select {
  flex-grow: 1;
}
#notifications-container {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.notification {
  padding: 10px 15px;
  border-radius: 4px;
  color: black;
  font-size: 0.9em;
  opacity: 0.95;
  border-left: 5px solid transparent;
  word-wrap: break-word;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}
.notification.info {
  background-color: #e0f2f7;
  border-left-color: #29b6f6;
}
.notification.warn {
  background-color: #fff3e0;
  border-left-color: #ffa726;
}
.notification.error {
  background-color: #ffebee;
  border-left-color: #ef5350;
}
.notification button {
  float: right;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  font-size: 1.1em;
  line-height: 1;
  margin-left: 10px;
  padding: 0;
  opacity: 0.6;
}
.notification button:hover {
  opacity: 1;
}
#tools-executed-container {
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-s);
}
#tools-executed-list {
  list-style: none;
  padding-left: 0;
  font-size: 0.9em;
}
#tools-executed-list li {
  margin-bottom: 5px;
  padding: 5px;
  border: 1px dotted #444;
  background-color: #0a0a0a;
}
#tools-executed-list li.tool-success {
  border-left: 3px solid green;
}
#tools-executed-list li.tool-fail {
  border-left: 3px solid red;
  background-color: #180000;
}
#tools-executed-list strong {
  color: cyan;
}
#tools-executed-list .tool-args,
#tools-executed-list .tool-result,
#tools-executed-list .tool-error {
  display: block;
  margin-left: 15px;
  font-size: 0.95em;
  color: #bbb;
  word-break: break-all;
}
#tools-executed-list .tool-error {
  color: red;
}
.autonomy-controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-s) var(--gap-n);
  align-items: center;
  border-top: 1px dashed gray;
  padding-top: 15px;
  margin-top: 15px;
}
.autonomy-controls label {
  min-width: auto;
  text-align: left;
  margin-bottom: 0;
}
.autonomy-controls select,
.autonomy-controls input[type="number"] {
  width: auto;
  margin-bottom: 0;
}
.autonomy-controls button {
  margin-left: auto;
}
.autonomy-n-label {
  padding-left: 5px;
}

.cycle-steps-minimap {
  border: 1px solid #555;
  padding: 10px;
  background-color: #080808;
  font-size: 0.9em;
  max-height: 300px;
  overflow-y: auto;
  margin-bottom: 15px;
}
.cycle-steps-minimap ol {
  list-style-type: none;
  padding: 0;
  margin: 0;
}
.cycle-steps-minimap li {
  padding: 4px 0;
  border-bottom: 1px dotted #333;
}
.cycle-steps-minimap li:last-child {
  border-bottom: none;
}
.cycle-steps-minimap li.active-step {
  background-color: #222;
  font-weight: bold;
  color: yellow;
}
.cycle-steps-minimap .step-icon {
  display: inline-block;
  width: 20px;
  text-align: center;
  margin-right: 5px;
}

@media (max-width: 1024px) {
  :root {
    --f-sz-n: 0.95em;
    --pad-fs: 15px;
    --gap-n: 15px;
  }
  h1 {
    font-size: 1.8em;
  }
  h2 {
    font-size: 1.4em;
  }
  h3 {
    font-size: 1.15em;
  }
  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  }
  #core-metrics-display {
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  }
  .timeline {
    max-height: 600px;
  }
  .autonomy-controls button {
    margin-left: 0;
    width: 100%;
    margin-top: 10px;
  }
}
@media (max-width: 768px) {
  :root {
    --f-sz-n: 0.9em;
    --pad-fs: 10px;
    --gap-n: 12px;
    --gap-s: 6px;
    --pad-btn: 8px 14px;
  }
  body {
    padding: 10px;
  }
  h1 {
    font-size: 1.6em;
  }
  h1 small {
    font-size: 0.4em;
    line-height: 1.1;
  }
  h2 {
    font-size: 1.3em;
  }
  h3 {
    font-size: 1.1em;
  }
  legend {
    font-size: 1.2em;
    margin-left: 10px;
    padding: 4px 8px 4px 10px;
  }
  .flex-row {
    flex-direction: column;
  }
  .cfg-item {
    flex-direction: column;
    align-items: stretch;
    gap: 5px;
  }
  .cfg-item label {
    text-align: left;
    min-width: auto;
    margin-bottom: 3px;
    padding-right: 0;
    flex-basis: auto;
  }
  .cfg-item input,
  .cfg-item select {
    width: 100%;
  }
  .persona-inputs input {
    min-width: 60px;
  }
  .cfg-grid,
  .metrics-grid,
  .controls-grid {
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  }
  .api-key-input label {
    flex-basis: auto;
  }
  #status-indicator {
    margin-left: 10px;
  }
  .goal-type-selector {
    padding-left: 0;
  }
  .model-selectors .cfg-item {
    flex-basis: 100%;
  }
  .timeline {
    max-height: 500px;
  }
  .timeline li {
    padding: 6px 12px 6px 10px;
  }
}
@media (max-width: 480px) {
  :root {
    --f-sz-n: 0.85em;
  }
  h1 {
    font-size: 1.4em;
  }
  h1 small {
    display: none;
  }
  h2 {
    font-size: 1.2em;
  }
  h3 {
    font-size: 1.05em;
  }
  .cfg-grid,
  .metrics-grid,
  .controls-grid {
    grid-template-columns: 1fr;
  }
  .metric-item {
    font-size: 0.85em;
    padding: 4px 8px;
  }
  button {
    font-size: 0.95em;
    padding: 6px 10px;
  }
  .timeline li {
    gap: 6px;
  }
  .timeline li::before {
    font-size: 0.8em;
    padding: 2px 4px;
  }
  #status-indicator {
    min-width: 120px;
    font-size: 0.85em;
  }
  #api-progress {
    font-size: 0.75em;
  }
  #notifications-container {
    width: calc(100% - 20px);
    right: 10px;
    left: 10px;
  }
}

ðŸˆ --- CATS_END_FILE ---

ðŸˆ --- CATS_START_FILE: utils.js ---
const UtilsModule = (() => {
  // --- Custom Error Definitions ---
  class ApplicationError extends Error {
    constructor(message, details = {}) {
      super(message);
      this.name = this.constructor.name;
      this.details = details;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }

  class ApiError extends ApplicationError {
    constructor(message, status = null, code = null, apiDetails = {}) {
      super(message, { status, code, ...apiDetails });
      this.status = status;
      this.code = code;
    }
  }

  class ToolError extends ApplicationError {
    constructor(message, toolName = null, toolArgs = null, toolDetails = {}) {
      super(message, { toolName, toolArgs, ...toolDetails });
      this.toolName = toolName;
    }
  }

  class StateError extends ApplicationError {
    constructor(message, stateDetails = {}) {
      super(message, stateDetails);
    }
  }

  class ConfigError extends ApplicationError {
    constructor(message, configKey = null, configDetails = {}) {
      super(message, { configKey, ...configDetails });
      this.configKey = configKey;
    }
  }

  class ArtifactError extends ApplicationError {
    constructor(message, artifactId = null, artifactCycle = null, artifactDetails = {}) {
      super(message, { artifactId, artifactCycle, ...artifactDetails });
      this.artifactId = artifactId;
    }
  }

  class AbortError extends ApplicationError {
    constructor(message = "Operation aborted") {
      super(message);
      this.isAbortError = true;
    }
  }

  class WebComponentError extends ApplicationError {
    constructor(message, componentName = null, componentDetails = {}) {
      super(message, { componentName, ...componentDetails });
      this.componentName = componentName;
    }
  }

  const Errors = {
    ApplicationError, ApiError, ToolError, StateError,
    ConfigError, ArtifactError, AbortError, WebComponentError,
  };
  // --- End Custom Error Definitions ---

  const MAX_LOG_ENTRIES = 1000; // From config, but hardcoded here for simplicity as config isn't available yet
  let logBufferArray = new Array(MAX_LOG_ENTRIES);
  let logBufferIndex = 0;
  let logBufferInitialized = false;

  const initLogBuffer = () => {
    logBufferArray.fill(null);
    logBufferIndex = 0;
    logBufferArray[logBufferIndex++] = `REPLOID Session Log Start - ${new Date().toISOString()}\n=========================================\n`;
    logBufferInitialized = true;
  };

  const stringifyDetail = (detail) => {
    if (detail === undefined || detail === null) return "";
    if (typeof detail === "string") return detail;
    if (detail instanceof Error) return `Error: ${detail.message}${detail.stack ? `\nStack: ${detail.stack}` : ""}`;
    try {
      return JSON.stringify(detail, (key, value) => typeof value === "bigint" ? value.toString() : value);
    } catch (e) {
      return "[Unserializable Object]";
    }
  };

  const logger = {
    logEvent: (level = "info", message = "[No Message]", ...details) => {
      if (!logBufferInitialized) initLogBuffer();
      const timestamp = new Date().toISOString();
      const levelUpper = String(level).toUpperCase();
      let logLine = `[${timestamp}] [${levelUpper}] ${String(message)}`;
      const detailsString = details.map(stringifyDetail).filter((s) => s !== "").join(" | ");
      if (detailsString) logLine += ` | ${detailsString}`;
      logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = logLine;
      logBufferIndex++;
      const consoleMethod = level?.toLowerCase() === "error" ? console.error :
                            level?.toLowerCase() === "warn" ? console.warn :
                            level?.toLowerCase() === "debug" ? console.debug : console.log;
      consoleMethod(logLine);
    },
    getLogBuffer: () => {
      if (!logBufferInitialized) return "Log buffer not initialized.\n";
      const bufferSize = Math.min(logBufferIndex, MAX_LOG_ENTRIES);
      const startIndex = logBufferIndex <= MAX_LOG_ENTRIES ? 0 : logBufferIndex % MAX_LOG_ENTRIES;
      const logLines = [];
      for (let i = 0; i < bufferSize; i++) {
        const currentIndex = (startIndex + i) % MAX_LOG_ENTRIES;
        if (logBufferArray[currentIndex] !== null) logLines.push(logBufferArray[currentIndex]);
      }
      let logContent = logLines.join("\n") + "\n";
      if (logBufferIndex > MAX_LOG_ENTRIES) {
        logContent = `... (Log truncated - showing last ${MAX_LOG_ENTRIES} entries) ...\n` + logContent;
      }
      return logContent;
    },
    setLogBuffer: (newBuffer) => {
      initLogBuffer();
      if (typeof newBuffer === "string") {
        const lines = newBuffer.split("\n").filter((line) => line);
        const startIndex = Math.max(0, lines.length - MAX_LOG_ENTRIES);
        let loadedCount = 0;
        for (let i = startIndex; i < lines.length; i++) {
          logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = lines[i];
          logBufferIndex++;
          loadedCount++;
        }
        if (lines.length > MAX_LOG_ENTRIES) {
          const header = `... (Log truncated during import - loaded last ${loadedCount} lines) ...`;
          const headerIndex = (logBufferIndex - loadedCount) % MAX_LOG_ENTRIES;
          logBufferArray[headerIndex] = header;
        }
      } else {
        logger.logEvent("warn", "setLogBuffer received invalid buffer type, resetting.");
      }
    },
  };

  const $id = (id) => document.getElementById(id);
  const $ = (selector, parent = document) => parent.querySelector(selector);
  const $$ = (selector, parent = document) => Array.from(parent.querySelectorAll(selector));

  const kabobToCamel = (s) => String(s ?? "").replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const camelToKabob = (s) => String(s ?? "").replace(/([A-Z])/g, "-$1").toLowerCase();
  const ucFirst = (s) => { const str = String(s ?? ""); return str.charAt(0).toUpperCase() + str.slice(1); };


  const trunc = (str, len, ellipsis = "...") => {
    const s = String(str ?? "");
    if (s.length <= len) return s;
    const ellipsisLen = ellipsis?.length ?? 0;
    return s.substring(0, Math.max(0, len - ellipsisLen)) + ellipsis;
  };

  const escapeHtml = (unsafe) => {
    if (unsafe === null || unsafe === undefined) return "";
    return String(unsafe)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  };

  const lc = (s) => String(s ?? "").toLowerCase();
  const uc = (s) => String(s ?? "").toUpperCase();

  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  const getRandomInt = (min, max) => {
    const minCeil = Math.ceil(min);
    const maxFloor = Math.floor(max);
    return Math.floor(Math.random() * (maxFloor - minCeil + 1)) + minCeil;
  };

  const getLatestMeta = (historyArray) => {
    if (!historyArray || historyArray.length === 0) return null;
    return [...historyArray].sort((a, b) => {
      if (b.latestCycle !== a.latestCycle) return b.latestCycle - a.latestCycle;
      return (b.timestamp || 0) - (a.timestamp || 0); // Fallback for items at same cycle
    })[0];
  };

  const getDefaultState = (appConfig) => ({ // appConfig is the loaded config.json content
    version: appConfig.STATE_VERSION,
    totalCycles: 0, agentIterations: 0, humanInterventions: 0, failCount: 0,
    currentGoal: { seed: null, cumulative: null, latestType: "Idle", summaryContext: null, currentContextFocus: null },
    lastCritiqueType: "N/A", personaMode: "XYZ", lastFeedback: null, lastSelfAssessment: null,
    forceHumanReview: false, apiKey: "",
    confidenceHistory: [], critiqueFailHistory: [], tokenHistory: [], failHistory: [], evaluationHistory: [], critiqueFeedbackHistory: [],
    avgConfidence: null, critiqueFailRate: null, avgTokens: null, avgEvalScore: null, evalPassRate: null,
    contextTokenEstimate: 0, contextTokenTarget: appConfig.CTX_TARGET || 700000,
    lastGeneratedFullSource: null, htmlHistory: [], lastApiResponse: null, retryCount: 0,
    autonomyMode: "Manual", autonomyCyclesRemaining: 0,
    cfg: { ...(appConfig.DEFAULT_CFG || {}) },
    artifactMetadata: {}, dynamicTools: [], registeredWebComponents: [],
  });

  async function calculateChecksum(content) {
    if (typeof content !== "string") return null;
    try {
      const msgUint8 = new TextEncoder().encode(content);
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return `sha256-${hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")}`;
    } catch (error) {
      logger.logEvent("error", "Checksum calculation failed:", error);
      return null;
    }
  }

  return {
    Errors, // Export the custom errors object
    logger,
    $id, $, $$,
    kabobToCamel, camelToKabob, ucFirst,
    trunc, escapeHtml, lc, uc,
    delay, getRandomInt, getLatestMeta,
    getDefaultState,
    calculateChecksum,
  };
})();
ðŸˆ --- CATS_END_FILE ---
