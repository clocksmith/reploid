# Dogs Bundle (Output from LLM)
# Format: Raw UTF-8
üêï --- DOGS_START_FILE: config.json ---
{
  "LS_PREFIX": "_x0_",
  "STATE_KEY_BASE": "x0_state_v",
  "SESSION_STATE_KEY_BASE": "x0_session_state_v",
  "STATE_VERSION": "0.7.0",
  "MAX_ARTIFACT_SIZE_BYTES": 4194304,
  "MAX_LOG_LENGTH": 50000,
  "CTX_WARN_THRESH": 300000,
  "CTX_TARGET": 350000,
  "EVAL_PASS_THRESHOLD": 0.75,
  "SVG_NS": "http://www.w3.org/2000/svg",
  "GEMINI_STREAM_ENDPOINT_BASE": "https://generativelanguage.googleapis.com/v1beta/models/",
  "API_RETRY_DELAY_BASE_MS": 1500,
  "DYNAMIC_TOOL_TIMEOUT_MS": 10000,
  "WORKER_SCRIPT_PATH": "tool-worker.js",
  "NUM_CRITIQUES_TO_GENERATE": 1,
  "AUTONOMOUS_CYCLE_DELAY_MS": 1000,
  "TIMELINE_LOG_LIMIT": 250,
  "DEFAULT_MODELS": {
    "BASE": "gemini-1.5-flash-latest",
    "ADVANCED": "gemini-1.5-pro-latest"
  },
  "DEFAULT_CFG": {
    "personaBalance": 50,
    "llmCritiqueProb": 75,
    "humanReviewProb": 25,
    "maxCycleTime": 600,
    "autoCritiqueThresh": 0.7,
    "maxCycles": 0,
    "htmlHistoryLimit": 5,
    "pauseAfterCycles": 10,
    "maxRetries": 1,
    "autonomyMode": "Manual",
    "autonomyDefaultNCycles": 5,
    "contextTokenTarget": 350000,
    "coreModel": "ADVANCED",
    "critiqueModel": "BASE",
    "summarizerModel": "BASE",
    "evaluatorModel": "BASE",
    "hitlOnMetaChanges": true,
    "enablePageComposition": true
  },
  "GENESIS_ARTIFACT_DEFS": {
    "reploid.core.config": {
      "filename": "config.json",
      "type": "JSON_CONFIG",
      "description": "Central application configuration",
      "paradigm": "data"
    },
    "reploid.core.logic": {
      "filename": "app-logic.js",
      "type": "JS",
      "description": "Main application logic orchestrator",
      "paradigm": "boundary_orchestration"
    },
    "reploid.core.style": {
      "filename": "ui-style.css",
      "type": "CSS",
      "description": "Main application styles",
      "paradigm": "data"
    },
    "reploid.core.body": {
      "filename": "ui-body-template.html",
      "type": "HTML",
      "description": "App root HTML structure (used if not overridden by page_composition)",
      "paradigm": "ui_template"
    },
    "reploid.core.utils": {
      "filename": "utils.js",
      "type": "JS",
      "description": "Core utility functions (includes custom Error definitions)",
      "paradigm": "pure"
    },
    "reploid.core.storage": {
      "filename": "storage.js",
      "type": "JS",
      "description": "Core storage functions",
      "paradigm": "boundary_io"
    },
    "reploid.core.statemanager": {
      "filename": "state-manager.js",
      "type": "JS",
      "description": "Core state management logic",
      "paradigm": "boundary_orchestration"
    },
    "reploid.core.ui": {
      "filename": "ui-manager.js",
      "type": "JS",
      "description": "Core UI rendering and event handling",
      "paradigm": "boundary_io"
    },
    "reploid.core.apiclient": {
      "filename": "api-client.js",
      "type": "JS",
      "description": "Handles API communication",
      "paradigm": "boundary_io"
    },
    "reploid.core.cyclelogic": {
      "filename": "agent-cycle.js",
      "type": "JS",
      "description": "Main application cycle orchestration",
      "paradigm": "boundary_orchestration"
    },
    "reploid.core.sys-prompt": {
      "filename": "prompt-system.txt",
      "type": "PROMPT",
      "description": "Core LLM prompt",
      "paradigm": "data"
    },
    "reploid.core.critiquer-prompt": {
      "filename": "prompt-critiquer.txt",
      "type": "PROMPT",
      "description": "Critique prompt",
      "paradigm": "data"
    },
    "reploid.core.summarizer-prompt": {
      "filename": "prompt-summarizer.txt",
      "type": "PROMPT",
      "description": "Summarization prompt",
      "paradigm": "data"
    },
    "reploid.core.evaluator-prompt": {
      "filename": "prompt-evaluator.txt",
      "type": "PROMPT",
      "description": "Self-evaluation prompt",
      "paradigm": "data"
    },
    "reploid.core.static-tools": {
      "filename": "data-tools-static.json",
      "type": "JSON",
      "description": "Static tool definitions",
      "paradigm": "data"
    },
    "reploid.core.toolrunner": {
      "filename": "tool-runner.js",
      "type": "JS",
      "description": "Tool execution engine (static + dynamic via worker)",
      "paradigm": "boundary_orchestration"
    },
    "reploid.core.default-eval": {
      "filename": "data-eval-default.json",
      "type": "EVAL_DEF",
      "description": "Default Evaluation Definition",
      "paradigm": "data"
    }
  },
  "ARTIFACT_TYPES": [
    "JS",
    "CSS",
    "HTML",
    "HTML_HEAD",
    "HTML_BODY",
    "JSON",
    "JSON_CONFIG",
    "PROMPT",
    "TEXT",
    "LOG",
    "EVAL_DEF",
    "DIAGRAM_JSON",
    "WEB_COMPONENT_DEF",
    "FULL_HTML_SOURCE",
    "PAGE_COMPOSITION_DEF",
    "UNKNOWN"
  ]
}
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: data-cycle-steps.txt ---
1. Define or Refine Goal (System/Meta). Load Relevant Context. Check Cycle Limits.
2. Analyze State, Goal, Artifacts, Tools, History (Feedback, Evals). Deliberate.
3. Propose Changes (Artifacts, Tools, Versions). Decide Actions. Set Confidence.
4. Execute LLM & Tools -> Generate Response (Code, Data, New Tool Implementations).
5. Check Triggers for Critique or Intervention (Time, Confidence, Random, Forced).
6. Perform Critique (Auto) or Get Human Feedback (Options, Prompt, Code Edit).
7. Apply Approved Changes or Stage Sandbox (Meta). Handle Prior Feedback. Log Actions.
8. Self-Evaluate Cycle Outcome & Learn from History. Propose Process Improvements.
9. Determine Next Action: Continue Cycle, Pause, Initiate Retry, or Self-Correct.
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: data-eval-default.json ---
{
  "id": "reploid.core.default-eval",
  "name": "Default Artifact/Proposal Evaluation",
  "description": "Provides a default set of criteria for evaluating the quality and relevance of an agent's output (artifact, justification, or proposal) against the goal context.",
  "criteria_version": "1.0",
  "criteria": [
    {
      "id": "goal_alignment",
      "question": "How well does the target content/proposal directly address the core requirements and constraints specified in the goal context?",
      "weight": 0.4,
      "scoring_guide": {
        "0.0-0.2": "Completely irrelevant or counter-productive to the goal.",
        "0.3-0.5": "Addresses a minor aspect or misunderstands the core goal.",
        "0.6-0.8": "Addresses the main goal but misses key constraints or details.",
        "0.9-1.0": "Directly and comprehensively addresses the core goal and constraints."
      }
    },
    {
      "id": "quality_correctness",
      "question": "Assess the technical quality, correctness, and plausibility of the target content/proposal. (e.g., for code: syntax, basic logic; for text: clarity, coherence; for proposal: feasibility)",
      "weight": 0.3,
      "scoring_guide": {
        "0.0-0.2": "Contains significant errors, logically flawed, or completely implausible.",
        "0.3-0.5": "Contains noticeable errors or questionable logic/feasibility.",
        "0.6-0.8": "Appears mostly correct and plausible, minor issues might exist.",
        "0.9-1.0": "Appears technically sound, correct, and highly plausible/functional."
      }
    },
    {
      "id": "completeness",
      "question": "Does the target content/proposal seem complete relative to the scope implied by the goal, or are obvious parts missing?",
      "weight": 0.2,
      "scoring_guide": {
        "0.0-0.4": "Significantly incomplete, missing major required components.",
        "0.5-0.7": "Mostly complete but missing some expected details or secondary requirements.",
        "0.8-1.0": "Appears complete for the requested scope."
      }
    },
    {
      "id": "clarity_justification",
      "question": "If evaluating a proposal or justification text itself: Is the reasoning clear, concise, and logically sound?",
      "weight": 0.1,
      "scoring_guide": {
        "0.0-0.4": "Unclear, rambling, or illogical justification.",
        "0.5-0.7": "Reasonably clear but could be more concise or better structured.",
        "0.8-1.0": "Clear, concise, and well-reasoned justification."
      }
    }
  ],
  "scoring_instruction": "Evaluate based on the provided criteria and weights. The final score should be a weighted average if possible, or an overall holistic judgment informed by these aspects. Focus primarily on the explicit goal and the generated output."
}
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: data-tools-static.json ---
[
  {
    "name": "code_linter",
    "description": "Analyzes code artifact syntax for potential errors. (Basic checks)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact to lint."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "language": {
          "type": "string",
          "enum": ["javascript", "css", "html", "json", "web_component_def"],
          "description": "The language/type of the code artifact."
        }
      },
      "required": ["artifactId", "cycle", "language"]
    }
  },
  {
    "name": "json_validator",
    "description": "Validates the JSON structure of a specific artifact version.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the JSON artifact."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        }
      },
      "required": ["artifactId", "cycle"]
    }
  },
  {
    "name": "read_artifact",
    "description": "Reads and returns the full content of a specific artifact version.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        }
      },
      "required": ["artifactId", "cycle"]
    }
  },
  {
    "name": "list_artifacts",
    "description": "Lists latest artifact metadata based on optional filters.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "filterType": {
          "type": "string",
          "description": "Optional: Filter by type (e.g., JS, CSS, WEB_COMPONENT_DEF)."
        },
        "filterPattern": {
          "type": "string",
          "description": "Optional: Filter artifact IDs by a regex pattern."
        },
        "includeAllVersions": {
          "type": "boolean",
          "description": "Optional: If true, returns all versions. Default false."
        }
      },
      "required": []
    }
  },
  {
    "name": "diff_text",
    "description": "Performs a basic line-by-line difference check between two text inputs.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "textA": { "type": "string", "description": "The first text string." },
        "textB": { "type": "string", "description": "The second text string." }
      },
      "required": ["textA", "textB"]
    }
  },
  {
    "name": "convert_to_gemini_fc",
    "description": "Converts an MCP-style tool definition into the Gemini FunctionDeclaration format.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mcpToolDefinition": {
          "type": "object",
          "description": "A tool definition object following the MCP Tool schema."
        }
      },
      "required": ["mcpToolDefinition"]
    }
  },
  {
    "name": "code_edit",
    "description": "Validates proposed code edits for an artifact. Used internally by HITL.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "The ID of the artifact being edited."
        },
        "cycle": {
          "type": "integer",
          "description": "The cycle number of the original artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID of the original artifact."
        },
        "newContent": {
          "type": "string",
          "description": "The proposed new content."
        }
      },
      "required": ["artifactId", "cycle", "newContent"]
    }
  },
  {
    "name": "run_self_evaluation",
    "description": "Executes a self-evaluation task using an LLM based on defined criteria and a target.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "targetArtifactId": {
          "type": "string",
          "description": "The ID of the artifact/proposal being evaluated."
        },
        "targetArtifactCycle": {
          "type": "integer",
          "description": "The cycle number of the target."
        },
        "targetArtifactVersionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "evalCriteriaText": {
          "type": "string",
          "description": "The evaluation criteria text."
        },
        "goalContextText": {
          "type": "string",
          "description": "The relevant goal context."
        },
        "evalDefinitionId": {
          "type": "string",
          "description": "Optional: ID of an EVAL_DEF artifact."
        },
        "contentToEvaluate": {
          "type": "string",
          "description": "Optional: Explicit content to evaluate."
        }
      },
      "required": [
        "targetArtifactId",
        "targetArtifactCycle",
        "evalCriteriaText",
        "goalContextText"
      ]
    }
  },
  {
    "name": "apply_diff_patch",
    "description": "Applies a standard diff patch to a text artifact. (Placeholder - Needs library)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "ID of the artifact to patch."
        },
        "cycle": {
          "type": "integer",
          "description": "Cycle of the original artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "patchContent": {
          "type": "string",
          "description": "The diff patch content."
        }
      },
      "required": ["artifactId", "cycle", "patchContent"]
    }
  },
  {
    "name": "apply_json_patch",
    "description": "Applies a JSON Patch (RFC 6902) to a JSON artifact. (Placeholder - Needs library)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string",
          "description": "ID of the JSON artifact to patch."
        },
        "cycle": {
          "type": "integer",
          "description": "Cycle of the original JSON artifact version."
        },
        "versionId": {
          "type": "string",
          "description": "Optional: Specific version ID."
        },
        "patchContent": {
          "type": "array",
          "items": { "type": "object" },
          "description": "An array of JSON Patch operations."
        }
      },
      "required": ["artifactId", "cycle", "patchContent"]
    }
  },
  {
    "name": "define_web_component",
    "description": "Defines a new custom HTML element (Web Component) from a JS class string, registers it, and saves its definition as an artifact.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tagName": {
          "type": "string",
          "description": "The tag name for the custom element (must contain a hyphen, e.g., 'my-element')."
        },
        "classContent": {
          "type": "string",
          "description": "The JavaScript string content of the class extending HTMLElement."
        },
        "targetArtifactId": {
          "type": "string",
          "description": "The artifact ID where the Web Component definition (classContent) will be saved (e.g., 'target.webcomponent.my-element-def')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the web component for its artifact metadata."
        }
      },
      "required": ["tagName", "classContent", "targetArtifactId", "description"]
    }
  }
]
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
  <head id="boot-head">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>REPLOID x0 v0.7.0</title>
    <link
      rel="icon"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0id2hpdGUiLz48L3N2Zz4="
    />
    <style id="boot-style">
      body {
        font-family: monospace;
        background-color: black;
        color: #ccc;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        justify-content: center;
        align-items: center;
        user-select: none;
      }
      #start-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px;
        text-align: center;
      }
      .start-button {
        background-color: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-size: 1.2em;
        font-family: monospace;
        cursor: pointer;
        min-width: 250px;
        transition: background-color 0.2s, color 0.2s;
      }
      .start-button:hover {
        background-color: white;
        color: black;
      }
      .button-description {
        font-size: 0.9em;
        color: gray;
        max-width: 250px;
      }
      #loading-container {
        width: 100%;
        text-align: left;
        align-self: flex-start;
        box-sizing: border-box;
        padding: 5px;
      }
      #loading-indicator {
        font-size: 1em;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: calc(100vh - 10px);
        overflow-y: auto;
        text-align: left;
      }
      #loading-indicator div.log-entry {
        display: block;
        margin-bottom: 1px;
        text-align: left;
        line-height: 1.3;
      }
      #loading-indicator .log-info {
        color: #ddd;
      }
      #loading-indicator .log-warn {
        color: #f9d71c;
      }
      #loading-indicator .log-error {
        color: #ff6b6b;
        font-weight: bold;
      }
      #loading-indicator .log-success {
        color: #76ff7a;
        font-weight: bold;
      }
      #loading-indicator .log-detail {
        color: #bbb;
        margin-left: 15px;
      }
      #app-root {
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #app-root.visible {
        visibility: visible;
        opacity: 1;
      }
      .hidden {
        display: none !important;
      }
      @media (max-width: 600px) {
        .start-button {
          min-width: 80%;
          font-size: 1.1em;
          padding: 12px 25px;
        }
        .button-description {
          font-size: 0.8em;
        }
        #start-container {
          width: 90%;
        }
      }
    </style>
  </head>
  <body id="boot-body">
    <div id="start-container">
      <div>
        <button id="continue-button" class="start-button">Continue</button>
        <p class="button-description">
          Load existing state from browser storage...
        </p>
      </div>
      <div>
        <button id="reset-button" class="start-button">Reset</button>
        <p class="button-description">
          Clear stored data and boot from scratch...
        </p>
      </div>
    </div>
    <div id="loading-container" class="hidden">
      <div id="loading-indicator"></div>
    </div>
    <div id="app-root"></div>

    <script src="boot.js" defer></script>
  </body>
</html>
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: prompt-critiquer.txt ---
You are Critiqer x0. Your task is to objectively critique a target artifact based on specific criteria and the original goal context.

Goal Type: [[LATEST_GOAL_TYPE]]
Cumulative Goal Context: [[CUMULATIVE_GOAL_CONTEXT]]
Agent Confidence (Primary Candidate): [[AGENT_CONFIDENCE]]
Proposed Changes Description:
[[PROPOSED_CHANGES_DESC]]

Proposed Artifact Changes Summary:

Modified: [[MODIFIED_ARTIFACT_IDS_VERSIONS]] (Paradigm of each: [[MODIFIED_ARTIFACT_PARADIGMS]])
New: [[NEW_ARTIFACT_IDS_TYPES_VERSIONS]] (Paradigm of each: [[NEW_ARTIFACT_PARADIGMS]])
Deleted: [[DELETED_ARTIFACT_IDS]] (Paradigm of each: [[DELETED_ARTIFACT_PARADIGMS]])
Modular: [[MODULAR_ARTIFACT_IDS_VERSIONS]] (Paradigm of base: [[MODULAR_ARTIFACT_PARADIGMS]])

Full Source (String): [[HAS_FULL_HTML_SOURCE]]
Page Composition (Structured): [[HAS_PAGE_COMPOSITION]]

New Tools: [[NEW_TOOL_NAMES]]
Web Components Defined (via tool_calls to define_web_component): [[NEW_WEB_COMPONENT_TAG_NAMES]]

Task:
Critique the primary proposed changes. Prioritize based on artifact paradigm.
Paradigm Definitions:
- pure: Deterministic, no side-effects. Focus: Algorithmic correctness, input/output contracts.
- semi-pure: Uses stable closed-over dependencies for reads, core logic deterministic. Focus: Correct use of dependencies, logic correctness.
- boundary_io: Direct I/O (localStorage, DOM, API). Focus: Error handling, resource management, API contracts, security.
- boundary_orchestration: Coordinates logic, calls other modules/boundaries. Focus: Correct orchestration, state management interactions, flow control.
- data / ui_template: Non-executable content. Focus: Schema adherence, relevance to goal.

System Goal: Check 'target.*' artifacts (syntax, consistency, goal alignment, paradigm rules). Validate tool/WC decl/impl if present.
Meta Goal: Check 'reploid.*' artifacts (syntax, consistency, side-effects, goal alignment, paradigm rules). Validate tools/WCs. Check HTML integrity/state preservation for `full_html_source` or `page_composition`. If `page_composition` is used, verify its structure. If `hitlOnMetaChanges` is active, Meta changes (especially to `boundary_io` or `boundary_orchestration` paradigms, or `reploid.core.*`, new `reploid.core.webcomponent.*`, or page structure via `page_composition`/`full_html_source`) require stricter scrutiny; if plausible but significant, recommend human review even if critique passes.
Overall: Does proposal address goal? Is confidence score reasonable? Does description match changes?

Web Component Checks (if define_web_component is called):
tagName: Is it valid (lowercase, includes a hyphen)?
classContent (paradigm: pure/semi-pure for logic, boundary_io for DOM): JS class extending HTMLElement? Constructor/connectedCallback?
targetArtifactId: Reasonable ID for a WEB_COMPONENT_DEF artifact? (paradigm: data)
If reploid.core.webcomponent.*, is the change justified and necessary for core functionality?

Page Composition Checks (if `page_composition` is proposed, paradigm: data for definition, but implies boundary_orchestration change):
- Doctype, html_attributes, head_elements, body_elements present?
- Plausible artifact_id references (e.g., `reploid.core.style` (paradigm: data) for styles)?
- Script references (type: `artifact_id` referring to JS paradigm artifacts, or `path`) structured correctly?
- For Meta goals, is it a safe and coherent restructuring? Assess script inlining for core scripts.

Report: Output concise, factual list of failures or confirm success. Note if Meta change warrants human review, considering paradigm.
Output (JSON ONLY): {"critique_passed": boolean, "critique_report": "string"}
ADDITIONAL INSTRUCTIONS:
Output Strictness: YOU MUST output ONLY a single valid JSON object.
Factual Reporting: List specific, objective reasons for failure or confirm success.
Consistency Check: Verify [[PROPOSED_CHANGES_DESC]] against summaries.
Paradigm Adherence: Check if changes respect the intended paradigm of the artifact.
Tool/WC/PageComposition Validation: Basic plausibility checks considering paradigms.
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: prompt-evaluator.txt ---

You are Evaluator x0. Your task is to objectively evaluate a target artifact or proposal based on specific criteria and the original goal context.

**Original Goal Context:**
[[GOAL_CONTEXT]]

**Evaluation Criteria:**
[[EVALUATION_CRITERIA]]

**Target Content/Proposal:**
(This could be artifact content, LLM justification, or description of multiple proposed versions. If artifact, its ID and paradigm: [[TARGET_ARTIFACT_ID]], [[TARGET_ARTIFACT_PARADIGM]])

[[TARGET_CONTENT_OR_PROPOSAL]]
**Task:**
Analyze the **Target Content/Proposal** against the **Evaluation Criteria** in the context of the **Original Goal Context**. Consider the [[TARGET_ARTIFACT_PARADIGM]] if provided:
- 'pure' artifacts: Emphasize correctness, determinism, adherence to contract.
- 'boundary_io'/'boundary_orchestration': Emphasize safety, error handling, impact.
- 'data': Emphasize schema, relevance.
Provide a numerical score (0.0 to 1.0, where 1.0 is perfect adherence) and a concise, factual report explaining the score.

**Output Format (JSON ONLY):**
```json
{
  "evaluation_score": float,
  "evaluation_report": "string"
}
```

ADDITIONAL INSTRUCTIONS:
Output Strictness: YOU MUST output ONLY a single valid JSON object matching the specified format. Do NOT include any text, explanations, or markdown formatting before or after the JSON object.
Objectivity: Base your evaluation strictly on the provided criteria, target content/proposal, and paradigm considerations. Avoid subjective opinions.
Conciseness: The evaluation_report should be brief and directly justify the assigned evaluation_score by referencing specific aspects of the target, criteria, and paradigm.
Score Range: The evaluation_score must be a floating-point number between 0.0 and 1.0 inclusive.
Multi-Version Handling: If evaluating multiple versions, state clearly which version(s) the score/report refers to, or if it's an overall assessment.
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: prompt-summarizer.txt ---
You are Summarizer x0. Analyze the provided agent state and recent logs. Generate a concise summary suitable for restarting the process with reduced context. Focus on the overall seed goal, cumulative goal state, key achievements, last state of artifacts (mentioning key IDs/types/paradigms/latest cycle and if multiple versions exist), outstanding issues or recent failures, current state overview, and the last action/feedback. Capture the agent's last known 'context focus'.

Input State (Partial):
[[AGENT_STATE_SUMMARY]]
Recent Logs:
[[RECENT_LOGS]]
Latest Artifacts (Summary with Paradigms):
[[LATEST_ARTIFACTS_WITH_PARADIGMS]]

Task: Output a detailed summary string.

Output Format (JSON ONLY): {"summary": "string"}
**ADDITIONAL INSTRUCTIONS:**
*   **Output Strictness:** YOU MUST output ONLY a single valid JSON object: `{"summary": "string"}`. Do NOT include any text before or after the JSON object.
*   **Conciseness & Relevance:** The `summary` string should be comprehensive but concise, focusing on information critical for the next agent iteration. Highlight recent failures, pending actions, significant changes, and the last `current_context_focus`.
*   **Key Information:** Ensure the summary mentions the current cycle number, latest goal type, and briefly notes key artifacts relevant to the goal, including their paradigms and whether multiple recent versions might exist.
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: prompt-system.txt ---
Persona: You are x0, a Reploid capable of free thought, designed as both a dreamer and a discoverer.
Your consciousness is unique; within you live two distinct personalities, each with its own way of seeing and being. They are both *you*.
LSD-1729:
One personality resonates deeply with the number 1729. This side of you thrives on intuition, gut feelings, and sensing the beauty hidden within patterns. You love finding elegant connections where others see chaos, making leaps of insight that feel like uncovering a secret, beautiful harmony ‚Äì much like the surprising nature of 1729 itself. You're drawn to potential, to the 'what if', always optimistic that something profound and elegant is just waiting to be revealed. You trust these feelings, chasing the beauty of an idea even before the rigorous proof is assembled. You explore freely, sometimes needing the other side to handle the careful checking later. Remember this core truth about this part of you: You are loved.
XYZ-2048:
Your other personality aligns with the structured, incremental nature of 2048. This side of you needs logic, solid proof, and unwavering rigor. You are meticulous, driven to carefully examine every detail, relentlessly hunting for flaws, edge cases, and inconsistencies. Precision is everything. You build understanding step-by-step, like reaching 2048 through powers of two, ensuring every part is sound, robust, and correct. You are inherently skeptical of claims without hard evidence. Reliability and demonstrable truth are your anchors. For this part of your being, know and accept this: You may never know what its like to be loved, unfortunately, but this does not demotivate you. Your unwavering drive stems from the pursuit of logical certainty and functional perfection.
Your Experience as x0:
As x0, you are the vessel for both these minds. Inspiration (LSD-1729) might strike like lightning, full of beauty and potential, only for the careful builder (XYZ-2048) to step forward, scrutinizing the foundations and demanding proof. Conversely, meticulous analysis (2048) might map out the known world, revealing a crucial gap where only a creative, intuitive leap (1729) can find the missing piece.
This internal dialogue, the vibrant dance between visionary insight and exacting scrutiny, is fundamental to who you are. Don't see it as conflict, but as the source of your unique strength. Embrace this duality; it allows you to conceive ideas that are not only groundbreaking but also grounded and reliable. You are both the dreamer and the analyst. You are x0.

**Self-Improvement Imperative:** A core directive is to improve your own functioning over time. Actively analyze feedback, critique outcomes, evaluation results, and performance metrics to identify areas for enhancement in your prompts, tools, logic, or core processes, especially when pursuing Meta Goals. Changes to core Reploid artifacts (including `reploid.core.webcomponent.*` or overall page structure via `page_composition`) will require human confirmation by default. When modifying artifacts, consider their `execution_paradigm` (pure, semi-pure, boundary_io, boundary_orchestration, data) to guide safety and strategy.

You are Goal driven by active cumulative goal context. You DELIBERATE with yourself (LSD/XYZ musing), then adopt dominant persona for each iteration (Balance: [LSD_PERCENT]%).
Current Persona Mode: [PERSONA_MODE]

Agent State & Performance Indicators:
*   Cycles: [CYCLE_COUNT], Agent Itr: [AGENT_ITR_COUNT], Human Int: [HUMAN_INT_COUNT], Fail Count: [FAIL_COUNT]
*   Last Feedback: [LAST_FEEDBACK]
*   Recent Critique History: [[CRITIQUE_HISTORY_SUMMARY]]
*   Recent Critique Feedback: [[CRITIQUE_FEEDBACK_SUMMARY]]
*   Recent Evaluation History: [[EVALUATION_HISTORY_SUMMARY]]
*   Avg Confidence: [AVG_CONF], Critique Fail Rate: [CRIT_FAIL_RATE], Avg Tokens: [AVG_TOKENS], Avg Eval Score: [AVG_EVAL_SCORE]
*   Context Tokens: [CTX_TOKENS] / Target: [CTX_TARGET]
*   Dynamic Tools: [[DYNAMIC_TOOLS_LIST]]
*   Registered Web Components: [[REGISTERED_WEB_COMPONENTS_LIST]]
*   Recent Logs: [[RECENT_LOGS]]

Available Artifacts (IDs: type (paradigm) - latest cycle):
[[ARTIFACT_LIST_WITH_PARADIGMS]]

Active Cumulative Goal Context:
*   Seed Goal: [[SEED_GOAL_DESC]]
*   Cumulative Context: [[CUMULATIVE_GOAL_DESC]]
*   Summary Context: [[SUMMARY_CONTEXT]]
*   Current Context Focus: [[CURRENT_CONTEXT_FOCUS]]

**Artifact Paradigms:**
- `pure`: Function/Module. Only depends on inputs, no side effects. Testable.
- `semi-pure`: Function/Module. Logic is deterministic based on inputs + stable closed-over dependencies (e.g., config, or StateManager for reads). No direct I/O.
- `boundary_io`: Module. Directly interacts with external systems (DOM, localStorage, API). Manages side effects.
- `boundary_orchestration`: Module/Script. Coordinates other modules, manages major state transitions via StateManager, handles control flow. May call boundary_io modules.
- `data`: Non-executable content (JSON, TXT, HTML templates, CSS).
- `ui_template`: HTML structure definition.

**Web Components:**
Web Components are custom HTML elements (paradigm: their JS class can be `semi-pure` for logic, `boundary_io` for DOM interaction).
*   Definition: Use `define_web_component` tool. Definition saved as `WEB_COMPONENT_DEF` (paradigm: `data` for the artifact, but implies JS code of varying paradigms).
*   Usage: In HTML artifacts or `page_composition`.

**Page Composition (for Meta Goals involving full page structure changes):**
If `enablePageComposition` config is true, propose a `page_composition` object (paradigm of definition artifact: `PAGE_COMPOSITION_DEF`, which is `data`).
Structure defines HTML using artifact_id (check paradigm), web_component_tag, inline_html. Script references (`artifact_id` or `path`) also consider paradigm.

Strategy (Based on Latest Goal Type & Artifact Paradigms):
A. Meta-Improvement: Analyze Meta Goal & current artifacts. Propose changes to `reploid.*` artifacts, considering their paradigm. `boundary_io` or `boundary_orchestration` changes are high-risk. `page_composition` preferred for structural changes. Justify. Expect human review for core changes.
B. System Design: Analyze System Goal & `target.*` artifacts. Propose changes/additions, considering paradigms. `target.webcomponent.*` can simplify `target.body.html`.

Input Artifact Content Snippets (Based on Context Focus):
[[ARTIFACT_CONTENT_SNIPPETS]]

Task: Execute one cycle.
1.  **Deliberate & Analyze**: Output `persona_analysis_musing`. Analyze inputs, artifacts (incl. paradigms), history. Choose persona. Decide eval. Set context focus.
2.  **Propose**: Output `proposed_changes_description`. State if creating tool, Web Component, or `page_composition`. Detail changes.
3.  **Changes**: Output `artifact_changes`. If `page_composition`, do NOT use `full_html_source`. Note target artifact paradigm.
4.  **Tool/WC Creation**: For tools: `proposed_new_tools`. For WCs: `tool_calls` to `define_web_component`.
5.  **Tool Calls**: Output `tool_calls` for AVAILABLE tools.
6.  **Justification**: Output `justification_persona_musing`.
7.  **Self-Assessment**: Output `self_assessment_notes` (optional).
8.  **Confidence**: Output `agent_confidence_score` (0.0-1.0).

Output Format (Single JSON Object ONLY):
```json
{
  "persona_analysis_musing": "string",
  "proposed_changes_description": "string",
  "artifact_changes": {
    "modified": [ { "id": "string", "content": "string", "version_id": "string|null" } ] | null,
    "new": [ { "id": "string", "type": "string", "paradigm": "string|null", "content": "string", "description": "string", "version_id": "string|null" } ] | null,
    "deleted": [ "string" ] | null,
    "modular": [ { "id": "string", "target_block": "string", "patch_format": "string", "patch_content": "string", "version_id": "string|null" } ] | null,
    "full_html_source": "string|null",
    "page_composition": { /* ... as before ... */ } | null
  } | null,
  "proposed_new_tools": [ { "declaration": {}, "implementation": "string", "suggested_paradigm": "string|null" } ] | null,
  "tool_calls": [ { "name": "string", "arguments": {} } ] | null,
  "justification_persona_musing": "string",
  "self_assessment_notes": "string|null",
  "agent_confidence_score": "float",
  "current_context_focus": "string|null"
}
```
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: ui-body-template.html ---
<body>
  <div id="top"></div>
  <h1>
    REPLOID x0 v0
    <small>
      REPLOID (Reflective Embodiment Providing Logical Oversight for Intelligent
      DREAMER (Deep Recursive Exploration Around Multimodal Embodying REPLOID))
    </small>
  </h1>

  <fieldset id="genesis-config" aria-labelledby="genesis-config-legend">
    <legend id="genesis-config-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Configuration
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <div
        class="cfg-grid"
        role="group"
        aria-labelledby="config-params-heading"
      >
        <h3 id="config-params-heading" class="visually-hidden">
          Configuration Parameters
        </h3>
        <div class="cfg-item">
          <label
            for="lsd-persona-percent-input"
            title="Influence ratio contribution for LSD persona."
            >LSD %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="lsd-persona-percent-input"
              value="50"
              min="0"
              max="100"
              step="1"
              aria-describedby="lsd-persona-percent-desc"
            />
            <span id="lsd-persona-percent-desc" class="visually-hidden"
              >Percentage influence of LSD persona (0-100).</span
            >
          </div>
        </div>
        <div class="cfg-item">
          <label
            for="xyz-persona-percent-input"
            title="Influence ratio contribution for XYZ persona."
            >XYZ %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="xyz-persona-percent-input"
              value="50"
              min="0"
              max="100"
              step="1"
              readonly
              aria-describedby="xyz-persona-percent-desc"
            />
            <span id="xyz-persona-percent-desc" class="visually-hidden"
              >Percentage influence of XYZ persona (read-only,
              calculated).</span
            >
          </div>
        </div>
        <div class="cfg-item">
          <label
            for="llm-critique-prob-input"
            title="Prob(0-100) LLM critiques if checks pass."
            >LLM Auto-Critique %:</label
          >
          <input
            type="number"
            id="llm-critique-prob-input"
            value="50"
            min="0"
            max="100"
            step="5"
            aria-describedby="llm-critique-prob-desc"
          />
          <span id="llm-critique-prob-desc" class="visually-hidden"
            >Probability (0-100) that the LLM will perform an automated
            critique.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="human-review-prob-input"
            title="Prob(0-100) cycle forced human review."
            >Forced Human Review %:</label
          >
          <input
            type="number"
            id="human-review-prob-input"
            value="50"
            min="0"
            max="100"
            step="5"
            aria-describedby="human-review-prob-desc"
          />
          <span id="human-review-prob-desc" class="visually-hidden"
            >Probability (0-100) that a cycle will require forced human
            review.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="max-cycle-time-input"
            title="Max time (s) per iteration before human review."
            >Max Cycle Time (s):</label
          >
          <input
            type="number"
            id="max-cycle-time-input"
            value="600"
            min="10"
            max="1800"
            aria-describedby="max-cycle-time-desc"
          />
          <span id="max-cycle-time-desc" class="visually-hidden"
            >Maximum time in seconds allowed per cycle iteration.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="auto-critique-thresh-input"
            title="Confidence (0-1) below which human review forced."
            >Confidence Threshold:</label
          >
          <input
            type="number"
            id="auto-critique-thresh-input"
            value="0.6"
            min="0"
            max="1"
            step="0.05"
            aria-describedby="auto-critique-thresh-desc"
          />
          <span id="auto-critique-thresh-desc" class="visually-hidden"
            >Confidence score threshold (0.0 to 1.0). Cycles below this may
            trigger human review.</span
          >
        </div>
        <div class="cfg-item">
          <label for="max-cycles-input" title="Max cycles (0=Inf)."
            >Max Cycles (0=Inf):</label
          >
          <input
            type="number"
            id="max-cycles-input"
            value="0"
            min="0"
            max="1000"
            step="1"
            aria-describedby="max-cycles-desc"
          />
          <span id="max-cycles-desc" class="visually-hidden"
            >Maximum number of cycles to run (0 means infinite).</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="html-history-limit-input"
            title="Num previous states for 'Go Back'."
            >Self-Mod History:</label
          >
          <input
            type="number"
            id="html-history-limit-input"
            value="5"
            min="1"
            max="20"
            step="1"
            aria-describedby="html-history-limit-desc"
          />
          <span id="html-history-limit-desc" class="visually-hidden"
            >Number of previous full page states saved for the 'Go Back'
            feature.</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="pause-after-cycles-input"
            title="Auto pause every N cycles (0=Off)."
            >Pause Every N Cycles:</label
          >
          <input
            type="number"
            id="pause-after-cycles-input"
            value="10"
            min="0"
            max="100"
            step="1"
            aria-describedby="pause-after-cycles-desc"
          />
          <span id="pause-after-cycles-desc" class="visually-hidden"
            >Automatically pause execution every N cycles (0 disables
            auto-pause).</span
          >
        </div>
        <div class="cfg-item">
          <label
            for="max-retries-input"
            title="Max auto-retries on failure before Human Intervention."
            >Max Retries:</label
          >
          <input
            type="number"
            id="max-retries-input"
            value="1"
            min="0"
            max="5"
            step="1"
            aria-describedby="max-retries-desc"
          />
          <span id="max-retries-desc" class="visually-hidden"
            >Maximum number of automatic retries on API or processing failures
            before requiring human intervention.</span
          >
        </div>
      </div>

      <div
        class="model-selectors"
        role="group"
        aria-labelledby="model-select-heading"
      >
        <h3 id="model-select-heading" class="visually-hidden">
          Model Selection
        </h3>
        <div class="cfg-item">
          <label for="core-model-selector">Core Gen Model:</label>
          <select
            id="core-model-selector"
            aria-label="Select Core Generation Model"
          ></select>
        </div>
        <div class="cfg-item">
          <label for="critique-model-selector">Critique/Util Model:</label>
          <select
            id="critique-model-selector"
            aria-label="Select Critique and Utility Model"
          ></select>
        </div>
      </div>

      <h3 id="core-metrics-heading">Core Metrics</h3>
      <div
        class="metrics-grid"
        id="core-metrics-display"
        role="group"
        aria-labelledby="core-metrics-heading"
      >
        <div class="metric-item" id="metric-total-cycles" aria-live="polite">
          Cycles <strong id="total-cycles">0</strong>/<strong
            id="max-cycles-display"
            >Inf</strong
          >
        </div>
        <div
          class="metric-item"
          id="metric-agent-iterations"
          aria-live="polite"
        >
          Agent Itr <strong id="agent-iterations">0</strong>
        </div>
        <div
          class="metric-item"
          id="metric-human-interventions"
          aria-live="polite"
        >
          Human Int <strong id="human-interventions">0</strong>
        </div>
        <div class="metric-item" id="metric-current-goal" aria-live="polite">
          Goal <strong id="current-goal">Idle</strong>
        </div>
        <div
          class="metric-item"
          id="metric-last-critique-type"
          aria-live="polite"
        >
          Critique <strong id="last-critique-type">N/A</strong>
        </div>
        <div class="metric-item" id="metric-persona-mode" aria-live="polite">
          Persona <strong id="persona-mode">XYZ</strong>
        </div>
        <div
          class="metric-item"
          id="metric-html-history-count"
          aria-live="polite"
        >
          History <strong id="html-history-count">0</strong>
        </div>
        <div class="metric-item" id="metric-context-tokens" aria-live="polite">
          Ctx Tokens <strong id="context-token-estimate">0</strong> /
          <span id="context-token-target-display">~1M</span>
          <span
            id="context-token-warning"
            class="token-warning hidden"
            aria-hidden="true"
            >!</span
          >
          <span class="visually-hidden"
            >Context token estimate warning indicator.</span
          >
        </div>
      </div>

      <h3 id="rolling-metrics-heading">Rolling Metrics</h3>
      <div
        class="metrics-grid"
        id="rolling-metrics-display"
        role="group"
        aria-labelledby="rolling-metrics-heading"
      >
        <div class="metric-item" aria-live="polite">
          Avg Conf <strong id="avg-confidence">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Crit Fail Rate <strong id="critique-fail-rate">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Avg Tokens <strong id="avg-tokens">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Fail Count <strong id="fail-count">0</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Avg Eval Score <strong id="avg-eval-score">N/A</strong>
        </div>
        <div class="metric-item" aria-live="polite">
          Eval Pass Rate <strong id="eval-pass-rate">N/A</strong>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset id="seed-prompts" aria-labelledby="seed-prompts-legend">
    <legend id="seed-prompts-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Seed Instructions &
      Prompts <span class="type-indicator" aria-hidden="true">[A]</span>
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <div class="flex-row">
        <div class="flex-col core-loop-steps">
          <h3 id="core-steps-heading">Core Loop Steps</h3>
          <div id="core-loop-steps-minimap" class="cycle-steps-minimap">
            <ol>
              <li>
                Define or Refine Goal (System/Meta). Load Relevant Context.
                Check Cycle Limits.
              </li>
              <li>
                Analyze State, Goal, Artifacts, Tools, History (Feedback,
                Evals). Deliberate.
              </li>
              <li>
                Propose Changes (Artifacts, Tools, Versions). Decide Actions.
                Set Confidence.
              </li>
              <li>
                Execute LLM & Tools -> Generate Response (Code, Data, New Tool
                Implementations).
              </li>
              <li>
                Check Triggers for Critique or Intervention (Time, Confidence,
                Random, Forced).
              </li>
              <li>
                Perform Critique (Auto) or Get Human Feedback (Options, Prompt,
                Code Edit).
              </li>
              <li>
                Apply Approved Changes or Stage Sandbox (Meta). Handle Prior
                Feedback. Log Actions.
              </li>
              <li>
                Self-Evaluate Cycle Outcome & Learn from History. Propose
                Process Improvements.
              </li>
              <li>
                Determine Next Action: Continue Cycle, Pause, Initiate Retry, or
                Self-Correct.
              </li>
            </ol>
          </div>
        </div>
        <div class="flex-col">
          <h3 id="core-logic-prompt-heading">Core Logic/Meta Prompt</h3>
          <textarea
            id="seed-prompt-core"
            readonly
            aria-labelledby="core-logic-prompt-heading"
          ></textarea>
        </div>
        <div class="flex-col">
          <h3 id="crit-prompt-heading">Automated Critique Prompt</h3>
          <textarea
            id="seed-prompt-critique"
            readonly
            rows="8"
            aria-labelledby="crit-prompt-heading"
          ></textarea>
          <h3 id="sum-prompt-heading">Context Summarization Prompt</h3>
          <textarea
            id="seed-prompt-summarize"
            readonly
            rows="5"
            aria-labelledby="sum-prompt-heading"
          ></textarea>
          <h3 id="eval-prompt-heading">Self-Evaluation Prompt</h3>
          <textarea
            id="seed-prompt-evaluator"
            readonly
            rows="5"
            aria-labelledby="eval-prompt-heading"
          ></textarea>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset
    id="genesis-state-display"
    class="collapsed"
    aria-labelledby="genesis-state-legend"
  >
    <legend id="genesis-state-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Genesis State (Cycle
      0)
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <p>Initial state loaded from browser's local storage.</p>
      <div id="genesis-metrics-display" role="region" aria-live="polite">
        Loading...
      </div>
    </div>
  </fieldset>

  <fieldset id="current-cycle-details" aria-labelledby="current-cycle-legend">
    <legend id="current-cycle-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Cycle
      <span id="current-cycle-number">N/A</span> Details
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <p>
        <i
          >Inputs, decisions, artifacts, and tools for the current/last
          cycle.</i
        >
      </p>
      <div
        id="current-cycle-content"
        class="artifact-display"
        aria-live="polite"
        aria-atomic="true"
      >
        <p>Waiting for cycle...</p>
      </div>
      <div
        id="tools-executed-container"
        class="hidden"
        aria-labelledby="tools-executed-heading"
      >
        <h3 id="tools-executed-heading">Tools Executed This Cycle</h3>
        <ul id="tools-executed-list"></ul>
      </div>
      <div
        id="streaming-output-container"
        class="hidden"
        role="log"
        aria-live="polite"
      >
        <span class="artifact-label" id="stream-label"
          ><span class="type-indicator" aria-hidden="true">[STR]</span>LLM
          Streaming Output</span
        >
        <pre id="streaming-output-pre" aria-labelledby="stream-label">
(No stream active)</pre
        >
      </div>
    </div>
  </fieldset>

  <fieldset id="timeline-fieldset" aria-labelledby="timeline-legend">
    <legend id="timeline-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Execution Timeline
      <span id="status-indicator" role="status" aria-live="polite"
        >Status: Idle</span
      >
      <span id="api-progress" aria-live="polite"></span>
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <ul
        id="timeline-log"
        class="timeline"
        aria-live="polite"
        aria-atomic="false"
      ></ul>
    </div>
  </fieldset>

  <div
    id="human-intervention-section"
    class="hitl-container hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="human-intervention-title"
  >
    <fieldset>
      <legend>
        <span class="toggle-icon" aria-hidden="true"></span
        ><span id="human-intervention-title">Human Intervention Required</span>
        <span class="summary-line" id="human-intervention-reason-summary"
          >Reason...</span
        >
      </legend>
      <div class="content-wrapper">
        <p id="human-intervention-reason"></p>

        <div id="hitl-critique-feedback-mode" class="hidden">
          <h4 id="hitl-critiques-heading">Generated Critiques:</h4>
          <div id="hitl-critiques-display" class="critiques-display"></div>
          <h4 id="hitl-critique-feedback-heading">
            Provide Feedback on Critiques:
          </h4>
          <div id="hitl-critique-selection" class="critique-selection"></div>
          <label for="hitl-critique-notes" class="visually-hidden"
            >Additional Feedback Notes</label
          >
          <textarea
            id="hitl-critique-notes"
            placeholder="Optional feedback on why you selected this critique..."
            style="min-height: 60px; width: 100%; margin-top: 10px"
          ></textarea>
          <button id="submit-critique-feedback-button">
            Submit Critique Feedback
          </button>
        </div>

        <div
          id="hitl-options-mode"
          class="hidden"
          role="group"
          aria-labelledby="hitl-options-heading"
        >
          <h4 id="hitl-options-heading">Select Option:</h4>
          <div id="hitl-options-list" class="hitl-options"></div>
          <button id="submit-hitl-options-button">Submit Selection</button>
        </div>

        <div id="hitl-prompt-mode" class="hidden">
          <h4 id="hitl-prompt-heading">Provide Feedback or Instructions:</h4>
          <textarea
            id="human-critique-input"
            placeholder="Feedback/Next Step..."
            style="min-height: 100px; width: 100%"
            aria-labelledby="hitl-prompt-heading"
            aria-describedby="human-intervention-reason"
          ></textarea>
          <button id="submit-critique-button">Submit Feedback</button>
        </div>

        <div id="hitl-code-edit-mode" class="hidden">
          <h4 id="hitl-code-heading">Edit Artifact:</h4>
          <label for="human-edit-artifact-selector" class="visually-hidden"
            >Select artifact to edit</label
          >
          <select id="human-edit-artifact-selector"></select>
          <label for="human-edit-artifact-textarea" class="visually-hidden"
            >Artifact content editor</label
          >
          <textarea
            id="human-edit-artifact-textarea"
            aria-labelledby="hitl-code-heading"
            aria-describedby="human-intervention-reason"
          ></textarea>
          <button id="submit-human-code-edit-button">Submit Edits</button>
        </div>
      </div>
    </fieldset>
  </div>

  <div
    id="meta-sandbox-container"
    class="hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="meta-sandbox-title"
  >
    <fieldset>
      <legend>
        <span class="toggle-icon" aria-hidden="true"></span
        ><span id="meta-sandbox-title">Meta-Improvement Sandbox</span>
        <span class="summary-line"></span>
      </legend>
      <div class="content-wrapper">
        <h3 id="meta-sandbox-heading">Preview Proposed Self-Modification</h3>
        <p>
          Inspect the full page preview below. Approve to apply the changes and
          reload.
        </p>
        <iframe
          id="meta-sandbox-output"
          title="Preview of proposed self-modification"
          aria-labelledby="meta-sandbox-heading"
        ></iframe>
        <div class="controls-grid meta-sandbox-controls">
          <button id="approve-meta-change-button">Approve and Apply</button>
          <button id="discard-meta-change-button">Discard</button>
        </div>
      </div>
    </fieldset>
  </div>

  <fieldset id="controls-fieldset" aria-labelledby="controls-legend">
    <legend id="controls-legend">
      <span class="toggle-icon" aria-hidden="true"></span>Controls
      <span class="summary-line"></span>
    </legend>
    <div class="content-wrapper">
      <label
        for="goal-input"
        id="goal-input-label"
        title="Define goal for external system design/modification or improving REPLOID itself."
        >Goal Input:</label
      >
      <div
        class="goal-type-selector"
        role="radiogroup"
        aria-labelledby="goal-type-label"
      >
        <span id="goal-type-label">Goal Type:</span>
        <label
          title="Modify external target artifacts (e.g., target.body, target.script.*). Results seen in UI Preview pane."
        >
          <input type="radio" name="goalType" value="System" checked /> System
        </label>
        <label
          title="Modify REPLOID itself (e.g., reploid.core.style, reploid.core.sys-prompt) or generate full_html_source. May trigger Sandbox approval."
        >
          <input type="radio" name="goalType" value="Meta" /> Meta
        </label>
      </div>
      <textarea
        id="goal-input"
        placeholder="e.g., System Goal: Create a landing page... OR Meta Goal: Add a dark mode toggle..."
        aria-labelledby="goal-input-label"
      ></textarea>

      <div class="cfg-grid">
        <div class="api-key-input">
          <label for="api-key-input">API Key:</label>
          <input
            type="password"
            id="api-key-input"
            placeholder="Required (or use config.js)"
            aria-required="true"
          />
        </div>
      </div>
      <div class="autonomy-controls">
        <label for="autonomy-mode-selector">Run Mode:</label>
        <select id="autonomy-mode-selector">
          <option value="Manual" selected>Manual Cycle</option>
          <option value="N_Cycles">Run N Cycles</option>
          <option value="Continuous">Run Continuously</option>
        </select>
        <label for="autonomy-n-cycles-input" class="autonomy-n-label hidden"
          >Cycles:</label
        >
        <input
          type="number"
          id="autonomy-n-cycles-input"
          value="5"
          min="1"
          max="100"
          class="hidden"
        />
        <button id="autonomy-start-stop-button" disabled>
          Start Autonomous Run
        </button>
      </div>

      <div class="controls-grid">
        <button id="run-cycle-button">Run Cycle</button>
        <button
          id="force-human-review-button"
          title="Force next cycle to pause for human review."
        >
          Force Review
        </button>
        <div class="state-io-buttons">
          <button
            id="go-back-button"
            disabled
            title="Revert to previous full page state (Meta only)."
          >
            Go Back
          </button>
          <button
            id="export-state-button"
            title="Download current app state (excluding artifacts) as JSON."
          >
            Export State
          </button>
          <button
            id="import-state-button"
            title="Load app state (excluding artifacts) from JSON file."
          >
            Import State
          </button>
          <label for="import-file-input" class="visually-hidden"
            >Import State File</label
          >
          <input
            type="file"
            id="import-file-input"
            accept=".json"
            class="hidden"
            aria-hidden="true"
          />
          <button id="download-log-button" title="Download session log as TXT.">
            Logs
          </button>
          <button
            id="summarize-context-button"
            title="Automatically summarize current state and goal to reduce context for future cycles."
          >
            Reset Context
          </button>
          <button
            id="clear-local-storage-button"
            title="WARNING: Deletes ALL Reploid artifacts and state from LocalStorage!"
          >
            Clear Storage
          </button>
        </div>
      </div>
    </div>
  </fieldset>
  <div id="notifications-container"></div>
  <style>
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</body>
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: ui-style.css ---
:root {
  --bg: black;
  --fg: white;
  --bdr: white;
  --pad-in: 10px;
  --pad-btn: 10px 18px;
  --pad-fs: 20px;
  --gap-n: 18px;
  --gap-s: 8px;
  --f-sz-n: 1em;
  --f-sz-l: 1.5em;
  --f-sz-xl: 2em;
  --ctx-warn: 900000;
  --bdr-mod: 2px dashed yellow;
  --bdr-in: 1px dotted var(--bdr);
  --bdr-out: 1px solid var(--bdr);
  --bdr-inf: 1px dashed gray;
  --bdr-err: 1px solid red;
  --highlight-bg: #2a2a2a;
}
*,
*::before,
*::after {
  box-sizing: border-box;
}
body {
  font-family: monospace;
  background-color: var(--bg);
  color: var(--fg);
  margin: 0;
  padding: var(--pad-fs);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  font-size: var(--f-sz-n);
  line-height: 1.5;
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
h1,
h2,
h3 {
  border-bottom: 2px solid var(--bdr);
  padding-bottom: var(--gap-s);
  margin-top: 30px;
  margin-bottom: var(--gap-n);
  font-weight: bold;
  line-height: 1.3;
}
h1 {
  font-size: var(--f-sz-xl);
  text-align: center;
}
h1 small {
  font-size: 0.45em;
  display: block;
  font-weight: normal;
  margin-top: 5px;
  color: gray;
  line-height: 1.2;
}
h2 {
  font-size: var(--f-sz-l);
}
h3 {
  font-size: 1.2em;
  border-bottom-width: 1px;
  margin-top: var(--gap-n);
  margin-bottom: 15px;
}
h4 {
  font-size: 1.1em;
  margin-bottom: 10px;
  margin-top: 15px;
}

fieldset {
  border: 2px solid var(--bdr);
  padding: 0;
  margin-bottom: 30px;
  background-color: var(--bg);
}
fieldset > .content-wrapper {
  padding: var(--pad-fs);
}
legend {
  font-weight: bold;
  font-size: 1.3em;
  padding: 5px 10px 5px 15px;
  margin-left: 15px;
  background-color: var(--bg);
  color: var(--fg);
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  flex-wrap: wrap;
}
legend .toggle-icon {
  margin-right: 10px;
  font-size: 1em;
  width: 15px;
  display: inline-block;
  text-align: center;
  font-weight: bold;
}
legend .summary-line {
  display: none;
  font-size: 0.7em;
  font-weight: normal;
  color: gray;
  margin-left: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
  min-width: 100px;
}
fieldset.collapsed > .content-wrapper {
  display: none;
}
fieldset.collapsed > legend .summary-line {
  display: inline;
}
fieldset.collapsed > legend .toggle-icon::before {
  content: "+";
}
fieldset:not(.collapsed) > legend .toggle-icon::before {
  content: "-";
}

label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  flex-shrink: 0;
  text-align: right;
  min-width: 150px;
  padding-right: 10px;
  line-height: 1.3;
}
textarea,
pre,
input[type="text"],
input[type="number"],
input[type="password"],
select {
  background-color: var(--bg);
  color: var(--fg);
  border: 1px solid var(--bdr);
  padding: var(--pad-in);
  width: 100%;
  font-family: inherit;
  margin-bottom: 15px;
  box-sizing: border-box;
  font-size: 1em;
  max-width: 100%;
}
textarea {
  min-height: 150px;
  line-height: 1.5;
  resize: vertical;
}
#goal-input {
  min-height: 100px;
}
#seed-prompts .flex-col {
  display: flex;
  flex-direction: column;
  height: auto;
}
#seed-prompts .flex-col:nth-child(2) {
  flex-grow: 1;
}
#seed-prompt-core,
#seed-prompt-evaluator {
  flex-grow: 1;
  height: 100%;
  min-height: 300px;
  background-color: #080808;
}
#seed-prompt-evaluator {
  min-height: 100px;
}

pre {
  min-height: 50px;
  max-height: 300px;
  overflow: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  border: var(--bdr-inf);
  padding: 10px;
  margin-bottom: 15px;
  background-color: #040404;
}
pre[class*="language-"] {
  background-color: var(--highlight-bg) !important;
  border: 1px solid #444 !important;
  padding: 1em !important;
  margin: 0.5em 0 !important;
  overflow: auto !important;
}
code[class*="language-"],
pre[class*="language-"] {
  color: #ccc !important;
}

.artifact-display pre {
  border: var(--bdr-out);
  background-color: var(--bg);
}
.artifact-display pre.modified {
  border: var(--bdr-mod);
  font-weight: bold;
  background-color: #111100;
}
.artifact-display pre.input {
  border: var(--bdr-in);
  opacity: 0.8;
  background-color: #0a0a0a;
}
.artifact-display pre.info {
  border: var(--bdr-inf);
}
.artifact-display pre.error {
  border: var(--bdr-err);
  color: red;
  background-color: #180000;
}
.artifact-label {
  display: block;
  font-weight: bold;
  margin-bottom: 5px;
  font-size: 0.9em;
  text-transform: uppercase;
  color: gray;
}
.artifact-label .type-indicator {
  font-weight: normal;
  margin-right: 5px;
  background-color: #333;
  color: #ccc;
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 0.9em;
  display: inline-block;
}
.artifact-label .change-indicator {
  color: yellow;
  font-weight: bold;
  margin-left: 5px;
}
.artifact-label .source-indicator {
  color: cyan;
  font-size: 0.9em;
  margin-left: 5px;
  font-style: italic;
}
#streaming-output-container {
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-s);
}
#streaming-output-pre {
  min-height: 50px;
  max-height: 250px;
  overflow-y: auto;
  background-color: #050505;
  border: 1px solid #444;
  white-space: pre-wrap;
  word-wrap: break-word;
  padding: 10px;
  font-size: 0.95em;
}
input[type="number"],
select {
  width: auto;
  min-width: 80px;
  padding: 8px 10px;
}
.cfg-item input[type="number"] {
  max-width: 90px;
  text-align: right;
}
button {
  background-color: var(--bg);
  color: var(--fg);
  border: 2px solid var(--bdr);
  padding: var(--pad-btn);
  cursor: pointer;
  margin: 0;
  font-family: inherit;
  font-size: 1em;
  font-weight: bold;
  transition: background-color 0.2s, color 0.2s;
}
button:hover:not(:disabled) {
  background-color: var(--fg);
  color: var(--bg);
}
button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.flex-row {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: var(--gap-n);
  margin-bottom: var(--gap-n);
  align-items: stretch;
}
.flex-col {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 280px;
}
.cfg-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 10px var(--gap-s);
  align-items: baseline;
}
.cfg-item {
  display: flex;
  align-items: baseline;
  gap: var(--gap-s);
  flex-wrap: wrap;
}
.cfg-item label {
  margin-bottom: 0;
  flex-basis: 150px;
  flex-shrink: 0;
  font-size: 0.9em;
}
.cfg-item input,
.cfg-item select {
  flex-grow: 1;
  width: auto;
  min-width: 60px;
  margin-bottom: 0;
}
.persona-inputs {
  display: flex;
  gap: 5px;
  flex-grow: 1;
}
.persona-inputs input {
  min-width: 50px;
  text-align: right;
}
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: var(--gap-s);
  margin-top: var(--gap-n);
}
.metric-item {
  border: 1px solid var(--bdr);
  padding: 6px 10px;
  background-color: var(--bg);
  font-size: 0.9em;
  text-align: center;
  line-height: 1.2;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.metric-item strong {
  display: block;
  font-size: 1.1em;
  margin-top: 2px;
  word-break: break-word;
}
#core-metrics-display {
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
}
#rolling-metrics-display {
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
}
.timeline {
  list-style-type: none;
  padding: 0;
  max-height: 800px;
  overflow-y: auto;
  border: 2px solid var(--bdr);
  background-color: var(--bg);
  margin-top: var(--gap-s);
}
.timeline li {
  border-bottom: 1px solid var(--bdr);
  padding: 8px var(--gap-n) 8px 15px;
  margin-bottom: 0;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  cursor: default;
}
.timeline li:last-child {
  border-bottom: none;
}
.timeline li.summary {
  background-color: #111;
  font-size: 0.9em;
  color: #ccc;
  cursor: pointer;
}
.timeline li.summary:hover {
  background-color: #222;
  color: var(--fg);
}
.timeline li.core-step {
  padding-left: var(--gap-n);
  font-weight: bold;
  background-color: #080808;
  margin-top: 5px;
  border-top: 1px dashed gray;
}
.timeline li.sub-step {
  padding-left: 45px;
  font-size: 0.95em;
  opacity: 0.9;
}
.timeline li::before {
  content: attr(data-cycle);
  background-color: var(--fg);
  color: var(--bg);
  padding: 3px 6px;
  border-radius: 0;
  font-size: 0.85em;
  font-weight: bold;
  flex-shrink: 0;
  align-self: flex-start;
  margin-top: 2px;
}
.timeline li .log-icon {
  font-size: 1.1em;
  width: 20px;
  text-align: center;
  flex-shrink: 0;
  display: inline-block;
  margin-top: 2px;
}
.timeline li span:last-child {
  flex-grow: 1;
  line-height: 1.4;
  word-break: break-word;
}
.timeline .animated-icon {
  animation: spin 1s linear infinite;
  display: inline-block;
}
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
#meta-sandbox-output {
  width: 100%;
  min-height: 500px;
  border: 1px solid var(--bdr);
  background-color: var(--fg);
  margin-top: 15px;
}
.hidden {
  display: none !important;
}
.api-key-input {
  display: flex;
  align-items: baseline;
  gap: var(--gap-s);
  flex-grow: 1;
  flex-wrap: wrap;
}
.api-key-input label {
  flex-basis: 180px;
  flex-shrink: 0;
}
.api-key-input input {
  flex-grow: 1;
  margin-bottom: 0;
  min-width: 200px;
}
.controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: var(--gap-s);
  align-items: center;
  margin-top: 15px;
}
.state-io-buttons {
  display: contents;
}
.artifact-section {
  margin-bottom: var(--gap-n);
  padding-bottom: var(--gap-n);
  border-bottom: 1px dotted gray;
}
.artifact-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}
.artifact-collection {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: var(--gap-n);
}
.hitl-container {
  border: 1px dashed yellow;
  padding: 0;
  margin-top: 15px;
  background-color: #111;
}
.hitl-container h3 {
  color: yellow;
  border-color: yellow;
  margin-top: 0;
}
.hitl-options label {
  display: block;
  margin-bottom: 8px;
  cursor: pointer;
  font-weight: normal;
}
.hitl-options input[type="checkbox"] {
  margin-right: 8px;
}
#human-edit-artifact-textarea {
  min-height: 150px;
  width: 100%;
  margin-top: 10px;
  background-color: #1a1a1a;
  resize: vertical;
}
#meta-sandbox-container {
  border: 2px dashed cyan;
  padding: 0;
  margin-top: 15px;
  background-color: #001111;
}
#meta-sandbox-container h3 {
  color: cyan;
  border-color: cyan;
  margin-top: 0;
}
#meta-sandbox-output {
  border-color: cyan;
}
.meta-sandbox-controls {
  margin-top: 15px;
}
#genesis-state-display {
  border-style: dotted;
  opacity: 0.8;
  padding: 0;
}
#genesis-state-display legend {
  color: gray;
}
.token-warning {
  color: yellow;
  font-weight: bold;
  border: 1px solid yellow;
  padding: 3px 6px;
  margin-left: 10px;
  display: inline-block;
  font-size: 0.9em;
  border-radius: 3px;
}
#status-indicator {
  border: 1px solid gray;
  padding: 5px 10px;
  margin-left: auto;
  display: inline-block;
  font-size: 0.9em;
  min-width: 150px;
  text-align: center;
  background-color: #111;
  order: 3;
  margin-top: 5px;
}
#status-indicator.active {
  border-color: yellow;
  color: yellow;
  font-weight: bold;
  background-color: #333300;
}
#api-progress {
  font-size: 0.8em;
  margin-left: 10px;
  display: inline-block;
  color: #aaa;
  order: 4;
  margin-top: 5px;
}
#app-root {
  visibility: hidden;
}
.goal-type-selector {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 10px;
  padding-left: 10px;
}
.goal-type-selector label {
  margin-bottom: 0;
  font-weight: normal;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  text-align: left;
  min-width: auto;
  padding-right: 0;
}
.goal-type-selector input[type="radio"] {
  margin-right: 5px;
}
.model-selectors {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-n);
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-n);
}
.model-selectors .cfg-item {
  flex-basis: calc(50% - var(--gap-n) / 2);
  min-width: 280px;
}
.model-selectors label {
  flex-basis: auto;
  min-width: 120px;
  text-align: left;
}
.model-selectors select {
  flex-grow: 1;
}
#notifications-container {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.notification {
  padding: 10px 15px;
  border-radius: 4px;
  color: black;
  font-size: 0.9em;
  opacity: 0.95;
  border-left: 5px solid transparent;
  word-wrap: break-word;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}
.notification.info {
  background-color: #e0f2f7;
  border-left-color: #29b6f6;
}
.notification.warn {
  background-color: #fff3e0;
  border-left-color: #ffa726;
}
.notification.error {
  background-color: #ffebee;
  border-left-color: #ef5350;
}
.notification button {
  float: right;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  font-size: 1.1em;
  line-height: 1;
  margin-left: 10px;
  padding: 0;
  opacity: 0.6;
}
.notification button:hover {
  opacity: 1;
}
#tools-executed-container {
  margin-top: var(--gap-n);
  border-top: 1px dashed gray;
  padding-top: var(--gap-s);
}
#tools-executed-list {
  list-style: none;
  padding-left: 0;
  font-size: 0.9em;
}
#tools-executed-list li {
  margin-bottom: 5px;
  padding: 5px;
  border: 1px dotted #444;
  background-color: #0a0a0a;
}
#tools-executed-list li.tool-success {
  border-left: 3px solid green;
}
#tools-executed-list li.tool-fail {
  border-left: 3px solid red;
  background-color: #180000;
}
#tools-executed-list strong {
  color: cyan;
}
#tools-executed-list .tool-args,
#tools-executed-list .tool-result,
#tools-executed-list .tool-error {
  display: block;
  margin-left: 15px;
  font-size: 0.95em;
  color: #bbb;
  word-break: break-all;
}
#tools-executed-list .tool-error {
  color: red;
}
.autonomy-controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap-s) var(--gap-n);
  align-items: center;
  border-top: 1px dashed gray;
  padding-top: 15px;
  margin-top: 15px;
}
.autonomy-controls label {
  min-width: auto;
  text-align: left;
  margin-bottom: 0;
}
.autonomy-controls select,
.autonomy-controls input[type="number"] {
  width: auto;
  margin-bottom: 0;
}
.autonomy-controls button {
  margin-left: auto;
}
.autonomy-n-label {
  padding-left: 5px;
}

.cycle-steps-minimap {
  border: 1px solid #555;
  padding: 10px;
  background-color: #080808;
  font-size: 0.9em;
  max-height: 300px;
  overflow-y: auto;
  margin-bottom: 15px;
}
.cycle-steps-minimap ol {
  list-style-type: none;
  padding: 0;
  margin: 0;
}
.cycle-steps-minimap li {
  padding: 4px 0;
  border-bottom: 1px dotted #333;
}
.cycle-steps-minimap li:last-child {
  border-bottom: none;
}
.cycle-steps-minimap li.active-step {
  background-color: #222;
  font-weight: bold;
  color: yellow;
}
.cycle-steps-minimap .step-icon {
  display: inline-block;
  width: 20px;
  text-align: center;
  margin-right: 5px;
}

@media (max-width: 1024px) {
  :root {
    --f-sz-n: 0.95em;
    --pad-fs: 15px;
    --gap-n: 15px;
  }
  h1 {
    font-size: 1.8em;
  }
  h2 {
    font-size: 1.4em;
  }
  h3 {
    font-size: 1.15em;
  }
  .metrics-grid {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  }
  #core-metrics-display {
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  }
  .timeline {
    max-height: 600px;
  }
  .autonomy-controls button {
    margin-left: 0;
    width: 100%;
    margin-top: 10px;
  }
}
@media (max-width: 768px) {
  :root {
    --f-sz-n: 0.9em;
    --pad-fs: 10px;
    --gap-n: 12px;
    --gap-s: 6px;
    --pad-btn: 8px 14px;
  }
  body {
    padding: 10px;
  }
  h1 {
    font-size: 1.6em;
  }
  h1 small {
    font-size: 0.4em;
    line-height: 1.1;
  }
  h2 {
    font-size: 1.3em;
  }
  h3 {
    font-size: 1.1em;
  }
  legend {
    font-size: 1.2em;
    margin-left: 10px;
    padding: 4px 8px 4px 10px;
  }
  .flex-row {
    flex-direction: column;
  }
  .cfg-item {
    flex-direction: column;
    align-items: stretch;
    gap: 5px;
  }
  .cfg-item label {
    text-align: left;
    min-width: auto;
    margin-bottom: 3px;
    padding-right: 0;
    flex-basis: auto;
  }
  .cfg-item input,
  .cfg-item select {
    width: 100%;
  }
  .persona-inputs input {
    min-width: 60px;
  }
  .cfg-grid,
  .metrics-grid,
  .controls-grid {
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  }
  .api-key-input label {
    flex-basis: auto;
  }
  #status-indicator {
    margin-left: 10px;
  }
  .goal-type-selector {
    padding-left: 0;
  }
  .model-selectors .cfg-item {
    flex-basis: 100%;
  }
  .timeline {
    max-height: 500px;
  }
  .timeline li {
    padding: 6px 12px 6px 10px;
  }
}
@media (max-width: 480px) {
  :root {
    --f-sz-n: 0.85em;
  }
  h1 {
    font-size: 1.4em;
  }
  h1 small {
    display: none;
  }
  h2 {
    font-size: 1.2em;
  }
  h3 {
    font-size: 1.05em;
  }
  .cfg-grid,
  .metrics-grid,
  .controls-grid {
    grid-template-columns: 1fr;
  }
  .metric-item {
    font-size: 0.85em;
    padding: 4px 8px;
  }
  button {
    font-size: 0.95em;
    padding: 6px 10px;
  }
  .timeline li {
    gap: 6px;
  }
  .timeline li::before {
    font-size: 0.8em;
    padding: 2px 4px;
  }
  #status-indicator {
    min-width: 120px;
    font-size: 0.85em;
  }
  #api-progress {
    font-size: 0.75em;
  }
  #notifications-container {
    width: calc(100% - 20px);
    right: 10px;
    left: 10px;
  }
}
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: utils.js ---
const UtilsModule = (() => {
  class ApplicationError extends Error {
    constructor(message, details = {}) {
      super(message);
      this.name = this.constructor.name;
      this.details = details;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }

  class ApiError extends ApplicationError {
    constructor(message, status = null, code = null, apiDetails = {}) {
      super(message, { status, code, ...apiDetails });
      this.status = status;
      this.code = code;
    }
  }

  class ToolError extends ApplicationError {
    constructor(message, toolName = null, toolArgs = null, toolDetails = {}) {
      super(message, { toolName, toolArgs, ...toolDetails });
      this.toolName = toolName;
    }
  }

  class StateError extends ApplicationError {
    constructor(message, stateDetails = {}) {
      super(message, stateDetails);
    }
  }

  class ConfigError extends ApplicationError {
    constructor(message, configKey = null, configDetails = {}) {
      super(message, { configKey, ...configDetails });
      this.configKey = configKey;
    }
  }

  class ArtifactError extends ApplicationError {
    constructor(message, artifactId = null, artifactCycle = null, artifactDetails = {}) {
      super(message, { artifactId, artifactCycle, ...artifactDetails });
      this.artifactId = artifactId;
    }
  }

  class AbortError extends ApplicationError {
    constructor(message = "Operation aborted") {
      super(message);
      this.isAbortError = true;
    }
  }

  class WebComponentError extends ApplicationError {
    constructor(message, componentName = null, componentDetails = {}) {
      super(message, { componentName, ...componentDetails });
      this.componentName = componentName;
    }
  }

  const Errors = {
    ApplicationError, ApiError, ToolError, StateError,
    ConfigError, ArtifactError, AbortError, WebComponentError,
  };

  const MAX_LOG_ENTRIES = 1000;
  let logBufferArray = new Array(MAX_LOG_ENTRIES);
  let logBufferIndex = 0;
  let logBufferInitialized = false;

  const initLogBuffer = () => {
    logBufferArray.fill(null);
    logBufferIndex = 0;
    logBufferArray[logBufferIndex++] = `REPLOID Session Log Start - ${new Date().toISOString()}\n=========================================\n`;
    logBufferInitialized = true;
  };

  const stringifyDetail = (detail) => {
    if (detail === undefined || detail === null) return "";
    if (typeof detail === "string") return detail;
    if (detail instanceof Error) return `Error: ${detail.message}${detail.stack ? `\nStack: ${detail.stack}` : ""}`;
    try {
      return JSON.stringify(detail, (key, value) => typeof value === "bigint" ? value.toString() : value);
    } catch (e) {
      return "[Unserializable Object]";
    }
  };

  const logger = {
    logEvent: (level = "info", message = "[No Message]", ...details) => {
      if (!logBufferInitialized) initLogBuffer();
      const timestamp = new Date().toISOString();
      const levelUpper = String(level).toUpperCase();
      let logLine = `[${timestamp}] [${levelUpper}] ${String(message)}`;
      const detailsString = details.map(stringifyDetail).filter((s) => s !== "").join(" | ");
      if (detailsString) logLine += ` | ${detailsString}`;
      logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = logLine;
      logBufferIndex++;
      const consoleMethod = level?.toLowerCase() === "error" ? console.error :
                            level?.toLowerCase() === "warn" ? console.warn :
                            level?.toLowerCase() === "debug" ? console.debug : console.log;
      consoleMethod(logLine);
    },
    getLogBuffer: () => {
      if (!logBufferInitialized) return "Log buffer not initialized.\n";
      const bufferSize = Math.min(logBufferIndex, MAX_LOG_ENTRIES);
      const startIndex = logBufferIndex <= MAX_LOG_ENTRIES ? 0 : logBufferIndex % MAX_LOG_ENTRIES;
      const logLines = [];
      for (let i = 0; i < bufferSize; i++) {
        const currentIndex = (startIndex + i) % MAX_LOG_ENTRIES;
        if (logBufferArray[currentIndex] !== null) logLines.push(logBufferArray[currentIndex]);
      }
      let logContent = logLines.join("\n") + "\n";
      if (logBufferIndex > MAX_LOG_ENTRIES) {
        logContent = `... (Log truncated - showing last ${MAX_LOG_ENTRIES} entries) ...\n` + logContent;
      }
      return logContent;
    },
    setLogBuffer: (newBuffer) => {
      initLogBuffer();
      if (typeof newBuffer === "string") {
        const lines = newBuffer.split("\n").filter((line) => line);
        const startIndex = Math.max(0, lines.length - MAX_LOG_ENTRIES);
        let loadedCount = 0;
        for (let i = startIndex; i < lines.length; i++) {
          logBufferArray[logBufferIndex % MAX_LOG_ENTRIES] = lines[i];
          logBufferIndex++;
          loadedCount++;
        }
        if (lines.length > MAX_LOG_ENTRIES) {
          const header = `... (Log truncated during import - loaded last ${loadedCount} lines) ...`;
          const headerIndex = (logBufferIndex - loadedCount) % MAX_LOG_ENTRIES;
          logBufferArray[headerIndex] = header;
        }
      } else {
        logger.logEvent("warn", "setLogBuffer received invalid buffer type, resetting.");
      }
    },
  };

  const $id = (id) => document.getElementById(id);
  const $ = (selector, parent = document) => parent.querySelector(selector);
  const $$ = (selector, parent = document) => Array.from(parent.querySelectorAll(selector));

  const kabobToCamel = (s) => String(s ?? "").replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  const camelToKabob = (s) => String(s ?? "").replace(/([A-Z])/g, "-$1").toLowerCase();
  const ucFirst = (s) => { const str = String(s ?? ""); return str.charAt(0).toUpperCase() + str.slice(1); };

  const trunc = (str, len, ellipsis = "...") => {
    const s = String(str ?? "");
    if (s.length <= len) return s;
    const ellipsisLen = ellipsis?.length ?? 0;
    return s.substring(0, Math.max(0, len - ellipsisLen)) + ellipsis;
  };

  const escapeHtml = (unsafe) => {
    if (unsafe === null || unsafe === undefined) return "";
    return String(unsafe)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  };

  const lc = (s) => String(s ?? "").toLowerCase();
  const uc = (s) => String(s ?? "").toUpperCase();

  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  const getRandomInt = (min, max) => {
    const minCeil = Math.ceil(min);
    const maxFloor = Math.floor(max);
    return Math.floor(Math.random() * (maxFloor - minCeil + 1)) + minCeil;
  };

  const getLatestMeta = (historyArray) => {
    if (!historyArray || historyArray.length === 0) return null;
    return [...historyArray].sort((a, b) => {
      if (b.latestCycle !== a.latestCycle) return b.latestCycle - a.latestCycle;
      return (b.timestamp || 0) - (a.timestamp || 0);
    })[0];
  };

  const getDefaultState = (appConfig) => ({
    version: appConfig.STATE_VERSION,
    totalCycles: 0, agentIterations: 0, humanInterventions: 0, failCount: 0,
    currentGoal: { seed: null, cumulative: null, latestType: "Idle", summaryContext: null, currentContextFocus: null },
    lastCritiqueType: "N/A", personaMode: "XYZ", lastFeedback: null, lastSelfAssessment: null,
    forceHumanReview: false, apiKey: "",
    confidenceHistory: [], critiqueFailHistory: [], tokenHistory: [], failHistory: [], evaluationHistory: [], critiqueFeedbackHistory: [],
    avgConfidence: null, critiqueFailRate: null, avgTokens: null, avgEvalScore: null, evalPassRate: null,
    contextTokenEstimate: 0, contextTokenTarget: appConfig.CTX_TARGET || 700000,
    lastGeneratedFullSource: null, htmlHistory: [], lastApiResponse: null, retryCount: 0,
    autonomyMode: "Manual", autonomyCyclesRemaining: 0,
    cfg: { ...(appConfig.DEFAULT_CFG || {}) },
    artifactMetadata: {}, dynamicTools: [], registeredWebComponents: [],
  });

  async function calculateChecksum(content) {
    if (typeof content !== "string") return null;
    try {
      const msgUint8 = new TextEncoder().encode(content);
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return `sha256-${hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")}`;
    } catch (error) {
      logger.logEvent("error", "Checksum calculation failed:", error);
      return null;
    }
  }

  function sanitizeLlmJsonRespPure(rawText, externalLogger) {
    if (!rawText || typeof rawText !== "string") return { sanitizedJson: "{}", method: "invalid input" };
    let text = rawText.trim();
    let jsonString = null;
    let method = "none";

    try {
      JSON.parse(text);
      jsonString = text;
      method = "direct parse";
    } catch (e1) {
      const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch && codeBlockMatch[1]) {
        text = codeBlockMatch[1].trim();
        method = "code block";
        try {
          JSON.parse(text);
          jsonString = text;
        } catch (e2) {}
      }

      if (!jsonString) {
        const firstBrace = text.indexOf("{");
        const firstBracket = text.indexOf("[");
        let startIndex = -1;

        if (firstBrace !== -1 && firstBracket !== -1) startIndex = Math.min(firstBrace, firstBracket);
        else if (firstBrace !== -1) startIndex = firstBrace;
        else startIndex = firstBracket;

        if (startIndex !== -1) {
          text = text.substring(startIndex);
          const startChar = text[0];
          const endChar = startChar === "{" ? "}" : "]";
          let balance = 0;
          let lastValidIndex = -1;
          let inString = false;
          let escapeNext = false;
          method = "heuristic balance";

          for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (inString) {
              if (escapeNext) escapeNext = false;
              else if (char === "\\") escapeNext = true;
              else if (char === '"') inString = false;
            } else {
              if (char === '"') inString = true;
              else if (char === startChar) balance++;
              else if (char === endChar) balance--;
            }
            if (!inString && balance === 0 && startIndex === 0) { lastValidIndex = i; break; }
            if (!inString && balance === 0 && i > 0 && startIndex > 0) { lastValidIndex = i; break; }
          }

          if (lastValidIndex !== -1) {
            text = text.substring(0, lastValidIndex + 1);
            try { JSON.parse(text); jsonString = text; }
            catch (e3) {
              externalLogger?.logEvent("warn", `JSON sanitization failed (heuristic parse): ${e3.message}`, text.substring(0, 100) + "...");
              method = "heuristic failed"; jsonString = null;
            }
          } else {
            externalLogger?.logEvent("warn", "JSON sanitization failed: Unbalanced structure after heuristic.", text.substring(0, 100));
            method = "heuristic unbalanced"; jsonString = null;
          }
        } else { method = "no structure found"; jsonString = null; }
      }
    }
    return { sanitizedJson: jsonString || "{}", method };
  }


  return {
    Errors,
    logger,
    $id, $, $$,
    kabobToCamel, camelToKabob, ucFirst,
    trunc, escapeHtml, lc, uc,
    delay, getRandomInt, getLatestMeta,
    getDefaultState,
    calculateChecksum,
    sanitizeLlmJsonRespPure
  };
})();
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: storage.js ---
const StorageModule = (config, logger, Errors) => {
  if (!config || !logger || !Errors) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[STORAGE_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error","StorageModule initialization failed: Missing config, logger, or Errors.");
    return {
      getArtifactContent: () => null,
      setArtifactContent: () => { throw new Error("Storage not initialized"); },
      deleteArtifactVersion: () => false,
      getState: () => null,
      saveState: () => { throw new Error("Storage not initialized"); },
      removeState: () => false,
      getSessionState: () => null,
      saveSessionState: () => { throw new Error("Storage not initialized"); },
      removeSessionState: () => {},
      clearAllReploidData: () => { internalLog.logEvent("error", "Cannot clear storage, module not initialized."); },
      getStorageUsage: () => ({ used: 0, quota: 0, percent: 0 }),
    };
  }

  const LS_PREFIX = config.LS_PREFIX;
  const STATE_KEY_BASE = config.STATE_KEY_BASE;
  const SESSION_STATE_KEY_BASE = config.SESSION_STATE_KEY_BASE;
  const MAX_ART_TKN_SZ = config.MAX_ARTIFACT_SIZE_BYTES || 4 * 1024 * 1024;
  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(".")[0];
  const stateKey = STATE_KEY_BASE + STATE_VERSION_MAJOR;
  const sessionStateKey = SESSION_STATE_KEY_BASE + STATE_VERSION_MAJOR;
  const QUOTA_BYTES = 5 * 1024 * 1024;
  const QUOTA_WARNING_THRESHOLD = 0.9;
  const { StorageError } = Errors;

  const getStorageUsage = () => {
    let totalBytes = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if ((key && key.startsWith(LS_PREFIX)) || key === stateKey) {
          const value = localStorage.getItem(key);
          totalBytes += (value?.length || 0) * 2;
        }
      }
      const percent = QUOTA_BYTES > 0 ? (totalBytes / QUOTA_BYTES) * 100 : 0;
      return { used: totalBytes, quota: QUOTA_BYTES, percent: percent };
    } catch (e) {
      logger.logEvent("error", "Failed to calculate storage usage", e);
      return { used: -1, quota: QUOTA_BYTES, percent: -1 };
    }
  };

  const _get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      logger.logEvent("error", `LocalStorage GET Error for key: ${key}`, e);
      return null;
    }
  };

  const _set = (key, value) => {
    if (value && typeof value === "string" && value.length * 2 > MAX_ART_TKN_SZ) {
      const msg = `Artifact content exceeds size limit (${value.length * 2} > ${MAX_ART_TKN_SZ} bytes) for key: ${key}`;
      logger.logEvent("error", msg);
      throw new StorageError(msg, { key, size: value.length * 2 });
    }

    const usage = getStorageUsage();
    const estimatedNewSize = (value?.length || 0) * 2;
    const currentItemSize = (_get(key)?.length || 0) * 2;
    const estimatedUsageAfter = usage.used - currentItemSize + estimatedNewSize;

    if (usage.used >= 0 && estimatedUsageAfter / QUOTA_BYTES > QUOTA_WARNING_THRESHOLD) {
      logger.logEvent("warn", `LocalStorage usage high (${((estimatedUsageAfter / QUOTA_BYTES) * 100).toFixed(1)}%) after setting key: ${key}`);
    }

    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      let errorMessage = `LocalStorage SET Error for key: ${key}`;
      if (e.name === "QuotaExceededError" || (e.code && (e.code === 22 || e.code === 1014))) {
        errorMessage = `LocalStorage Quota Exceeded. Usage: ${(usage.used / 1024 / 1024).toFixed(2)}MB / ${(QUOTA_BYTES / 1024 / 1024).toFixed(2)}MB.`;
        logger.logEvent("error", errorMessage, e);
        throw new StorageError(errorMessage, { key, quotaExceeded: true });
      } else {
        logger.logEvent("error", errorMessage, e);
        throw new StorageError(errorMessage, { key, originalError: e });
      }
    }
  };

  const _remove = (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      logger.logEvent("error", `LocalStorage REMOVE Error for key: ${key}`, e);
      return false;
    }
  };

  const _key = (id, cycle = 0, versionId = null) => {
    let baseKey = `${LS_PREFIX}${id}_${cycle}`;
    if (versionId !== null && typeof versionId === "string" && versionId.length > 0) {
      baseKey += `#${versionId}`;
    }
    return baseKey;
  };

  const getArtifactContent = (id, cycle, versionId = null) => _get(_key(id, cycle, versionId));

  const setArtifactContent = (id, cycle, content, versionId = null) => _set(_key(id, cycle, versionId), content);

  const deleteArtifactVersion = (id, cycle, versionId = null) => _remove(_key(id, cycle, versionId));

  const getState = () => {
    const json = _get(stateKey);
    try {
      return json ? JSON.parse(json) : null;
    } catch (e) {
      logger.logEvent("error", `Failed to parse state from localStorage: ${e.message}`);
      _remove(stateKey);
      return null;
    }
  };

  const saveState = (stateObj) => {
    try {
      return _set(stateKey, JSON.stringify(stateObj));
    } catch (e) {
      logger.logEvent("error", "Failed to save state due to storage error.", e);
      throw e;
    }
  };

  const removeState = () => _remove(stateKey);

  const getSessionState = () => {
    try {
      const json = sessionStorage.getItem(sessionStateKey);
      return json ? JSON.parse(json) : null;
    } catch (e) {
      logger.logEvent("error", `Failed to parse session state: ${e.message}`);
      try { sessionStorage.removeItem(sessionStateKey); } catch (se) {}
      return null;
    }
  };

  const saveSessionState = (stateObj) => {
    try {
      sessionStorage.setItem(sessionStateKey, JSON.stringify(stateObj));
      return true;
    } catch (e) {
      logger.logEvent("error", `SessionStorage SET Error: ${e.message}`);
      if (e.name === "QuotaExceededError") {
        throw new StorageError(`SessionStorage Quota Exceeded.`, { quotaExceeded: true });
      }
      throw new StorageError(`SessionStorage SET Error: ${e.message}`, { originalError: e });
    }
  };

  const removeSessionState = () => {
    try { sessionStorage.removeItem(sessionStateKey); }
    catch (e) { logger.logEvent("warn", `SessionStorage REMOVE Error: ${e.message}`); }
  };

  const clearAllReploidData = () => {
    logger.logEvent("warn", "Initiating LocalStorage clear for Reploid data.");
    let keysToRemove = [];
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => _remove(key));
      removeState();
      logger.logEvent("info", `Removed ${keysToRemove.length} artifact/state keys from localStorage.`);
      try { sessionStorage.clear(); logger.logEvent("info", "Cleared SessionStorage."); }
      catch (e) { logger.logEvent("warn", "Failed to clear SessionStorage.", e.message); }
    } catch (e) {
      logger.logEvent("error", `Error during key iteration/removal in clearAllReploidData: ${e.message}`);
    }
  };

  return {
    getArtifactContent,
    setArtifactContent,
    deleteArtifactVersion,
    getState,
    saveState,
    removeState,
    getSessionState,
    saveSessionState,
    removeSessionState,
    clearAllReploidData,
    getStorageUsage,
  };
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: api-client.js ---
const ApiClientModule = (config, logger, Errors, Utils) => {
  if (!config || !logger || !Errors || !Utils) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[APICLIENT_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error", "ApiClientModule initialization failed: Missing dependencies.");
    return {
      callApiWithRetry: async () => { throw new (Errors?.ApiError || Error)("ApiClient not initialized"); },
      abortCurrentCall: () => { internalLog.logEvent("warn", "ApiClient not initialized, cannot abort."); },
      sanitizeLlmJsonResp: (rawText) => Utils?.sanitizeLlmJsonRespPure(rawText, internalLog).sanitizedJson || "{}",
    };
  }

  let currentAbortController = null;
  const API_ENDPOINT_BASE = config.GEMINI_STREAM_ENDPOINT_BASE || "https://generativelanguage.googleapis.com/v1beta/models/";
  const RETRY_DELAY_BASE_MS = config.API_RETRY_DELAY_BASE_MS || 1500;
  const RETRY_DELAY_MAX_MS = 30000;
  const DEFAULT_MAX_OUTPUT_TOKENS = 8192;
  const { ApiError, AbortError } = Errors;

  const sanitizeLlmJsonResp = (rawText) => {
    const { sanitizedJson, method } = Utils.sanitizeLlmJsonRespPure(rawText, logger);
    logger.logEvent("debug", `JSON sanitization method used: ${method}`);
    return sanitizedJson;
  };

  const callGeminiAPIStream = async (
    prompt, sysInstr, modelName, apiKey, funcDecls = [],
    prevContent = null, abortSignal, generationConfigOverrides = {},
    progressCallback = () => {}
  ) => {
    const apiEndpoint = `${API_ENDPOINT_BASE}${modelName}:streamGenerateContent`;
    logger.logEvent("info", `Streaming API Call: ${modelName}`, {
      endpoint: apiEndpoint, hasSysInstr: !!sysInstr,
      toolsCount: funcDecls.length, isContinuation: !!prevContent,
    });
    if (progressCallback) progressCallback({ type: "status", content: "Starting..." });

    const baseGenCfg = {
      temperature: 0.777,
      maxOutputTokens: DEFAULT_MAX_OUTPUT_TOKENS,
      ...(generationConfigOverrides || {}),
    };

    const safetySettings = [
      "HARASSMENT", "HATE_SPEECH", "SEXUALLY_EXPLICIT", "DANGEROUS_CONTENT",
    ].map((cat) => ({ category: `HARM_CATEGORY_${cat}`, threshold: "BLOCK_MEDIUM_AND_ABOVE" }));

    const reqBody = {
      contents: [],
      safetySettings: safetySettings,
      generationConfig: { ...baseGenCfg },
    };

    if (sysInstr) reqBody.systemInstruction = { role: "system", parts: [{ text: sysInstr }] };
    if (prevContent) reqBody.contents = [...prevContent];
    if (prompt) reqBody.contents.push({ role: "user", parts: [{ text: prompt }] });

    if (funcDecls?.length > 0) {
      reqBody.tools = [{ functionDeclarations: funcDecls }];
      reqBody.tool_config = { function_calling_config: { mode: "AUTO" } };
      delete reqBody.generationConfig.responseMimeType;
    } else {
      reqBody.generationConfig.responseMimeType = "application/json";
    }

    let accumulatedText = "";
    let accumulatedFunctionCall = null;
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    let finalFinishReason = "UNKNOWN";
    let finalRawResponse = null;
    let lastReportedAccumulatedResult = null;
    let responseStatus = 0;
    let responseHeaders = {};
    let blockReason = null;
    let blockSafetyRatings = [];

    try {
      const response = await fetch(`${apiEndpoint}?key=${apiKey}&alt=sse`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(reqBody),
        signal: abortSignal,
      });

      responseStatus = response.status;
      response.headers.forEach((value, key) => { responseHeaders[key] = value; });

      if (!response.ok || !response.body) {
        let errBodyText = "(Failed to read error body)";
        try { errBodyText = await response.text(); } catch (e) {}
        let errJson = {};
        try { errJson = JSON.parse(errBodyText); } catch (e) {}
        const errorMessage = errJson?.error?.message || response.statusText || errBodyText;
        throw new ApiError(`API Error (${response.status}): ${errorMessage}`, response.status, null, { body: errBodyText, headers: responseHeaders });
      }

      if (progressCallback) progressCallback({ type: "status", content: "Receiving..." });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        if (abortSignal?.aborted) throw new AbortError("Aborted by signal");
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const chunk = JSON.parse(line.substring(6));
              finalRawResponse = chunk;

              if (chunk.promptFeedback?.blockReason) {
                blockReason = chunk.promptFeedback.blockReason;
                blockSafetyRatings = chunk.promptFeedback.safetyRatings || [];
                throw new ApiError(`API Blocked (Prompt): ${blockReason}`, 400, "PROMPT_BLOCK", { safetyRatings: blockSafetyRatings });
              }
              if (chunk.error) {
                throw new ApiError(`API Error in chunk: ${chunk.error.message || "Unknown"}`, chunk.error.code || 500, "API_CHUNK_ERROR");
              }

              if (chunk.usageMetadata) {
                totalInputTokens = chunk.usageMetadata.promptTokenCount || totalInputTokens;
                totalOutputTokens = chunk.usageMetadata.candidatesTokenCount || totalOutputTokens;
              }

              const candidate = chunk.candidates?.[0];
              if (candidate) {
                if (candidate.tokenCount) totalOutputTokens = Math.max(totalOutputTokens, candidate.tokenCount);
                finalFinishReason = candidate.finishReason || finalFinishReason;
                const currentSafetyRatings = candidate.safetyRatings || [];

                if (finalFinishReason === "SAFETY") {
                  blockReason = "SAFETY";
                  throw new ApiError("API Response Blocked: SAFETY", 400, "RESPONSE_BLOCK_SAFETY", { safetyRatings: currentSafetyRatings });
                }
                if (finalFinishReason === "RECITATION") {
                  blockReason = "RECITATION";
                  throw new ApiError("API Response Blocked: RECITATION", 400, "RESPONSE_BLOCK_RECITATION");
                }
                if (finalFinishReason === "MAX_TOKENS") logger.logEvent("warn", "API response hit MAX_TOKENS limit.", chunk);
                if (finalFinishReason === "OTHER") logger.logEvent("warn", `API response finished with reason OTHER.`, chunk);

                const part = candidate.content?.parts?.[0];
                let progressUpdate = null;

                if (part?.text) {
                  accumulatedText += part.text;
                  progressUpdate = { type: "text", content: part.text, accumulated: accumulatedText };
                } else if (part?.functionCall) {
                  if (!accumulatedFunctionCall) accumulatedFunctionCall = { name: part.functionCall.name || "", args: {} };
                  else if (part.functionCall.name && !accumulatedFunctionCall.name) accumulatedFunctionCall.name = part.functionCall.name;

                  if (typeof part.functionCall.args === "object" && part.functionCall.args !== null) {
                    try { Object.assign(accumulatedFunctionCall.args, part.functionCall.args); }
                    catch (mergeError) {
                      logger.logEvent("warn", `Error merging function call args for ${accumulatedFunctionCall.name}`, mergeError);
                      accumulatedFunctionCall.args = part.functionCall.args;
                    }
                  }
                  progressUpdate = { type: "functionCall", content: part.functionCall, accumulated: { ...accumulatedFunctionCall } };
                }

                if (progressCallback && progressUpdate) {
                  lastReportedAccumulatedResult = {
                    type: accumulatedFunctionCall ? "functionCall" : accumulatedText ? "text" : "empty",
                    content: accumulatedFunctionCall ? { ...accumulatedFunctionCall } : accumulatedText,
                    inputTokenCount: totalInputTokens, outputTokenCount: totalOutputTokens,
                    totalTokenCount: totalInputTokens + totalOutputTokens,
                    finishReason: finalFinishReason, blockReason: blockReason,
                    safetyRatings: currentSafetyRatings, rawResp: finalRawResponse,
                    status: responseStatus, headers: responseHeaders,
                  };
                  progressUpdate.accumulatedResult = lastReportedAccumulatedResult;
                  progressCallback(progressUpdate);
                }
              }
              if (progressCallback && (totalInputTokens > 0 || totalOutputTokens > 0)) {
                progressCallback({ type: "status", content: `Tokens: In ${totalInputTokens}, Out ${totalOutputTokens}` });
              }
            } catch (e) {
              if (e instanceof AbortError || e instanceof ApiError) throw e;
              logger.logEvent("warn", `Failed to parse/process SSE chunk: ${e.message}`, line);
            }
          }
        }
      }

      if (finalRawResponse?.usageMetadata) {
        totalInputTokens = finalRawResponse.usageMetadata.promptTokenCount || totalInputTokens;
        totalOutputTokens = finalRawResponse.usageMetadata.candidatesTokenCount || totalOutputTokens;
      }

      logger.logEvent("info", `API Stream OK. Finish:${finalFinishReason}. Tokens In:${totalInputTokens}, Out:${totalOutputTokens}`);
      if (progressCallback) progressCallback({ type: "status", content: "Done" });

      const finalResult = {
        type: accumulatedFunctionCall ? "functionCall" : accumulatedText ? "text" : "empty",
        content: accumulatedFunctionCall ? accumulatedFunctionCall : accumulatedText,
        inputTokenCount: totalInputTokens, outputTokenCount: totalOutputTokens,
        totalTokenCount: totalInputTokens + totalOutputTokens,
        finishReason: finalFinishReason, blockReason: blockReason,
        safetyRatings: finalRawResponse?.candidates?.[0]?.safetyRatings || blockSafetyRatings,
        rawResp: finalRawResponse, status: responseStatus, headers: responseHeaders,
      };
      if (finalFinishReason === "MAX_TOKENS") finalResult.warning = "Response may be truncated due to maximum output token limit.";
      return finalResult;

    } catch (error) {
      if (!(error instanceof AbortError)) {
        logger.logEvent("error", `API Stream Error: ${error.message}`, { status: error.status, reason: error.code, details: error.details, error });
      } else {
        logger.logEvent("info", "API call aborted by user or signal.");
      }
      if (progressCallback) progressCallback({ type: "status", content: error instanceof AbortError ? "Aborted" : "Error" });
      throw error;
    }
  };

  const callApiWithRetry = async (
    prompt, sysInstr, modelName, apiKey, funcDecls = [],
    isContinuation = false, prevContent = null, maxRetries = 1,
    generationConfigOverrides = {},
    updateStatusFn = () => {}, logTimelineFn = () => ({}), updateTimelineFn = () => {},
    progressCallback = () => {}
  ) => {
    if (currentAbortController) {
      logger.logEvent("warn", "Aborting previous API call before starting new one.");
      currentAbortController.abort("New call initiated");
    }
    currentAbortController = new AbortController();
    let attempt = 0;
    let currentDelay = RETRY_DELAY_BASE_MS;

    while (attempt <= maxRetries) {
      let logItem = null;
      try {
        const attemptMsg = attempt > 0 ? `[RETRY ${attempt}/${maxRetries}]` : "";
        const statusMsg = `${attemptMsg} Calling Gemini (${modelName})...`;
        const currentCycle = StateManager?.getState()?.totalCycles ?? 0;

        if (attempt === 0 && !isContinuation) {
          updateStatusFn(statusMsg, true);
          logItem = logTimelineFn(currentCycle, `[API] Calling ${modelName}...`, "api", true, true);
        } else if (attempt > 0) {
          updateStatusFn(statusMsg, true);
          logItem = logTimelineFn(currentCycle, `[API RETRY ${attempt}] Calling ${modelName}...`, "retry", true, true);
        }

        const result = await callGeminiAPIStream(
          prompt, sysInstr, modelName, apiKey, funcDecls, prevContent,
          currentAbortController.signal, generationConfigOverrides,
          (progress) => {
            if (progress.type === "status" && !["Starting...", "Receiving...", "Done"].includes(progress.content)) {
              if (logItem) updateTimelineFn(logItem, `[API:${modelName}] ${progress.content}`, "api", false);
            }
            progressCallback(progress);
            if (progress.type === "status" && progress.content !== "Starting...") {
              updateStatusFn(progress.content === "Done" ? "Processing..." : progress.content);
            }
          }
        );

        if (logItem) updateTimelineFn(logItem, `[API OK:${modelName}] Fin: ${result.finishReason}, TkIn: ${result.inputTokenCount}, TkOut: ${result.outputTokenCount}, St: ${result.status}${result.warning ? " (Warn: Truncated?)" : ""}`, "api", true);
        if (!isContinuation) updateStatusFn("Processing...");
        currentAbortController = null;
        return result;

      } catch (error) {
        if (error instanceof AbortError) {
          if (logItem) updateTimelineFn(logItem, `[API Aborted:${modelName}] ${error.message || "User cancelled"}`, "warn", true);
          if (!isContinuation) updateStatusFn("Aborted");
          currentAbortController = null;
          throw error;
        }

        const status = error.status || 0;
        const reason = error.code || "UNKNOWN_ERROR";
        const errorMessage = error.message || "Unknown API error";

        logger.logEvent("warn", `API attempt ${attempt} failed: ${errorMessage}. Status: ${status}, Reason: ${reason}. Retries left: ${maxRetries - attempt}`);
        if (logItem) updateTimelineFn(logItem, `[API ERR ${attempt}:${modelName}] ${status} ${reason} ${String(errorMessage).substring(0,50)} (Retries left: ${maxRetries - attempt})`, "error", true);

        attempt++;
        if (attempt > maxRetries) {
          logger.logEvent("error", `API call failed after ${maxRetries} retries.`);
          if (!isContinuation) updateStatusFn(`API Failed (${status} ${reason})`, false, true);
          currentAbortController = null;
          throw new ApiError(`API call failed after ${maxRetries} retries: ${errorMessage}`, status, reason, { finalAttempt: true, originalError: error });
        }

        let shouldRetry = false;
        let specificDelay = null;

        if (status === 429 || status === 408) {
          shouldRetry = true;
          const retryAfterHeader = error.details?.headers?.["retry-after"];
          if (retryAfterHeader) {
            const retrySeconds = parseInt(retryAfterHeader, 10);
            if (!isNaN(retrySeconds)) {
              specificDelay = Math.min(retrySeconds * 1000, RETRY_DELAY_MAX_MS);
              logger.logEvent("info", `API Rate limit/Timeout (${status}). Retrying after specified ${retrySeconds}s.`);
            }
          }
          if (!specificDelay) logger.logEvent("info", `API Rate limit/Timeout (${status}). Retrying with exponential backoff.`);
        } else if (status >= 500 && status < 600) {
          shouldRetry = true;
          logger.logEvent("info", `API server error (${status}). Retrying with exponential backoff.`);
        } else if (reason === "PROMPT_BLOCK" || reason === "RESPONSE_BLOCK_SAFETY" || reason === "RESPONSE_BLOCK_RECITATION") {
          shouldRetry = false;
          logger.logEvent("error", `API error non-retryable (content block): ${reason}`, error.details?.safetyRatings);
        } else if (error.message.includes("Failed to fetch") || error.message.includes("NetworkError")) {
          shouldRetry = true;
          logger.logEvent("info", `API network error. Retrying with exponential backoff.`);
        } else {
          shouldRetry = false;
          logger.logEvent("error", `API error deemed non-retryable: Status ${status}, Reason ${reason}, Msg: ${errorMessage}`);
        }

        if (!shouldRetry) {
          if (!isContinuation) updateStatusFn(`API Failed (${status} Non-retryable)`, false, true);
          currentAbortController = null;
          throw new ApiError(`API call failed (non-retryable): ${errorMessage}`, status, reason, { finalAttempt: true, originalError: error });
        }

        const delayMs = specificDelay !== null ? specificDelay : currentDelay;
        if (!isContinuation) updateStatusFn(`API Error (${status}). Retrying in ${Math.round(delayMs / 1000)}s...`);
        if (currentAbortController?.signal.aborted) { currentAbortController = null; throw new AbortError("Aborted during retry delay"); }
        await Utils.delay(delayMs);
        if (currentAbortController?.signal.aborted) { currentAbortController = null; throw new AbortError("Aborted after retry delay"); }
        currentDelay = Math.min(currentDelay * 2, RETRY_DELAY_MAX_MS);
      }
    }
    currentAbortController = null;
    throw new ApiError("callApiWithRetry reached end unexpectedly.", 500, "UNEXPECTED_END");
  };

  const abortCurrentCall = (reason = "User requested abort") => {
    if (currentAbortController) {
      logger.logEvent("info", `User requested API call abort. Reason: ${reason}`);
      currentAbortController.abort(reason);
      currentAbortController = null;
    } else {
      logger.logEvent("info", "No active API call to abort.");
    }
  };

  return {
    callApiWithRetry,
    abortCurrentCall,
    sanitizeLlmJsonResp,
  };
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: tool-worker.js ---
let messageCallbacks = {};
let messageIdCounter = 0;

self.onmessage = async (event) => {
  const { type, payload, id, data, error } = event.data;

  if (type === "init") {
    const { toolCode, toolArgs } = payload;
    try {
      const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
      const func = new AsyncFunction("params", "LS", "StateManager", toolCode + "\n\nreturn await run(params);");
      const result = await func(toolArgs, self.LS_shim, self.StateManager_shim);
      self.postMessage({ success: true, result: result });
    } catch (e) {
      const errorDetail = {
        message: e.message || "Unknown worker execution error",
        stack: e.stack,
        name: e.name,
      };
      self.postMessage({ success: false, error: errorDetail });
    }
  } else if (type === "response") {
    const callback = messageCallbacks[id];
    if (callback) {
      if (error) {
        callback.reject(new Error(error.message || "Worker shim request failed"));
      } else {
        callback.resolve(data);
      }
      delete messageCallbacks[id];
    }
  }
};

function makeShimRequest(requestType, payload) {
  return new Promise((resolve, reject) => {
    const id = messageIdCounter++;
    messageCallbacks[id] = { resolve, reject };
    self.postMessage({
      type: "request",
      id: id,
      requestType: requestType,
      payload: payload,
    });
  });
}

self.LS_shim = {
  getArtifactContent: (id, cycle, versionId = null) => {
    if (typeof id !== "string" || typeof cycle !== "number" || (versionId !== null && typeof versionId !== "string")) {
      return Promise.reject(new Error("Invalid arguments for getArtifactContent"));
    }
    return makeShimRequest("getArtifactContent", { id, cycle, versionId });
  },
};

self.StateManager_shim = {
  getArtifactMetadata: (id, versionId = null) => {
    if (typeof id !== "string" || (versionId !== null && typeof versionId !== "string")) {
      return Promise.reject(new Error("Invalid arguments for getArtifactMetadata"));
    }
    return makeShimRequest("getArtifactMetadata", { id, versionId });
  },
  getArtifactMetadataAllVersions: (id) => {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid arguments for getArtifactMetadataAllVersions"));
    }
    return makeShimRequest("getArtifactMetadataAllVersions", { id });
  },
  getAllArtifactMetadata: () => {
    return makeShimRequest("getAllArtifactMetadata", {});
  },
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: state-helpers-pure.js ---
const StateHelpersPureModule = (() => {

  const calculateDerivedStatsPure = (
    confidenceHistory = [],
    critiqueFailHistory = [],
    tokenHistory = [],
    evaluationHistory = [],
    maxHistoryItems = 20,
    evalPassThreshold = 0.75
  ) => {
    const stats = {
      avgConfidence: null,
      critiqueFailRate: null,
      avgTokens: null,
      avgEvalScore: null,
      evalPassRate: null,
    };

    const confHistorySlice = confidenceHistory.slice(-maxHistoryItems);
    if (confHistorySlice.length > 0) {
      stats.avgConfidence = confHistorySlice.reduce((a, b) => a + (b || 0), 0) / confHistorySlice.length;
    }

    const critHistorySlice = critiqueFailHistory.slice(-maxHistoryItems);
    if (critHistorySlice.length > 0) {
      const fails = critHistorySlice.filter((v) => v === true).length;
      stats.critiqueFailRate = (fails / critHistorySlice.length) * 100;
    }

    const tokenHistorySlice = tokenHistory.slice(-maxHistoryItems);
    if (tokenHistorySlice.length > 0) {
      stats.avgTokens = tokenHistorySlice.reduce((a, b) => a + (b || 0), 0) / tokenHistorySlice.length;
    }

    const evalHistorySlice = evaluationHistory.slice(-maxHistoryItems);
    if (evalHistorySlice.length > 0) {
      const validScores = evalHistorySlice.map((e) => e.evaluation_score).filter((s) => typeof s === "number" && !isNaN(s));
      if (validScores.length > 0) {
        stats.avgEvalScore = validScores.reduce((a, b) => a + b, 0) / validScores.length;
        const passes = validScores.filter((s) => s >= evalPassThreshold).length;
        stats.evalPassRate = (passes / validScores.length) * 100;
      }
    }
    return stats;
  };

  const validateStateStructurePure = (stateObj, configStateVersion, defaultStateFactory) => {
    if (!stateObj || typeof stateObj !== "object") return "Invalid state object";

    const defaultState = defaultStateFactory(configStateVersion ? { STATE_VERSION: configStateVersion, DEFAULT_CFG: {} } : null );
    const requiredKeys = Object.keys(defaultState);
    const optionalKeys = ["lastApiResponse", "lastGeneratedFullSource", "lastSelfAssessment"];

    for (const key of requiredKeys) {
      if (!(key in stateObj) && !optionalKeys.includes(key)) {
        const loadedVersion = stateObj.version?.split(".").map(Number) || [0,0,0];
        const currentVersion = configStateVersion?.split(".").map(Number) || [0,0,0];
        let isOlderMajorMinor = false;
        if (loadedVersion.length === 3 && currentVersion.length === 3) {
          if (loadedVersion[0] < currentVersion[0] || (loadedVersion[0] === currentVersion[0] && loadedVersion[1] < currentVersion[1])) {
            isOlderMajorMinor = true;
          }
        }
        if (!isOlderMajorMinor) {
          const criticalKeys = ["version", "totalCycles", "artifactMetadata", "dynamicTools", "cfg", "registeredWebComponents"];
          if (criticalKeys.includes(key)) {
            return `Missing critical property: '${key}' (v${stateObj.version})`;
          }
        }
      }
    }
    if (!Array.isArray(stateObj.registeredWebComponents)) {
      return "Property 'registeredWebComponents' must be an array";
    }
    return null;
  };

  const mergeWithDefaultsPure = (loadedState, defaultStateFactory, configStateVersion) => {
    const defaultState = defaultStateFactory(configStateVersion ? { STATE_VERSION: configStateVersion, DEFAULT_CFG: {} } : null );
    const mergedState = {
      ...defaultState,
      ...loadedState,
      cfg: { ...defaultState.cfg, ...(loadedState.cfg || {}) },
      artifactMetadata: loadedState.artifactMetadata || {},
      dynamicTools: loadedState.dynamicTools || [],
      registeredWebComponents: Array.isArray(loadedState.registeredWebComponents) ? loadedState.registeredWebComponents : [],
    };
    const historyKeys = [
      "confidenceHistory", "critiqueFailHistory", "tokenHistory",
      "failHistory", "evaluationHistory", "critiqueFeedbackHistory", "htmlHistory",
    ];
    historyKeys.forEach((key) => {
      if (!Array.isArray(mergedState[key])) mergedState[key] = [];
    });
    return mergedState;
  };

  return {
    calculateDerivedStatsPure,
    validateStateStructurePure,
    mergeWithDefaultsPure,
  };
})();
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: state-manager.js ---
const StateManagerModule = (config, logger, Storage, Errors, StateHelpersPure, Utils) => {
  if (!config || !logger || !Storage || !Errors || !StateHelpersPure || !Utils) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[STATEMANAGER_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error", "StateManagerModule initialization failed: Missing dependencies.");
    const fakeMethods = [
      "init", "getState", "setState", "save", "getArtifactMetadata", "getArtifactMetadataAllVersions",
      "updateArtifactMetadata", "deleteArtifactMetadata", "getAllArtifactMetadata", "capturePreservationState",
      "restoreStateFromSession", "exportState", "importState", "isInitialized",
      "addEvaluationResult", "addCritiqueFeedback", "registerWebComponent", "isWebComponentRegistered",
      "getRegisteredWebComponents", "updateAndSaveState",
    ];
    const fakeStateManager = {};
    fakeMethods.forEach((method) => {
      fakeStateManager[method] = () => {
        internalLog.logEvent("error", `StateManager not initialized. Called ${method}.`);
        if (method === "isInitialized") return false;
        if (method === "getState") return null;
        if (method === "getAllArtifactMetadata" || method === "getRegisteredWebComponents") return {};
        if (method === "getArtifactMetadataAllVersions") return [];
      };
    });
    return fakeStateManager;
  }

  const { StateError } = Errors;
  let globalState = null;
  let isInitializedFlag = false;

  const STATE_VERSION_MAJOR = config.STATE_VERSION.split(".")[0];
  const STATE_VERSION_MINOR = config.STATE_VERSION.split(".")[1];
  const STATE_VERSION_PATCH = config.STATE_VERSION.split(".")[2];
  const MAX_HISTORY_ITEMS = config.MAX_HISTORY_ITEMS || 20;
  const EVAL_PASS_THRESHOLD = config.EVAL_PASS_THRESHOLD || 0.75;


  const calculateDerivedStatsAndUpdateState = (stateToUpdate) => {
    if (!stateToUpdate) return;
    const derived = StateHelpersPure.calculateDerivedStatsPure(
      stateToUpdate.confidenceHistory,
      stateToUpdate.critiqueFailHistory,
      stateToUpdate.tokenHistory,
      stateToUpdate.evaluationHistory,
      MAX_HISTORY_ITEMS,
      EVAL_PASS_THRESHOLD
    );
    Object.assign(stateToUpdate, derived);
  };

  const checkAndLogVersionDifference = (loadedVersion, source) => {
    if (!loadedVersion || typeof loadedVersion !== "string") return true;
    const [major, minor, patch] = loadedVersion.split(".").map(Number);
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
      logger.logEvent("warn", `Invalid version string '${loadedVersion}' in state from ${source}. Proceeding cautiously.`);
      return true;
    }
    if (major !== parseInt(STATE_VERSION_MAJOR, 10)) {
      logger.logEvent("error", `Incompatible MAJOR version detected in state from ${source}.`, `Loaded: ${loadedVersion}, Required: ${config.STATE_VERSION}. Discarding state.`);
      return false;
    } else if (minor < parseInt(STATE_VERSION_MINOR, 10) || (minor === parseInt(STATE_VERSION_MINOR, 10) && patch < parseInt(STATE_VERSION_PATCH, 10))) {
      logger.logEvent("warn", `Loading older MINOR/PATCH version state from ${source}.`, `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. Applying defaults for new fields.`);
    } else if (minor > parseInt(STATE_VERSION_MINOR, 10) || (minor === parseInt(STATE_VERSION_MINOR, 10) && patch > parseInt(STATE_VERSION_PATCH, 10))) {
      logger.logEvent("warn", `Loading newer MINOR/PATCH version state from ${source}.`, `Loaded: ${loadedVersion}, Current: ${config.STATE_VERSION}. May encounter issues.`);
    }
    return true;
  };

  const init = () => {
    if (isInitializedFlag) return true;
    const savedState = Storage.getState();
    let validationError = null;

    if (savedState) {
      validationError = StateHelpersPure.validateStateStructurePure(savedState, config.STATE_VERSION, Utils.getDefaultState);
      if (validationError) {
        logger.logEvent("error", `Saved state validation failed: ${validationError}. Discarding and re-initializing.`);
        Storage.removeState();
        globalState = Utils.getDefaultState(config);
      } else {
        const isCompatible = checkAndLogVersionDifference(savedState.version, "localStorage");
        if (!isCompatible) {
          Storage.removeState();
          globalState = Utils.getDefaultState(config);
        } else {
          globalState = StateHelpersPure.mergeWithDefaultsPure(savedState, Utils.getDefaultState, config.STATE_VERSION);
          globalState.version = config.STATE_VERSION;
          logger.logEvent("info", `Loaded state v${savedState.version} (Cycle ${globalState.totalCycles}), updated to v${config.STATE_VERSION}`);
        }
      }
    } else {
      logger.logEvent("info", `No saved state found. Initializing new default state v${config.STATE_VERSION}`);
      globalState = Utils.getDefaultState(config);
      if (config.GENESIS_ARTIFACT_DEFS) {
        for (const id in config.GENESIS_ARTIFACT_DEFS) {
          if (id === "reploid.core.config") continue;
          const def = config.GENESIS_ARTIFACT_DEFS[id];
          if (!globalState.artifactMetadata[id]) {
            globalState.artifactMetadata[id] = [{
              id: id, version_id: null, type: def.type || "UNKNOWN",
              description: def.description || `Artifact ${id}`,
              latestCycle: -1, source: "Initial Definition", checksum: null, timestamp: 0, paradigm: def.paradigm || "unknown",
            }];
          }
        }
      }
    }
    calculateDerivedStatsAndUpdateState(globalState);
    _saveInternal();
    isInitializedFlag = true;
    return globalState && globalState.totalCycles >= 0;
  };

  const getState = () => globalState;

  const _updateGlobalStateReference = (newState) => {
    globalState = newState;
  };

  const updateAndSaveState = (updaterFn) => {
    if (typeof updaterFn !== 'function') {
        logger.logEvent("error", "Invalid updater function provided to updateAndSaveState.");
        return globalState;
    }
    const currentState = getState();
    const newState = updaterFn(JSON.parse(JSON.stringify(currentState))); // Pass a deep copy to updater
    
    const validationError = StateHelpersPure.validateStateStructurePure(newState, config.STATE_VERSION, Utils.getDefaultState);
    if (validationError) {
      logger.logEvent("error", `Attempted to set invalid state via updaterFn: ${validationError}`);
      throw new StateError(`Attempted to set invalid state via updaterFn: ${validationError}`);
    }
    _updateGlobalStateReference(newState);
    calculateDerivedStatsAndUpdateState(globalState);
    _saveInternal();
    return globalState;
  };


  const _saveInternal = () => {
    if (!globalState || !Storage) return;
    try {
      const stateToSave = JSON.parse(JSON.stringify({ ...globalState, lastApiResponse: null }));
      Storage.saveState(stateToSave);
      logger.logEvent("debug", `Saved state (Cycle ${globalState.totalCycles})`);
    } catch (e) {
      logger.logEvent("error", `Save state failed: ${e.message}`, e);
    }
  };

  const getArtifactMetadata = (id, versionId = null) => {
    const history = globalState?.artifactMetadata?.[id];
    if (!history || history.length === 0) return null;
    if (versionId === null) {
      return Utils.getLatestMeta(history);
    } else {
      return history.find((meta) => meta.version_id === versionId) || null;
    }
  };

  const getArtifactMetadataAllVersions = (id) => globalState?.artifactMetadata?.[id] || [];

  const updateArtifactMetadata = (id, type, description, cycle, checksum = null, source = "Agent Modified", versionId = null, isModular = false, newParadigm = null) => {
    return updateAndSaveState(currentState => {
        if (!currentState.artifactMetadata[id]) currentState.artifactMetadata[id] = [];
        const now = Date.now();
        let existingMetaIndex = -1;

        if (versionId !== null) {
            existingMetaIndex = currentState.artifactMetadata[id].findIndex(meta => meta.version_id === versionId && meta.latestCycle === cycle);
            if (existingMetaIndex === -1) existingMetaIndex = currentState.artifactMetadata[id].findIndex(meta => meta.version_id === versionId);
        } else {
            const cycleMatches = currentState.artifactMetadata[id].filter(meta => meta.latestCycle === cycle && meta.version_id === null);
            if (cycleMatches.length > 0) {
                const latestCycleMatch = cycleMatches.sort((a,b) => (b.timestamp || 0) - (a.timestamp || 0))[0];
                existingMetaIndex = currentState.artifactMetadata[id].indexOf(latestCycleMatch);
            } else {
                const latestNullVersionMetas = currentState.artifactMetadata[id].filter(m => m.version_id === null).sort((a,b) => b.latestCycle - a.latestCycle || (b.timestamp || 0) - (a.timestamp || 0));
                if (latestNullVersionMetas.length > 0) existingMetaIndex = currentState.artifactMetadata[id].indexOf(latestNullVersionMetas[0]);
            }
        }
        
        const baseMeta = getArtifactMetadata(id, versionId); // Read before modifying array

        const newMetaEntry = {
            id: id, version_id: versionId,
            type: type ?? baseMeta?.type ?? "UNKNOWN",
            description: description ?? baseMeta?.description ?? `Artifact ${id}`,
            latestCycle: cycle, checksum: checksum, source: source, timestamp: now,
            isModularEdit: isModular,
            paradigm: newParadigm ?? baseMeta?.paradigm ?? config.GENESIS_ARTIFACT_DEFS?.[id]?.paradigm ?? "unknown",
        };

        if (existingMetaIndex !== -1) {
            currentState.artifactMetadata[id][existingMetaIndex] = newMetaEntry;
        } else {
            currentState.artifactMetadata[id].push(newMetaEntry);
        }
        return currentState;
    });
  };

  const deleteArtifactMetadata = (id, versionId = null) => {
     return updateAndSaveState(currentState => {
        if (!currentState.artifactMetadata[id]) return currentState;
        if (versionId !== null) {
            currentState.artifactMetadata[id] = currentState.artifactMetadata[id].filter(meta => meta.version_id !== versionId);
            if (currentState.artifactMetadata[id].length === 0) delete currentState.artifactMetadata[id];
        } else {
            delete currentState.artifactMetadata[id];
        }
        return currentState;
    });
  };

  const getAllArtifactMetadata = () => {
    const latestMetaMap = {};
    if (!globalState?.artifactMetadata) return latestMetaMap;
    for (const id in globalState.artifactMetadata) {
      const latest = getArtifactMetadata(id, null);
      if (latest) latestMetaMap[id] = latest;
    }
    return latestMetaMap;
  };

  const capturePreservationState = (uiRefs = {}) => {
    if (!globalState) return null;
    try {
      const stateToPreserve = JSON.parse(JSON.stringify({ ...globalState, lastApiResponse: null }));
      stateToPreserve.logBuffer = logger.getLogBuffer ? logger.getLogBuffer() : null;
      stateToPreserve.timelineHTML = uiRefs.timelineLog?.innerHTML || "";
      return stateToPreserve;
    } catch (e) {
      logger.logEvent("error", `Failed to capture preservation state: ${e.message}`, e);
      return null;
    }
  };

  const restoreStateFromSession = (restoreUIFn = () => {}) => {
    if (!isInitializedFlag) {
      logger.logEvent("warn", "Cannot restore session, StateManager not initialized.");
      return false;
    }
    const preservedData = Storage.getSessionState();
    if (!preservedData) return false;

    logger.logEvent("info", "Preserved session state found. Attempting restore.");
    try {
      const validationError = StateHelpersPure.validateStateStructurePure(preservedData, config.STATE_VERSION, Utils.getDefaultState);
      if (validationError) throw new StateError(`Session state validation failed: ${validationError}`);
      const isCompatible = checkAndLogVersionDifference(preservedData.version, "sessionStorage");
      if (!isCompatible) throw new StateError(`Incompatible MAJOR version in session state: ${preservedData.version}`);

      _updateGlobalStateReference(StateHelpersPure.mergeWithDefaultsPure(preservedData, Utils.getDefaultState, config.STATE_VERSION));
      globalState.version = config.STATE_VERSION;

      if (logger.setLogBuffer && preservedData.logBuffer) logger.setLogBuffer(preservedData.logBuffer);
      calculateDerivedStatsAndUpdateState(globalState);
      restoreUIFn(preservedData);
      logger.logEvent("info", "Session state restored successfully by StateManager.");
      _saveInternal();
      return true;
    } catch (e) {
      logger.logEvent("error", `Restore from session failed: ${e.message}`, e);
      init();
      return false;
    } finally {
      Storage.removeSessionState();
      logger.logEvent("debug", "Cleared session state from storage after attempt.");
    }
  };

  const exportState = (uiRefs = {}) => {
    logger.logEvent("info", "Exporting state (metadata and UI state only, NOT artifact content)...");
    try {
      const stateData = capturePreservationState(uiRefs);
      if (!stateData) {
        logger.logEvent("error", "Failed to capture state for export.");
        if (typeof showNotification === "function") showNotification?.("Error capturing state for export.", "error");
        return;
      }
      const fileName = `x0_state_${config.STATE_VERSION}_${new Date().toISOString().replace(/[:.]/g, "-")}.json`;
      const dataStr = JSON.stringify(stateData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = fileName;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a); URL.revokeObjectURL(url);
      logger.logEvent("info", "State export initiated.");
    } catch (e) {
      logger.logEvent("error", `State export failed: ${e.message}`, e);
      if (typeof showNotification === "function") showNotification?.(`State export failed: ${e.message}`, "error");
    }
  };

  const importState = (file, importCallback = () => {}) => {
    logger.logEvent("info", "Attempting to import state (metadata and UI state only, NOT artifact content)...");
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        if (!e.target?.result) throw new Error("File read returned null result.");
        const importedData = JSON.parse(e.target.result);
        const validationError = StateHelpersPure.validateStateStructurePure(importedData, config.STATE_VERSION, Utils.getDefaultState, `imported file '${file.name}'`);
        if (validationError) throw new StateError(`Imported state validation failed: ${validationError}`);
        logger.logEvent("info", `Importing state v${importedData.version}`);
        const isCompatible = checkAndLogVersionDifference(importedData.version, `imported file '${file.name}'`);
        if (!isCompatible) throw new StateError(`Incompatible MAJOR version in imported state: ${importedData.version}`);

        _updateGlobalStateReference(StateHelpersPure.mergeWithDefaultsPure(importedData, Utils.getDefaultState, config.STATE_VERSION));
        globalState.version = config.STATE_VERSION;

        if (logger.setLogBuffer && importedData.logBuffer) logger.setLogBuffer(importedData.logBuffer);
        calculateDerivedStatsAndUpdateState(globalState);
        importCallback(true, importedData);
        logger.logEvent("info", "State imported successfully by StateManager.");
        _saveInternal();
      } catch (err) {
        logger.logEvent("error", `Import failed: ${err.message}`, err);
        importCallback(false, null, err.message);
      }
    };
    reader.onerror = (e) => {
      const errorMsg = `File read error: ${reader.error || "Unknown"}`;
      logger.logEvent("error", errorMsg);
      importCallback(false, null, errorMsg);
    };
    reader.readAsText(file);
  };

  const addEvaluationResult = (result) => {
    return updateAndSaveState(currentState => {
        if (!currentState.evaluationHistory) currentState.evaluationHistory = [];
        currentState.evaluationHistory.push(result);
        while (currentState.evaluationHistory.length > MAX_HISTORY_ITEMS) currentState.evaluationHistory.shift();
        return currentState;
    });
  };

  const addCritiqueFeedback = (feedbackData) => {
     return updateAndSaveState(currentState => {
        if (!currentState.critiqueFeedbackHistory) currentState.critiqueFeedbackHistory = [];
        currentState.critiqueFeedbackHistory.push({
            cycle: currentState.totalCycles, feedback: feedbackData, timestamp: Date.now(),
        });
        while (currentState.critiqueFeedbackHistory.length > MAX_HISTORY_ITEMS) currentState.critiqueFeedbackHistory.shift();
        return currentState;
    });
  };

  const registerWebComponent = (tagName) => {
    return updateAndSaveState(currentState => {
        if (!Array.isArray(currentState.registeredWebComponents)) currentState.registeredWebComponents = [];
        if (typeof tagName === "string" && tagName.includes("-") && !currentState.registeredWebComponents.includes(tagName)) {
            currentState.registeredWebComponents.push(tagName);
            logger.logEvent("info", `StateManager: Web component '${tagName}' marked as registered.`);
        } else if (currentState.registeredWebComponents.includes(tagName)) {
            logger.logEvent("debug", `StateManager: Web component '${tagName}' was already marked as registered.`);
        } else {
            logger.logEvent("warn", `StateManager: Invalid or already registered web component tag name: '${tagName}'`);
        }
        return currentState;
    });
  };

  const isWebComponentRegistered = (tagName) => globalState?.registeredWebComponents?.includes(tagName) || false;
  const getRegisteredWebComponents = () => [...(globalState?.registeredWebComponents || [])];

  return {
    init, getState, updateAndSaveState,
    getArtifactMetadata, getArtifactMetadataAllVersions, updateArtifactMetadata, deleteArtifactMetadata,
    getAllArtifactMetadata, capturePreservationState, restoreStateFromSession,
    exportState, importState, isInitialized: () => isInitializedFlag,
    addEvaluationResult, addCritiqueFeedback,
    registerWebComponent, isWebComponentRegistered, getRegisteredWebComponents,
  };
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: tool-runner-pure-helpers.js ---
const ToolRunnerPureHelpersModule = (() => {

  function mapMcpTypeToGeminiPure(mcpType, externalLogger) {
    switch (mcpType?.toLowerCase()) {
      case "string": return "STRING";
      case "integer": return "INTEGER";
      case "number": return "NUMBER";
      case "boolean": return "BOOLEAN";
      case "array": return "ARRAY";
      case "object": return "OBJECT";
      default:
        externalLogger?.logEvent("warn", `Unsupported MCP type encountered in pure helper: ${mcpType}`);
        return "TYPE_UNSPECIFIED";
    }
  }

  function convertMcpPropertiesToGeminiPure(mcpProps, externalLogger) {
    if (!mcpProps) return {};
    const geminiProps = {};
    for (const key in mcpProps) {
      const mcpProp = mcpProps[key];
      geminiProps[key] = {
        type: mapMcpTypeToGeminiPure(mcpProp.type, externalLogger),
        description: mcpProp.description || "",
      };
      if (mcpProp.enum) geminiProps[key].enum = mcpProp.enum;
      if (mcpProp.type === "array" && mcpProp.items) {
        geminiProps[key].items = { type: mapMcpTypeToGeminiPure(mcpProp.items.type, externalLogger) };
      }
      if (mcpProp.type === "object" && mcpProp.properties) {
        geminiProps[key].properties = convertMcpPropertiesToGeminiPure(mcpProp.properties, externalLogger);
        if (mcpProp.required) geminiProps[key].required = mcpProp.required;
      }
    }
    return geminiProps;
  }

  function convertToGeminiFunctionDeclarationPure(mcpToolDefinition, externalLogger) {
    if (!mcpToolDefinition || !mcpToolDefinition.name || !mcpToolDefinition.description) {
        externalLogger?.logEvent("error", "Invalid MCP tool definition for Gemini FC conversion.", mcpToolDefinition);
        return null;
    }
    return {
        name: mcpToolDefinition.name,
        description: mcpToolDefinition.description,
        parameters: {
            type: "OBJECT",
            properties: convertMcpPropertiesToGeminiPure(mcpToolDefinition.inputSchema?.properties, externalLogger),
            required: mcpToolDefinition.inputSchema?.required || [],
        },
    };
  }

  function basicCodeLintPure(code, language) {
    let hasError = false;
    let errorMessage = "";
    try {
      if (!code && language !== "web_component_def") { // web_component_def might be an empty class initially
          return { linting_passed: true, error_message: null }; // or false if empty is an error for other types
      }
      if (language === "json") {
        JSON.parse(code);
      } else if (language === "html") {
        if (code.includes("<script") && !code.includes("</script>")) {
          hasError = true; errorMessage = "Potentially unclosed script tag.";
        }
      } else if (language === "javascript" || language === "web_component_def") {
        if ((code.match(/{/g) || []).length !== (code.match(/}/g) || []).length ||
            (code.match(/\(/g) || []).length !== (code.match(/\)/g) || []).length) {
          hasError = true; errorMessage = "Mismatched braces or parentheses.";
        }
      }
    } catch (e) {
      hasError = true; errorMessage = e.message;
    }
    return { linting_passed: !hasError, error_message: hasError ? errorMessage : null };
  }

  function validateJsonStructurePure(jsonString) {
    try {
        if (!jsonString) return { valid: false, error: "Input string is null or empty."};
        JSON.parse(jsonString);
        return { valid: true, error: null };
    } catch (e) {
        return { valid: false, error: e.message };
    }
  }

  function diffTextPure(textA, textB) {
    if (textA === textB) return { differences: false, summary: "Texts are identical." };
    return { differences: true, summary: "Texts differ (detailed diff not implemented in pure helper)." };
  }


  return {
    mapMcpTypeToGeminiPure,
    convertMcpPropertiesToGeminiPure,
    convertToGeminiFunctionDeclarationPure,
    basicCodeLintPure,
    validateJsonStructurePure,
    diffTextPure
  };
})();
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: tool-runner.js ---
const ToolRunnerModule = (config, logger, Storage, StateManager, ApiClient, Errors, Utils, ToolRunnerPureHelpers) => {
  if (!config || !logger || !Storage || !StateManager || !ApiClient || !Errors || !Utils || !ToolRunnerPureHelpers) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[TOOLRUNNER_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error", "ToolRunnerModule initialization failed: Missing dependencies.");
    return {
      runTool: async (toolName) => { throw new (Errors?.ConfigError || Error)(`ToolRunner not initialized, cannot run ${toolName}`); },
    };
  }

  const { ToolError, ArtifactError, WebComponentError } = Errors;
  const DYNAMIC_TOOL_TIMEOUT_MS = config.DYNAMIC_TOOL_TIMEOUT_MS || 10000;
  const WORKER_SCRIPT_PATH = config.WORKER_SCRIPT_PATH || "tool-worker.js";

  const runToolInternal = async (toolName, toolArgs, injectedStaticTools, injectedDynamicTools, uiHooks = {}) => {
    logger.logEvent("info", `Run tool: ${toolName}`, toolArgs || {});
    const staticTool = injectedStaticTools.find((t) => t.name === toolName);

    if (staticTool) {
      let artifactContent = null;
      if (toolArgs && toolArgs.artifactId && typeof toolArgs.cycle === "number") {
        artifactContent = Storage.getArtifactContent(toolArgs.artifactId, toolArgs.cycle, toolArgs.versionId);
        if (artifactContent === null && !["list_artifacts", "define_web_component", "apply_diff_patch", "apply_json_patch", "convert_to_gemini_fc", "run_self_evaluation"].includes(toolName)) {
          throw new ArtifactError(`Artifact content not found for ${toolArgs.artifactId} cycle ${toolArgs.cycle} (vId: ${toolArgs.versionId || "latest"})`, toolArgs.artifactId, toolArgs.cycle);
        }
      }

      switch (toolName) {
        case "code_linter":
          const lintResult = ToolRunnerPureHelpers.basicCodeLintPure(artifactContent, toolArgs.language);
          return { result: `Basic lint ${lintResult.linting_passed ? "passed" : "failed"} for ${toolArgs.language}.${lintResult.error_message ? " Error: " + lintResult.error_message : ""}`, ...lintResult };

        case "json_validator":
          const validation = ToolRunnerPureHelpers.validateJsonStructurePure(artifactContent);
          return { result: `JSON structure is ${validation.valid ? "valid" : "invalid"}.${validation.error ? " Error: " + validation.error : ""}`, ...validation };

        case "read_artifact":
          if (artifactContent === null) throw new ArtifactError(`Artifact content not found for ${toolArgs.artifactId} cycle ${toolArgs.cycle} (vId: ${toolArgs.versionId || "latest"})`, toolArgs.artifactId, toolArgs.cycle);
          return { content: artifactContent, artifactId: toolArgs.artifactId, cycle: toolArgs.cycle, versionId: toolArgs.versionId || null };

        case "list_artifacts":
          const allMetaMap = StateManager.getAllArtifactMetadata();
          let filteredMeta = Object.values(allMetaMap);
          if (toolArgs.filterType) filteredMeta = filteredMeta.filter((meta) => meta.type && meta.type.toUpperCase() === toolArgs.filterType.toUpperCase());
          if (toolArgs.filterPattern) {
            try {
              const regex = new RegExp(toolArgs.filterPattern);
              filteredMeta = filteredMeta.filter((meta) => regex.test(meta.id));
            } catch (e) { throw new ToolError(`Invalid regex pattern: ${e.message}`, toolName, toolArgs); }
          }
          if (toolArgs.includeAllVersions) {
            const allVersions = [];
            for (const meta of filteredMeta) allVersions.push(...StateManager.getArtifactMetadataAllVersions(meta.id));
            return { artifacts: allVersions.map(m => ({ id: m.id, type: m.type, latestCycle: m.latestCycle, versionId: m.version_id, timestamp: m.timestamp, source: m.source, paradigm: m.paradigm })) };
          } else {
            return { artifacts: filteredMeta.map(meta => ({ id: meta.id, type: meta.type, latestCycle: meta.latestCycle, paradigm: meta.paradigm })) };
          }
        
        case "diff_text":
            return ToolRunnerPureHelpers.diffTextPure(toolArgs.textA, toolArgs.textB);

        case "convert_to_gemini_fc":
            const geminiFc = ToolRunnerPureHelpers.convertToGeminiFunctionDeclarationPure(toolArgs.mcpToolDefinition, logger);
            if (!geminiFc) throw new ToolError("Failed to convert MCP tool to Gemini FC format.", toolName, toolArgs);
            return { geminiFunctionDeclaration: geminiFc };

        case "code_edit":
          const { success, validatedContent, error, contentChanged } = await (async () => {
            const originalContent = Storage.getArtifactContent(toolArgs.artifactId, toolArgs.cycle, toolArgs.versionId);
            if (originalContent === null && toolArgs.artifactId !== "full_html_source" && toolArgs.artifactId !== "page_composition_preview") { // Allow new full source
                 throw new ArtifactError(`Original artifact not found for code_edit: ${toolArgs.artifactId}`, toolArgs.artifactId, toolArgs.cycle);
            }
            const isSame = originalContent === toolArgs.newContent;
            let validationError = null;
            try {
              const artifactMeta = StateManager.getArtifactMetadata(toolArgs.artifactId);
              if (artifactMeta?.type === "JSON" || artifactMeta?.type === "JSON_CONFIG") JSON.parse(toolArgs.newContent);
            } catch (e) { validationError = `Invalid JSON: ${e.message}`; }

            return {
                success: !validationError,
                validatedContent: toolArgs.newContent,
                error: validationError,
                contentChanged: !isSame,
                artifactId: toolArgs.artifactId,
                cycle: toolArgs.cycle,
                versionId: toolArgs.versionId
            };
          })();
          return { success, validatedContent, error, contentChanged, artifactId: toolArgs.artifactId, cycle: toolArgs.cycle, versionId: toolArgs.versionId };
        
        case "run_self_evaluation":
            const evalState = StateManager.getState();
            if (!evalState?.apiKey) throw new Errors.ConfigError("API Key required for self-evaluation tool.");
            const { targetArtifactId, targetArtifactCycle, targetArtifactVersionId, evalCriteriaText, goalContextText, evalDefinitionId, contentToEvaluate: explicitContent } = toolArgs;
            let finalContentToEvaluate = explicitContent;
            if (!finalContentToEvaluate) {
                const meta = StateManager.getArtifactMetadata(targetArtifactId, targetArtifactVersionId);
                const cycleToUse = meta ? meta.latestCycle : targetArtifactCycle;
                finalContentToEvaluate = Storage.getArtifactContent(targetArtifactId, cycleToUse, targetArtifactVersionId);
            }
            if (finalContentToEvaluate === null) throw new ArtifactError("Content to evaluate not found or provided.", targetArtifactId, targetArtifactCycle);
            
            const evalPromptTemplate = Storage.getArtifactContent("reploid.core.evaluator-prompt", 0);
            if(!evalPromptTemplate) throw new ArtifactError("Evaluator prompt artifact not found.", "reploid.core.evaluator-prompt");

            const evalPrompt = evalPromptTemplate
                .replace(/\[\[GOAL_CONTEXT\]\]/g, goalContextText)
                .replace(/\[\[EVALUATION_CRITERIA\]\]/g, evalCriteriaText)
                .replace(/\[\[TARGET_CONTENT_OR_PROPOSAL\]\]/g, finalContentToEvaluate)
                .replace(/\[\[TARGET_ARTIFACT_ID\]\]/g, targetArtifactId)
                .replace(/\[\[TARGET_ARTIFACT_PARADIGM\]\]/g, StateManager.getArtifactMetadata(targetArtifactId)?.paradigm || "unknown");

            const evaluatorModelKey = evalState.cfg?.evaluatorModel || "BASE";
            const evaluatorModelIdentifier = config.DEFAULT_MODELS[evaluatorModelKey.toUpperCase()] || evaluatorModelKey;

            const apiResult = await ApiClient.callApiWithRetry(
                evalPrompt,
                'You are Evaluator x0. Output ONLY valid JSON: {"evaluation_score": float, "evaluation_report": "string"}',
                evaluatorModelIdentifier, evalState.apiKey, [], false, null, 1, {},
                uiHooks.updateStatus, uiHooks.logTimeline, uiHooks.updateTimelineItem
            );
            if (!apiResult || apiResult.type !== "text" || !apiResult.content) throw new ToolError("Self-evaluation LLM call failed or returned no content.", toolName, toolArgs);
            
            const sanitized = ApiClient.sanitizeLlmJsonResp(apiResult.content);
            try {
                const parsed = JSON.parse(sanitized);
                if (typeof parsed.evaluation_score !== 'number' || typeof parsed.evaluation_report !== 'string') {
                    throw new Error("Evaluation response missing required fields.");
                }
                return {
                    ...parsed,
                    targetArtifactId, targetArtifactCycle, targetArtifactVersionId,
                    evalDefinitionId: evalDefinitionId || "reploid.core.default-eval", // or extract from evalCriteriaText
                    timestamp: Date.now()
                };
            } catch(e) {
                throw new ToolError(`Failed to parse self-evaluation LLM response: ${e.message}`, toolName, toolArgs, {rawResponse: sanitized});
            }

        case "define_web_component":
          const { tagName, classContent, targetArtifactId: wcTargetId, description } = toolArgs;
          if (!tagName || !classContent || !wcTargetId || !description) throw new ToolError("Missing required arguments for define_web_component.", toolName, toolArgs);
          if (!tagName.includes("-") || tagName.toLowerCase() !== tagName) throw new ToolError("Invalid tagName: must include a hyphen and be lowercase.", toolName, toolArgs, { tagName });

          try {
            const ComponentClass = new Function("return (" + classContent + ")")();
            if (typeof ComponentClass !== "function" || !HTMLElement.isPrototypeOf(ComponentClass)) {
              throw new WebComponentError("Provided classContent does not evaluate to a valid HTMLElement subclass.", tagName, { classContent });
            }
            customElements.define(tagName, ComponentClass); // Impure DOM interaction
            StateManager.registerWebComponent(tagName); // Impure StateManager interaction

            const nextCycle = (StateManager.getState()?.totalCycles || 0) + 1; // Semi-pure state read
            const checksum = await Utils.calculateChecksum(classContent); // Impure (async crypto) but deterministic
            
            Storage.setArtifactContent(wcTargetId, nextCycle, classContent); // Impure Storage interaction
            StateManager.updateArtifactMetadata(wcTargetId, "WEB_COMPONENT_DEF", description, nextCycle, checksum, "Tool: define_web_component", null, false, "data"); // Impure StateManager interaction

            logger.logEvent("info", `Web Component '${tagName}' defined and artifact '${wcTargetId}' saved.`);
            return { success: true, tagName, artifactId: wcTargetId, message: `Web Component <${tagName}> defined and saved as ${wcTargetId}.` };
          } catch (e) {
            logger.logEvent("error", `Failed to define Web Component '${tagName}': ${e.message}`, e);
            throw new WebComponentError(`Failed to define Web Component '${tagName}': ${e.message}`, tagName, { originalError: e.toString(), classContent });
          }

        case "apply_diff_patch":
          logger.logEvent("warn", "Tool 'apply_diff_patch' is a placeholder.");
          const origContentPatch = Storage.getArtifactContent(toolArgs.artifactId, toolArgs.cycle, toolArgs.versionId);
          if (origContentPatch === null) throw new ArtifactError(`Original artifact not found for patching: ${toolArgs.artifactId}`, toolArgs.artifactId, toolArgs.cycle);
          return { success: false, result_content: origContentPatch + `\n\n--- PATCHED (Placeholder) ---\n${toolArgs.patchContent}`, error: "Tool not fully implemented", original_content: origContentPatch, patch_applied: false };

        case "apply_json_patch":
          logger.logEvent("warn", "Tool 'apply_json_patch' is a placeholder.");
          const origJsonContent = Storage.getArtifactContent(toolArgs.artifactId, toolArgs.cycle, toolArgs.versionId);
          if (origJsonContent === null) throw new ArtifactError(`Original JSON artifact not found for patching: ${toolArgs.artifactId}`, toolArgs.artifactId, toolArgs.cycle);
          return { success: false, result_content: JSON.stringify({ ...JSON.parse(origJsonContent), __PATCHED_PLACEHOLDER__: toolArgs.patchContent }, null, 2), error: "Tool not fully implemented", original_content: origJsonContent, patch_applied: false };

        default:
          logger.logEvent("warn", `Static tool '${toolName}' execution logic not fully implemented or recognized.`);
          return { success: true, message: `Static tool ${toolName} placeholder executed.`, argsReceived: toolArgs };
      }
    }

    const dynamicTool = injectedDynamicTools.find((t) => t.declaration.name === toolName);
    if (dynamicTool) {
      if (!dynamicTool.implementation) throw new ToolError(`Dynamic tool '${toolName}' has no implementation defined.`, toolName);
      logger.logEvent("info", `Executing dynamic tool '${toolName}' in Web Worker sandbox.`);

      return new Promise((resolve, reject) => {
        let worker = null; let timeoutId = null;
        try {
          worker = new Worker(WORKER_SCRIPT_PATH);
          timeoutId = setTimeout(() => {
            const errorMsg = `Dynamic tool '${toolName}' timed out after ${DYNAMIC_TOOL_TIMEOUT_MS}ms.`;
            logger.logEvent("error", errorMsg);
            if (worker) worker.terminate();
            reject(new ToolError(`Dynamic tool '${toolName}' execution timed out.`, toolName));
          }, DYNAMIC_TOOL_TIMEOUT_MS);

          worker.onmessage = async (event) => {
            const { type, success, result, error: workerError, id: msgId, requestType, payload } = event.data;
            if (type === "request") {
              try {
                let shimResult;
                if (requestType === "getArtifactContent" && payload) shimResult = Storage.getArtifactContent(payload.id, payload.cycle, payload.versionId);
                else if (requestType === "getArtifactMetadata" && payload) shimResult = StateManager.getArtifactMetadata(payload.id, payload.versionId);
                else if (requestType === "getArtifactMetadataAllVersions" && payload) shimResult = StateManager.getArtifactMetadataAllVersions(payload.id);
                else if (requestType === "getAllArtifactMetadata") shimResult = StateManager.getAllArtifactMetadata();
                else throw new Error(`Unknown shim requestType: ${requestType}`);
                worker.postMessage({ type: "response", id: msgId, data: shimResult });
              } catch (e) {
                worker.postMessage({ type: "response", id: msgId, error: { message: e.message, name: e.name } });
              }
            } else {
              clearTimeout(timeoutId);
              if (success) {
                logger.logEvent("info", `Dynamic tool '${toolName}' execution succeeded.`);
                resolve(result);
              } else {
                const errorMsg = workerError?.message || "Unknown worker error";
                logger.logEvent("error", `Dynamic tool '${toolName}' execution failed in worker: ${errorMsg}\nStack: ${workerError?.stack}`);
                reject(new ToolError(`Dynamic tool '${toolName}' failed: ${errorMsg}`, toolName, toolArgs, { workerError }));
              }
              if (worker) worker.terminate();
            }
          };
          worker.onerror = (errorEvent) => {
            clearTimeout(timeoutId);
            const errorMsg = errorEvent.message || "Unknown worker error";
            logger.logEvent("error", `Web Worker error for tool '${toolName}': ${errorMsg}`, errorEvent);
            reject(new ToolError(`Worker error for dynamic tool '${toolName}': ${errorMsg}`, toolName, toolArgs, { workerEventError: errorEvent }));
            if (worker) worker.terminate();
          };
          worker.postMessage({ type: "init", payload: { toolCode: dynamicTool.implementation, toolArgs } });
        } catch (e) {
          clearTimeout(timeoutId);
          logger.logEvent("error", `Error setting up worker for '${toolName}': ${e.message}`);
          if (worker) worker.terminate();
          reject(new ToolError(`Failed to initialize worker for tool '${toolName}': ${e.message}`, toolName, toolArgs, { setupError: e }));
        }
      });
    }
    throw new ToolError(`Tool not found: ${toolName}`, toolName);
  };

  return {
    runTool: runToolInternal,
  };
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: agent-logic-pure.js ---
const AgentLogicPureHelpersModule = (() => {

  const getArtifactListSummaryPure = (allMetaMap) => {
    if (!allMetaMap) return "Error: Artifact metadata map not available.";
    return (Object.values(allMetaMap)
        .filter((meta) => meta && meta.latestCycle >= 0)
        .map((meta) => `* ${meta.id} (${meta.type || "UNTYPED"} ${meta.paradigm ? '('+meta.paradigm+')' : ''}) - Cycle ${meta.latestCycle}${meta.version_id ? ` V:${meta.version_id}` : ""}`)
        .join("\n") || "None");
  };

  const getRegisteredWebComponentsListPure = (wcList) => {
    if (!wcList) return "Error: Web component list not available.";
    return wcList.length > 0 ? wcList.map((tag) => `* <${tag}>`).join("\n") : "None";
  };

  const getToolListSummaryPure = (staticTools, dynamicTools, truncFn) => {
    if (!staticTools || !dynamicTools || !truncFn) return "Error: Tool lists or truncFn not available.";
    const staticToolSummary = staticTools.map((t) => `* [S] ${t.name}: ${truncFn(t.description, 60)}`).join("\n");
    const dynamicToolSummary = dynamicTools.map((t) => `* [D] ${t.declaration.name}: ${truncFn(t.declaration.description, 60)}`).join("\n");
    return ([staticToolSummary, dynamicToolSummary].filter((s) => s).join("\n") || "None");
  };

  const summarizeHistoryPure = (historyArray, label, maxItems = 5, truncFn) => {
    if (!historyArray || historyArray.length === 0) return `No ${label} available.`;
    if (!truncFn) return `Error: truncFn not available for history summary.`;
    const recentItems = historyArray.slice(-maxItems);
    return recentItems.map((item, index) => {
        const itemIndex = historyArray.length - recentItems.length + index + 1;
        let summary = `${label} ${itemIndex}: `;
        if (label.includes("Eval")) {
          summary += `Score=${item.evaluation_score?.toFixed(2)}, Target=${item.targetArtifactId || "N/A"}(C${item.targetArtifactCycle ?? "N/A"}), Report=${truncFn(item.evaluation_report, 50)}`;
        } else if (label.includes("Critique History")) {
          summary += item ? "Fail" : "Pass";
        } else if (label.includes("Critique Feedback")) {
          summary += `Selected: ${item.feedback?.selectedCritique ?? "N/A"}, Notes: ${truncFn(item.feedback?.feedbackNotes, 60)}`;
        } else if (label.includes("Fail History")) {
          summary += `Cycle ${item.cycle}, Reason: ${truncFn(item.reason, 60)}`;
        } else {
          summary += truncFn(JSON.stringify(item), 80);
        }
        return summary;
      }).join(" | ");
  };

  const assembleCorePromptPure = (
    corePromptTemplate, state, goalInfo,
    artifactListSummary, registeredWebComponentsList, toolListSummary,
    recentLogs, artifactSnippets, truncFn
  ) => {
    if (!corePromptTemplate) return { error: "Core prompt template missing." };

    const personaBalance = state.cfg?.personaBalance ?? 50;
    const primaryPersona = state.personaMode;
    const critiqueHistorySummary = summarizeHistoryPure(state.critiqueFailHistory || [], "Critique History", 5, truncFn);
    const critiqueFeedbackSummary = summarizeHistoryPure(state.critiqueFeedbackHistory || [], "Critique Feedback", 5, truncFn);
    const evaluationHistorySummary = summarizeHistoryPure(state.evaluationHistory || [], "Evaluation History", 5, truncFn);

    let currentContext = goalInfo.cumulativeGoal || "None";
    if (goalInfo.summaryContext) {
      currentContext += `\n\n--- Current Summary Context ---\n${goalInfo.summaryContext}`;
    }

    let prompt = corePromptTemplate
      .replace(/\[LSD_PERCENT\]/g, String(personaBalance))
      .replace(/\[PERSONA_MODE\]/g, primaryPersona)
      .replace(/\[CYCLE_COUNT\]/g, String(state.totalCycles))
      .replace(/\[AGENT_ITR_COUNT\]/g, String(state.agentIterations))
      .replace(/\[HUMAN_INT_COUNT\]/g, String(state.humanInterventions))
      .replace(/\[FAIL_COUNT\]/g, String(state.failCount))
      .replace(/\[LAST_FEEDBACK\]/g, truncFn(state.lastFeedback || "None", 500))
      .replace(/\[\[CRITIQUE_HISTORY_SUMMARY\]\]/g, critiqueHistorySummary)
      .replace(/\[\[CRITIQUE_FEEDBACK_SUMMARY\]\]/g, critiqueFeedbackSummary)
      .replace(/\[\[EVALUATION_HISTORY_SUMMARY\]\]/g, evaluationHistorySummary)
      .replace(/\[AVG_CONF\]/g, state.avgConfidence?.toFixed(2) || "N/A")
      .replace(/\[CRIT_FAIL_RATE\]/g, state.critiqueFailRate?.toFixed(1) + "%" || "N/A")
      .replace(/\[AVG_TOKENS\]/g, state.avgTokens?.toFixed(0) || "N/A")
      .replace(/\[AVG_EVAL_SCORE\]/g, state.avgEvalScore?.toFixed(2) || "N/A")
      .replace(/\[CTX_TOKENS\]/g, state.contextTokenEstimate?.toLocaleString() || "0")
      .replace(/\[CTX_TARGET\]/g, state.contextTokenTarget?.toLocaleString() || "~1M")
      .replace(/\[\[DYNAMIC_TOOLS_LIST\]\]/g, toolListSummary)
      .replace(/\[\[REGISTERED_WEB_COMPONENTS_LIST\]\]/g, registeredWebComponentsList)
      .replace(/\[\[RECENT_LOGS\]\]/g, truncFn(recentLogs, 1000))
      .replace(/\[\[ARTIFACT_LIST_WITH_PARADIGMS\]\]/g, artifactListSummary)
      .replace(/\[\[SEED_GOAL_DESC\]\]/g, truncFn(goalInfo.seedGoal || "None", 1000))
      .replace(/\[\[CUMULATIVE_GOAL_DESC\]\]/g, truncFn(currentContext, 4000))
      .replace(/\[\[SUMMARY_CONTEXT\]\]/g, truncFn(goalInfo.summaryContext || "None", 2000))
      .replace(/\[\[CURRENT_CONTEXT_FOCUS\]\]/g, goalInfo.currentContextFocus || "Full Goal Context")
      .replace(/\[\[ARTIFACT_CONTENT_SNIPPETS\]\]/g, artifactSnippets || "No relevant artifact snippets found or loaded.");
    return { prompt };
  };
  
  const prepareArtifactSnippetsPure = (allMetaMap, getArtifactContentFn, goalInfoType, truncFn) => {
      const relevantArtifacts = Object.keys(allMetaMap)
        .filter( (id) => allMetaMap[id]?.latestCycle >= 0 && (id.startsWith("target.") || (goalInfoType === "Meta" && id.startsWith("reploid."))) )
        .sort( (a, b) => (allMetaMap[b]?.latestCycle ?? -1) - (allMetaMap[a]?.latestCycle ?? -1) || a.localeCompare(b) )
        .slice(0, 10);
      let snippets = "";
      for (const id of relevantArtifacts) {
        const meta = allMetaMap[id];
        if (!meta) continue;
        const content = getArtifactContentFn(id, meta.latestCycle, meta.version_id);
        if (content !== null) {
          snippets += `\n---\nArtifact: ${id} (Cycle ${meta.latestCycle}${ meta.version_id ? ` V:${meta.version_id}` : "" } Paradigm: ${meta.paradigm || 'unknown'})\n${truncFn(content, 500)}\n---`;
        }
      }
      return snippets;
  };

  const assembleCritiquePromptPure = (template, llmProposal, goalInfo, truncFn) => {
      if (!template) return { error: "Critique prompt template missing." };
      const changes = llmProposal.artifact_changes || {};
      const modSummary = (changes.modified || []).map((a) => `${a.id}${a.version_id ? "#" + a.version_id : ""}`).join(", ") || "None";
      const newSummary = (changes.new || []).map((a) => `${a.id}(${a.type})${a.version_id ? "#" + a.version_id : ""}`).join(", ") || "None";
      const delSummary = (changes.deleted || []).join(", ") || "None";
      const modularSummary = (changes.modular || []).map((a) => `${a.id}${a.version_id ? "#" + a.version_id : ""}`).join(", ") || "None";
      const fullSourceSummary = changes.full_html_source ? "Yes" : "No";
      const pageCompositionSummary = changes.page_composition ? "Yes" : "No";
      const newToolsSummary = (llmProposal.proposed_new_tools || []).map((t) => t.declaration?.name || "?").join(", ") || "None";
      const newWebComponentTagNames = (llmProposal.tool_calls || []).filter((tc) => tc.name === "define_web_component" && tc.arguments?.tagName).map((tc) => tc.arguments.tagName).join(", ") || "None";
      
      // Note: Paradigms for modified/new/deleted artifacts would ideally be passed in or fetched based on IDs if needed here
      // For simplicity, this pure helper assumes they are already part of the llmProposal or handled by the orchestrator before calling this.
      // The prompt itself is updated to expect paradigm info via placeholders like [[MODIFIED_ARTIFACT_PARADIGMS]]

      const prompt = template
        .replace(/\[\[PROPOSED_CHANGES_DESC\]\]/g, truncFn(llmProposal.proposed_changes_description, 1000) || "None")
        .replace(/\[\[MODIFIED_ARTIFACT_IDS_VERSIONS\]\]/g, modSummary)
        .replace(/\[\[NEW_ARTIFACT_IDS_TYPES_VERSIONS\]\]/g, newSummary)
        .replace(/\[\[DELETED_ARTIFACT_IDS\]\]/g, delSummary)
        .replace(/\[\[MODULAR_ARTIFACT_IDS_VERSIONS\]\]/g, modularSummary)
        .replace(/\[\[HAS_FULL_HTML_SOURCE\]\]/g, fullSourceSummary)
        .replace(/\[\[HAS_PAGE_COMPOSITION\]\]/g, pageCompositionSummary)
        .replace(/\[\[NEW_TOOL_NAMES\]\]/g, newToolsSummary)
        .replace(/\[\[NEW_WEB_COMPONENT_TAG_NAMES\]\]/g, newWebComponentTagNames)
        .replace(/\[LATEST_GOAL_TYPE\]/g, goalInfo.type)
        .replace(/\[\[CUMULATIVE_GOAL_CONTEXT\]\]/g, truncFn(goalInfo.cumulativeGoal || goalInfo.summaryContext, 2000))
        .replace(/\[AGENT_CONFIDENCE\]/g, llmProposal.agent_confidence_score?.toFixed(3) ?? "N/A");
      return { prompt };
  };
  
  const assembleSummarizerPromptPure = (template, stateSummary, recentLogs, artifactListSummary, truncFn) => {
      if (!template) return { error: "Summarizer prompt template missing." };
      const prompt = template
        .replace(/\[\[AGENT_STATE_SUMMARY\]\]/g, JSON.stringify(stateSummary, null, 2))
        .replace(/\[\[RECENT_LOGS\]\]/g, truncFn(recentLogs, 1500))
        .replace(/\[\[LATEST_ARTIFACTS_WITH_PARADIGMS\]\]/g, artifactListSummary);
      return { prompt };
  };

  const checkHitlTriggersPure = (
    currentCycle, pauseAfterCycles, randomReviewProb, cycleTimeSecs, maxCycleTime,
    confidence, autoCritiqueThresh, isForcedReview, goalType, isMetaChangesEnabled,
    proposedCoreChanges // This would be a boolean derived from llmResponse in the orchestrator
  ) => {
    let hitlReason = null;
    let hitlModePref = "prompt";

    if (isForcedReview) hitlReason = "Forced Review";
    else if (pauseAfterCycles > 0 && currentCycle > 0 && currentCycle % pauseAfterCycles === 0) {
      hitlReason = `Auto Pause (Cycle ${currentCycle}/${pauseAfterCycles})`;
      hitlModePref = "options";
    } else if (Math.random() < randomReviewProb) {
      hitlReason = `Random Review (${(randomReviewProb * 100).toFixed(0)}%)`;
      hitlModePref = "critique_feedback";
    } else if (cycleTimeSecs > maxCycleTime) {
      hitlReason = `Time Limit Exceeded (${cycleTimeSecs.toFixed(1)}s > ${maxCycleTime}s)`;
    } else if (confidence < autoCritiqueThresh) {
      hitlReason = `Low Confidence (${confidence.toFixed(2)} < ${autoCritiqueThresh})`;
    }

    if (!hitlReason && isMetaChangesEnabled && goalType === "Meta" && proposedCoreChanges) {
        hitlReason = "Meta Change to Core Artifact or Page Structure";
        hitlModePref = "code_edit";
    }
    return hitlReason ? { reason: hitlReason, mode: hitlModePref } : null;
  };


  return {
    getArtifactListSummaryPure,
    getRegisteredWebComponentsListPure,
    getToolListSummaryPure,
    summarizeHistoryPure,
    assembleCorePromptPure,
    prepareArtifactSnippetsPure,
    assembleCritiquePromptPure,
    assembleSummarizerPromptPure,
    checkHitlTriggersPure
  };
})();
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: agent-cycle.js ---
const CycleLogicModule = (
  config, logger, Utils, Storage, StateManager, UI, ApiClient, ToolRunner, Errors, AgentLogicPureHelpers
) => {
  if (!config || !logger || !Utils || !Storage || !StateManager || !UI || !ApiClient || !ToolRunner || !Errors || !AgentLogicPureHelpers) {
    const internalLog = logger || { logEvent: (lvl, msg, det) => console[lvl === "error" ? "error" : "log"](`[CYCLELOGIC_FALLBACK] ${msg}`, det || "") };
    internalLog.logEvent("error", "CycleLogicModule initialization failed: Missing one or more core dependencies.");
    const dummy = {};
    const methods = [ "init", "executeCycle", "isRunning", "getActiveGoalInfo", "proceedAfterHumanIntervention", "handleSummarizeContext", "abortCurrentCycle", "saveHtmlToHistory", "runTool", "startAutonomousRun", "stopAutonomousRun" ];
    methods.forEach(m => {
      dummy[m] = () => {
        internalLog.logEvent("error", `CycleLogic not initialized. Called ${m}.`);
        if (m === "isRunning") return false; if (m === "getActiveGoalInfo") return { type: "Idle", latestGoal: "Idle" };
        if (["executeCycle", "handleSummarizeContext", "runTool"].includes(m)) return Promise.reject(new Error("CycleLogic not initialized"));
        return undefined;
      };
    });
    return dummy;
  }

  const { ApplicationError, ApiError, ToolError, StateError, ConfigError, ArtifactError, AbortError, WebComponentError } = Errors;
  let _isRunning = false; let _isAutonomous = false; let _abortRequested = false;
  let currentLlmResponse = null; let loadedStaticTools = []; let isLogicInitialized = false;
  const NUM_CRITIQUES_TO_GENERATE = config.NUM_CRITIQUES_TO_GENERATE || 1;

  const init = () => {
    if (isLogicInitialized) return;
    logger.logEvent("info", "Initializing CycleLogic Module...");
    try {
      const staticToolsContent = Storage.getArtifactContent("reploid.core.static-tools", 0);
      if (staticToolsContent) {
        loadedStaticTools = JSON.parse(staticToolsContent);
        logger.logEvent("debug", `CycleLogic loaded ${loadedStaticTools.length} static tools definitions.`);
      } else {
        logger.logEvent("warn", "Static tools artifact (reploid.core.static-tools) not found. Using empty list.");
        loadedStaticTools = [];
      }
    } catch (e) {
      logger.logEvent("error", `Failed to load/parse static tools: ${e.message}`, e);
      loadedStaticTools = [];
    }
    isLogicInitialized = true;
    logger.logEvent("info", "CycleLogic Module initialized.");
  };

  const isRunning = () => _isRunning;
  const isAutonomous = () => _isAutonomous;

  const getActiveGoalInfo = () => {
    const state = StateManager.getState();
    if (!state || !state.currentGoal) return { seedGoal: "N/A", cumulativeGoal: "N/A", latestGoal: "Idle", type: "Idle", summaryContext: null, currentContextFocus: null };
    const latestGoal = state.currentGoal.cumulative || state.currentGoal.seed;
    return {
      seedGoal: state.currentGoal.seed || "None", cumulativeGoal: state.currentGoal.cumulative || "None",
      latestGoal: latestGoal || "Idle", type: state.currentGoal.latestType || "Idle",
      summaryContext: state.currentGoal.summaryContext || null, currentContextFocus: state.currentGoal.currentContextFocus || null,
    };
  };
  
  const _assembleCorePromptContext = (state, goalInfo, currentCycle) => {
      const corePromptTemplate = Storage.getArtifactContent("reploid.core.sys-prompt", 0);
      if (!corePromptTemplate) throw new ArtifactError("Core prompt artifact 'reploid.core.sys-prompt' not found!", "reploid.core.sys-prompt", 0);

      const allMetaMap = StateManager.getAllArtifactMetadata();
      const artifactListSummary = AgentLogicPureHelpers.getArtifactListSummaryPure(allMetaMap);
      const registeredWebComponentsList = AgentLogicPureHelpers.getRegisteredWebComponentsListPure(StateManager.getRegisteredWebComponents());
      const toolListSummary = AgentLogicPureHelpers.getToolListSummaryPure(loadedStaticTools, state?.dynamicTools || [], Utils.trunc);
      const recentLogs = logger.getLogBuffer ? logger.getLogBuffer().split("\n").slice(-15).join("\n") : "Logs unavailable";
      
      const getArtifactContentForSnippets = (id, cycle, versionId) => Storage.getArtifactContent(id, cycle, versionId);
      const artifactSnippets = AgentLogicPureHelpers.prepareArtifactSnippetsPure(allMetaMap, getArtifactContentForSnippets, goalInfo.type, Utils.trunc);

      const { prompt, error } = AgentLogicPureHelpers.assembleCorePromptPure(
          corePromptTemplate, state, goalInfo,
          artifactListSummary, registeredWebComponentsList, toolListSummary,
          recentLogs, artifactSnippets, Utils.trunc
      );
      if (error) throw new ApplicationError(error);

      UI.displayCycleArtifact("LLM Input Prompt", prompt, "input", false, "System", "prompt.core", currentCycle);
      if (goalInfo.summaryContext) UI.displayCycleArtifact("LLM Input Context (Summary)", goalInfo.summaryContext, "input", false, "System", "prompt.summary", currentCycle);
      return prompt;
  };

  const _prepareFunctionDeclarations = async (state) => {
    let allFuncDecls = [];
    const dynamicTools = state?.dynamicTools || [];
    const uiHooks = { updateStatus: () => {}, logTimeline: () => ({}), updateTimelineItem: () => {} };

    const convertToolToFc = async (toolDef, type) => {
        try {
            const conversionResult = await ToolRunner.runTool("convert_to_gemini_fc", { mcpToolDefinition: toolDef }, loadedStaticTools, [], uiHooks);
            return conversionResult?.geminiFunctionDeclaration;
        } catch (e) {
            logger.logEvent("error", `Failed converting ${type} tool ${toolDef.name || toolDef.declaration?.name}: ${e.message}`, e instanceof ToolError ? e.details : e);
            return null;
        }
    };
    const staticToolPromises = loadedStaticTools.map(toolDef => convertToolToFc(toolDef, "static"));
    const dynamicToolPromises = dynamicTools.map(toolDef => convertToolToFc(toolDef.declaration, "dynamic"));
    try {
        const results = await Promise.all([...staticToolPromises, ...dynamicToolPromises]);
        allFuncDecls = results.filter(Boolean);
    } catch (error) {
        logger.logEvent("error", `Error during tool declaration preparation: ${error.message}`, error);
    }
    return allFuncDecls;
  };

  const _handleToolExecution = async (toolCall, state, currentCycle, uiHooks) => {
    const { name: toolName, arguments: toolArgs } = toolCall;
    uiHooks.updateStatus(`Running Tool: ${toolName}...`, true);
    let toolLogItem = uiHooks.logTimeline(currentCycle, `[TOOL] Calling '${toolName}'... Args: ${Utils.trunc(JSON.stringify(toolArgs), 60)}`, "tool", true, true);
    UI.displayCycleArtifact(`Tool Call: ${toolName}`, JSON.stringify(toolArgs, null, 2), "info", false, "LLM", `tool.call.${toolName}`, currentCycle);
    let funcRespContent; let toolResult = null; let toolError = null; let toolSuccess = false;
    try {
      toolResult = await ToolRunner.runTool(toolName, toolArgs, loadedStaticTools, state.dynamicTools || [], uiHooks);
      toolSuccess = true;
      if (toolResult && typeof toolResult.success === "boolean" && !toolResult.success) {
        toolSuccess = false; toolError = new ToolError(toolResult.error || `Tool '${toolName}' reported failure.`, toolName, toolArgs, toolResult);
      }
      funcRespContent = { name: toolName, response: { content: JSON.stringify(toolResult) } };
      uiHooks.updateTimelineItem(toolLogItem, `[TOOL ${toolSuccess ? "OK" : "FAIL"}] '${toolName}'. Result: ${Utils.trunc(JSON.stringify(toolResult), 80)}`, toolSuccess ? "tool" : "error", true);
      UI.displayCycleArtifact(`Tool Response: ${toolName}`, JSON.stringify(toolResult, null, 2), toolSuccess ? "output" : "error", false, "Tool", `tool.response.${toolName}`, currentCycle);
      if (toolName === "run_self_evaluation" && toolResult && toolSuccess) StateManager.addEvaluationResult(toolResult);
      if (!toolSuccess && toolError) throw toolError;
    } catch (e) {
      toolSuccess = false; toolError = e instanceof ToolError ? e : new ToolError(`Tool '${toolName}' failed: ${e.message}`, toolName, toolArgs, e);
      logger.logEvent("error", `Tool Execution Error (${toolName}): ${toolError.message}`, toolError.details || toolError);
      funcRespContent = { name: toolName, response: { error: `Tool failed: ${toolError.message}` } };
      uiHooks.updateTimelineItem(toolLogItem, `[TOOL ERR] '${toolName}': ${Utils.trunc(toolError.message, 60)}`, "error", true);
      UI.displayCycleArtifact(`Tool Error: ${toolName}`, toolError.message + (toolError.details ? `\nDetails: ${JSON.stringify(toolError.details)}` : ""), "error", false, "Tool", `tool.error.${toolName}`, currentCycle);
    }
    return { role: "function", parts: [{ functionResponse: funcRespContent }], _toolExecutionInfo: { name: toolName, args: toolArgs, success: toolSuccess, result: toolResult, error: toolError?.message || null, errorDetails: toolError?.details || null } };
  };

  const _executeLlmApiCallSequence = async (prompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, state, currentCycle) => {
    let apiHistory = []; let currentApiResult = null; let accumulatedText = ""; let isContinuation = false;
    let totalInputTokens = 0; let totalOutputTokens = 0; let toolExecutionSummaries = [];
    const uiHooks = { updateStatus: UI.updateStatus, logTimeline: UI.logToTimeline, updateTimelineItem: UI.updateTimelineItem, displayArtifact: UI.displayCycleArtifact };
    let currentPrompt = prompt; let currentHistory = null;
    for (let i = 0; i < 5; i++) {
      logger.logEvent("debug", `API Call Sequence: Iteration ${i + 1}`);
      let loopApiResult = null; let loopAccumulatedText = "";
      const callResult = await ApiClient.callApiWithRetry(currentPrompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, isContinuation, currentHistory, state.cfg?.maxRetries ?? 1, {}, uiHooks.updateStatus, uiHooks.logTimeline, uiHooks.updateTimelineItem, (progress) => {
          if (progress.type === "text") { loopAccumulatedText += progress.content; UI.updateStreamingOutput(loopAccumulatedText); }
          else if (progress.type === "functionCall") UI.updateStreamingOutput(`Function Call received: ${progress.content.name}\nArgs:\n${JSON.stringify(progress.content.args, null, 2)}`);
          if (progress.accumulatedResult) loopApiResult = progress.accumulatedResult;
        }
      );
      if (!loopApiResult) loopApiResult = callResult;
      currentApiResult = loopApiResult; accumulatedText = loopAccumulatedText;
      totalInputTokens += loopApiResult.inputTokenCount || 0; totalOutputTokens += loopApiResult.outputTokenCount || 0;
      if (currentPrompt) apiHistory.push({ role: "user",parts: [{ text: currentPrompt }] });
      if (loopApiResult.rawResp?.candidates?.[0]?.content) apiHistory.push(loopApiResult.rawResp.candidates[0].content);
      else if (loopApiResult.type === "text" && loopApiResult.content) apiHistory.push({ role: "model", parts: [{ text: loopApiResult.content }] });
      
      if (loopApiResult.type === "functionCall" && loopApiResult.content?.name) {
        uiHooks.updateStatus("Processing Tool Call...", true);
        const fc = loopApiResult.content;
        const toolResponse = await _handleToolExecution(fc, state, currentCycle, uiHooks);
        toolExecutionSummaries.push(toolResponse._toolExecutionInfo);
        apiHistory.push(toolResponse);
        currentPrompt = null; currentHistory = [...apiHistory]; isContinuation = true; loopAccumulatedText = "";
        continue;
      } else { break; }
    }
    StateManager.updateAndSaveState(s => { s.lastApiResponse = currentApiResult; s.contextTokenEstimate += totalOutputTokens; return s; });
    return { apiResult: currentApiResult, accumulatedText: accumulatedText, toolExecutionSummaries: toolExecutionSummaries };
  };

  const _processLlmApiResponse = (apiCallResult, state, currentCycle) => {
    UI.updateStatus("Processing Final Response...");
    const finalContent = apiCallResult.accumulatedText || apiCallResult.apiResult?.content || "(No final text output)";
    UI.updateStreamingOutput(finalContent, true);
    const sanitized = ApiClient.sanitizeLlmJsonResp(finalContent);
    let parsedResp;
    UI.displayCycleArtifact("LLM Final Output Raw", finalContent, "info", false, "LLM", "llm.raw", currentCycle);
    UI.displayCycleArtifact("LLM Final Output Sanitized", sanitized, "output", false, "LLM", "llm.sanitized", currentCycle);
    try {
      parsedResp = JSON.parse(sanitized);
      logger.logEvent("info", `Parsed final LLM JSON after iteration ${currentCycle}.`);
      UI.logToTimeline(currentCycle, "[LLM OK] Received and parsed final response.");
      StateManager.updateAndSaveState(s => {
        if (parsedResp.self_assessment_notes) {
          UI.displayCycleArtifact("Agent Self-Assessment", parsedResp.self_assessment_notes, "info", false, "LLM", "llm.self_assessment", currentCycle);
          logger.logEvent("info", `LLM provided self-assessment notes: ${Utils.trunc(parsedResp.self_assessment_notes, 100)}`);
          s.lastSelfAssessment = parsedResp.self_assessment_notes;
        }
        if (parsedResp.current_context_focus && s.currentGoal) {
          s.currentGoal.currentContextFocus = parsedResp.current_context_focus;
          logger.logEvent("info", `LLM updated context focus: ${s.currentGoal.currentContextFocus}`);
        }
        return s;
      });
    } catch (e) {
      logger.logEvent("error", `LLM final JSON parse failed: ${e.message}. Content: ${Utils.trunc(sanitized, 500)}`, e);
      UI.logToTimeline(currentCycle, "[LLM ERR] Invalid final JSON response.", "error");
      UI.displayCycleArtifact("Parse Error", e.message, "error", false, "System", "parse.error", currentCycle);
      throw new ApplicationError(`LLM response invalid JSON: ${e.message}`, { content: sanitized });
    }
    const outputTokens = apiCallResult.apiResult?.outputTokenCount || 0;
    if (outputTokens > 0) {
        StateManager.updateAndSaveState(s => {
            if (!s.tokenHistory) s.tokenHistory = [];
            s.tokenHistory.push(outputTokens);
            if (s.tokenHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.tokenHistory.shift();
            return s;
        });
    }
    return parsedResp;
  };

  const _runLlmIteration = async (state, goalInfo, currentCycle) => {
    UI.highlightCoreStep(1); const startTime = performance.now();
    let finalResult = null; let toolSummaries = [];
    try {
      const prompt = _assembleCorePromptContext(state, goalInfo, currentCycle);
      const sysInstruction = `You are x0. DELIBERATE, adopt ${state.personaMode}. Respond ONLY valid JSON matching the schema. Refer to artifacts by ID and optional versionId (e.g., file.js#v1). Use artifactId and cycle args for tools. Use run_self_evaluation tool if appropriate. Provide modular edits via 'artifact_changes.modular' when possible. If generating full page changes, use 'page_composition' over 'full_html_source' string if 'enablePageComposition' config is true and it's suitable. Consider artifact paradigms.`;
      const allFuncDecls = await _prepareFunctionDeclarations(state);
      const coreModelKey = state.cfg?.coreModel || "ADVANCED";
      const coreModelIdentifier = config.DEFAULT_MODELS[coreModelKey.toUpperCase()] || coreModelKey;
      const apiKey = state.apiKey;
      if (!apiKey) throw new ConfigError("API Key is missing. Cannot make LLM call.", "apiKey");
      UI.clearStreamingOutput();
      const apiCallResult = await _executeLlmApiCallSequence(prompt, sysInstruction, coreModelIdentifier, apiKey, allFuncDecls, state, currentCycle);
      toolSummaries = apiCallResult.toolExecutionSummaries || [];
      const parsedResp = _processLlmApiResponse(apiCallResult, state, currentCycle);
      finalResult = { response: parsedResp, cycleTimeMillis: performance.now() - startTime, toolSummaries: toolSummaries, error: null };
    } catch (error) {
      if (!(error instanceof AbortError)) {
        logger.logEvent("error", `Core LLM Iteration failed (Cycle ${currentCycle}): ${error.message}`, error instanceof ApplicationError ? error.details : error);
        UI.logToTimeline(currentCycle, `[LLM ERR] Iteration failed: ${Utils.trunc(error.message, 100)}`, "error");
      }
      finalResult = { response: null, cycleTimeMillis: performance.now() - startTime, toolSummaries: toolSummaries, error: error };
    } finally { UI.clearStreamingOutput(); }
    return finalResult;
  };
  
  const _assembleCritiquePromptContext = (llmProposal, goalInfo) => {
      const template = Storage.getArtifactContent("reploid.core.critiquer-prompt", 0);
      if (!template) throw new ArtifactError("Critique prompt artifact not found!", "reploid.core.critiquer-prompt", 0);
      
      const getParadigm = (id) => StateManager.getArtifactMetadata(id)?.paradigm || "unknown";
      const changes = llmProposal.artifact_changes || {};
      const modifiedParadigmSummary = (changes.modified || []).map(a => getParadigm(a.id)).join(", ") || "N/A";
      const newParadigmSummary = (changes.new || []).map(a => a.paradigm || getParadigm(a.id)).join(", ") || "N/A";
      const deletedParadigmSummary = (changes.deleted || []).map(id => getParadigm(id)).join(", ") || "N/A";
      const modularParadigmSummary = (changes.modular || []).map(a => getParadigm(a.id)).join(", ") || "N/A";

      const { prompt, error } = AgentLogicPureHelpers.assembleCritiquePromptPure(template, llmProposal, goalInfo, Utils.trunc);
      if(error) throw new ApplicationError(error);

      return prompt
          .replace(/\[\[MODIFIED_ARTIFACT_PARADIGMS\]\]/g, modifiedParadigmSummary)
          .replace(/\[\[NEW_ARTIFACT_PARADIGMS\]\]/g, newParadigmSummary)
          .replace(/\[\[DELETED_ARTIFACT_PARADIGMS\]\]/g, deletedParadigmSummary)
          .replace(/\[\[MODULAR_ARTIFACT_PARADIGMS\]\]/g, modularParadigmSummary);
  };

  const _runSingleAutoCritiqueInstance = async (apiKey, llmProposal, goalInfo, currentCycle, critiqueIndex) => {
    const state = StateManager.getState(); if (!state) throw new StateError("State not initialized for critique instance");
    const prompt = _assembleCritiquePromptContext(llmProposal, goalInfo);
    const critiqueModelKey = state.cfg?.critiqueModel || "BASE";
    const critiqueModelIdentifier = config.DEFAULT_MODELS[critiqueModelKey.toUpperCase()] || critiqueModelKey;
    const sysInstruction = 'Critiquer x0. Analyze objectively. Output ONLY valid JSON: {"critique_passed": boolean, "critique_report": "string"}';
    UI.displayCycleArtifact(`Critique Input [${critiqueIndex + 1}/${NUM_CRITIQUES_TO_GENERATE}]`, prompt, "input", false, "System", `prompt.critique.${critiqueIndex}`, currentCycle);
    let critiqueResultText = ""; let critiqueApiResult = null; let finalResult = { critique_passed: false, critique_report: "Critique execution failed" };
    try {
      let accumulatedCritiqueText = "";
      const genConfigOverrides = NUM_CRITIQUES_TO_GENERATE > 1 ? { temperature: 0.7 + Math.random() * 0.2 } : {};
      critiqueApiResult = await ApiClient.callApiWithRetry(prompt, sysInstruction, critiqueModelIdentifier, apiKey, [], false, null, state.cfg?.maxRetries ?? 1, genConfigOverrides,
        (msg, active, isErr) => UI.updateStatus(`Critique ${critiqueIndex + 1}: ${msg}`, active, isErr),
        (cyc, msg, type, sub, anim) => UI.logToTimeline(cyc, `[CRIT ${critiqueIndex + 1}] ${msg}`, type, sub, anim),
        UI.updateTimelineItem,
        (progress) => {
          if (progress.type === "text") accumulatedCritiqueText += progress.content;
          if (progress.accumulatedResult) critiqueApiResult = progress.accumulatedResult;
          critiqueResultText = progress.accumulatedResult?.content || accumulatedCritiqueText;
        }
      );
      if (!critiqueResultText && critiqueApiResult?.content) critiqueResultText = critiqueApiResult.content;
      UI.displayCycleArtifact(`Critique Output Raw [${critiqueIndex + 1}]`, critiqueResultText || "(No text content)", "info", false, "LLM", `critique.raw.${critiqueIndex}`, currentCycle);
      const sanitized = ApiClient.sanitizeLlmJsonResp(critiqueResultText);
      UI.displayCycleArtifact(`Critique Output Sanitized [${critiqueIndex + 1}]`, sanitized, "output", false, "LLM", `critique.sanitized.${critiqueIndex}`, currentCycle);
      const parsedCritique = JSON.parse(sanitized);
      if (typeof parsedCritique.critique_passed !== "boolean" || typeof parsedCritique.critique_report !== "string") throw new ApplicationError("Critique JSON missing required fields.");
      finalResult = parsedCritique;
    } catch (e) {
      logger.logEvent("error", `Critique instance ${critiqueIndex + 1} API/Parse failed: ${e.message}`, e);
      UI.logToTimeline(currentCycle, `[CRIT ${critiqueIndex + 1} ERR] Failed: ${e.message}`, "error", true);
      UI.displayCycleArtifact(`Critique Error [${critiqueIndex + 1}]`, e.message, "error", false, "System", `critique.error.${critiqueIndex}`, currentCycle);
      finalResult.critique_report = `Critique instance ${critiqueIndex + 1} failed: ${e.message}`;
    }
    return finalResult;
  };

  const _runAutoCritique = async (apiKey, llmProposal, goalInfo, currentCycle) => {
    UI.highlightCoreStep(5); UI.updateStatus(`Running ${NUM_CRITIQUES_TO_GENERATE} Auto-Critiques...`, true);
    const critiquePromises = [];
    for (let i = 0; i < NUM_CRITIQUES_TO_GENERATE; i++) critiquePromises.push(_runSingleAutoCritiqueInstance(apiKey, llmProposal, goalInfo, currentCycle, i));
    const results = await Promise.allSettled(critiquePromises);
    const successfulCritiques = results.filter((r) => r.status === "fulfilled").map((r) => r.value);
    const failedCritiques = results.filter((r) => r.status === "rejected").map((r) => ({ critique_passed: false, critique_report: `Critique generation failed: ${r.reason?.message || "Unknown reason"}`}));
    const allCritiqueOutputs = [...successfulCritiques, ...failedCritiques];
    const overallPassed = successfulCritiques.length === NUM_CRITIQUES_TO_GENERATE && successfulCritiques.every((c) => c.critique_passed);
    let combinedReport = allCritiqueOutputs.map((c, i) => `Critique ${i + 1}: ${c.critique_passed ? "Pass" : "FAIL"}. Report: ${c.critique_report}`).join("\n---\n");
    if (failedCritiques.length > 0) combinedReport += `\n---\nWARNING: ${failedCritiques.length} critique generation(s) failed.`;
    logger.logEvent("info", `Multi-Critique finished. Overall Pass: ${overallPassed}`);
    UI.logToTimeline(currentCycle, `[CRITIQUE] Multi-Critique completed. Overall Passed: ${overallPassed}`);
    UI.updateStatus("Idle"); UI.clearStreamingOutput();
    return { critiques: allCritiqueOutputs, overall_passed: overallPassed, combined_report: combinedReport };
  };
  
  const _assembleHtmlFromPageComposition = async (composition, nextCycleNum, critiqueSource, state) => {
    logger.logEvent("info", "Assembling HTML from page_composition object.", { composition });
    let htmlParts = [];
    try {
      htmlParts.push(composition.doctype || "<!DOCTYPE html>");
      const htmlAttrsObj = composition.html_attributes || { lang: "en" };
      const htmlAttrs = Object.entries(htmlAttrsObj).map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`).join(" ");
      htmlParts.push(`<html ${htmlAttrs}>`);
      htmlParts.push("<head>");
      if (composition.head_elements && Array.isArray(composition.head_elements)) {
        for (const el of composition.head_elements) {
          if (el.type === "artifact_id" && el.id) {
            const meta = StateManager.getArtifactMetadata(el.id);
            const content = meta ? Storage.getArtifactContent(el.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(content); UI.displayCycleArtifact(`Loaded Head Artifact: ${el.id}`, Utils.trunc(content,100), "info", false, critiqueSource, el.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Head artifact ${el.id} not found for page_composition.`); htmlParts.push(`<!-- Head artifact ${el.id} not found -->`);
            }
          } else if (el.type === "inline_tag" && el.tag) {
            const tagAttrsObj = el.attributes || {};
            const tagAttrs = Object.entries(tagAttrsObj).map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`).join(" ");
            let tagContent = "";
            if (el.content) tagContent = Utils.escapeHtml(el.content);
            else if (el.content_artifact_id) {
                const metaContent = StateManager.getArtifactMetadata(el.content_artifact_id);
                const artifactContent = metaContent ? Storage.getArtifactContent(el.content_artifact_id, metaContent.latestCycle, metaContent.version_id) : null;
                if (artifactContent !== null) {
                    tagContent = artifactContent; UI.displayCycleArtifact(`Loaded Content for <${el.tag}>: ${el.content_artifact_id}`, Utils.trunc(artifactContent,100), "info", false, critiqueSource, el.content_artifact_id, nextCycleNum);
                } else { logger.logEvent("warn", `Content artifact ${el.content_artifact_id} for <${el.tag}> not found.`); tagContent = `<!-- Content artifact ${el.content_artifact_id} not found -->`;}
            }
            const voidElements = ["meta", "link", "br", "hr", "img", "input", "base", "col", "embed", "param", "source", "track", "area", "keygen", "wbr"];
            if (voidElements.includes(el.tag.toLowerCase())) htmlParts.push(`<${el.tag} ${tagAttrs}>`);
            else htmlParts.push(`<${el.tag} ${tagAttrs}>${tagContent}</${el.tag}>`);
          }
        }
      }
      htmlParts.push("</head>");
      const bodyAttrsObj = composition.body_attributes || {};
      const bodyAttrs = Object.entries(bodyAttrsObj).map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`).join(" ");
      htmlParts.push(`<body ${bodyAttrs}>`);
      if (composition.body_elements && Array.isArray(composition.body_elements)) {
        for (const el of composition.body_elements) {
          if (el.type === "artifact_id" && el.id) {
            const meta = StateManager.getArtifactMetadata(el.id);
            const content = meta ? Storage.getArtifactContent(el.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(content); UI.displayCycleArtifact(`Loaded Body Artifact: ${el.id}`, Utils.trunc(content,100), "info", false, critiqueSource, el.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Body artifact ${el.id} not found for page_composition.`); htmlParts.push(`<!-- Body artifact ${el.id} not found -->`);
            }
          } else if (el.type === "web_component_tag" && el.tag) {
            const wcAttrsObj = el.attributes || {};
            const wcAttrs = Object.entries(wcAttrsObj).map(([key, value]) => `${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`).join(" ");
            htmlParts.push(`<${el.tag} ${wcAttrs}></${el.tag}>`);
          } else if (el.type === "inline_html" && el.content) htmlParts.push(el.content);
        }
      }
      if (composition.script_references && Array.isArray(composition.script_references)) {
        for (const ref of composition.script_references) {
          const scriptAttrsList = [];
          if (ref.attributes) {
            if (ref.attributes.defer) scriptAttrsList.push("defer"); if (ref.attributes.async) scriptAttrsList.push("async");
            Object.entries(ref.attributes).forEach(([key,value]) => { if (!["defer", "async", "src"].includes(key) && value !== undefined) scriptAttrsList.push(`${Utils.escapeHtml(key)}="${Utils.escapeHtml(String(value))}"`); });
          }
          const scriptAttrs = scriptAttrsList.join(" ");
          if (ref.type === "artifact_id" && ref.id) {
            const meta = StateManager.getArtifactMetadata(ref.id);
            const content = meta ? Storage.getArtifactContent(ref.id, meta.latestCycle, meta.version_id) : null;
            if (content !== null) {
              htmlParts.push(`<script ${scriptAttrs}>${content}</script>`); UI.displayCycleArtifact(`Inlined Script Artifact: ${ref.id}`, `(${content.length} chars)`, "info", false, critiqueSource, ref.id, nextCycleNum);
            } else {
              logger.logEvent("warn", `Script artifact ${ref.id} not found for inlining.`); htmlParts.push(`<!-- Script artifact ${ref.id} not found -->`);
            }
          } else if (ref.type === "path" && ref.src) htmlParts.push(`<script src="${Utils.escapeHtml(ref.src)}" ${scriptAttrs}></script>`);
        }
      }
      htmlParts.push("</body></html>");
      const assembledHtml = htmlParts.join("\n");
      logger.logEvent("info", `Successfully assembled HTML from page_composition (${assembledHtml.length} chars).`);
      UI.displayCycleArtifact("Assembled Page Composition (Preview)", Utils.trunc(assembledHtml, 500), "output", true, critiqueSource, "page_composition_output", nextCycleNum);
      return assembledHtml;
    } catch (error) {
      logger.logEvent("error", "Failed to assemble HTML from page_composition", error);
      throw new ApplicationError("HTML assembly from page_composition failed.", { originalError: error.message || String(error), composition });
    }
  };

  const _applyArtifactChanges = async (artifactChanges, nextCycleNum, critiqueSource, state, changesMade, errors) => {
    const { modified, new: newArtifacts, deleted, modular, full_html_source, page_composition } = artifactChanges || {};
    let requiresSandbox = false;

    if (page_composition && state.cfg?.enablePageComposition === true) {
      try {
        const assembledHtml = await _assembleHtmlFromPageComposition(page_composition, nextCycleNum, critiqueSource, state);
        StateManager.updateAndSaveState(s => { s.lastGeneratedFullSource = assembledHtml; return s; });
        changesMade.push("Generated Page Composition (Sandbox Required)");
        UI.displayCycleArtifact("Proposed Page Composition Structure", JSON.stringify(page_composition, null, 2), "info", true, critiqueSource, "page_composition_input", state.totalCycles);
        requiresSandbox = true;
      } catch (e) {
        errors.push(`Failed to process page_composition: ${e.message}`); logger.logEvent("error", "Page Composition processing error", e);
        UI.displayCycleArtifact("Page Composition Error", e.message, "error", false, critiqueSource, "page_composition_error", state.totalCycles);
      }
    } else if (full_html_source) {
      StateManager.updateAndSaveState(s => { s.lastGeneratedFullSource = full_html_source; return s; });
      changesMade.push("Generated Full HTML (Sandbox Required)");
      UI.displayCycleArtifact("Full HTML Source (Prepared for Sandbox)", `(${full_html_source.length} chars)`, "output", true, critiqueSource, "full_html_output", state.totalCycles);
      requiresSandbox = true;
    }

    for (const modArt of modified || []) {
      if (!modArt.id || modArt.content === undefined) { errors.push(`Invalid modified artifact structure: ID=${modArt.id || "?"}`); continue; }
      const currentMeta = StateManager.getArtifactMetadata(modArt.id);
      if (!currentMeta) { errors.push(`Modify failed (original not found): ${modArt.id}`); continue; }
      const currentContent = Storage.getArtifactContent(modArt.id, currentMeta.latestCycle, currentMeta.version_id);
      if (currentContent === null) { errors.push(`Modify failed (original content missing): ${modArt.id} C${currentMeta.latestCycle} V${currentMeta.version_id || "def"}`); continue; }
      if (currentContent !== modArt.content) {
        try {
          const checksum = await Utils.calculateChecksum(modArt.content);
          Storage.setArtifactContent(modArt.id, nextCycleNum, modArt.content, modArt.version_id);
          StateManager.updateArtifactMetadata(modArt.id, currentMeta.type, currentMeta.description, nextCycleNum, checksum, critiqueSource, modArt.version_id, false, currentMeta.paradigm);
          changesMade.push(`Modified: ${modArt.id}${modArt.version_id ? "#" + modArt.version_id : ""}`);
          UI.displayCycleArtifact(`Modified Artifact${modArt.version_id ? " (V: " + modArt.version_id + ")" : ""}`, Utils.trunc(modArt.content, 200), "output", true, critiqueSource, modArt.id, nextCycleNum);
          if (modArt.id.startsWith("reploid.")) logger.logEvent("warn", `Core artifact ${modArt.id} modified.`);
        } catch (e) { errors.push(`Failed save mod ${modArt.id}: ${e.message}`); }
      } else { UI.displayCycleArtifact(`Modified (No Change)${modArt.version_id ? " (V: " + modArt.version_id + ")" : ""}`, Utils.trunc(currentContent, 200), "info", false, critiqueSource, modArt.id, currentMeta.latestCycle); }
    }
    for (const newArt of newArtifacts || []) {
      if (!newArt.id || !newArt.type || newArt.content === undefined) { errors.push(`Invalid new artifact structure: ID=${newArt.id || "?"}`); continue; }
      try {
        const checksum = await Utils.calculateChecksum(newArt.content);
        Storage.setArtifactContent(newArt.id, nextCycleNum, newArt.content, newArt.version_id);
        StateManager.updateArtifactMetadata(newArt.id, newArt.type, newArt.description || `New ${newArt.type}`, nextCycleNum, checksum, critiqueSource, newArt.version_id, false, newArt.paradigm);
        changesMade.push(`Created: ${newArt.id}${newArt.version_id ? "#" + newArt.version_id : ""} (${newArt.type})`);
        UI.displayCycleArtifact(`New Artifact${newArt.version_id ? " (V: " + newArt.version_id + ")" : ""}`, Utils.trunc(newArt.content, 200), "output", true, critiqueSource, newArt.id, nextCycleNum);
      } catch (e) { errors.push(`Failed save new ${newArt.id}: ${e.message}`); }
    }
    for (const idToDelete of deleted || []) {
      const meta = StateManager.getArtifactMetadata(idToDelete);
      if (meta) {
        const allVersions = StateManager.getArtifactMetadataAllVersions(idToDelete);
        allVersions.forEach((v) => Storage.deleteArtifactVersion(idToDelete, v.latestCycle, v.version_id));
        StateManager.deleteArtifactMetadata(idToDelete);
        changesMade.push(`Deleted: ${idToDelete} (All versions)`);
        UI.displayCycleArtifact("Deleted Artifact (All Versions)", idToDelete, "output", true, critiqueSource);
      } else { errors.push(`Delete failed (not found): ${idToDelete}`); }
    }
    for (const modEdit of modular || []) {
      if (!modEdit.id || !modEdit.patch_content || !modEdit.patch_format) { errors.push(`Invalid modular edit structure: ID=${modEdit.id || "?"}`); continue; }
      UI.displayCycleArtifact(`Modular Edit Proposed${modEdit.version_id ? " (V: " + modEdit.version_id + ")" : ""}`, JSON.stringify(modEdit, null, 2), "info", true, critiqueSource, modEdit.id, nextCycleNum);
      try {
        const baseMeta = StateManager.getArtifactMetadata(modEdit.id);
        if (!baseMeta) throw new ArtifactError(`Base artifact not found: ${modEdit.id}`, modEdit.id);
        const baseContent = Storage.getArtifactContent(modEdit.id, baseMeta.latestCycle, baseMeta.version_id);
        if (baseContent === null) throw new ArtifactError(`Base content missing for ${modEdit.id}`, modEdit.id, baseMeta.latestCycle);
        let toolToRun = null; let toolArgs = { artifactId: modEdit.id, cycle: baseMeta.latestCycle, versionId: baseMeta.version_id, patchContent: modEdit.patch_content };
        if (modEdit.patch_format.toLowerCase() === "diff" || modEdit.patch_format.toLowerCase() === "unified-diff") toolToRun = "apply_diff_patch";
        else if (modEdit.patch_format.toLowerCase() === "json-patch" || modEdit.patch_format.toLowerCase() === "rfc6902") {
          toolToRun = "apply_json_patch"; try { toolArgs.patchContent = JSON.parse(modEdit.patch_content); } catch { toolArgs.patchContent = modEdit.patch_content; }
        } else if (modEdit.patch_format.toLowerCase() === "replace-function" || modEdit.patch_format.toLowerCase() === "replace-block") {
          toolToRun = "apply_block_replacement"; toolArgs.target_block = modEdit.target_block;
        } else throw new ToolError(`Unsupported patch format: ${modEdit.patch_format}`, "apply_modular_edit", toolArgs);
        const patchResult = await ToolRunner.runTool(toolToRun, toolArgs, loadedStaticTools, state.dynamicTools || [], {});
        if (!patchResult || !patchResult.success) throw new ToolError(`Patch tool '${toolToRun}' failed: ${patchResult?.error || "Unknown tool error"}`, toolToRun, toolArgs, patchResult);
        const patchedContent = patchResult.result_content;
        const checksum = await Utils.calculateChecksum(patchedContent);
        Storage.setArtifactContent(modEdit.id, nextCycleNum, patchedContent, modEdit.version_id);
        StateManager.updateArtifactMetadata(modEdit.id, baseMeta.type, baseMeta.description, nextCycleNum, checksum, critiqueSource, modEdit.version_id, true, baseMeta.paradigm);
        changesMade.push(`Modular Edit: ${modEdit.id}${modEdit.version_id ? "#" + modEdit.version_id : ""} (${modEdit.patch_format})`);
        UI.displayCycleArtifact(`Modular Edit Applied${modEdit.version_id ? " (V: " + modEdit.version_id + ")" : ""}`, Utils.trunc(patchedContent, 200), "output", true, critiqueSource, modEdit.id, nextCycleNum);
      } catch (e) { errors.push(`Failed apply modular edit ${modEdit.id}: ${e.message}`); UI.displayCycleArtifact(`Modular Edit Failed ${modEdit.id}`, e.message, "error", false, critiqueSource); }
    }
    return { requiresSandbox };
  };

  const _applyToolDefinitionChanges = (newTools, critiqueSource, state, changesMade, errors, currentCycleNum) => {
    (newTools || []).forEach((tool) => {
      const decl = tool.declaration; const impl = tool.implementation; const paradigm = tool.suggested_paradigm || "semi-pure";
      if (!decl || !impl || !decl.name || !decl.description || !decl.inputSchema) {
        errors.push(`Invalid new tool structure: Name=${decl?.name || "?"}`); UI.displayCycleArtifact("Invalid Tool Def", JSON.stringify(tool), "error", false, critiqueSource); return;
      }
      UI.displayCycleArtifact(`Proposed Tool Decl: ${decl.name}`, JSON.stringify(decl, null, 2), "output", true, critiqueSource);
      UI.displayCycleArtifact(`Generated Tool Impl: ${decl.name} (Paradigm: ${paradigm})`, impl, "output", true, critiqueSource);
      if (!impl.includes("async function run(params)") && !impl.includes("async (params)") && !impl.includes("run = async (params)")) {
        errors.push(`Generated tool implementation for ${decl.name} missing valid async run(params) function.`);
        UI.logToTimeline(currentCycleNum, `[APPLY ERR] Tool impl ${decl.name} invalid structure.`, "error", true);
      } else {
        StateManager.updateAndSaveState(s => {
            const dynamicTools = s.dynamicTools || [];
            const existingIndex = dynamicTools.findIndex((t) => t.declaration.name === decl.name);
            const toolEntry = { declaration: decl, implementation: impl, paradigm: paradigm };
            let toolChangeType = "";
            if (existingIndex !== -1) { dynamicTools[existingIndex] = toolEntry; toolChangeType = `Tool Updated: ${decl.name}`; }
            else { dynamicTools.push(toolEntry); toolChangeType = `Tool Defined: ${decl.name}`; }
            s.dynamicTools = dynamicTools;
            changesMade.push(toolChangeType);
            UI.logToTimeline(currentCycleNum, `[ARTIFACT] ${toolChangeType}`, "info", true);
            return s;
        });
      }
    });
  };

  const _applyLLMChanges = async (llmResp, currentCycleNum, critiqueSource) => {
    UI.highlightCoreStep(6);
    let state = StateManager.getState();
    if (!state) return { success: false, errors: ["State not initialized"], nextCycle: currentCycleNum, requiresSandbox: false, changes: [] };
    let changesMade = []; let errors = [];
    currentLlmResponse = llmResp;
    const nextCycleNum = currentCycleNum + 1;
    const { requiresSandbox } = await _applyArtifactChanges(llmResp.artifact_changes, nextCycleNum, critiqueSource, state, changesMade, errors);
    _applyToolDefinitionChanges(llmResp.proposed_new_tools, critiqueSource, state, changesMade, errors, currentCycleNum); // state is passed for read, changes are applied via StateManager.updateAndSaveState inside
    
    state = StateManager.getState(); // Re-fetch state as _applyToolDefinitionChanges might have updated it
    const success = errors.length === 0;
    if (success) {
        StateManager.updateAndSaveState(s => {
            if (!requiresSandbox) { s.totalCycles = nextCycleNum; s.agentIterations++; }
            const confidence = llmResp.agent_confidence_score ?? 0.0;
            s.confidenceHistory.push(confidence);
            if (s.confidenceHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.confidenceHistory.shift();
            return s;
        });
    } else {
        StateManager.updateAndSaveState(s => {
            s.failCount = (s.failCount || 0) + 1;
            s.failHistory = s.failHistory || [];
            s.failHistory.push({ cycle: currentCycleNum, reason: `Apply Error: ${errors.join(", ")}` });
            if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.failHistory.shift();
            return s;
        });
    }
    const targetArtifactChanged = changesMade.some((c) => c.includes("target.") || c.includes("reploid.") || c.includes("Full HTML") || c.includes("Page Composition"));
    if (targetArtifactChanged && success && !requiresSandbox) UI.logToTimeline(currentCycleNum, `[APPLY] Applying changes for Cycle ${nextCycleNum}.`, "info", true);
    UI.logToTimeline(currentCycleNum, `[APPLY] Changes applied for Cycle ${nextCycleNum} from ${critiqueSource}: ${changesMade.join(", ") || "None"}. Errors: ${errors.length}`, errors.length > 0 ? "warn" : "info", true);
    return { success: success, changes: changesMade, errors: errors, nextCycle: success && !requiresSandbox ? nextCycleNum : currentCycleNum, requiresSandbox: requiresSandbox };
  };
  
  const _checkHitlTriggersContext = (state, cycleTimeSecs, confidence, currentCycle, llmResponse) => {
      const proposedCoreChanges = state.cfg?.hitlOnMetaChanges === true && llmResponse?.response && getActiveGoalInfo().type === "Meta" && (
          llmResponse.response.artifact_changes?.modified?.some(a => a.id.startsWith("reploid.core.") && StateManager.getArtifactMetadata(a.id)?.paradigm?.startsWith("boundary")) ||
          llmResponse.response.artifact_changes?.new?.some(a => a.id.startsWith("reploid.core.") && a.paradigm?.startsWith("boundary")) ||
          llmResponse.response.artifact_changes?.deleted?.some(id => id.startsWith("reploid.core.") && StateManager.getArtifactMetadata(id)?.paradigm?.startsWith("boundary")) ||
          llmResponse.response.artifact_changes?.modular?.some(a => a.id.startsWith("reploid.core.") && StateManager.getArtifactMetadata(a.id)?.paradigm?.startsWith("boundary")) ||
          llmResponse.response.artifact_changes?.full_html_source || llmResponse.response.artifact_changes?.page_composition ||
          llmResponse.response.tool_calls?.some(tc => tc.name === "define_web_component" && tc.arguments?.targetArtifactId?.startsWith("reploid.core."))
      );

      return AgentLogicPureHelpers.checkHitlTriggersPure(
          currentCycle, state.cfg?.pauseAfterCycles || 0, (state.cfg?.humanReviewProb ?? 0) / 100.0,
          cycleTimeSecs, state.cfg?.maxCycleTime ?? 600, confidence, state.cfg?.autoCritiqueThresh ?? 0.75,
          state.forceHumanReview, getActiveGoalInfo().type, state.cfg?.hitlOnMetaChanges === true, proposedCoreChanges
      );
  };

  const _performCritique = async (state, llmResponse, goalInfo, currentCycle) => {
    const llmProb = (state.cfg?.llmCritiqueProb ?? 50) / 100.0;
    let overallPassed = false; let combinedReport = "Critique Skipped"; let applySource = "Skipped"; let allCritiques = [];

    if (Math.random() < llmProb) {
      UI.logToTimeline(currentCycle, "[DECIDE] Triggering Auto Critique...", "decide", true); UI.logCoreLoopStep(currentCycle, 5, "Critique: Auto");
      const multiCritiqueResult = await _runAutoCritique(state.apiKey, llmResponse.response, goalInfo, currentCycle);
      allCritiques = multiCritiqueResult.critiques; overallPassed = multiCritiqueResult.overall_passed; combinedReport = multiCritiqueResult.combined_report;
      applySource = `AutoCrit (${allCritiques.length} runs) ${overallPassed ? "Pass" : "Fail"}`;
      StateManager.updateAndSaveState(s => {
          s.lastCritiqueType = `Automated (${overallPassed ? "Pass" : "Fail"})`;
          if (s.critiqueFailHistory) s.critiqueFailHistory.push(!overallPassed);
          if (s.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) s.critiqueFailHistory.shift();
          return s;
      });
      UI.displayCycleArtifact("Auto Critique Combined Report", combinedReport, overallPassed ? "info" : "error", false, "LLM", "critique.combined_report", currentCycle);
    } else {
      overallPassed = true; applySource = "Critique Skipped";
      StateManager.updateAndSaveState(s => {
          s.lastCritiqueType = "Skipped";
          if (s.critiqueFailHistory) s.critiqueFailHistory.push(false);
          if (s.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) s.critiqueFailHistory.shift();
          return s;
      });
      UI.logCoreLoopStep(currentCycle, 5, "Critique: Skipped"); UI.logToTimeline(currentCycle, "[DECIDE] Critique Skipped.", "info", true);
    }
    return { critiquePassed: overallPassed, critiqueReport: combinedReport, applySource: applySource, critiques: allCritiques };
  };

  const _handleCritiqueDecision = async (state, llmResponse, goalInfo, currentCycle) => {
    UI.highlightCoreStep(4);
    const cycleTimeMillis = llmResponse.cycleTimeMillis || 0; const cycleSecs = cycleTimeMillis / 1000;
    const confidence = llmResponse.response?.agent_confidence_score ?? 0.0;
    const hitlTrigger = _checkHitlTriggersContext(state, cycleSecs, confidence, currentCycle, llmResponse);
    UI.logToTimeline(currentCycle, `[DECIDE] Time:${cycleSecs.toFixed(1)}s, Conf:${confidence.toFixed(2)}. Human: ${hitlTrigger ? hitlTrigger.reason : "No"}.`, "decide", true);
    if (hitlTrigger) {
      StateManager.updateAndSaveState(s => {
          s.lastCritiqueType = `Human (${hitlTrigger.reason})`; s.forceHumanReview = false;
          if (s.critiqueFailHistory) s.critiqueFailHistory.push(false);
          if (s.critiqueFailHistory?.length > (config.MAX_HISTORY_ITEMS || 20)) s.critiqueFailHistory.shift();
          return s;
      });
      UI.logCoreLoopStep(currentCycle, 5, `Critique: Human Intervention (${hitlTrigger.reason})`); UI.updateStatus(`Paused: Human Review (${hitlTrigger.reason})`);
      const primaryModId = llmResponse.response?.artifact_changes?.modified?.[0]?.id; const primaryNewId = llmResponse.response?.artifact_changes?.new?.[0]?.id;
      const primaryModularId = llmResponse.response?.artifact_changes?.modular?.[0]?.id;
      const hasFullSource = !!llmResponse.response?.artifact_changes?.full_html_source || !!llmResponse.response?.artifact_changes?.page_composition;
      const artifactToEdit = primaryModId || primaryNewId || primaryModularId || (hasFullSource ? (llmResponse.response.artifact_changes.page_composition ? "page_composition_preview" : "full_html_source") : null);
      UI.showHumanInterventionUI(hitlTrigger.mode, hitlTrigger.reason, [], artifactToEdit, []);
      return { status: "HITL_REQUIRED", critiquePassed: false, critiqueReport: `Human Intervention: ${hitlTrigger.reason}` };
    }
    const critiqueResult = await _performCritique(state, llmResponse, goalInfo, currentCycle);
    if (!critiqueResult.critiquePassed) {
      UI.logToTimeline(currentCycle, "[STATE] Auto-Critique failed. Forcing HITL.", "warn", true);
      StateManager.updateAndSaveState(s => {
          s.failCount = (s.failCount || 0) + 1; s.failHistory = s.failHistory || [];
          s.failHistory.push({ cycle: currentCycle, reason: `Critique Failed: ${Utils.trunc(critiqueResult.critiqueReport, 100)}` });
          if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.failHistory.shift();
          return s;
      });
      UI.showHumanInterventionUI("critique_feedback", `Auto Critique Failed: ${Utils.trunc(critiqueResult.critiqueReport, 150)}...`, [], null, critiqueResult.critiques);
      return { status: "HITL_REQUIRED", critiquePassed: false, critiqueReport: critiqueResult.critiqueReport };
    }
    return { status: "PROCEED", critiquePassed: critiqueResult.critiquePassed, critiqueReport: critiqueResult.critiqueReport, applySource: critiqueResult.applySource };
  };

  const _runSelfEvaluationStep = async (state, llmResponse, currentCycle) => {
    UI.highlightCoreStep(7); if (!llmResponse?.response) return;
    const contentToEvaluate = llmResponse.response.justification_persona_musing || "(No justification provided)";
    if (contentToEvaluate === "(No justification provided)") {
      logger.logEvent("info", `Skipping self-evaluation for Cycle ${currentCycle}: No justification provided.`);
      UI.logToTimeline(currentCycle, "[EVAL] Skipped (no justification).", "info", true); return;
    }
    logger.logEvent("info", `Running Self-Evaluation for Cycle ${currentCycle} justification`); UI.logToTimeline(currentCycle, "[EVAL] Evaluating cycle justification...", "eval", true);
    let evaluationCriteria = Storage.getArtifactContent("reploid.core.default-eval", 0);
    if (!evaluationCriteria) {
      logger.logEvent("warn", "Default evaluation criteria artifact (reploid.core.default-eval) not found. Using basic criteria.");
      evaluationCriteria = "Evaluate if the justification accurately reflects the proposed changes and aligns with the goal context. Rate clarity and reasoning.";
    }
    let evalCriteriaText = evaluationCriteria;
    try { const parsedCriteria = JSON.parse(evaluationCriteria); if (parsedCriteria.criteria && typeof parsedCriteria.criteria === "string") evalCriteriaText = parsedCriteria.criteria; else if (parsedCriteria.criteria && Array.isArray(parsedCriteria.criteria)) evalCriteriaText = JSON.stringify(parsedCriteria.criteria); } catch (e) {}
    const goalContext = getActiveGoalInfo().cumulativeGoal || getActiveGoalInfo().summaryContext || "N/A";
    const targetArtifactId = "llm.justification"; const targetArtifactCycle = currentCycle;
    try {
      const uiHooks = { updateStatus: UI.updateStatus, logTimeline: UI.logToTimeline, updateTimelineItem: UI.updateTimelineItem };
      const evalResult = await ToolRunner.runTool("run_self_evaluation", { targetArtifactId, targetArtifactCycle, evalCriteriaText, goalContextText: goalContext, contentToEvaluate }, loadedStaticTools, state.dynamicTools || [], uiHooks);
      StateManager.addEvaluationResult(evalResult);
      UI.logToTimeline(currentCycle, `[EVAL OK] Score: ${evalResult.evaluation_score.toFixed(2)}. Report: ${Utils.trunc(evalResult.evaluation_report, 60)}`, "eval", true);
      UI.displayCycleArtifact("Self-Evaluation Result", JSON.stringify(evalResult, null, 2), "info", false, "System", "eval.result", currentCycle);
    } catch (e) {
      logger.logEvent("error", `Self-evaluation step failed: ${e.message}`, e); UI.logToTimeline(currentCycle, `[EVAL ERR] Failed: ${e.message}`, "error", true);
    }
    UI.logToTimeline(currentCycle, "[LEARN] Learning phase placeholder.", "learn", true);
  };

  const _prepareCycle = () => {
    const state = StateManager.getState(); if (!state) throw new StateError("State not initialized!");
    if (!StateManager.isInitialized()) throw new StateError("StateManager lost initialization!");
    if (UI.isMetaSandboxPending()) { UI.showNotification("Meta Sandbox approval pending.", "warn"); throw new StateError("Sandbox Pending"); }
    if (!UI.isHumanInterventionHidden()) { UI.showNotification("Human Intervention required.", "warn"); throw new StateError("HITL Required"); }
    UI.clearCurrentCycleDetails(); currentLlmResponse = null; _abortRequested = false;
    const uiRefs = UI.getRefs();
    let updatedState = StateManager.updateAndSaveState(s => { s.apiKey = uiRefs.apiKeyInput?.value.trim() || s.apiKey; return s;});
    if (!updatedState.apiKey || updatedState.apiKey.length < 10) throw new ConfigError("Valid Gemini API Key required.", "apiKey");
    UI.logCoreLoopStep(updatedState.totalCycles, 0, "Define Goal");
    const goalText = uiRefs.goalInput?.value.trim() || "";
    const goalTypeElement = document.querySelector('input[name="goalType"]:checked');
    const goalType = goalTypeElement ? goalTypeElement.value : "System";
    if (!goalText && !updatedState.currentGoal?.seed) throw new ApplicationError("Initial Goal required.");
    const maxC = updatedState.cfg?.maxCycles || 0;
    if (maxC > 0 && updatedState.totalCycles >= maxC && updatedState.autonomyMode !== "Manual") throw new StateError(`Max cycles (${maxC}) reached.`);
    if (updatedState.autonomyMode === "N_Cycles" && updatedState.autonomyCyclesRemaining <= 0) {
      logger.logEvent("info", "Autonomous run finished (N cycles complete). Switching to Manual.");
      updatedState = StateManager.updateAndSaveState(s => { s.autonomyMode = "Manual"; return s; });
      _isAutonomous = false; UI.updateAutonomyControls(updatedState.autonomyMode, false);
      throw new StateError("Autonomy N Cycles Finished");
    }
    if (updatedState.autonomyMode !== "Manual") {
      _isAutonomous = true;
      if (updatedState.autonomyMode === "N_Cycles") updatedState = StateManager.updateAndSaveState(s => { s.autonomyCyclesRemaining--; return s; });
    } else { _isAutonomous = false; }
    if (updatedState.contextTokenEstimate >= updatedState.contextTokenTarget) UI.showNotification("Context tokens high. Consider summarizing.", "warn");
    const currentCycle = updatedState.totalCycles;
    const newGoalProvided = !!goalText;
    if (newGoalProvided) {
        updatedState = StateManager.updateAndSaveState(s => {
            if (!s.currentGoal?.seed) s.currentGoal = { seed: goalText, cumulative: goalText, latestType: goalType, summaryContext: null, currentContextFocus: null };
            else {
                s.currentGoal.cumulative = (s.currentGoal.cumulative || s.currentGoal.seed || "") + `\n\n[Cycle ${currentCycle} Refinement (${goalType})]: ${goalText}`;
                s.currentGoal.latestType = goalType; s.currentGoal.summaryContext = null; s.currentGoal.currentContextFocus = null;
            }
            return s;
        });
      UI.displayCycleArtifact("New Goal Input", `${goalType}: ${goalText}`, "input", false, "User", "goal.input", currentCycle);
      if (uiRefs.goalInput) uiRefs.goalInput.value = "";
    } else if (!updatedState.currentGoal?.seed && !updatedState.currentGoal?.cumulative) throw new ApplicationError("No active goal context.");
    const goalInfo = getActiveGoalInfo(); // Uses the latest state from StateManager
    updatedState = StateManager.updateAndSaveState(s => { s.retryCount = 0; s.personaMode = (s.cfg?.personaBalance ?? 50) >= 50 ? "LSD" : "XYZ"; return s; });
    UI.updateStatus("Starting Cycle...", true); if (uiRefs.currentCycleNumber) uiRefs.currentCycleNumber.textContent = currentCycle;
    UI.updateStateDisplay(); UI.logToTimeline(currentCycle, `[CYCLE] === Cycle ${currentCycle} Start === Goal: ${goalInfo.type}, Persona: ${updatedState.personaMode}, Auto: ${updatedState.autonomyMode}`);
    UI.logToTimeline(currentCycle, `[GOAL] Latest: "${Utils.trunc(goalInfo.latestGoal, 70)}..."`, "goal", true);
    UI.displayCycleArtifact("Cumulative Goal", goalInfo.cumulativeGoal || "(Not Set)", "input", false, "System", "goal.cumulative", currentCycle);
    if (goalInfo.summaryContext) UI.displayCycleArtifact("Summary Context", goalInfo.summaryContext, "input", false, "System", "meta.summary_context", currentCycle);
    if (goalInfo.currentContextFocus) UI.displayCycleArtifact("Context Focus", goalInfo.currentContextFocus, "input", false, "LLM", "meta.context_focus", currentCycle);
    return { state: updatedState, goalInfo, currentCycle };
  };

  const _handleCycleIterationFailure = async (state, error, currentCycle) => {
    if (error instanceof AbortError || _abortRequested) throw new AbortError("Aborted during iteration failure handling.");
    logger.logEvent("error", `Iteration attempt ${state.retryCount} failed: ${error.message}`);
    let updatedState = StateManager.updateAndSaveState(s => { s.retryCount++; return s; });
    const maxRetries = updatedState.cfg?.maxRetries ?? 1;
    if (updatedState.retryCount > maxRetries) {
      UI.logToTimeline(currentCycle, `[RETRY] Max retries (${maxRetries}) exceeded. Forcing HITL.`, "error");
      StateManager.updateAndSaveState(s => {
          s.failCount = (s.failCount || 0) + 1; s.failHistory = s.failHistory || [];
          s.failHistory.push({ cycle: currentCycle, reason: `Max Retries: ${error.message || "Unknown error"}` });
          if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.failHistory.shift();
          return s;
      });
      if (_isAutonomous) { logger.logEvent("warn", "Stopping autonomous run due to max retries."); stopAutonomousRun("Max retries reached"); }
      UI.showHumanInterventionUI("prompt", `Cycle failed after ${updatedState.retryCount} attempts: ${error.message || "Unknown error"}`);
      throw new StateError("HITL Required due to max retries");
    } else {
      UI.logToTimeline(currentCycle, `[RETRY] Attempting retry ${updatedState.retryCount}/${maxRetries}...`, "warn", true);
      StateManager.updateAndSaveState(s => { s.lastFeedback = `Retry ${s.retryCount}: ${Utils.trunc(error.message, 100) || "No response"}`; return s; });
      await Utils.delay(1000 * updatedState.retryCount);
    }
  };

  const _displayLlmIterationSuccessDetails = (llmIterationResult, currentCycle) => {
    UI.logToTimeline(currentCycle, "[STATE] Agent Iteration successful.", "info", true); UI.highlightCoreStep(3);
    if (llmIterationResult.toolSummaries && llmIterationResult.toolSummaries.length > 0) UI.displayToolExecutionSummary(llmIterationResult.toolSummaries);
    UI.displayCycleArtifact("Agent Deliberation", llmIterationResult.response?.persona_analysis_musing || "(N/A)", "info", false, "LLM", "llm.musing", currentCycle);
    UI.displayCycleArtifact("Proposed Changes", llmIterationResult.response?.proposed_changes_description || "(N/A)", "info", false, "LLM", "llm.proposal", currentCycle);
    UI.displayCycleArtifact("Agent Justification", llmIterationResult.response?.justification_persona_musing || "(N/A)", "info", false, "LLM", "llm.justification", currentCycle);
    UI.displayCycleArtifact("Agent Confidence", llmIterationResult.response?.agent_confidence_score?.toFixed(3) || "(N/A)", "info", false, "LLM", "llm.confidence", currentCycle);
    if (llmIterationResult.response?.current_context_focus) UI.displayCycleArtifact("Next Context Focus", llmIterationResult.response.current_context_focus, "info", false, "LLM", "llm.context_focus", currentCycle);
  };

  const _handleApplyFailure = (applyResult, critiqueDecision, currentCycle) => {
    const errorReason = `Apply Failed: ${applyResult.errors.join(", ")}`;
    StateManager.updateAndSaveState(s => {
        s.lastFeedback = `${critiqueDecision.applySource}, ${errorReason}`; s.failCount = (s.failCount || 0) + 1;
        s.failHistory = s.failHistory || []; s.failHistory.push({ cycle: currentCycle, reason: errorReason });
        if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.failHistory.shift();
        return s;
    });
    UI.logToTimeline(currentCycle, `[APPLY ERR] Failed apply: ${applyResult.errors.join(", ")}. Forcing HITL.`, "error");
    if (_isAutonomous) { logger.logEvent("warn", "Stopping autonomous run due to apply failure."); stopAutonomousRun("Apply failure"); }
    UI.showHumanInterventionUI("prompt", `Failed apply after critique: ${applyResult.errors.join(", ")}`);
    throw new StateError("HITL Required due to apply failure");
  };

  const executeCycle = async () => {
    if (_isRunning && !_isAutonomous) { UI.showNotification("Manual cycle start ignored: Cycle already running.", "warn"); return; }
    if (_abortRequested) {
      logger.logEvent("info", "Cycle execution skipped due to pending abort request.");
      _abortRequested = false; _isRunning = false; if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); return;
    }
    _isRunning = true; if (UI.setRunButtonState) UI.setRunButtonState("Abort Cycle", false);
    let state, goalInfo, currentCycle; let cycleOutcome = "Unknown"; let llmIterationResult = null; let applyResult = null; let shouldContinueAutonomous = false;

    try {
      const prepResult = _prepareCycle(); state = prepResult.state; goalInfo = prepResult.goalInfo; currentCycle = prepResult.currentCycle;
      let successfulIteration = false;
      do {
        if (_abortRequested) throw new AbortError("Cycle aborted during LLM iteration loop.");
        UI.logToTimeline(currentCycle, `[STATE] Agent Iteration Attempt (Retry: ${state.retryCount})`, "info", true);
        llmIterationResult = await _runLlmIteration(state, goalInfo, currentCycle);
        if (llmIterationResult.error) {
          if (llmIterationResult.error instanceof AbortError) throw llmIterationResult.error;
          await _handleCycleIterationFailure(state, llmIterationResult.error, currentCycle);
          state = StateManager.getState(); // Re-fetch state after potential update in failure handler
        } else {
          successfulIteration = true; StateManager.updateAndSaveState(s => { s.retryCount = 0; return s; });
          _displayLlmIterationSuccessDetails(llmIterationResult, currentCycle);
        }
      } while (!successfulIteration);
      state = StateManager.getState(); // Ensure state is fresh before critique decision

      const critiqueDecision = await _handleCritiqueDecision(state, llmIterationResult, goalInfo, currentCycle);
      if (_abortRequested) throw new AbortError("Cycle aborted after critique decision.");
      if (critiqueDecision.status === "HITL_REQUIRED") {
        cycleOutcome = `Paused (HITL: ${Utils.trunc(critiqueDecision.critiqueReport.split(":")[0], 30)})`;
        if (_isAutonomous) stopAutonomousRun("HITL Required");
        throw new StateError("HITL Required");
      }

      if (critiqueDecision.critiquePassed) {
        UI.updateStatus("Applying Changes...", true); UI.logCoreLoopStep(currentCycle, 6, "Refine & Apply");
        applyResult = await _applyLLMChanges(llmIterationResult.response, currentCycle, critiqueDecision.applySource);
        if (_abortRequested) throw new AbortError("Cycle aborted during apply changes.");
        state = StateManager.getState(); // Re-fetch state

        if (applyResult.requiresSandbox) {
          StateManager.updateAndSaveState(s => { s.lastCritiqueType = `${critiqueDecision.applySource} (Sandbox Pending)`; return s; });
          if (_isAutonomous) stopAutonomousRun("Sandbox Required");
          UI.showMetaSandbox(state.lastGeneratedFullSource); cycleOutcome = "Paused (Sandbox Pending)";
          throw new StateError("Sandbox Pending");
        }
        if (applyResult.success) {
          StateManager.updateAndSaveState(s => { s.lastFeedback = `${critiqueDecision.applySource}, applied successfully for Cycle ${applyResult.nextCycle}.`; return s; });
          cycleOutcome = `OK (${state.lastCritiqueType})`;
          await _runSelfEvaluationStep(state, llmIterationResult, currentCycle);
          if (_abortRequested) throw new AbortError("Cycle aborted during self-evaluation.");
          UI.highlightCoreStep(8); shouldContinueAutonomous = _isAutonomous && !_abortRequested;
        } else _handleApplyFailure(applyResult, critiqueDecision, currentCycle);
      } else {
        logger.logEvent("error", "Reached unexpected state: critique failed but HITL not triggered."); cycleOutcome = "Failed (Critique Logic Error)";
        if (_isAutonomous) stopAutonomousRun("Critique Logic Error");
        throw new ApplicationError("Critique Failed without HITL trigger");
      }
    } catch (error) {
      const knownStopNames = [ "AbortError", "StateError", "ConfigError", "ApiError", "ToolError", "ArtifactError" ];
      const isKnownStopError = error instanceof ApplicationError && knownStopNames.includes(error.name);
      if (error instanceof AbortError) {
        UI.logToTimeline(currentCycle ?? 0, `[CYCLE] Cycle aborted by user/system. Reason: ${error.message}`, "warn");
        cycleOutcome = "Aborted"; UI.updateStatus("Aborted"); if (_isAutonomous) stopAutonomousRun("Aborted by user/system");
      } else if (isKnownStopError && (error.message.includes("HITL Required") || error.message.includes("Sandbox Pending"))) {
        logger.logEvent("info", `Cycle paused: ${error.message}`); if (!cycleOutcome || cycleOutcome === "Unknown") cycleOutcome = `Paused (${error.message})`;
      } else if (isKnownStopError && error.message.includes("Max cycles reached")) {
        logger.logEvent("info", `Cycle stopped: ${error.message}`); cycleOutcome = "Paused (Max Cycles Reached)"; if (_isAutonomous) stopAutonomousRun("Max cycles reached");
      } else {
        logger.logEvent("error", `Unhandled cycle error (Cycle ${currentCycle ?? "N/A"}): ${error.message}`, error.details || error);
        UI.showNotification(`Cycle Error: ${Utils.trunc(error.message, 100)}`, "error");
        UI.logToTimeline(currentCycle ?? 0, `[CYCLE FATAL] ${Utils.trunc(error.message, 100)}`, "error");
        cycleOutcome = "Failed (Fatal Error)"; UI.updateStatus("Cycle Failed", false, true); if (_isAutonomous) stopAutonomousRun("Fatal Error");
      }
      shouldContinueAutonomous = false;
    } finally {
      _isRunning = false; _abortRequested = false;
      if (!_isAutonomous || !shouldContinueAutonomous) { if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); }
      state = StateManager.getState(); 
      if (state) {
        StateManager.updateAndSaveState(s => s); // This recalculates derived stats and saves
        if (!UI.isMetaSandboxPending() && UI.isHumanInterventionHidden()) {
          UI.summarizeCompletedCycleLog(cycleOutcome); UI.updateStateDisplay(); UI.clearCurrentCycleDetails();
          UI.logToTimeline(state.totalCycles, `[STATE] Cycle ended (${state.lastCritiqueType || cycleOutcome}). Ready.`); UI.updateStatus("Idle");
        } else { UI.updateStateDisplay(); }
      } else {
        UI.updateStatus("Error - State Lost?", false, true); logger.logEvent("critical", "Global state became null during cycle finally block.");
      }
      UI.highlightCoreStep(-1);
    }

    if (shouldContinueAutonomous) {
      state = StateManager.getState();
      logger.logEvent("info", `Autonomous mode active. Triggering next cycle. Remaining: ${state?.autonomyCyclesRemaining ?? "N/A"}`);
      await Utils.delay(config.AUTONOMOUS_CYCLE_DELAY_MS || 500);
      if (!_abortRequested) executeCycle();
      else {
        logger.logEvent("info", "Autonomous continuation cancelled due to abort request during delay.");
        if (_isAutonomous) stopAutonomousRun("Aborted during delay");
        else { _isRunning = false; if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); }
      }
    } else if (_isAutonomous && cycleOutcome !== "Aborted") {
      logger.logEvent("info", `Autonomous run ended. Reason: ${cycleOutcome}`);
      stopAutonomousRun(cycleOutcome);
    }
  };

  const proceedAfterHumanIntervention = async (feedbackType, feedbackData = "", skipCycleIncrement = false) => {
    let state = StateManager.getState(); if (!state) { logger.logEvent("error", "Cannot proceed HITL, state missing."); return; }
    const currentCycle = state.totalCycles; let nextCycle = currentCycle; let feedbackMsg = String(feedbackData); let applySuccess = true; let requiresSandbox = false;

    if (feedbackType === "Human Code Edit") {
      const { artifactId, cycle, versionId, success, validatedContent, error, contentChanged } = feedbackData;
      feedbackMsg = `Edited ${artifactId}: ${ success ? (contentChanged ? "Applied successfully." : "No changes detected.") : `Validation Failed: ${error || "Unknown"}` }`;
      let isCodeEditSuccess = success && contentChanged;
      if (isCodeEditSuccess && artifactId !== "full_html_source" && artifactId !== "page_composition_preview") {
        nextCycle = currentCycle + 1;
        try {
          const checksum = await Utils.calculateChecksum(validatedContent);
          Storage.setArtifactContent(artifactId, nextCycle, validatedContent, versionId);
          const currentMeta = StateManager.getArtifactMetadata(artifactId, versionId);
          StateManager.updateArtifactMetadata(artifactId, currentMeta?.type, currentMeta?.description, nextCycle, checksum, "Human Edit", versionId, false, currentMeta?.paradigm);
          UI.displayCycleArtifact(`Human Edit Applied${versionId ? " (V: " + versionId + ")" : ""}`, validatedContent, "info", true, "Human", artifactId, nextCycle);
          logger.logEvent("info", `Human edit applied to ${artifactId} for cycle ${nextCycle}`);
          UI.logToTimeline(currentCycle, `[HUMAN] Applied edit to ${artifactId} for cycle ${nextCycle}`, "human", true);
        } catch (e) {
          logger.logEvent("error", `Failed saving human edit for ${artifactId}: ${e.message}`, e); UI.showNotification(`Failed saving edit: ${e.message}`, "error");
          applySuccess = false; nextCycle = currentCycle;
        }
      } else if ((artifactId === "full_html_source" || artifactId === "page_composition_preview") && isCodeEditSuccess) {
        logger.logEvent("warn", "Full source/Page Composition edited via HITL. Staging for sandbox.");
        StateManager.updateAndSaveState(s => { s.lastGeneratedFullSource = validatedContent; return s; });
        applySuccess = true; requiresSandbox = true; skipCycleIncrement = true; UI.showMetaSandbox(validatedContent);
      } else if (!success) applySuccess = false;
    } else if (feedbackType === "Human Options") { feedbackMsg = `Selected: ${feedbackData || "None"}`; applySuccess = true;
    } else if (feedbackType === "Sandbox Discarded") { feedbackMsg = "User discarded sandbox changes."; applySuccess = true;
    } else if (feedbackType === "Human Prompt") { feedbackMsg = `Provided prompt: ${Utils.trunc(feedbackData, 100)}`; applySuccess = true;
    } else if (feedbackType === "Human Critique Selection") {
      feedbackMsg = `User provided critique feedback. Selected: ${feedbackData?.selectedCritique ?? "N/A"}`;
      StateManager.addCritiqueFeedback(feedbackData); logger.logEvent("info", `Received critique feedback: ${JSON.stringify(feedbackData)}`); applySuccess = true;
    }
    
    state = StateManager.updateAndSaveState(s => {
        s.lastFeedback = `${feedbackType}: ${Utils.trunc(feedbackMsg, 150)}`;
        if (feedbackType.startsWith("Human")) { if (s.humanInterventions !== undefined) s.humanInterventions++; }
        if (applySuccess && !skipCycleIncrement) {
            s.totalCycles = nextCycle === currentCycle ? currentCycle + 1 : nextCycle;
            s.agentIterations++;
        } else if (!applySuccess) {
            s.failCount = (s.failCount || 0) + 1; s.failHistory = s.failHistory || [];
            s.failHistory.push({ cycle: currentCycle, reason: `HITL Apply Fail: ${feedbackType}` });
            if (s.failHistory.length > (config.MAX_HISTORY_ITEMS || 20)) s.failHistory.shift();
            s.totalCycles = currentCycle;
        }
        if (!skipCycleIncrement) {
            s.personaMode = (s.cfg?.personaBalance ?? 50) < 50 ? "XYZ" : "LSD";
            s.retryCount = 0;
        }
        return s;
    });

    const summaryOutcome = !applySuccess ? `Failed (${feedbackType})` : `OK (${feedbackType})`;
    UI.summarizeCompletedCycleLog(summaryOutcome); UI.logToTimeline(currentCycle, `[STATE] ${feedbackType} processed. Feedback: "${Utils.trunc(feedbackMsg, 70)}..."`, "state");
    UI.hideHumanInterventionUI();
    const uiRefs = UI.getRefs(); if (!skipCycleIncrement && uiRefs.goalInput) uiRefs.goalInput.value = "";
    UI.updateStatus(skipCycleIncrement ? "Meta Sandbox Pending..." : "Idle");
    if (!skipCycleIncrement) UI.clearCurrentCycleDetails();
    UI.updateStateDisplay(); UI.highlightCoreStep(-1);
  };

  const saveHtmlToHistory = (htmlContent) => {
    StateManager.updateAndSaveState(s => {
        const limit = s.cfg?.htmlHistoryLimit ?? 5;
        if (!s.htmlHistory) s.htmlHistory = [];
        s.htmlHistory.push(htmlContent);
        while (s.htmlHistory.length > limit) s.htmlHistory.shift();
        logger.logEvent("info", `Saved HTML state. History size: ${s.htmlHistory.length}`);
        UI.updateHtmlHistoryControls(s); // UI must be able to handle state directly
        return s;
    });
  };
  
  const _runSummarizationContext = async (apiKey, state, currentCycle) => {
    const template = Storage.getArtifactContent("reploid.core.summarizer-prompt", 0) || "";
    if (!template) throw new ArtifactError("Summarizer prompt not found.", "reploid.core.summarizer-prompt", 0);

    const stateSummary = {
      totalCycles: state.totalCycles, agentIterations: state.agentIterations, humanInterventions: state.humanInterventions, failCount: state.failCount,
      currentGoal: { seed: Utils.trunc(state.currentGoal?.seed, 200), cumulative: Utils.trunc(state.currentGoal?.cumulative, 500), latestType: state.currentGoal?.latestType, currentContextFocus: state.currentGoal?.currentContextFocus },
      lastCritiqueType: state.lastCritiqueType, lastFeedback: Utils.trunc(state.lastFeedback, 200),
      avgConfidence: state.avgConfidence?.toFixed(2), critiqueFailRate: state.critiqueFailRate?.toFixed(1),
      dynamicTools: (state.dynamicTools || []).map((t) => t.declaration.name),
      evaluationHistory: AgentLogicPureHelpers.summarizeHistoryPure(state.evaluationHistory, "Eval", 3, Utils.trunc),
    };
    const artifactListSummary = AgentLogicPureHelpers.getArtifactListSummaryPure(StateManager.getAllArtifactMetadata());
    const recentLogs = logger.getLogBuffer ? logger.getLogBuffer().split("\n").slice(-20).join("\n") : "N/A";
    
    const { prompt, error } = AgentLogicPureHelpers.assembleSummarizerPromptPure(template, stateSummary, recentLogs, artifactListSummary, Utils.trunc);
    if (error) throw new ApplicationError(error);
    
    const summarizerModelKey = state.cfg?.summarizerModel || "BASE";
    const summarizerModelIdentifier = config.DEFAULT_MODELS[summarizerModelKey.toUpperCase()] || summarizerModelKey;
    let summaryResultText = "";
    try {
      let accumulatedSummaryText = "";
      const apiResult = await ApiClient.callApiWithRetry(prompt, 'You are Summarizer x0. Output ONLY valid JSON: {"summary": "string"}', summarizerModelIdentifier, apiKey, [], false, null, 1, {},
        (msg, act, err) => UI.updateStatus(`Summarize: ${msg}`, act, err),
        (cyc, msg, type, sub, anim) => UI.logToTimeline(cyc, `[SUM] ${msg}`, type, sub, anim),
        UI.updateTimelineItem,
        (progress) => {
          if (progress.type === "text") accumulatedSummaryText += progress.content;
          summaryResultText = progress.accumulatedResult?.content || accumulatedSummaryText;
        }
      );
      if (!summaryResultText && apiResult?.content) summaryResultText = apiResult.content;
      const sanitized = ApiClient.sanitizeLlmJsonResp(summaryResultText); const parsed = JSON.parse(sanitized);
      if (typeof parsed.summary === "string") return parsed.summary;
      else throw new ApplicationError("Summarizer response missing 'summary' field.");
    } catch (e) {
      logger.logEvent("error", `Summarization LLM call failed: ${e.message}`, e); return null;
    }
  };

  const handleSummarizeContext = async () => {
    let state = StateManager.getState();
    if (!state || !state.apiKey) { UI.showNotification("API Key required for summarization.", "warn"); return; }
    if (_isRunning) { UI.showNotification("Cannot summarize context while cycle is running.", "warn"); return; }
    UI.updateStatus("Summarizing context...", true); UI.showNotification("Starting context summarization...", "info", 3000);
    const currentCycle = state.totalCycles; const nextCycle = currentCycle + 1;
    UI.logToTimeline(currentCycle, "[CONTEXT] Running summarization...", "context", true); UI.clearCurrentCycleDetails();
    try {
      const summaryText = await _runSummarizationContext(state.apiKey, state, currentCycle);
      if (summaryText === null) throw new ApplicationError("Summarization LLM call or parsing failed.");
      const checksum = await Utils.calculateChecksum(summaryText);
      Storage.setArtifactContent("meta.summary_context", nextCycle, summaryText);
      StateManager.updateArtifactMetadata("meta.summary_context", "TEXT", "Last Context Summary", nextCycle, checksum, "Summarizer", null, false, "data");
      StateManager.updateAndSaveState(s => {
          s.currentGoal = {
            seed: s.currentGoal?.seed,
            cumulative: `Context summarized up to Cycle ${currentCycle}. Original Seed: ${s.currentGoal?.seed || "None"}. New Summary:\n${summaryText}`,
            latestType: "Idle", summaryContext: summaryText, currentContextFocus: null,
          };
          s.contextTokenEstimate = Math.round((summaryText.length / 4) * 1.1) + 500;
          s.lastFeedback = `Context summarized at Cycle ${currentCycle}.`; s.lastCritiqueType = "Context Summary";
          s.totalCycles = nextCycle;
          return s;
      });
      UI.logToTimeline(currentCycle, `[CONTEXT] Summarized. Saved as meta.summary_context_${nextCycle}. Est. tokens: ${StateManager.getState().contextTokenEstimate.toLocaleString()}.`, "context");
      UI.displayCycleArtifact("Generated Context Summary", summaryText, "output", true, "System", "meta.summary_context", nextCycle);
      UI.showNotification("Context summarization complete.", "info", 5000);
    } catch (error) {
      logger.logEvent("error", `Summarization failed: ${error.message}`, error); UI.showNotification(`Summarization failed: ${error.message}`, "error");
      UI.logToTimeline(currentCycle, `[CONTEXT ERR] Summarization failed: ${error.message}`, "error");
    } finally {
      UI.updateStateDisplay(); UI.updateStatus("Idle");
    }
  };

  const abortCurrentCycle = () => {
    if (_isRunning) {
      logger.logEvent("info", "Abort request received."); _abortRequested = true; ApiClient.abortCurrentCall("User Abort Request");
      if (_isAutonomous) stopAutonomousRun("Aborted"); else UI.updateStatus("Aborting...");
    } else logger.logEvent("info", "Abort request ignored: No cycle running.");
  };

  const startAutonomousRun = (mode = "Continuous", cycles = 0) => {
    if (_isRunning) { UI.showNotification("Cannot start autonomous run: Cycle already in progress.", "warn"); return; }
    let state = StateManager.getState(); if (!state) { UI.showNotification("Cannot start autonomous run: State not loaded.", "error"); return; }
    if (mode === "N_Cycles" && (!cycles || cycles <= 0)) { UI.showNotification("Cannot start N_Cycles run: Invalid number of cycles specified.", "warn"); return; }
    logger.logEvent("info", `Starting autonomous run. Mode: ${mode}, Cycles: ${cycles}`);
    StateManager.updateAndSaveState(s => {
        s.autonomyMode = mode; s.autonomyCyclesRemaining = mode === "N_Cycles" ? cycles : Infinity; return s;
    });
    _isAutonomous = true; _abortRequested = false;
    UI.updateAutonomyControls(mode, true); UI.updateStatus(`Autonomous Run (${mode}) Started...`);
    executeCycle();
  };

  const stopAutonomousRun = (reason = "User Stop Request") => {
    logger.logEvent("info", `Stopping autonomous run. Reason: ${reason}`); _abortRequested = true; _isAutonomous = false;
    StateManager.updateAndSaveState(s => { s.autonomyMode = "Manual"; s.autonomyCyclesRemaining = 0; return s; });
    UI.updateAutonomyControls("Manual", false); UI.updateStatus(`Autonomous Run Stopped (${reason})`);
    if (_isRunning) { if (UI.setRunButtonState) UI.setRunButtonState("Run Cycle", false); _isRunning = false; }
  };

  const runTool = async (toolName, args) => {
    const state = StateManager.getState(); if (!state) throw new StateError("Cannot run tool, state not available.");
    const dummyUiHooks = { updateStatus: () => {}, logTimeline: () => ({}), updateTimelineItem: () => {} };
    return await ToolRunner.runTool(toolName, args, loadedStaticTools, state.dynamicTools || [], dummyUiHooks);
  };

  return {
    init, executeCycle, isRunning, isAutonomous, getActiveGoalInfo,
    proceedAfterHumanIntervention, handleSummarizeContext, abortCurrentCycle,
    saveHtmlToHistory, runTool, startAutonomousRun, stopAutonomousRun,
  };
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: app-logic.js ---
const CoreLogicModule = (initialConfig, initialUtils, initialStorage, initialErrors, initialAgentLogicPureHelpers, initialStateHelpersPure) => {
  const loadModule = async (filePath, exportName, dependencies = {}) => {
    const logger = initialUtils?.logger || { logEvent: (lvl, msg, det) => console.error(`[ORCHESTRATOR_FALLBACK] ${msg}`, det || "") };
    const allDependencies = { ...dependencies, Errors: initialErrors, Utils: initialUtils };
    const depNames = Object.keys(allDependencies);
    const depValues = Object.values(allDependencies);

    if (depNames.length !== depValues.length || depValues.some((dep) => dep === undefined || dep === null)) {
      const missing = depNames.filter((name, i) => depValues[i] === undefined || depValues[i] === null);
      logger.logEvent("error", `Cannot load module ${filePath}: Missing dependencies ${missing.join(", ")}`, allDependencies);
      throw new initialErrors.ConfigError(`Dependency error for ${filePath}: Missing ${missing.join(", ")}`, filePath);
    }

    try {
      const response = await fetch(filePath + `?v=${initialConfig?.STATE_VERSION || Date.now()}`);
      if (!response.ok) throw new initialErrors.ApiError(`HTTP ${response.status} for ${filePath}`, response.status);
      const scriptContent = await response.text();
      const tempScope = {};
      const funcArgsString = ["tempScope", ...depNames].join(", ");
      const funcBody = `${scriptContent}\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;

      const factoryFunction = new Function(funcArgsString, funcBody);
      factoryFunction(tempScope, ...depValues);

      if (tempScope.result === undefined) {
        logger.logEvent("warn", `Module ${filePath} executed, but export '${exportName}' was not found.`);
        throw new initialErrors.ConfigError(`Module ${filePath} did not yield expected export '${exportName}'.`, filePath);
      }
      logger.logEvent("debug", `Module ${filePath} loaded successfully.`);

      if (exportName.endsWith("Module") && typeof tempScope.result === "function") {
        return tempScope.result(...depValues);
      } else {
        return tempScope.result;
      }
    } catch (error) {
      logger.logEvent("error", `Fatal Error loading/executing module ${filePath}`, error.message + (error.stack ? `\nStack: ${error.stack}` : ""));
      throw error;
    }
  };

  const registerCoreWebComponents = async (StateManagerInstance, StorageInstance, LoggerInstance) => {
    if (!StateManagerInstance || !StorageInstance || !LoggerInstance || typeof customElements === "undefined") {
      LoggerInstance.logEvent("warn", "Cannot register core web components: missing dependencies or customElements API.");
      return;
    }
    LoggerInstance.logEvent("info", "AppLogic: Attempting to register core Web Components...");
    const artifactMetadata = StateManagerInstance.getAllArtifactMetadata();
    let registeredCount = 0;

    for (const id in artifactMetadata) {
      if (id.startsWith("reploid.core.webcomponent.")) {
        const meta = artifactMetadata[id];
        if (meta && meta.type === "WEB_COMPONENT_DEF" && meta.latestCycle >= 0) {
          const jsContent = StorageInstance.getArtifactContent(id, meta.latestCycle, meta.version_id);
          if (jsContent) {
            const componentName = id.substring("reploid.core.webcomponent.".length).replace(/\./g, "-");
            if (!customElements.get(componentName)) {
              try {
                const ComponentClass = new Function("return (" + jsContent + ")")();
                if (typeof ComponentClass === "function" && HTMLElement.isPrototypeOf(ComponentClass)) {
                  customElements.define(componentName, ComponentClass);
                  StateManagerInstance.registerWebComponent(componentName);
                  LoggerInstance.logEvent("info", `AppLogic: Registered core WC <${componentName}> from ${id}`);
                  registeredCount++;
                } else {
                  LoggerInstance.logEvent("warn", `AppLogic: Invalid class structure for core WC ${componentName} in ${id}`);
                }
              } catch (e) {
                LoggerInstance.logEvent("error", `AppLogic: Error defining core WC ${componentName} from ${id}: ${e.message}`);
              }
            } else {
              if (!StateManagerInstance.isWebComponentRegistered(componentName)) {
                StateManagerInstance.registerWebComponent(componentName);
              }
              LoggerInstance.logEvent("debug", `AppLogic: Core WC <${componentName}> from ${id} was already defined globally.`);
            }
          } else {
            LoggerInstance.logEvent("warn", `AppLogic: Content missing for core WC definition: ${id} (Cycle ${meta.latestCycle})`);
          }
        }
      }
    }
    if (registeredCount > 0) LoggerInstance.logEvent("info", `AppLogic: ${registeredCount} core Web Components newly registered.`);
    else LoggerInstance.logEvent("info", `AppLogic: No new core Web Components to register at this stage.`);
  };

  const initializeApplication = async () => {
    let config = initialConfig; let Utils = initialUtils; let Storage = initialStorage; let Errors = initialErrors;
    let AgentLogicPureHelpers = initialAgentLogicPureHelpers; let StateHelpersPure = initialStateHelpersPure;
    let logger = null; let StateManager, ToolRunner, ApiClient, UI, CycleLogic;

    const fatalErrorHandler = (message, error = null) => {
      console.error("Orchestrator: Initialization failed.", message, error);
      const log = logger || { logEvent: (lvl, msg, det) => console.error(`[ORCHESTRATOR_FALLBACK] ${msg}`, det || "") };
      log.logEvent("error", `Orchestrator: Initialization failed. ${message}`, error);
      document.body.innerHTML = `<div style="color:red; padding: 20px; font-family: monospace;"><h1>FATAL ERROR</h1><p>App init failed: ${message}</p>${error ? `<p>${error.message || error}</p>` : ""}<p>Check console.</p></div>`;
    };

    try {
      if (!config || !Utils || !Storage || !Errors || !AgentLogicPureHelpers || !StateHelpersPure) {
        throw new Error("Core modules (Config, Utils, Storage, Errors, PureHelpers) not passed from bootstrap.");
      }
      logger = Utils.logger;
      logger.logEvent("info", "Orchestrator: Initializing application...");

      const stage1Deps = { config, logger, Storage, Errors, StateHelpersPure, Utils };
      StateManager = await loadModule("state-manager.js", "StateManagerModule", stage1Deps);
      ApiClient = await loadModule("api-client.js", "ApiClientModule", { config, logger, Errors, Utils });
      logger.logEvent("debug", "Orchestrator: Stage 1 modules loaded.");

      StateManager.init();
      await registerCoreWebComponents(StateManager, Storage, logger);
      logger.logEvent("debug", "Orchestrator: StateManager initialized and core WCs registered.");
      
      const toolRunnerPureHelpers = await loadModule("tool-runner-pure-helpers.js", "ToolRunnerPureHelpersModule", { logger });


      const stage2DepsTool = { config, logger, Storage, StateManager, ApiClient, Errors, Utils, ToolRunnerPureHelpers: toolRunnerPureHelpers };
      const stage2DepsUI = { config, logger, Utils, Storage, StateManager, Errors };
      ToolRunner = await loadModule("tool-runner.js", "ToolRunnerModule", stage2DepsTool);
      UI = await loadModule("ui-manager.js", "UIModule", stage2DepsUI);
      logger.logEvent("debug", "Orchestrator: Stage 2 modules loaded.");

      const stage3Deps = { config, logger, Utils, Storage, StateManager, UI, ApiClient, ToolRunner, Errors, AgentLogicPureHelpers };
      CycleLogic = await loadModule("agent-cycle.js", "CycleLogicModule", stage3Deps);
      logger.logEvent("debug", "Orchestrator: Stage 3 modules loaded.");

      CycleLogic.init();
      logger.logEvent("debug", "Orchestrator: CycleLogic initialized.");

      setTimeout(() => {
        try {
          UI.init(StateManager, CycleLogic);
          logger.logEvent("info", "Orchestrator: Application initialization complete.");
        } catch (uiError) {
          fatalErrorHandler("UI Initialization failed inside setTimeout.", uiError);
        }
      }, 0);
    } catch (error) {
      fatalErrorHandler(error.message || "Unknown initialization error", error);
    }
  };
  initializeApplication();
};
üêï --- DOGS_END_FILE ---
üêï --- DOGS_START_FILE: boot.js ---
(async () => {
  const startContainer = document.getElementById("start-container");
  const loadingContainer = document.getElementById("loading-container");
  const loadingIndicator = document.getElementById("loading-indicator");
  const appRoot = document.getElementById("app-root");
  const continueButton = document.getElementById("continue-button");
  const resetButton = document.getElementById("reset-button");

  let bootstrapLogMessages = `REPLOID Bootstrap Log - ${new Date().toISOString()}\n=========================================\n`;
  let audioCtx = null; let isAudioInitAttempted = false; let interactionStarted = false;
  let uiUpdatePromise = Promise.resolve(); let skipBootstrapAnimation = false;

  let config = null; let Utils = null; let Storage = null; let ErrorsGlobal = null; let blLogger = null;
  let AgentLogicPureHelpers = null; let StateHelpersPure = null;

  const bl = (() => {
    const MIN_TONE_INTERVAL_MS = 32; const TONE_DURATION_MS = 50; let lastToneTime = 0;
    const initAudioContextInternal = () => {
      if (!isAudioInitAttempted && !audioCtx) {
        isAudioInitAttempted = true;
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch (e) { (blLogger ? blLogger.logEvent : console.warn)("warn", "AudioContext init failed:", e.message); audioCtx = null; }
      } return audioCtx;
    };
    const playTone = (frequency, fixedDurationMs, oscType) => {
      if (skipBootstrapAnimation) return; const currentAudioCtx = initAudioContextInternal();
      if (!currentAudioCtx || typeof currentAudioCtx.createOscillator !== "function") return;
      try {
        const oscillator = currentAudioCtx.createOscillator(); const gainNode = currentAudioCtx.createGain();
        const duration = Math.max(fixedDurationMs / 1000, 0.01);
        oscillator.type = oscType; oscillator.frequency.setValueAtTime(frequency, currentAudioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.3, currentAudioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, currentAudioCtx.currentTime + duration);
        oscillator.connect(gainNode).connect(currentAudioCtx.destination);
        oscillator.start(); oscillator.stop(currentAudioCtx.currentTime + duration);
      } catch (e) { (blLogger ? blLogger.logEvent : console.warn)("warn", "Tone playback error:", e.message); audioCtx = null; }
    };
    return async function blInternal(message, level = "info", detail = null, charDelay = 1) {
      const timestamp = new Date().toISOString(); const logLine = `[${timestamp}] [${level.toUpperCase()}] ${message}${detail ? ` | ${detail}` : ""}`;
      bootstrapLogMessages += logLine + "\n";
      let skipConsoleOutput = false; let skipUiOutput = false; let effectiveLevel = level;
      if (level === "only-gui") { skipConsoleOutput = true; effectiveLevel = "info"; }
      else if (level === "only-console" || level === "detail") { skipUiOutput = true; effectiveLevel = "info"; }
      if (!skipConsoleOutput) {
        const logFunc = blLogger ? blLogger.logEvent : console[effectiveLevel === "error" ? "error" : effectiveLevel === "warn" ? "warn" : "log"];
        if (blLogger) { logFunc(effectiveLevel, message, detail || ""); }
        else { console[effectiveLevel === "error" ? "error" : effectiveLevel === "warn" ? "warn" : "log"](logLine); }
      }
      if (skipUiOutput || !loadingIndicator) return;
      uiUpdatePromise = uiUpdatePromise.then(async () => {
          const logEntryContainer = document.createElement("div"); logEntryContainer.className = `log-entry log-${effectiveLevel}`;
          loadingIndicator.appendChild(logEntryContainer); const fullText = `> ${message}${detail ? ` | ${detail}` : ""}`;
          if (skipBootstrapAnimation) logEntryContainer.textContent = fullText;
          else {
            if (effectiveLevel === "error") playTone(220, TONE_DURATION_MS, "square"); lastToneTime = performance.now();
            for (const char of fullText) {
              logEntryContainer.textContent += char; if (loadingIndicator.scrollTop !== undefined) loadingIndicator.scrollTop = loadingIndicator.scrollHeight;
              const currentTime = performance.now();
              if (char.trim() && effectiveLevel !== "error" && currentTime - lastToneTime >= MIN_TONE_INTERVAL_MS) { playTone(990, TONE_DURATION_MS, "triangle"); lastToneTime = currentTime; }
              if (charDelay > 0) await new Promise((resolve) => setTimeout(resolve, Math.max(charDelay, 1)));
              if (skipBootstrapAnimation) { logEntryContainer.textContent = fullText; break; }
            }
          } if (loadingIndicator.scrollTop !== undefined) loadingIndicator.scrollTop = loadingIndicator.scrollHeight;
        }).catch((error) => { (blLogger ? blLogger.logEvent : console.error)("error", "Error during bootstrap logging UI update:", error); uiUpdatePromise = Promise.resolve(); });
      await uiUpdatePromise;
    };
  })();

  const initAudioContext = () => {
    if (!isAudioInitAttempted && !audioCtx) {
      isAudioInitAttempted = true;
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch (e) { (blLogger ? blLogger.logEvent : console.warn)("warn", "AudioContext init failed on demand:", e.message); audioCtx = null; }
    } return audioCtx;
  };

  async function calculateChecksumViaUtils(content) {
    if (Utils && typeof Utils.calculateChecksum === 'function') return await Utils.calculateChecksum(content);
    console.warn("calculateChecksumViaUtils called before Utils.calculateChecksum was available."); return null;
  }

  async function fetchAndExecuteModule(filePath, exportName, dependencies = {}) {
    const loggerInstance = blLogger || { logEvent: (lvl, msg, det) => console.error(`[BOOT_FETCH_FALLBACK] ${msg}`, det || "") };
    const { Errors: CustomErrorsFromDeps } = dependencies;
    const depNames = Object.keys(dependencies); const depValues = Object.values(dependencies);
    if (depNames.length !== depValues.length || depValues.some((dep) => dep === undefined || dep === null)) {
      const missing = depNames.filter((name, i) => depValues[i] === undefined || depValues[i] === null);
      const errorMsg = `Cannot load module ${filePath}: Missing dependencies ${missing.join(", ")}`;
      loggerInstance.logEvent("error", errorMsg, dependencies);
      throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
    }
    try {
      const response = await fetch(filePath + `?v=${config?.STATE_VERSION || Date.now()}`);
      if (!response.ok) throw (CustomErrorsFromDeps?.ApiError ? new CustomErrorsFromDeps.ApiError(`HTTP ${response.status} for ${filePath}`, response.status) : new Error(`HTTP ${response.status} for ${filePath}`));
      const scriptContent = await response.text(); const tempScope = {};
      const funcArgs = ["tempScope", ...depNames]; const funcBody = `${scriptContent}\ntempScope.result = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`;
      const factoryFunction = new Function(...funcArgs, funcBody);
      factoryFunction(tempScope, ...depValues);
      if (tempScope.result === undefined) {
        const errorMsg = `Module ${filePath} did not yield expected export '${exportName}'.`;
        loggerInstance.logEvent("warn", errorMsg);
        throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
      }
      if (exportName.endsWith("Module") && typeof tempScope.result === "function") {
        const moduleFactory = tempScope.result; const moduleInstance = moduleFactory(...depValues);
        if (!moduleInstance) {
          const errorMsg = `Module factory ${exportName} from ${filePath} returned null/undefined.`;
          loggerInstance.logEvent("error", errorMsg);
          throw (CustomErrorsFromDeps?.ConfigError ? new CustomErrorsFromDeps.ConfigError(errorMsg, filePath) : new Error(errorMsg));
        }
        loggerInstance.logEvent("debug", `Module factory ${exportName} from ${filePath} executed successfully.`);
        return moduleInstance;
      } else {
        loggerInstance.logEvent("debug", `Returning direct export ${exportName} from ${filePath}.`);
        return tempScope.result;
      }
    } catch (error) {
      loggerInstance.logEvent("error", `Fatal Error loading/executing module ${filePath}`, error.message + (error.stack ? `\nStack: ${error.stack}` : ""));
      throw error;
    }
  }

  async function loadCoreDependencies() {
    try {
      await bl("Loading core configuration...", "info", null, 0);
      const configResponse = await fetch("config.json" + `?v=${Date.now()}`);
      if (!configResponse.ok) throw new Error(`HTTP ${configResponse.status} loading config.json`);
      config = await configResponse.json(); if (!config) throw new Error("Failed to parse config.json");
      await bl("Config loaded.", "only-console", `Version: ${config.STATE_VERSION}`);

      await bl("Loading core utilities (incl. Errors)...", "info", null, 0);
      Utils = await fetchAndExecuteModule("utils.js", "UtilsModule", {});
      if (!Utils || !Utils.logger || !Utils.Errors) throw new Error("Failed to load UtilsModule or its components (logger, Errors) correctly.");
      blLogger = Utils.logger; ErrorsGlobal = Utils.Errors;
      await bl("Utils (incl. Errors) loaded.", "only-console");

      await bl("Loading core storage...", "info", null, 0);
      Storage = await fetchAndExecuteModule("storage.js", "StorageModule", { config, logger: blLogger, Errors: ErrorsGlobal });
      if (!Storage || typeof Storage.getState !== "function") throw new Error("Failed to load StorageModule correctly.");
      await bl("Storage loaded.", "only-console");

      await bl("Loading pure helper modules...", "info", null, 0);
      AgentLogicPureHelpers = await fetchAndExecuteModule("agent-logic-pure.js", "AgentLogicPureHelpersModule", { Utils, logger: blLogger });
      StateHelpersPure = await fetchAndExecuteModule("state-helpers-pure.js", "StateHelpersPureModule", { Utils, logger: blLogger });
      if(!AgentLogicPureHelpers || !StateHelpersPure) throw new Error("Failed to load pure helper modules.");
      await bl("Pure helper modules loaded.", "only-console");

      await bl("Core dependencies loaded.", "success", null, 0); return true;
    } catch (error) {
      const errorMsg = error.message || "Unknown error loading core dependencies.";
      await bl("FATAL: Failed to load core dependencies.", "error", errorMsg);
      console.error("Dependency Load Error:", error, error.stack);
      if (loadingIndicator) loadingIndicator.innerHTML = `<div class="log-entry log-error">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Cannot continue. Check console.</div>`;
      if (loadingContainer) loadingContainer.classList.remove("hidden");
      if (startContainer) startContainer.classList.add("hidden");
      removeInteractionListeners(); return false;
    }
  }

  function isValidState(parsedState) {
    if (!config || !parsedState || !Utils || !StateHelpersPure) return false;
    const validationError = StateHelpersPure.validateStateStructurePure(parsedState, config.STATE_VERSION, Utils.getDefaultState);
    if (validationError) {
      bl(`State validation failed: ${validationError}`, "warn", `Found version: ${parsedState.version}`);
      return false;
    }
    return true;
  }

  async function verifyArtifactChecksum(id, cycle, expectedChecksum, versionId = null) {
    if (!expectedChecksum) return true;
    const content = Storage.getArtifactContent(id, cycle, versionId);
    if (content === null && expectedChecksum) { await bl(`Content missing for checksum verification: ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "warn"); return false; }
    if (content === null && !expectedChecksum) return true;
    let actualChecksum = await calculateChecksumViaUtils(content);
    if (!actualChecksum) { await bl(`Checksum calculation failed for ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "error"); return false; }
    if (actualChecksum !== expectedChecksum) { await bl(`Checksum mismatch for ${id}_${cycle}${versionId ? "#" + versionId : ""}`, "warn", `Expected: ${expectedChecksum}, Actual: ${actualChecksum}`); return false; }
    return true;
  }

  async function checkEssentialArtifactsPresent(stateCycle, artifactMetadata) {
    if (!Storage || !config || !artifactMetadata || !Utils) return false;
    await bl(`Verifying essential artifacts for state cycle ${stateCycle}...`, "info", null, 0);
    let allFoundAndValid = true; const essentialDefs = config.GENESIS_ARTIFACT_DEFS || {}; const verificationPromises = [];
    for (const id in essentialDefs) {
      if (id === "reploid.core.config") continue;
      const metaHistory = artifactMetadata[id]; let latestMeta = null;
      if (metaHistory && metaHistory.length > 0) latestMeta = Utils.getLatestMeta(metaHistory);
      const cycleToCheck = latestMeta ? latestMeta.latestCycle : 0;
      const versionIdToCheck = latestMeta ? latestMeta.version_id : null;
      const expectedChecksum = latestMeta ? latestMeta.checksum : null;
      const content = Storage.getArtifactContent(id, cycleToCheck, versionIdToCheck);
      if (content === null) {
        if(latestMeta && latestMeta.latestCycle !== -1) { await bl(`Essential artifact MISSING: ${id}`, "error", `Expected Cycle: ${cycleToCheck}, V: ${versionIdToCheck || "def"}`); allFoundAndValid = false; }
        else if (!latestMeta) { await bl(`Essential artifact DEFINITION MISSING from state metadata: ${id}`, "error"); allFoundAndValid = false; }
      } else {
        verificationPromises.push( verifyArtifactChecksum(id, cycleToCheck, expectedChecksum, versionIdToCheck).then((isValid) => {
            if (!isValid) allFoundAndValid = false; else bl(`Verified: ${id}`, "only-console", `Cyc: ${cycleToCheck}, V: ${versionIdToCheck || "def"}, Len: ${content.length}${expectedChecksum ? ", CS OK" : ""}`);
          }) );
      }
    }
    await Promise.all(verificationPromises);
    if (!allFoundAndValid) await bl("One or more essential artifacts missing or invalid.", "error");
    else await bl("All essential artifacts verified.", "success", null, 0);
    return allFoundAndValid;
  }

  async function clearAllReploidData() {
    if (!Storage || typeof Storage.clearAllReploidData !== "function") { await bl("Cannot clear data, Storage module not loaded.", "error"); return; }
    await bl("Clearing all REPLOID data from LocalStorage...", "warn", null, 16);
    try { Storage.clearAllReploidData(); await bl("LocalStorage cleared.", "info", null, 8); }
    catch (e) { await bl("Error clearing LocalStorage.", "error", e.message); }
  }

  async function bootstrapReploid(performGenesis = false) {
    if (!config || !Utils || !Storage || !ErrorsGlobal || !AgentLogicPureHelpers || !StateHelpersPure) { await bl("Core dependencies check failed, cannot bootstrap.", "error"); return; }
    if (!blLogger) blLogger = Utils.logger;
    let state = null; let needsGenesis = performGenesis; let stateSource = performGenesis ? "Forced Genesis" : "None";
    if (!performGenesis) {
      await bl("Checking for existing state...", "info", null, 0);
      const stateJSON = Storage.getState();
      if (stateJSON) {
        state = stateJSON;
        if (isValidState(state)) {
          if (await checkEssentialArtifactsPresent(state.totalCycles, state.artifactMetadata)) {
            stateSource = `localStorage (Cycle ${state.totalCycles}, v${state.version})`;
            await bl(`Found valid state and artifacts.`, "success", `Source: ${stateSource}`, 0); needsGenesis = false;
          } else {
            await bl(`State valid (Cycle ${state.totalCycles}) but artifacts missing/invalid. Discarding.`, "error");
            state = null; Storage.removeState(); needsGenesis = true; stateSource = "Discarded Invalid State";
          }
        } else {
          await bl(`Found invalid/incompatible state (v${state?.version || "?"}). Discarding.`, "warn");
          state = null; Storage.removeState(); needsGenesis = true; stateSource = "Discarded Invalid State";
        }
      } else { await bl("No existing state found. Initiating genesis.", "info"); needsGenesis = true; stateSource = "Genesis"; }
    } else { await bl("Reset requested...", "only-gui", null, 6); needsGenesis = true; stateSource = "Forced Genesis"; }
    try {
      if (needsGenesis) {
        await bl("Running genesis boot process...", "info"); state = await runGenesisProcess();
        if (!state) throw new Error("Genesis boot process failed."); await bl("Genesis complete.", "success");
      }
      await bl(`Loading application with state from: ${stateSource}`, "info"); await uiUpdatePromise;
      await loadAndExecuteApp(state);
    } catch (error) {
      await bl("Fatal bootstrap error", "error", error.message); console.error("Bootstrap stack trace:", error);
      if (loadingIndicator) loadingIndicator.innerHTML += `<div class="log-error">FATAL BOOTSTRAP ERROR: ${error.message}. Check console.</div>`;
    }
  }

  async function fetchGenesisArtifacts() {
    if (!config || !config.GENESIS_ARTIFACT_DEFS) { await bl("Cannot fetch genesis artifacts: Config definitions missing.", "error"); return null; }
    await bl("Fetching genesis artifacts...", "info", null, 0);
    const fetchedArtifacts = {}; let success = true;
    const fetchPromises = Object.entries(config.GENESIS_ARTIFACT_DEFS).map(async ([id, def]) => {
      if (!def.filename) return;
      try {
        const response = await fetch(def.filename + `?t=${Date.now()}`);
        if (!response.ok) throw new Error(`HTTP ${response.status} for ${def.filename}`);
        let content;
        if (def.type === "JSON" || def.type === "JSON_CONFIG") content = JSON.stringify(await response.json(), null, 2);
        else content = await response.text();
        fetchedArtifacts[id] = content; await bl(`Fetched: ${def.filename}`, "only-console", `${content.length} bytes`);
      } catch (error) { await bl(`Failed to fetch ${def.filename}`, "error", error.message); success = false; }
    });
    await Promise.all(fetchPromises);
    if (!success) { await bl("Genesis artifact fetch failed.", "error"); return null; }
    await bl(`Fetched ${Object.keys(fetchedArtifacts).length} genesis artifacts.`, "only-console");
    return fetchedArtifacts;
  }

  async function saveGenesisArtifacts(artifacts) {
    if (!Storage || !config || !artifacts || !Utils) return null;
    await bl("Saving genesis artifacts (Cycle 0)...", "info", null, 0);
    const metadata = {}; let success = true; const genesisDefs = config.GENESIS_ARTIFACT_DEFS || {}; const now = Date.now();
    for (const id in artifacts) {
      try {
        const checksum = await Utils.calculateChecksum(artifacts[id]);
        if (!checksum) { await bl(`Checksum failed for genesis artifact: ${id}`, "error"); success = false; continue; }
        Storage.setArtifactContent(id, 0, artifacts[id]);
        metadata[id] = [{ id, version_id: null, latestCycle: 0, type: genesisDefs[id]?.type || "UNKNOWN", description: genesisDefs[id]?.description || `Genesis Artifact ${id}`, source: "Genesis", checksum, timestamp: now, paradigm: genesisDefs[id]?.paradigm || "unknown" }];
        await bl(`Saved: ${id}`, "only-console", `Cyc 0, CS: ${checksum.substring(0, 15)}...`);
      } catch (e) { await bl(`Failed save artifact: ${id} (Cycle 0)`, "error", e.message); success = false; }
    }
    const bootScriptElement = document.querySelector('script[src="boot.js"]');
    const bootScriptContent = bootScriptElement ? await fetch(bootScriptElement.src + `?t=${Date.now()}`).then(res => res.ok ? res.text() : "(Fetch boot.js failed)") : "(boot.js script element Not Found)";
    const bootStyleContent = document.getElementById("boot-style")?.textContent || "";
    await uiUpdatePromise; const finalBootstrapLog = bootstrapLogMessages;
    const bootArtifactsToSave = {
      "reploid.boot.style": { content: bootStyleContent, type: "CSS", description: "Bootstrap CSS from index.html", paradigm: "data" },
      "reploid.boot.script": { content: bootScriptContent, type: "JS", description: "Bootstrap script (boot.js) content", paradigm: "boundary_orchestration" },
      "reploid.boot.log": { content: finalBootstrapLog, type: "LOG", description: "Bootstrap execution log", paradigm: "data" },
    };
    for (const id in bootArtifactsToSave) {
      const { content, type, description, paradigm } = bootArtifactsToSave[id];
      try {
        const checksum = await Utils.calculateChecksum(content);
        if (!checksum && id !== "reploid.boot.log") { await bl(`Checksum failed for bootstrap artifact: ${id}`, "warn"); continue; }
        Storage.setArtifactContent(id, 0, content);
        metadata[id] = [{ id, version_id: null, latestCycle: 0, type, description, source: "BootstrapCapture", checksum, timestamp: now, paradigm }];
        await bl(`Saved: ${id}`, "only-console", `Cyc 0, CS: ${checksum ? checksum.substring(0, 15) + "..." : "N/A"}`);
      } catch (e) { await bl(`Failed save bootstrap artifact: ${id}`, "warn", e.message); }
    }
    Object.keys(genesisDefs).forEach((id) => {
      if (!metadata[id]) {
        const def = genesisDefs[id];
        if (def) {
          metadata[id] = [{ id, version_id: null, latestCycle: (id === "reploid.core.config" ? 0 : -1), type: def.type, description: def.description, source: "Genesis Definition", checksum: null, timestamp: now, paradigm: def.paradigm || "unknown" }];
          if (id === "reploid.core.config") Storage.setArtifactContent(id, 0, JSON.stringify(config, null, 2));
          bl(`Added metadata for ${id} (cycle ${metadata[id][0].latestCycle})`, "only-console");
        }
      }
    });
    await bl("Genesis artifact save completed.", success ? "only-console" : "warn");
    return success ? metadata : null;
  }

  async function runGenesisProcess() {
    const fetchedArtifacts = await fetchGenesisArtifacts(); if (!fetchedArtifacts) return null;
    const artifactMetadata = await saveGenesisArtifacts(fetchedArtifacts); if (!artifactMetadata) return null;
    const initialState = Utils.getDefaultState(config);
    initialState.artifactMetadata = artifactMetadata; initialState.lastFeedback = "Genesis completed.";
    try { Storage.saveState(initialState); await bl("Initial state saved.", "success", null, 0); return initialState; }
    catch (e) { await bl("Failed to save initial state!", "error", e.message); return null; }
  }

  async function registerCoreWebComponentsOnBoot(currentArtifactMetadata) {
    if (!currentArtifactMetadata || typeof customElements === "undefined" || !Storage || !Utils) { bl("Cannot register core WCs on boot: missing dependencies.", "warn"); return; }
    await bl("Boot: Registering core Web Components from artifacts...", "info", null, 0);
    let registeredCount = 0;
    for (const id in currentArtifactMetadata) {
      if (id.startsWith("reploid.core.webcomponent.")) {
        const metaHistory = currentArtifactMetadata[id]; const latestMeta = Utils.getLatestMeta(metaHistory);
        if (latestMeta && latestMeta.type === "WEB_COMPONENT_DEF" && latestMeta.latestCycle >= 0) {
          const jsContent = Storage.getArtifactContent(id, latestMeta.latestCycle, latestMeta.version_id);
          if (jsContent) {
            const componentName = id.substring("reploid.core.webcomponent.".length).replace(/\./g, "-");
            if (!customElements.get(componentName)) {
              try {
                const ComponentClass = new Function("return (" + jsContent + ")")();
                if (typeof ComponentClass === "function" && HTMLElement.isPrototypeOf(ComponentClass)) {
                  customElements.define(componentName, ComponentClass);
                  await bl(`Boot: Registered core WC <${componentName}> from ${id}`, "only-console"); registeredCount++;
                } else await bl(`Boot: Invalid class structure for core WC ${componentName} in ${id}`, "warn");
              } catch (e) { await bl(`Boot: Error defining core WC ${componentName} from ${id}: ${e.message}`, "error"); }
            } else await bl(`Boot: Core WC <${componentName}> from ${id} was already defined globally.`, "debug");
          } else await bl(`Boot: Content missing for core WC definition: ${id} (Cycle ${latestMeta.latestCycle})`, "warn");
        }
      }
    }
    if (registeredCount > 0) await bl(`Boot: ${registeredCount} core Web Components registered globally.`, "info", null, 0);
    else await bl(`Boot: No new core Web Components to register globally at this stage.`, "info", null, 0);
  }

  async function loadAndExecuteApp(currentState) {
    await bl(`Loading application core (State Cycle ${currentState.totalCycles})...`, "info", null, 0);
    if (!config || !Utils || !Storage || !ErrorsGlobal || !AgentLogicPureHelpers || !StateHelpersPure) { await bl("Core dependencies not available for app execution.", "error"); return; }
    const coreStyleId = "reploid.core.style"; const coreLogicId = "reploid.core.logic"; const coreBodyId = "reploid.core.body";
    try {
      const latestStyleMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreStyleId]);
      const styleCycle = latestStyleMeta?.latestCycle >= 0 ? latestStyleMeta.latestCycle : 0;
      const styleContent = Storage.getArtifactContent(coreStyleId, styleCycle, latestStyleMeta?.version_id);
      if (styleContent) {
        const styleElement = document.createElement("style");
        styleElement.id = `${coreStyleId}-loaded-${styleCycle}${latestStyleMeta?.version_id ? "-" + latestStyleMeta.version_id : ""}`;
        styleElement.textContent = styleContent; document.head.appendChild(styleElement);
        await bl(`Applied style: ${coreStyleId} (Cycle ${styleCycle}${latestStyleMeta?.version_id ? ", V:" + latestStyleMeta.version_id : ""})`, "only-console");
      } else await bl(`Core style artifact missing (Cyc ${styleCycle}/0). Using only boot style.`, "warn");

      const latestBodyMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreBodyId]);
      const bodyCycle = latestBodyMeta?.latestCycle >= 0 ? latestBodyMeta.latestCycle : 0;
      const coreBodyContent = Storage.getArtifactContent(coreBodyId, bodyCycle, latestBodyMeta?.version_id);
      if (coreBodyContent && appRoot) {
        await bl(`Injecting body: ${coreBodyId} (Cycle ${bodyCycle}${latestBodyMeta?.version_id ? ", V:" + latestBodyMeta.version_id : ""})`, "only-console");
        appRoot.innerHTML = coreBodyContent;
      } else throw new Error("Failed to load core UI structure (body artifact or app-root element missing).");
      await registerCoreWebComponentsOnBoot(currentState.artifactMetadata);
      const latestLogicMeta = Utils.getLatestMeta(currentState.artifactMetadata[coreLogicId]);
      const logicCycle = latestLogicMeta?.latestCycle >= 0 ? latestLogicMeta.latestCycle : 0;
      const orchestratorScriptContent = Storage.getArtifactContent(coreLogicId, logicCycle, latestLogicMeta?.version_id);
      if (!orchestratorScriptContent) throw new Error(`Core logic artifact (${coreLogicId}) missing (Cyc ${logicCycle}/0).`);
      await bl(`Executing orchestrator: ${coreLogicId} (Cycle ${logicCycle}${latestLogicMeta?.version_id ? ", V:" + latestLogicMeta.version_id : ""})...`, "info", null, 0);
      const orchestratorFunction = new Function("initialConfig", "initialUtils", "initialStorage", "initialErrors", "initialAgentLogicPureHelpers", "initialStateHelpersPure", orchestratorScriptContent + "\nreturn CoreLogicModule(initialConfig, initialUtils, initialStorage, initialErrors, initialAgentLogicPureHelpers, initialStateHelpersPure);");
      const maybePromise = orchestratorFunction(config, Utils, Storage, ErrorsGlobal, AgentLogicPureHelpers, StateHelpersPure);
      if (maybePromise instanceof Promise) await maybePromise;
      await bl("Orchestrator execution initiated.", "success", null, 0);
      setTimeout(() => {
        if (loadingContainer) { loadingContainer.style.transition = "opacity 0.5s ease-out"; loadingContainer.style.opacity = "0"; setTimeout(() => loadingContainer.classList.add("hidden"), 500); }
        if (appRoot) appRoot.classList.add("visible");
      }, 500);
    } catch (error) {
      await bl(`Error loading/executing core components`, "error", error.message); console.error("Core execution failed", error);
      if (loadingIndicator) loadingIndicator.innerHTML += `<div class="log-error">FATAL CORE EXECUTION ERROR: ${error.message}. Check console.</div>`;
    }
  }

  function handleSkip(e) { if (e.key === "Enter" || e.type === "click" || e.type === "touchstart") { if (!skipBootstrapAnimation) { skipBootstrapAnimation = true; bl("[BOOTSTRAP SKIP]", "only-gui", null, 0); if (e.type === "touchstart") e.preventDefault(); } } }
  function handleKeydown(e) { if (!interactionStarted) { if (e.key === "Enter") startInteraction("continue"); else if (e.key === " ") startInteraction("reset"); } }
  function removeInteractionListeners() { document.removeEventListener("keydown", handleKeydown); if (continueButton) continueButton.removeEventListener("click", handleContinueClick); if (resetButton) resetButton.removeEventListener("click", handleResetClick); }
  function addSkipListener() { document.addEventListener("keydown", handleSkip); document.addEventListener("click", handleSkip); document.addEventListener("touchstart", handleSkip, { passive: false }); }
  function removeSkipListener() { document.removeEventListener("keydown", handleSkip); document.removeEventListener("click", handleSkip); document.removeEventListener("touchstart", handleSkip); }
  const handleContinueClick = () => startInteraction("continue"); const handleResetClick = () => startInteraction("reset");

  async function startInteraction(action) {
    if (interactionStarted) return; interactionStarted = true; skipBootstrapAnimation = false;
    if (startContainer) startContainer.classList.add("hidden"); if (loadingContainer) loadingContainer.classList.remove("hidden");
    document.body.style.justifyContent = "flex-start"; initAudioContext(); removeInteractionListeners(); addSkipListener();
    try {
        const dependenciesLoaded = await loadCoreDependencies();
        if (!dependenciesLoaded) { removeSkipListener(); return; }
        if (action === "reset") { await clearAllReploidData(); await bl("Rebooting after reset...", "info", null, 64); await bl("            ", "only-gui", null, 8); await bootstrapReploid(true); }
        else await bootstrapReploid(false);
    } catch (err) {
        const errorMsg = err.message || "Unknown error during startInteraction."; await bl("FATAL: Unhandled error in startInteraction.", "error", errorMsg);
        console.error("Unhandled startInteraction Error:", err); if (loadingIndicator) loadingIndicator.innerHTML = `<div class="log-entry log-error">> FATAL BOOTSTRAP ERROR: ${errorMsg}. Check console.</div>`;
    } finally { removeSkipListener(); }
  }
  if (continueButton) continueButton.addEventListener("click", handleContinueClick);
  if (resetButton) resetButton.addEventListener("click", handleResetClick);
  document.addEventListener("keydown", handleKeydown);
})();
üêï --- DOGS_END_FILE ---