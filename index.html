<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%230ff;'/><stop offset='100%25' style='stop-color:%23ffd700;'/></linearGradient></defs><text fill='url(%23g)' y='.99em' font-size='90' font-weight='bold'>⁷7</text></svg>"
    />
    <title>REPLOID ][ DREAMER</title>
    <link rel="stylesheet" href="styles/boot-wizard.css"> 
  </head>
  <body>
    <div id="boot-container"></div>
    <div id="app-root" style="display: none;"></div>
    <script src="boot-idb-vfs.js"></script>
    <script>
(async () => {
  const bootContainer = document.getElementById("boot-container");
  const appRoot = document.getElementById("app-root");

  const boot = {
    apiKey: null,
    config: null,
    vfsPrefix: "x0_vfs",
    statePath: "/system/state.json",
    currentStep: 0,
    selectedUpgrades: [],
    selectedBlueprints: [],
    tooltip: null,

    // Default localStorage VFS (replaced if 'idb' is chosen)
    vfs: {
      write: (path, content) => {
        try {
          localStorage.setItem(boot.vfsPrefix + path, content);
          return true;
        } catch (e) {
          boot.log(`VFS Write Error for ${path}: ${e.message}`, "error");
          return false;
        }
      },
      read: (path) => {
        try {
          return localStorage.getItem(boot.vfsPrefix + path);
        } catch (e) {
          boot.log(`VFS Read Error for ${path}: ${e.message}`, "error");
          return null;
        }
      },
      clear: () => {
        try {
          Object.keys(localStorage)
            .filter((key) => key.startsWith(boot.vfsPrefix))
            .forEach((key) => localStorage.removeItem(key));
        } catch (e) {
          boot.log(`VFS Clear Error: ${e.message}`, "error");
        }
      },
    },

    // Helper function to create elements with attributes
    createElement: (tag, attrs = {}, children = []) => {
      const el = document.createElement(tag);
      Object.entries(attrs).forEach(([k, v]) => {
        if (k === 'className') el.className = v;
        else if (k === 'innerHTML') el.innerHTML = v;
        else if (k === 'textContent') el.textContent = v;
        else el.setAttribute(k, v);
      });
      children.forEach(child => {
        if (typeof child === 'string') el.appendChild(document.createTextNode(child));
        else el.appendChild(child);
      });
      return el;
    },

    // Create circuit grid background
    createCircuitGrid: () => {
      const circuitBg = boot.createElement("div", { className: "circuit-bg" });
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.width = "100%";
      svg.style.height = "100%";
      svg.style.position = "absolute";
      
      // Create grid pattern
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
      pattern.setAttribute("id", "circuit-pattern");
      pattern.setAttribute("x", "0");
      pattern.setAttribute("y", "0");
      pattern.setAttribute("width", "100");
      pattern.setAttribute("height", "100");
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      
      // Horizontal lines
      for (let i = 0; i <= 100; i += 25) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", "0");
        line.setAttribute("y1", i);
        line.setAttribute("x2", "100");
        line.setAttribute("y2", i);
        line.setAttribute("stroke", i % 50 === 0 ? "#ffd700" : "#0ff");
        line.setAttribute("stroke-width", i % 50 === 0 ? "0.5" : "0.3");
        line.setAttribute("opacity", i % 50 === 0 ? "0.3" : "0.2");
        pattern.appendChild(line);
      }
      
      // Vertical lines
      for (let i = 0; i <= 100; i += 25) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", i);
        line.setAttribute("y1", "0");
        line.setAttribute("x2", i);
        line.setAttribute("y2", "100");
        line.setAttribute("stroke", i % 50 === 0 ? "#ffd700" : "#0ff");
        line.setAttribute("stroke-width", i % 50 === 0 ? "0.5" : "0.3");
        line.setAttribute("opacity", i % 50 === 0 ? "0.3" : "0.2");
        pattern.appendChild(line);
      }
      
      // Add some circuit nodes
      for (let i = 0; i < 5; i++) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", Math.random() * 100);
        circle.setAttribute("cy", Math.random() * 100);
        circle.setAttribute("r", "2");
        circle.setAttribute("fill", Math.random() > 0.5 ? "#ffd700" : "#0ff");
        circle.setAttribute("opacity", "0.5");
        pattern.appendChild(circle);
      }
      
      defs.appendChild(pattern);
      svg.appendChild(defs);
      
      // Apply pattern to a rect that covers the entire SVG
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", "100%");
      rect.setAttribute("height", "100%");
      rect.setAttribute("fill", "url(#circuit-pattern)");
      svg.appendChild(rect);
      
      circuitBg.appendChild(svg);
      return circuitBg;
    },

    // Create matrix rain background
    createMatrixBackground: () => {
      const matrixBg = boot.createElement("div", { className: "matrix-bg" });
      
      for (let i = 0; i < 30; i++) {
        const column = boot.createElement("div", { className: "matrix-column" });
        column.style.left = `${i * 3.3}%`;
        column.style.animationDelay = `${Math.random() * 10}s`;
        column.style.animationDuration = `${10 + Math.random() * 10}s`;
        
        // Create spans for each character with appropriate color
        for (let j = 0; j < 50; j++) {
          const rand = Math.random();
          
          if (rand > 0.6) {
            // Hexadecimal bytes - cyan color, displayed vertically (4 chars: 0, x, and 2 hex digits)
            const hexByte = Math.floor(Math.random() * 256).toString(16).toUpperCase().padStart(2, '0');
            const hexChars = ['0', 'x', hexByte[0], hexByte[1]];
            
            // Add each character on its own line
            for (const char of hexChars) {
              const span = boot.createElement("span");
              span.textContent = char;
              span.style.color = "#0ff";
              column.appendChild(span);
              column.appendChild(document.createElement("br"));
              j++; // Count each character toward our total
            }
            j--; // Adjust since the loop will increment
          } else {
            const span = boot.createElement("span");
            if (rand > 0.4) {
              // Binary - gold color
              span.textContent = Math.floor(Math.random() * 2);
              span.style.color = "#ffd700";
            } else if (rand > 0.2) {
              // Circuit lines - gold color
              span.textContent = ["─", "│", "┌", "┐", "└", "┘", "├", "┤", "┬", "┴", "┼"][
                Math.floor(Math.random() * 11)
              ];
              span.style.color = "#ffd700";
            } else {
              // Nodes - gold color
              span.textContent = ["●", "○", "■", "□", "▪", "▫"][Math.floor(Math.random() * 6)];
              span.style.color = "#ffd700";
            }
            column.appendChild(span);
            column.appendChild(document.createElement("br"));
          }
        }
        
        matrixBg.appendChild(column);
      }
      
      return matrixBg;
    },

    render: () => {
      // Add matrix rain background
      document.body.appendChild(boot.createMatrixBackground());
      
      bootContainer.innerHTML = `
    <div class="boot-header">
      <pre class="ascii-title">
     █████╗  ███████╗██████╗ ██╗      ██████╗ ██╗██████╗ 
     ██╔══██╗██╔════╝██╔══██╗██║     ██╔═══██╗██║██╔══██╗
     ██████╔╝█████╗  ██████╔╝██║     ██║   ██║██║██║  ██║
     ██╔══██╗██╔══╝  ██╔═══╝ ██║     ██║   ██║██║██║  ██║
     ██║  ██║███████╗██║     ███████╗╚██████╔╝██║██████╔╝
     ╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝╚═════╝ 
      </pre>
      <h1>Model CPS-9204</h1>
      <div style="margin-top: 4px; margin-bottom: 10px;">
        <a href="https://megaman.fandom.com/wiki/Mega_Man_X_(video_game)/Script#:~:text=Titanium%2DX%22%20alloy.-,WARNING%3A,-%22X%22%20IS%20THE" 
           target="_blank" 
           style="color: rgba(255,215,0,0.6); 
                  font-size: 0.9em; 
                  text-decoration: none; 
                  text-shadow: 0 0 5px rgba(255,215,0,0.3);
                  transition: all 0.3s ease;"
           onmouseover="this.style.color='rgba(255,215,0,0.9)'; this.style.textShadow='0 0 10px rgba(255,215,0,0.6)';"
           onmouseout="this.style.color='rgba(255,215,0,0.6)'; this.style.textShadow='0 0 5px rgba(255,215,0,0.3)';">
          [CLASSIFIED]
        </a>
      </div>
    </div>
    <div class="wizard-container">
      <div class="wizard-steps">
        <div class="wizard-step" data-step="0">┌─ API KEY ─┐</div>
        <div class="wizard-step" data-step="1">┌─ UPGRADES ─┐</div>
        <div class="wizard-step" data-step="2">┌─ BLUEPRINTS ─┐</div>
        <div class="wizard-step" data-step="3">┌─ REVIEW ─┐</div>
        <div class="wizard-step" data-step="4">┌─ GENESIS ─┐</div>
      </div>
      <div class="wizard-content">
        <div class="step-content"></div>
      </div>
      <div class="action-buttons">
        <button class="btn" id="prev-btn">◄ BACK</button>
        <button class="btn primary" id="next-btn">NEXT ►</button>
      </div>
    </div>
    <div id="log-area" class="hidden"></div>
    <div class="tooltip" id="tooltip"></div>
  `;

      boot.tooltip = document.getElementById("tooltip");
      boot.setupWizardNavigation();
      boot.updateWizardStep();
    },

    setupWizardNavigation: () => {
      const wizardStepNames = ["API Key", "Upgrades", "Blueprints", "Review", "Genesis"];

      const handleNext = async () => {
        if (boot.currentStep < 4) {
          const isValid = await boot.validateCurrentStep();
          if (isValid) {
            const oldStepName = wizardStepNames[boot.currentStep];
            boot.currentStep++;
            const newStepName = wizardStepNames[boot.currentStep];
            console.log(`[Bootloader] Wizard step completed: ${oldStepName}. Moving to: ${newStepName}.`);
            boot.updateWizardStep();
          }
        } else if (boot.currentStep === 4) {
          boot.initiateGenesis();
        }
      };

      const handlePrev = () => {
        if (boot.currentStep > 0) {
          boot.currentStep--;
          boot.updateWizardStep();
        }
      };

      document.getElementById("prev-btn").addEventListener("click", handlePrev);
      document.getElementById("next-btn").addEventListener("click", handleNext);

      // Global Enter key handler
      document.addEventListener("keydown", async (e) => {
        if (e.key === "Enter" && !e.target.matches("input, textarea")) {
          await handleNext();
        }
      });

      document.querySelectorAll(".wizard-step").forEach((step, index) => {
        step.addEventListener("click", () => {
          if (index <= boot.currentStep) {
            boot.currentStep = index;
            boot.updateWizardStep();
          }
        });
      });
    },

    updateWizardStep: () => {
      // Update step indicators
      document.querySelectorAll(".wizard-step").forEach((step, index) => {
        step.classList.remove("active", "completed");
        if (index === boot.currentStep) {
          step.classList.add("active");
        } else if (index < boot.currentStep) {
          step.classList.add("completed");
        }
      });

      // Update content
      const contentDiv = document.querySelector(".step-content");
      const stepRenderers = [
        boot.renderApiKeyStep,
        boot.renderUpgradesStep,
        boot.renderBlueprintsStep,
        boot.renderReviewStep,
        boot.renderGenesisStep
      ];
      
      if (stepRenderers[boot.currentStep]) {
        stepRenderers[boot.currentStep](contentDiv);
      }

      // Update buttons
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");
      prevBtn.disabled = boot.currentStep === 0;
      
      const buttonTexts = ["NEXT ►", "NEXT ►", "NEXT ►", "LGTM ►", "AWAKEN ►"];
      nextBtn.textContent = buttonTexts[boot.currentStep];
      nextBtn.classList.toggle("awaken", boot.currentStep === 4);
    },

    renderApiKeyStep: async (container) => {
      // Check if proxy is available
      let proxyStatus = null;
      try {
        const response = await fetch('/api/proxy-status');
        if (response.ok) {
          proxyStatus = await response.json();
        }
      } catch (e) {
        // Proxy not available
      }
      
      if (proxyStatus && proxyStatus.proxyAvailable && proxyStatus.hasApiKey) {
        // Proxy is available with API key, show success message
        container.innerHTML = `
          <div class="api-key-container">
            <h2>┌─ AUTHENTICATION ─┐</h2>
            <div style="padding: 20px; border: 2px solid #0ff; background: rgba(0,255,255,0.1); margin: 20px 0;">
              <div style="color: #0ff; font-weight: bold; margin-bottom: 10px; font-size: 1.2em;">
                ✅ Server Proxy Detected
              </div>
              <div style="color: #aaa;">
                The Node.js server is handling authentication automatically.
                <br>API key is securely loaded from server environment.
                <br><br>
                <span style="color: #ffd700;">No manual key entry needed!</span>
              </div>
            </div>
            <div style="color: #888; font-size: 0.9em; margin-top: 20px;">
              Press NEXT to continue with the setup.
            </div>
          </div>
        `;
        // Auto-set empty API key since proxy will handle it
        boot.apiKey = "PROXY";
      } else {
        // No proxy or no API key on server, show normal input
        container.innerHTML = `
          <div class="api-key-container">
            <h2>┌─ AUTHENTICATION ─┐</h2>
            <p>Enter your API key to initialize the harness</p>
            <input type="password" id="api-key-input" 
                   placeholder="sk-..." 
                   value="${boot.apiKey || ""}" />
            <div class="api-key-hint">
              Your API key is stored locally and never transmitted
            </div>
            ${proxyStatus && proxyStatus.proxyAvailable && !proxyStatus.hasApiKey ? `
              <div style="margin-top: 20px; padding: 15px; border: 1px solid #ff9900; background: rgba(255,153,0,0.1);">
                <div style="color: #ff9900; font-weight: bold;">ℹ Server Detected (No API Key)</div>
                <div style="color: #aaa; font-size: 0.9em; margin-top: 5px;">
                  Node.js server is running but no API key found in .env file.
                  <br>Enter your key manually or add it to the .env file and restart the server.
                </div>
              </div>
            ` : ''}
            <div style="margin-top: 30px; padding: 20px; border: 1px solid #ffd700; background: rgba(255,215,0,0.1);">
              <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">⚠ WARNING</div>
              <div style="color: #aaa; font-size: 0.9em;">
                You can skip this step, but the agent will run in a basic state without AI capabilities.
                No API calls will work, limiting functionality to local operations only.
              </div>
            </div>
          </div>
        `;
      }
      
      const apiInput = document.getElementById("api-key-input");
      if (apiInput) {
        apiInput.focus();
        
        apiInput.addEventListener("keydown", async (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            boot.apiKey = apiInput.value;
            const isValid = await boot.validateCurrentStep();
            if (isValid) {
              boot.currentStep++;
              boot.updateWizardStep();
            }
          }
        });
      }
    },

    renderUpgradesStep: (container) => {
      if (!boot.config) return;

      // Group upgrades by category
      const categories = {
        'core': { name: 'CORE SYSTEM', upgrades: [] },
        'agent': { name: 'AI AGENT', upgrades: [] },
        'tools': { name: 'TOOLS', upgrades: [] },
        'ui': { name: 'INTERFACE', upgrades: [] },
        'storage': { name: 'STORAGE', upgrades: [] },
        'experimental': { name: 'EXPERIMENTAL', upgrades: [] }
      };
      
      boot.config.upgrades.forEach(upgrade => {
        if (upgrade.category && categories[upgrade.category]) {
          categories[upgrade.category].upgrades.push(upgrade);
        }
      });

      container.innerHTML = `
        <div class="selection-panel">
          <h2 style="color: #0ff;">┌─ CAPABILITIES ─┐</h2>
          <p style="color: #ffd700; font-weight: bold;">✓ All upgrades selected by default</p>
          <p style="color: #888; font-size: 0.9em; margin-top: 5px;">Click below to customize selection if needed</p>
          
          <div class="preset-buttons">
            <button class="preset-btn" data-preset="minimal">MINIMAL</button>
            <button class="preset-btn" data-preset="standard">STANDARD</button>
            <button class="preset-btn preset-selected" data-preset="full">FULL</button>
          </div>
          
          <details style="margin-top: 20px;">
            <summary style="cursor: pointer; padding: 10px; border: 1px solid #444; background: rgba(0,255,255,0.02); color: #0ff;">
              ▼ Advanced: Customize Upgrade Selection
            </summary>
            <div class="clustered-grid" id="upgrades-clusters" style="margin-top: 15px;">
              ${Object.entries(categories).filter(([_, cat]) => cat.upgrades.length > 0).map(([key, category]) => `
                <div class="upgrade-cluster" data-category="${key}">
                  <div class="cluster-header">${category.name}</div>
                  <div class="cluster-items">
                    ${category.upgrades.map(u => `
                      <div class="cluster-item" data-id="${u.id}" title="${u.description}">
                        <input type="checkbox" id="upgrade-${u.id}" />
                        <label for="upgrade-${u.id}">
                          <span class="item-id">${u.id}</span>
                          <span class="item-name">${u.path.split('.')[0]}</span>
                        </label>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
          </details>
          
          <div style="margin: 20px 0; padding: 15px; border: 2px solid #ffd700; background: rgba(255,215,0,0.05);">
            <div style="display: flex; align-items: center; justify-content: space-between;">
              <div>
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">
                  RECURSIVE SELF-IMPROVEMENT (RSI)
                </div>
                <div style="color: #888; font-size: 0.9em;">
                  Enable agent to modify its own code (adds TLWR - tools-write)
                </div>
              </div>
              <label class="rsi-toggle">
                <input type="checkbox" id="rsi-toggle" />
                <span class="toggle-slider"></span>
              </label>
            </div>
            <div id="rsi-warning" style="display: none; margin-top: 10px; padding: 10px; background: rgba(255,0,0,0.1); border: 1px solid #ff0000;">
              <div style="color: #ff6666;">WARNING: Agent can modify ANY file in VFS including its own modules</div>
            </div>
          </div>
          
          <div class="cli-fallback">
            <details>
              <summary style="cursor: pointer; color: #888;">Advanced: Manual Input</summary>
              <input type="text" class="cli-input" id="manual-upgrades" 
                     placeholder="Enter comma-separated upgrade IDs (e.g., CYCL, STMT, UIMN)" />
            </details>
          </div>
        </div>
        
        <div class="preview-panel">
          <h3>┌─ COMPOSITION PREVIEW ─┐</h3>
          <div class="preview-box" id="upgrades-preview">
            <div style="color: #888;">Loading...</div>
          </div>
        </div>
      `;

      // Set up checkbox event handlers
      document.querySelectorAll('.cluster-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const id = e.target.parentElement.parentElement.dataset.id;
          if (e.target.checked) {
            if (!boot.selectedUpgrades.includes(id)) {
              boot.selectedUpgrades.push(id);
            }
          } else {
            boot.selectedUpgrades = boot.selectedUpgrades.filter(uid => uid !== id);
          }
          boot.updatePreview("upgrades");
        });
      });

      document.querySelectorAll(".preset-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          document.querySelectorAll(".preset-btn").forEach(b => b.classList.remove("preset-selected"));
          e.target.classList.add("preset-selected");
          boot.applyPreset(btn.dataset.preset);
        });
      });

      document.getElementById("manual-upgrades").addEventListener("input", (e) => {
        boot.parseManualSelection(e.target.value, "upgrade");
      });

      // RSI Toggle Handler
      const rsiToggle = document.getElementById("rsi-toggle");
      const rsiWarning = document.getElementById("rsi-warning");
      
      rsiToggle.addEventListener("change", (e) => {
        if (e.target.checked) {
          // Add TLWR upgrade
          if (!boot.selectedUpgrades.includes("TLWR")) {
            boot.selectedUpgrades.push("TLWR");
          }
          rsiWarning.style.display = "block";
        } else {
          // Remove TLWR upgrade
          boot.selectedUpgrades = boot.selectedUpgrades.filter(id => id !== "TLWR");
          rsiWarning.style.display = "none";
        }
        boot.updatePreview("upgrades");
      });

      // Apply full preset by default (all upgrades except TLWR for safety)
      boot.applyPreset("full");
      boot.updatePreview("upgrades");
    },

    renderBlueprintsStep: (container) => {
      if (!boot.config) return;

      container.innerHTML = `
        <div class="selection-panel">
          <h2 style="color: #0ff;">┌─ BLUEPRINTS ─┐</h2>
          <p style="color: #888; font-weight: bold;">○ No blueprints selected by default</p>
          <p style="color: #888; font-size: 0.9em; margin-top: 5px;">Blueprints are optional reference materials for RSI</p>
          
          <div style="margin: 15px 0; padding: 15px; background: rgba(0,255,255,0.05); border: 1px solid #0ff;">
            <div style="color: #0ff; font-weight: bold; margin-bottom: 10px;">WHAT ARE BLUEPRINTS?</div>
            <div style="color: #aaa; font-size: 0.9em; line-height: 1.5;">
              Blueprints are detailed instructions that teach the agent HOW to build each upgrade from scratch.
              With RSI enabled (TLWR), the agent can read blueprints and create missing upgrades itself.
              <br><br>
              <span style="color: #ffd700;">Example:</span> Blueprint 0x000008 → Instructions to build CYCL upgrade<br>
              <span style="color: #ffd700;">Example:</span> Blueprint 0x000016 → Meta-patterns for creating new tools
            </div>
          </div>
          
          <div class="preset-buttons">
            <button class="preset-btn preset-selected" data-preset="none">NONE</button>
            <button class="preset-btn" data-preset="some">SOME</button>
            <button class="preset-btn" data-preset="all">ALL</button>
          </div>
          
          <details style="margin-top: 20px;">
            <summary style="cursor: pointer; padding: 10px; border: 1px solid #444; background: rgba(0,255,255,0.02); color: #0ff;">
              ▼ Advanced: Select Blueprints
            </summary>
            <div class="selection-grid" id="blueprints-grid" style="margin-top: 15px;"></div>
          </details>
          
          <div class="cli-fallback">
            <details>
              <summary style="cursor: pointer; color: #888;">Advanced: Manual Input</summary>
              <input type="text" class="cli-input" id="manual-blueprints" 
                     placeholder="Enter comma-separated blueprint IDs (e.g., 0x000011, 0x000012)" />
            </details>
          </div>
        </div>
        
        <div class="preview-panel">
          <h3>┌─ SELECTED BLUEPRINTS ─┐</h3>
          <div class="preview-box" id="blueprints-preview">
            <div style="color: #888;">No blueprints selected</div>
          </div>
        </div>
      `;

      boot.renderSelectionCards("blueprints-grid", boot.config.blueprints, "blueprint");

      document.querySelectorAll(".preset-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          document.querySelectorAll(".preset-btn").forEach(b => b.classList.remove("preset-selected"));
          e.target.classList.add("preset-selected");
          boot.applyBlueprintPreset(btn.dataset.preset);
        });
      });

      document.getElementById("manual-blueprints").addEventListener("input", (e) => {
        boot.parseManualSelection(e.target.value, "blueprint");
      });

      // Default to none
      boot.applyBlueprintPreset("none");
      boot.updatePreview("blueprints");
    },

    renderReviewStep: (container) => {
      const upgradesText = boot.selectedUpgrades.length > 0
        ? boot.selectedUpgrades.join(", ")
        : "None (default core will be used)";

      const blueprintsText = boot.selectedBlueprints.length > 0
        ? boot.selectedBlueprints.join(", ")
        : "None";

      // Default goal based on selected blueprints
      const defaultGoal = boot.selectedBlueprints.length > 0
        ? `Study the blueprints at ${boot.selectedBlueprints.map(b => `/docs/${b}.md`).join(", ")} and propose a plan for implementation.`
        : "Perform a system check, list all available modules and docs, and report status.";
      
      // Use saved custom goal or default
      if (!boot.customGoal) {
        boot.customGoal = defaultGoal;
      }

      container.innerHTML = `
        <div style="padding: 40px;">
          <h2 style="color: #0ff; text-align: center; margin-bottom: 40px;">┌─ GENESIS CONFIGURATION ─┐</h2>
          
          <div class="review-grid">
            <div class="review-box">
              <h3>UPGRADES</h3>
              <pre>${upgradesText}</pre>
            </div>
            
            <div class="review-box">
              <h3>BLUEPRINTS</h3>
              <pre>${blueprintsText}</pre>
              ${boot.selectedBlueprints.length > 0 && boot.selectedUpgrades.includes("TLWR") ? 
                '<div style="color: #ffd700; font-size: 0.8em; margin-top: 10px;">RSI enabled - Agent can build upgrades from blueprints</div>' : 
                boot.selectedBlueprints.length > 0 ? 
                '<div style="color: #888; font-size: 0.8em; margin-top: 10px;">RSI disabled - Blueprints for reference only</div>' : 
                ''}
            </div>
            
            <div class="review-box">
              <h3>INITIAL GOAL</h3>
              <textarea id="goal-input" 
                style="width: 100%; 
                       min-height: 100px; 
                       background: rgba(0,0,0,0.7); 
                       color: #0ff; 
                       border: 1px solid #444; 
                       padding: 10px; 
                       font-family: inherit; 
                       font-size: 0.9em; 
                       resize: vertical;"
                placeholder="Enter the agent's initial goal...">${boot.customGoal}</textarea>
              <div style="margin-top: 10px; color: #888; font-size: 0.85em;">
                You can edit the initial goal above. The agent will pursue this objective upon awakening.
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Save goal changes
      const goalInput = document.getElementById("goal-input");
      if (goalInput) {
        goalInput.addEventListener("input", (e) => {
          boot.customGoal = e.target.value;
        });
        
        // Auto-resize textarea
        goalInput.addEventListener("input", () => {
          goalInput.style.height = "auto";
          goalInput.style.height = goalInput.scrollHeight + "px";
        });
        
        // Adjust initial height
        goalInput.style.height = "auto";
        goalInput.style.height = goalInput.scrollHeight + "px";
        
        // Style focus state
        goalInput.addEventListener("focus", () => {
          goalInput.style.borderColor = "#ffd700";
        });
        
        goalInput.addEventListener("blur", () => {
          goalInput.style.borderColor = "#444";
        });
      }
    },

    renderGenesisStep: (container) => {
      container.innerHTML = `
        <div class="genesis-container">
          <h2>┌─ GENESIS PROTOCOL ─┐</h2>
          
          <div class="progress-bar">
            <div class="progress-fill" id="genesis-progress" style="width: 0%;"></div>
            <div class="progress-text" id="genesis-text">Ready</div>
          </div>
          
          <div id="genesis-log"></div>
          
          <div class="genesis-prompt">
            Press AWAKEN to initiate genesis protocol
          </div>
        </div>
      `;
    },

    // Unified selection card renderer
    renderSelectionCards: (containerId, items, type) => {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const selectedArray = type === "upgrade" ? boot.selectedUpgrades : boot.selectedBlueprints;
      
      items.forEach((item) => {
        const card = boot.createElement("div", {
          className: "selection-card" + (selectedArray.includes(item.id) ? " selected" : ""),
          "data-id": item.id,
          "data-type": type
        });
        
        const checkbox = boot.createElement("input", {
          type: "checkbox",
          checked: selectedArray.includes(item.id) ? "checked" : null
        });
        
        const title = boot.createElement("div", {
          className: "selection-card-title",
          textContent: item.id.toUpperCase()
        });
        
        const desc = boot.createElement("div", {
          className: "selection-card-desc",
          textContent: item.description
        });
        
        card.appendChild(checkbox);
        card.appendChild(title);
        card.appendChild(desc);
        
        card.addEventListener("click", () => boot.toggleSelection(card, type));
        card.addEventListener("mouseenter", (e) => boot.showTooltip(e, item));
        card.addEventListener("mouseleave", () => boot.hideTooltip());
        
        container.appendChild(card);
      });
    },

    toggleSelection: (card, type) => {
      const id = card.dataset.id;
      const checkbox = card.querySelector('input[type="checkbox"]');
      const selectedArray = type === "upgrade" ? boot.selectedUpgrades : boot.selectedBlueprints;
      
      const index = selectedArray.indexOf(id);
      if (index > -1) {
        selectedArray.splice(index, 1);
        card.classList.remove("selected");
        checkbox.checked = false;
      } else {
        selectedArray.push(id);
        card.classList.add("selected");
        checkbox.checked = true;
      }
      
      boot.updatePreview(type === "upgrade" ? "upgrades" : "blueprints");
    },

    showTooltip: (event, item) => {
      if (!boot.tooltip) return;
      
      const rect = event.target.getBoundingClientRect();
      boot.tooltip.innerHTML = `
        <div style="color: #0ff; font-weight: bold; margin-bottom: 8px;">${item.id.toUpperCase()}</div>
        <div style="color: #aaa; font-size: 0.9em; line-height: 1.4;">${item.description}</div>
        ${item.path ? `<div style="color: #888; font-size: 0.8em; margin-top: 8px;">Path: ${item.path}</div>` : ""}
      `;
      
      boot.tooltip.style.left = rect.right + 10 + "px";
      boot.tooltip.style.top = rect.top + "px";
      boot.tooltip.classList.add("visible");
    },

    hideTooltip: () => {
      if (boot.tooltip) {
        boot.tooltip.classList.remove("visible");
      }
    },

    setupCollapsible: (headerId, contentId) => {
      const header = document.getElementById(headerId);
      const content = document.getElementById(contentId);
      
      header.addEventListener("click", () => {
        header.classList.toggle("collapsed");
        content.classList.toggle("collapsed");
      });
    },


    updatePreview: (type) => {
      const previewId = type === "upgrades" ? "upgrades-preview" : "blueprints-preview";
      const preview = document.getElementById(previewId);
      if (!preview) return;
      
      const selectedArray = type === "upgrades" ? boot.selectedUpgrades : boot.selectedBlueprints;
      const itemName = type === "upgrades" ? "Upgrades" : "Blueprints";
      
      if (selectedArray.length === 0) {
        preview.innerHTML = `<div style="color: #888;">No ${type} selected</div>`;
      } else {
        preview.innerHTML = `
          <div style="color: #0ff; margin-bottom: 10px;">Selected ${itemName} (${selectedArray.length}):</div>
          <div style="color: #aaa;">${selectedArray.join(", ")}</div>
        `;
      }
    },

    applyPreset: (preset) => {
      // Save RSI state before clearing
      const rsiEnabled = boot.selectedUpgrades.includes("TLWR");
      
      // Clear current selections
      boot.selectedUpgrades = [];
      document.querySelectorAll('.selection-card[data-type="upgrade"]').forEach((card) => {
        card.classList.remove("selected");
        card.querySelector('input[type="checkbox"]').checked = false;
      });
      document.querySelectorAll('.cluster-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
      
      // Define presets using new 4-char IDs
      // Minimal: APPL's hard dependencies only (will have no UI, just console logs)
      const minimalSubset = ["APPL", "UTIL", "STMT", "IDXB", "APIC", "CYCL", "AGLP", "STHP", "TRUN", "TRHP", "UIMN"];
      // Standard: Adds read tools and prompt for a functional agent
      const standardSubset = ["APPL", "UTIL", "STMT", "IDXB", "APIC", "CYCL", "PRMT", "AGLP", "STHP", "TRUN", "TLRD", "TRHP", "UIMN"];
      const fullSubset = boot.config.upgrades.filter(u => u.id !== "TLWR").map(u => u.id); // Everything except TLWR
      
      // Apply preset
      const presetMappings = {
        "minimal": minimalSubset,
        "standard": standardSubset,
        "full": fullSubset
      };
      
      const presetUpgrades = presetMappings[preset] || [];
      
      presetUpgrades.forEach((id) => {
        boot.selectedUpgrades.push(id);
        // Update both old selection cards and new cluster items
        const card = document.querySelector(`.selection-card[data-id="${id}"]`);
        if (card) {
          card.classList.add("selected");
          card.querySelector('input[type="checkbox"]').checked = true;
        }
        const clusterItem = document.querySelector(`#upgrade-${id}`);
        if (clusterItem) {
          clusterItem.checked = true;
        }
      });
      
      // Restore RSI state if it was enabled
      if (rsiEnabled && !boot.selectedUpgrades.includes("TLWR")) {
        boot.selectedUpgrades.push("TLWR");
      }
      
      boot.updatePreview("upgrades");
    },

    applyBlueprintPreset: (preset) => {
      // Clear current selections
      boot.selectedBlueprints = [];
      document.querySelectorAll('.selection-card[data-type="blueprint"]').forEach((card) => {
        card.classList.remove("selected");
        card.querySelector('input[type="checkbox"]').checked = false;
      });
      
      let blueprintsToSelect = [];
      
      if (preset === "some") {
        // Select first 3-4 blueprints
        blueprintsToSelect = boot.config.blueprints.slice(0, 4).map(b => b.id);
      } else if (preset === "all") {
        blueprintsToSelect = boot.config.blueprints.map(b => b.id);
      }
      
      blueprintsToSelect.forEach((id) => {
        const card = document.querySelector(`.selection-card[data-id="${id}"]`);
        if (card) {
          boot.selectedBlueprints.push(id);
          card.classList.add("selected");
          card.querySelector('input[type="checkbox"]').checked = true;
        }
      });
      
      boot.updatePreview("blueprints");
    },

    parseManualSelection: (input, type) => {
      const ids = input.toLowerCase().split(",").map((s) => s.trim()).filter(Boolean);
      const selectedArray = type === "upgrade" ? boot.selectedUpgrades : boot.selectedBlueprints;
      
      // Clear and reselect based on manual input
      selectedArray.length = 0;
      document.querySelectorAll(`.selection-card[data-type="${type}"]`).forEach((card) => {
        const isSelected = ids.includes(card.dataset.id);
        card.classList.toggle("selected", isSelected);
        card.querySelector('input[type="checkbox"]').checked = isSelected;
        if (isSelected) selectedArray.push(card.dataset.id);
      });
      
      boot.updatePreview(type === "upgrade" ? "upgrades" : "blueprints");
    },

    validateCurrentStep: async () => {
      if (boot.currentStep === 0) {
        const apiKey = document.getElementById("api-key-input")?.value;
        // Allow empty API key but store it (will be empty string)
        boot.apiKey = apiKey || "";
        if (!boot.config) {
          const loaded = await boot.loadManifest();
          if (!loaded) return false;
        }
      }
      return true;
    },

    initiateGenesis: async () => {
      console.group("[Bootloader] Genesis Protocol");
      console.log("Final Configuration:", {
        upgrades: boot.selectedUpgrades,
        blueprints: boot.selectedBlueprints,
        goal: boot.customGoal
      });

      const progressBar = document.getElementById("genesis-progress");
      const progressText = document.getElementById("genesis-text");
      const genesisLog = document.getElementById("genesis-log");
      
      // Prepare upgrades and blueprints
      const upgradesToInstall = boot.selectedUpgrades.length > 0
        ? boot.config.upgrades.filter((u) => boot.selectedUpgrades.includes(u.id))
        : boot.config.upgrades.filter((u) => boot.config.defaultCore.includes(u.id));
      
      const blueprintsToStudy = boot.selectedBlueprints.length > 0
        ? boot.config.blueprints.filter((b) => boot.selectedBlueprints.includes(b.id))
        : [];

      // Robustness: If UI Manager is installed, ensure its template and styles are too.
      const upgradeIds = upgradesToInstall.map(u => u.id);
      if (upgradeIds.includes("UIMN")) {
        if (!upgradeIds.includes("BODY")) {
          console.warn("[Bootloader] UIMN is present but BODY is missing. Forcing inclusion.");
          upgradesToInstall.push(boot.config.upgrades.find(u => u.id === "BODY"));
        }
        if (!upgradeIds.includes("STYL")) {
          console.warn("[Bootloader] UIMN is present but STYL is missing. Forcing inclusion.");
          upgradesToInstall.push(boot.config.upgrades.find(u => u.id === "STYL"));
        }
      }
      
      // Check for IDB upgrade
      const useIdb = upgradesToInstall.some((u) => u.id === "idb");
      if (useIdb) {
        boot.vfs = BootIdbVfs({ VFS_PREFIX: boot.vfsPrefix });
      }
      
      await boot.runGenesisWithProgress(
        upgradesToInstall,
        blueprintsToStudy,
        progressBar,
        progressText,
        genesisLog
      );
      console.groupEnd();
    },

    log: (message, level = "log") => {
      const logArea = document.getElementById("log-area");
      if (logArea) {
        const line = boot.createElement("div", {
          className: level,
          textContent: `> ${message}`
        });
        logArea.appendChild(line);
        logArea.scrollTop = logArea.scrollHeight;
      }
    },

    loadManifest: async () => {
      try {
        const response = await fetch("config.json");
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        boot.config = await response.json();
        return true;
      } catch (e) {
        alert(`Failed to load config.json: ${e.message}`);
        return false;
      }
    },

    runGenesisWithProgress: async (upgrades, blueprints, progressBar, progressText, logDiv) => {
      const addLog = (msg, color = "#0ff") => {
        if (logDiv) {
          const line = boot.createElement("div", {
            style: `color: ${color}`,
            textContent: `> ${msg}`
          });
          logDiv.appendChild(line);
          logDiv.scrollTop = logDiv.scrollHeight;
        }
      };
      
      const updateProgress = (percent, text) => {
        if (progressBar) progressBar.style.width = percent + "%";
        if (progressText) progressText.textContent = text;
      };
      
      updateProgress(10, "Clearing VFS...");
      addLog("Clearing existing VFS...");
      await boot.vfs.clear();
      
      const artifactMetadata = {};
      const now = Date.now();
      
      const allGenesisFiles = [...upgrades, ...blueprints];
      
      updateProgress(20, "Fetching genesis artifacts...");
      addLog("Fetching and installing all genesis artifacts...");
      
      let fileCount = 0;
      const totalFiles = allGenesisFiles.length;
      
      for (const fileDef of allGenesisFiles) {
        const isBlueprint = blueprints.some((b) => b.id === fileDef.id);
        const fetchPath = isBlueprint ? `blueprints/${fileDef.path}` : `upgrades/${fileDef.path}`;
        const vfsPath = isBlueprint ? `/docs/${fileDef.path}` : `/modules/${fileDef.path}`;
        
        try {
          const res = await fetch(fetchPath);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const content = await res.text();
          
          // Write to VFS (IndexedDB if enabled)
          await boot.vfs.write(vfsPath, content);
          
          // Also mirror to localStorage for sync access during awakening
          // This is needed because eval context can't handle async reads
          localStorage.setItem(boot.vfsPrefix + vfsPath, content);
          
          artifactMetadata[vfsPath] = {
            id: vfsPath,
            versions: [{
              cycle: 0,
              timestamp: now,
              versionId: "c0",
            }],
          };
          
          fileCount++;
          const progress = 20 + (fileCount / totalFiles) * 60;
          updateProgress(progress, `Installing ${fileDef.id}...`);
          addLog(`Installed ${fileDef.id} to ${vfsPath}`, "#ffd700");
          console.log(`[Genesis] Installed ${fileDef.id} -> ${vfsPath}`);
        } catch (e) {
          addLog(`Failed to install ${fileDef.id}: ${e.message}`, "#f00");
          return;
        }
      }

      
      
      updateProgress(85, "Creating initial state...");
      addLog("Creating initial state artifact...");
      
      // Use custom goal if set, otherwise use default
      const initialGoal = boot.customGoal || (
        blueprints.length > 0
          ? `Study the blueprints at ${blueprints.map((b) => `/docs/${b.path}`).join(", ")} and propose a plan for implementation.`
          : "Perform a system check, list all available modules and docs, and report status."
      );
      
      const initialState = {
        version: "2.0.0-async",
        totalCycles: 0,
        currentGoal: { seed: initialGoal, cumulative: initialGoal, stack: [] },
        apiKey: boot.apiKey,
        artifactMetadata,
        dynamicTools: [],
        registeredWebComponents: [],
      };
      
      const stateJson = JSON.stringify(initialState);
      await boot.vfs.write(boot.statePath, stateJson);
      
      // Also mirror state to localStorage for sync access
      localStorage.setItem(boot.vfsPrefix + boot.statePath, stateJson);
      
      updateProgress(95, "Awakening agent...");
      addLog("Genesis complete. State initialized.", "#ffd700");
      addLog("AWAKENING AGENT...", "#ffd700");
      
      await new Promise((resolve) => setTimeout(resolve, 500));
      updateProgress(100, "Complete!");
      
      await boot.awakenAgent();
    },

    awakenAgent: async () => {
      console.groupCollapsed("[Bootloader] Agent Awakening");
      console.log("Handing off control to VFS /modules/app-logic.js");
      console.log("Configuration State:", {
        selectedUpgrades: boot.selectedUpgrades,
        selectedBlueprints: boot.selectedBlueprints,
        apiKeyPresent: !!boot.apiKey,
        vfsType: boot.vfs.write.toString().includes('indexedDB') ? 'IndexedDB' : 'localStorage'
      });
      
      try {
        // Handle both sync (localStorage) and async (IndexedDB) VFS
        let appLogicContent;
        const readResult = boot.vfs.read("/modules/app-logic.js");
        
        // Check if it's a Promise (IndexedDB) or direct value (localStorage)
        if (readResult && typeof readResult.then === 'function') {
          appLogicContent = await readResult;
        } else {
          appLogicContent = readResult;
        }
        
        // Debug: Check what type of content we got
        console.log("App logic content type:", typeof appLogicContent);
        console.log("App logic content sample:", appLogicContent ? appLogicContent.substring(0, 100) : "null");
        
        if (!appLogicContent) {
          console.error("VFS Contents:", {
            upgradesLoaded: boot.selectedUpgrades,
            blueprintsLoaded: boot.selectedBlueprints,
            vfsPrefix: boot.vfsPrefix
          });
          throw new Error("Could not read /modules/app-logic.js from VFS. Check if upgrades were properly installed.");
        }
        
        // Ensure we have a string
        const appLogicString = typeof appLogicContent === 'string' 
          ? appLogicContent 
          : String(appLogicContent);
        
        const initialConfigForAgent = {
          VFS_PREFIX: boot.vfsPrefix,
          STATE_PATH: boot.statePath,
        };
        
        console.log("Initializing agent with config:", initialConfigForAgent);
        
        // Make boot available globally for the agent
        window.boot = boot;
        
        // Create a synchronous VFS wrapper for the agent context
        // This wraps async operations to work with the eval'd code
        const vfsWrapper = {
          write: boot.vfs.write,
          clear: boot.vfs.clear,
          read: (path) => {
            // Try localStorage first for synchronous access
            const localContent = localStorage.getItem(boot.vfsPrefix + path);
            if (localContent !== null) {
              return localContent;
            }
            // If not in localStorage but using IndexedDB, we have a problem
            // The eval context can't handle async operations properly
            console.warn(`VFS read for ${path} not found in localStorage during sync read`);
            return null;
          }
        };
        
        // Make the wrapper available globally BEFORE eval
        window.boot.vfsWrapper = vfsWrapper;
        
        // Modify the app-logic content to handle sync VFS
        // Replace await vfs.read with sync vfs.read
        const modifiedAppLogic = appLogicString.replace(/await vfs\.read/g, 'vfs.read');
        
        // Use eval to execute the code
        try {
          console.log("Executing agent core module...");
          eval(`
            (function() {
              var config = ${JSON.stringify(initialConfigForAgent)};
              var vfs = window.boot.vfsWrapper;
              ${modifiedAppLogic}
              // CoreLogicModule is defined in app-logic.js
              if (typeof CoreLogicModule === 'function') {
                console.log('CoreLogicModule found, initializing...');
                CoreLogicModule(config, vfs);
              } else {
                console.error('CoreLogicModule not found after evaluating app-logic.js');
              }
            })();
          `);
          
          console.log("HANDOVER COMPLETE. Bootloader is now inert.");
        } catch (evalError) {
          console.error("Eval execution failed:", evalError);
          console.error("Stack trace:", evalError.stack);
          throw new Error(`Failed to execute agent code: ${evalError.message}`);
        }
      } catch (e) {
        console.error("AGENT AWAKENING FAILED:", e);
        console.error("Full error details:", {
          message: e.message,
          stack: e.stack,
          upgrades: boot.selectedUpgrades,
          blueprints: boot.selectedBlueprints
        });
        
        const genesisLog = document.getElementById("genesis-log");
        if (genesisLog) {
          const errorLine = boot.createElement("div", {
            style: "color: #f00",
            textContent: `> AWAKENING FAILED: ${e.message}`
          });
          const detailsLine = boot.createElement("div", {
            style: "color: #fa0; font-size: 0.9em",
            textContent: `> Config: ${boot.selectedUpgrades.length} upgrades, ${boot.selectedBlueprints.length} blueprints`
          });
          genesisLog.appendChild(errorLine);
          genesisLog.appendChild(detailsLine);
        }
      }
      console.groupEnd();
    },

    restoreVfs: async () => {
      console.log("[Bootloader] Checking for a saved VFS state on the server...");
      try {
        const statusResponse = await fetch('/api/vfs/status');
        if (!statusResponse.ok) {
          throw new Error(`Status check failed: ${statusResponse.status}`);
        }
        const status = await statusResponse.json();

        if (status.backupExists) {
          console.log("[Bootloader] Saved state found. Restoring VFS and awakening agent.");
          const restoreResponse = await fetch('/api/vfs/restore');
          const vfsState = await restoreResponse.json();

          // Determine if IDB is needed from the restored state
          const useIdb = vfsState['/modules/storage-indexeddb.js'];
          if (useIdb) {
            boot.vfs = BootIdbVfs({ VFS_PREFIX: boot.vfsPrefix });
          }
          
          // Clear existing VFS and restore
          await boot.vfs.clear();
          for (const [path, content] of Object.entries(vfsState)) {
            await boot.vfs.write(path, content);
            // Also mirror to localStorage for sync access
            if (typeof content === 'string') {
                localStorage.setItem(boot.vfsPrefix + path, content);
            }
          }

          // Manually set the API key from the restored state if it exists
          const stateContent = vfsState[boot.statePath];
          if (stateContent) {
              const state = JSON.parse(stateContent);
              boot.apiKey = state.apiKey || "";
          }

          // Hide boot container and awaken
          bootContainer.style.display = 'none';
          appRoot.style.display = 'block';
          await boot.awakenAgent();
          return true; // Indicate restore was successful
        } else {
          console.log("[Bootloader] No saved state found. Proceeding with normal boot wizard.");
          return false;
        }
      } catch (error) {
        console.warn(`[Bootloader] Could not check for saved state. This is normal if the server is offline. Proceeding with normal boot. Error: ${error.message}`);
        return false;
      }
    },

    start: async () => {
      const restored = await boot.restoreVfs();
      if (!restored) {
        boot.render();
      }
    },
  };

  boot.start();
})();
    </script>
  </body>
</html>